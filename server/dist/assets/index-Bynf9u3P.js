const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/ccip-D6kDQOZ3.js","assets/isAddressEqual-O_zXrJKR.js","assets/index-DydxHIo5.js","assets/clsx.m-D57qXwfE.js","assets/secp256k1-btqibVvj.js","assets/index-CZ19Q9_0.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _provider, _providerCalled, _a2, _focused, _cleanup, _setup, _b, _online, _cleanup2, _setup2, _c, _gcTimeout, _d, _initialState, _revertState, _cache, _client, _retryer, _defaultOptions, _abortSignalConsumed, _Query_instances, dispatch_fn, _e2, _observers, _mutationCache, _retryer2, _Mutation_instances, dispatch_fn2, _f2, _mutations, _scopes, _mutationId, _g, _client2, _currentResult, _currentMutation, _mutateOptions, _MutationObserver_instances, updateResult_fn, notify_fn, _h, _queries, _i2, _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _j;
function _mergeNamespaces(n3, m3) {
  for (var i4 = 0; i4 < m3.length; i4++) {
    const e2 = m3[i4];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n3)) {
          const d3 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d3) {
            Object.defineProperty(n3, k2, d3.get ? d3 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n3, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n3) {
  if (Object.prototype.hasOwnProperty.call(n3, "__esModule")) return n3;
  var f2 = n3.default;
  if (typeof f2 == "function") {
    var a2 = function a22() {
      if (this instanceof a22) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n3).forEach(function(k2) {
    var d3 = Object.getOwnPropertyDescriptor(n3, k2);
    Object.defineProperty(a2, k2, d3.get ? d3 : {
      enumerable: true,
      get: function() {
        return n3[k2];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  /**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var l2 = Symbol.for("react.element"), n3 = Symbol.for("react.portal"), p2 = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r2 = Symbol.for("react.profiler"), t2 = Symbol.for("react.provider"), u2 = Symbol.for("react.context"), v2 = Symbol.for("react.forward_ref"), w2 = Symbol.for("react.suspense"), x2 = Symbol.for("react.memo"), y3 = Symbol.for("react.lazy"), z3 = Symbol.iterator;
  function A2(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = z3 && a2[z3] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var B3 = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C2 = Object.assign, D = {};
  function E2(a2, b2, e2) {
    this.props = a2;
    this.context = b2;
    this.refs = D;
    this.updater = e2 || B3;
  }
  E2.prototype.isReactComponent = {};
  E2.prototype.setState = function(a2, b2) {
    if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a2, b2, "setState");
  };
  E2.prototype.forceUpdate = function(a2) {
    this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E2.prototype;
  function G(a2, b2, e2) {
    this.props = a2;
    this.context = b2;
    this.refs = D;
    this.updater = e2 || B3;
  }
  var H2 = G.prototype = new F();
  H2.constructor = G;
  C2(H2, E2.prototype);
  H2.isPureReactComponent = true;
  var I2 = Array.isArray, J = Object.prototype.hasOwnProperty, K2 = { current: null }, L3 = { key: true, ref: true, __self: true, __source: true };
  function M2(a2, b2, e2) {
    var d3, c2 = {}, k2 = null, h2 = null;
    if (null != b2) for (d3 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J.call(b2, d3) && !L3.hasOwnProperty(d3) && (c2[d3] = b2[d3]);
    var g2 = arguments.length - 2;
    if (1 === g2) c2.children = e2;
    else if (1 < g2) {
      for (var f2 = Array(g2), m3 = 0; m3 < g2; m3++) f2[m3] = arguments[m3 + 2];
      c2.children = f2;
    }
    if (a2 && a2.defaultProps) for (d3 in g2 = a2.defaultProps, g2) void 0 === c2[d3] && (c2[d3] = g2[d3]);
    return { $$typeof: l2, type: a2, key: k2, ref: h2, props: c2, _owner: K2.current };
  }
  function N2(a2, b2) {
    return { $$typeof: l2, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
  }
  function O2(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === l2;
  }
  function escape(a2) {
    var b2 = { "=": "=0", ":": "=2" };
    return "$" + a2.replace(/[=:]/g, function(a22) {
      return b2[a22];
    });
  }
  var P2 = /\/+/g;
  function Q2(a2, b2) {
    return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
  }
  function R2(a2, b2, e2, d3, c2) {
    var k2 = typeof a2;
    if ("undefined" === k2 || "boolean" === k2) a2 = null;
    var h2 = false;
    if (null === a2) h2 = true;
    else switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l2:
          case n3:
            h2 = true;
        }
    }
    if (h2) return h2 = a2, c2 = c2(h2), a2 = "" === d3 ? "." + Q2(h2, 0) : d3, I2(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P2, "$&/") + "/"), R2(c2, b2, e2, "", function(a22) {
      return a22;
    })) : null != c2 && (O2(c2) && (c2 = N2(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P2, "$&/") + "/") + a2)), b2.push(c2)), 1;
    h2 = 0;
    d3 = "" === d3 ? "." : d3 + ":";
    if (I2(a2)) for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d3 + Q2(k2, g2);
      h2 += R2(k2, b2, e2, f2, c2);
    }
    else if (f2 = A2(a2), "function" === typeof f2) for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; ) k2 = k2.value, f2 = d3 + Q2(k2, g2++), h2 += R2(k2, b2, e2, f2, c2);
    else if ("object" === k2) throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
    return h2;
  }
  function S2(a2, b2, e2) {
    if (null == a2) return a2;
    var d3 = [], c2 = 0;
    R2(a2, d3, "", "", function(a22) {
      return b2.call(e2, a22, c2++);
    });
    return d3;
  }
  function T2(a2) {
    if (-1 === a2._status) {
      var b2 = a2._result;
      b2 = b2();
      b2.then(function(b22) {
        if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b22;
      }, function(b22) {
        if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b22;
      });
      -1 === a2._status && (a2._status = 0, a2._result = b2);
    }
    if (1 === a2._status) return a2._result.default;
    throw a2._result;
  }
  var U = { current: null }, V2 = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V2, ReactCurrentOwner: K2 };
  function X() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S2, forEach: function(a2, b2, e2) {
    S2(a2, function() {
      b2.apply(this, arguments);
    }, e2);
  }, count: function(a2) {
    var b2 = 0;
    S2(a2, function() {
      b2++;
    });
    return b2;
  }, toArray: function(a2) {
    return S2(a2, function(a22) {
      return a22;
    }) || [];
  }, only: function(a2) {
    if (!O2(a2)) throw Error("React.Children.only expected to receive a single React element child.");
    return a2;
  } };
  react_production_min.Component = E2;
  react_production_min.Fragment = p2;
  react_production_min.Profiler = r2;
  react_production_min.PureComponent = G;
  react_production_min.StrictMode = q;
  react_production_min.Suspense = w2;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
  react_production_min.act = X;
  react_production_min.cloneElement = function(a2, b2, e2) {
    if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
    var d3 = C2({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
    if (null != b2) {
      void 0 !== b2.ref && (k2 = b2.ref, h2 = K2.current);
      void 0 !== b2.key && (c2 = "" + b2.key);
      if (a2.type && a2.type.defaultProps) var g2 = a2.type.defaultProps;
      for (f2 in b2) J.call(b2, f2) && !L3.hasOwnProperty(f2) && (d3[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
    }
    var f2 = arguments.length - 2;
    if (1 === f2) d3.children = e2;
    else if (1 < f2) {
      g2 = Array(f2);
      for (var m3 = 0; m3 < f2; m3++) g2[m3] = arguments[m3 + 2];
      d3.children = g2;
    }
    return { $$typeof: l2, type: a2.type, key: c2, ref: k2, props: d3, _owner: h2 };
  };
  react_production_min.createContext = function(a2) {
    a2 = { $$typeof: u2, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a2.Provider = { $$typeof: t2, _context: a2 };
    return a2.Consumer = a2;
  };
  react_production_min.createElement = M2;
  react_production_min.createFactory = function(a2) {
    var b2 = M2.bind(null, a2);
    b2.type = a2;
    return b2;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a2) {
    return { $$typeof: v2, render: a2 };
  };
  react_production_min.isValidElement = O2;
  react_production_min.lazy = function(a2) {
    return { $$typeof: y3, _payload: { _status: -1, _result: a2 }, _init: T2 };
  };
  react_production_min.memo = function(a2, b2) {
    return { $$typeof: x2, type: a2, compare: void 0 === b2 ? null : b2 };
  };
  react_production_min.startTransition = function(a2) {
    var b2 = V2.transition;
    V2.transition = {};
    try {
      a2();
    } finally {
      V2.transition = b2;
    }
  };
  react_production_min.unstable_act = X;
  react_production_min.useCallback = function(a2, b2) {
    return U.current.useCallback(a2, b2);
  };
  react_production_min.useContext = function(a2) {
    return U.current.useContext(a2);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a2) {
    return U.current.useDeferredValue(a2);
  };
  react_production_min.useEffect = function(a2, b2) {
    return U.current.useEffect(a2, b2);
  };
  react_production_min.useId = function() {
    return U.current.useId();
  };
  react_production_min.useImperativeHandle = function(a2, b2, e2) {
    return U.current.useImperativeHandle(a2, b2, e2);
  };
  react_production_min.useInsertionEffect = function(a2, b2) {
    return U.current.useInsertionEffect(a2, b2);
  };
  react_production_min.useLayoutEffect = function(a2, b2) {
    return U.current.useLayoutEffect(a2, b2);
  };
  react_production_min.useMemo = function(a2, b2) {
    return U.current.useMemo(a2, b2);
  };
  react_production_min.useReducer = function(a2, b2, e2) {
    return U.current.useReducer(a2, b2, e2);
  };
  react_production_min.useRef = function(a2) {
    return U.current.useRef(a2);
  };
  react_production_min.useState = function(a2) {
    return U.current.useState(a2);
  };
  react_production_min.useSyncExternalStore = function(a2, b2, e2) {
    return U.current.useSyncExternalStore(a2, b2, e2);
  };
  react_production_min.useTransition = function() {
    return U.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production_min();
  }
  return react.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f2 = requireReact(), k2 = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m3 = Object.prototype.hasOwnProperty, n3 = f2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p2 = { key: true, ref: true, __self: true, __source: true };
  function q(c2, a2, g2) {
    var b2, d3 = {}, e2 = null, h2 = null;
    void 0 !== g2 && (e2 = "" + g2);
    void 0 !== a2.key && (e2 = "" + a2.key);
    void 0 !== a2.ref && (h2 = a2.ref);
    for (b2 in a2) m3.call(a2, b2) && !p2.hasOwnProperty(b2) && (d3[b2] = a2[b2]);
    if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d3[b2] && (d3[b2] = a2[b2]);
    return { $$typeof: k2, type: c2, key: e2, ref: h2, props: d3, _owner: n3.current };
  }
  reactJsxRuntime_production_min.Fragment = l2;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports) {
    function f2(a2, b2) {
      var c2 = a2.length;
      a2.push(b2);
      a: for (; 0 < c2; ) {
        var d3 = c2 - 1 >>> 1, e2 = a2[d3];
        if (0 < g2(e2, b2)) a2[d3] = b2, a2[c2] = e2, c2 = d3;
        else break a;
      }
    }
    function h2(a2) {
      return 0 === a2.length ? null : a2[0];
    }
    function k2(a2) {
      if (0 === a2.length) return null;
      var b2 = a2[0], c2 = a2.pop();
      if (c2 !== b2) {
        a2[0] = c2;
        a: for (var d3 = 0, e2 = a2.length, w2 = e2 >>> 1; d3 < w2; ) {
          var m3 = 2 * (d3 + 1) - 1, C2 = a2[m3], n3 = m3 + 1, x2 = a2[n3];
          if (0 > g2(C2, c2)) n3 < e2 && 0 > g2(x2, C2) ? (a2[d3] = x2, a2[n3] = c2, d3 = n3) : (a2[d3] = C2, a2[m3] = c2, d3 = m3);
          else if (n3 < e2 && 0 > g2(x2, c2)) a2[d3] = x2, a2[n3] = c2, d3 = n3;
          else break a;
        }
      }
      return b2;
    }
    function g2(a2, b2) {
      var c2 = a2.sortIndex - b2.sortIndex;
      return 0 !== c2 ? c2 : a2.id - b2.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l2 = performance;
      exports.unstable_now = function() {
        return l2.now();
      };
    } else {
      var p2 = Date, q = p2.now();
      exports.unstable_now = function() {
        return p2.now() - q;
      };
    }
    var r2 = [], t2 = [], u2 = 1, v2 = null, y3 = 3, z3 = false, A2 = false, B3 = false, D = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a2) {
      for (var b2 = h2(t2); null !== b2; ) {
        if (null === b2.callback) k2(t2);
        else if (b2.startTime <= a2) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
        else break;
        b2 = h2(t2);
      }
    }
    function H2(a2) {
      B3 = false;
      G(a2);
      if (!A2) if (null !== h2(r2)) A2 = true, I2(J);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
    }
    function J(a2, b2) {
      A2 = false;
      B3 && (B3 = false, E2(L3), L3 = -1);
      z3 = true;
      var c2 = y3;
      try {
        G(b2);
        for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
          var d3 = v2.callback;
          if ("function" === typeof d3) {
            v2.callback = null;
            y3 = v2.priorityLevel;
            var e2 = d3(v2.expirationTime <= b2);
            b2 = exports.unstable_now();
            "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
            G(b2);
          } else k2(r2);
          v2 = h2(r2);
        }
        if (null !== v2) var w2 = true;
        else {
          var m3 = h2(t2);
          null !== m3 && K2(H2, m3.startTime - b2);
          w2 = false;
        }
        return w2;
      } finally {
        v2 = null, y3 = c2, z3 = false;
      }
    }
    var N2 = false, O2 = null, L3 = -1, P2 = 5, Q2 = -1;
    function M2() {
      return exports.unstable_now() - Q2 < P2 ? false : true;
    }
    function R2() {
      if (null !== O2) {
        var a2 = exports.unstable_now();
        Q2 = a2;
        var b2 = true;
        try {
          b2 = O2(true, a2);
        } finally {
          b2 ? S2() : (N2 = false, O2 = null);
        }
      } else N2 = false;
    }
    var S2;
    if ("function" === typeof F) S2 = function() {
      F(R2);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T2 = new MessageChannel(), U = T2.port2;
      T2.port1.onmessage = R2;
      S2 = function() {
        U.postMessage(null);
      };
    } else S2 = function() {
      D(R2, 0);
    };
    function I2(a2) {
      O2 = a2;
      N2 || (N2 = true, S2());
    }
    function K2(a2, b2) {
      L3 = D(function() {
        a2(exports.unstable_now());
      }, b2);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a2) {
      a2.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A2 || z3 || (A2 = true, I2(J));
    };
    exports.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y3;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h2(r2);
    };
    exports.unstable_next = function(a2) {
      switch (y3) {
        case 1:
        case 2:
        case 3:
          var b2 = 3;
          break;
        default:
          b2 = y3;
      }
      var c2 = y3;
      y3 = b2;
      try {
        return a2();
      } finally {
        y3 = c2;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a2, b2) {
      switch (a2) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a2 = 3;
      }
      var c2 = y3;
      y3 = a2;
      try {
        return b2();
      } finally {
        y3 = c2;
      }
    };
    exports.unstable_scheduleCallback = function(a2, b2, c2) {
      var d3 = exports.unstable_now();
      "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d3 + c2 : d3) : c2 = d3;
      switch (a2) {
        case 1:
          var e2 = -1;
          break;
        case 2:
          e2 = 250;
          break;
        case 5:
          e2 = 1073741823;
          break;
        case 4:
          e2 = 1e4;
          break;
        default:
          e2 = 5e3;
      }
      e2 = c2 + e2;
      a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
      c2 > d3 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B3 ? (E2(L3), L3 = -1) : B3 = true, K2(H2, c2 - d3))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z3 || (A2 = true, I2(J)));
      return a2;
    };
    exports.unstable_shouldYield = M2;
    exports.unstable_wrapCallback = function(a2) {
      var b2 = y3;
      return function() {
        var c2 = y3;
        y3 = b2;
        try {
          return a2.apply(this, arguments);
        } finally {
          y3 = c2;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production_min();
  }
  return scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa2 = requireReact(), ca2 = requireScheduler();
  function p2(a2) {
    for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da2 = /* @__PURE__ */ new Set(), ea2 = {};
  function fa2(a2, b2) {
    ha2(a2, b2);
    ha2(a2 + "Capture", b2);
  }
  function ha2(a2, b2) {
    ea2[a2] = b2;
    for (a2 = 0; a2 < b2.length; a2++) da2.add(b2[a2]);
  }
  var ia2 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja2 = Object.prototype.hasOwnProperty, ka2 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la2 = {}, ma2 = {};
  function oa2(a2) {
    if (ja2.call(ma2, a2)) return true;
    if (ja2.call(la2, a2)) return false;
    if (ka2.test(a2)) return ma2[a2] = true;
    la2[a2] = true;
    return false;
  }
  function pa2(a2, b2, c2, d3) {
    if (null !== c2 && 0 === c2.type) return false;
    switch (typeof b2) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d3) return false;
        if (null !== c2) return !c2.acceptsBooleans;
        a2 = a2.toLowerCase().slice(0, 5);
        return "data-" !== a2 && "aria-" !== a2;
      default:
        return false;
    }
  }
  function qa2(a2, b2, c2, d3) {
    if (null === b2 || "undefined" === typeof b2 || pa2(a2, b2, c2, d3)) return true;
    if (d3) return false;
    if (null !== c2) switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
    return false;
  }
  function v2(a2, b2, c2, d3, e2, f2, g2) {
    this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
    this.attributeName = d3;
    this.attributeNamespace = e2;
    this.mustUseProperty = c2;
    this.propertyName = a2;
    this.type = b2;
    this.sanitizeURL = f2;
    this.removeEmptyString = g2;
  }
  var z3 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
    z3[a2] = new v2(a2, 0, false, a2, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
    var b2 = a2[0];
    z3[b2] = new v2(b2, 1, false, a2[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
    z3[a2] = new v2(a2, 2, false, a2.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
    z3[a2] = new v2(a2, 2, false, a2, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
    z3[a2] = new v2(a2, 3, false, a2.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
    z3[a2] = new v2(a2, 3, true, a2, null, false, false);
  });
  ["capture", "download"].forEach(function(a2) {
    z3[a2] = new v2(a2, 4, false, a2, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a2) {
    z3[a2] = new v2(a2, 6, false, a2, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a2) {
    z3[a2] = new v2(a2, 5, false, a2.toLowerCase(), null, false, false);
  });
  var ra2 = /[\-:]([a-z])/g;
  function sa2(a2) {
    return a2[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
    var b2 = a2.replace(
      ra2,
      sa2
    );
    z3[b2] = new v2(b2, 1, false, a2, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
    var b2 = a2.replace(ra2, sa2);
    z3[b2] = new v2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
    var b2 = a2.replace(ra2, sa2);
    z3[b2] = new v2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a2) {
    z3[a2] = new v2(a2, 1, false, a2.toLowerCase(), null, false, false);
  });
  z3.xlinkHref = new v2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a2) {
    z3[a2] = new v2(a2, 1, false, a2.toLowerCase(), null, true, true);
  });
  function ta2(a2, b2, c2, d3) {
    var e2 = z3.hasOwnProperty(b2) ? z3[b2] : null;
    if (null !== e2 ? 0 !== e2.type : d3 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa2(b2, c2, e2, d3) && (c2 = null), d3 || null === e2 ? oa2(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d3 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d3 ? a2.setAttributeNS(d3, b2, c2) : a2.setAttribute(b2, c2)));
  }
  var ua2 = aa2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va2 = Symbol.for("react.element"), wa2 = Symbol.for("react.portal"), ya2 = Symbol.for("react.fragment"), za2 = Symbol.for("react.strict_mode"), Aa2 = Symbol.for("react.profiler"), Ba2 = Symbol.for("react.provider"), Ca2 = Symbol.for("react.context"), Da2 = Symbol.for("react.forward_ref"), Ea2 = Symbol.for("react.suspense"), Fa2 = Symbol.for("react.suspense_list"), Ga2 = Symbol.for("react.memo"), Ha2 = Symbol.for("react.lazy");
  var Ia2 = Symbol.for("react.offscreen");
  var Ja2 = Symbol.iterator;
  function Ka2(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = Ja2 && a2[Ja2] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var A2 = Object.assign, La2;
  function Ma2(a2) {
    if (void 0 === La2) try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La2 = b2 && b2[1] || "";
    }
    return "\n" + La2 + a2;
  }
  var Na2 = false;
  function Oa2(a2, b2) {
    if (!a2 || Na2) return "";
    Na2 = true;
    var c2 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b2) if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d3 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d3 = l2;
        }
        a2.call(b2.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l2) {
          d3 = l2;
        }
        a2();
      }
    } catch (l2) {
      if (l2 && d3 && "string" === typeof l2.stack) {
        for (var e2 = l2.stack.split("\n"), f2 = d3.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; ) h2--;
        for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
      }
    } finally {
      Na2 = false, Error.prepareStackTrace = c2;
    }
    return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma2(a2) : "";
  }
  function Pa2(a2) {
    switch (a2.tag) {
      case 5:
        return Ma2(a2.type);
      case 16:
        return Ma2("Lazy");
      case 13:
        return Ma2("Suspense");
      case 19:
        return Ma2("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a2 = Oa2(a2.type, false), a2;
      case 11:
        return a2 = Oa2(a2.type.render, false), a2;
      case 1:
        return a2 = Oa2(a2.type, true), a2;
      default:
        return "";
    }
  }
  function Qa2(a2) {
    if (null == a2) return null;
    if ("function" === typeof a2) return a2.displayName || a2.name || null;
    if ("string" === typeof a2) return a2;
    switch (a2) {
      case ya2:
        return "Fragment";
      case wa2:
        return "Portal";
      case Aa2:
        return "Profiler";
      case za2:
        return "StrictMode";
      case Ea2:
        return "Suspense";
      case Fa2:
        return "SuspenseList";
    }
    if ("object" === typeof a2) switch (a2.$$typeof) {
      case Ca2:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba2:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da2:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga2:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa2(a2.type) || "Memo";
      case Ha2:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa2(a2(b2));
        } catch (c2) {
        }
    }
    return null;
  }
  function Ra2(a2) {
    var b2 = a2.type;
    switch (a2.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b2.displayName || "Context") + ".Consumer";
      case 10:
        return (b2._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b2;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa2(b2);
      case 8:
        return b2 === za2 ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b2) return b2.displayName || b2.name || null;
        if ("string" === typeof b2) return b2;
    }
    return null;
  }
  function Sa2(a2) {
    switch (typeof a2) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a2;
      case "object":
        return a2;
      default:
        return "";
    }
  }
  function Ta2(a2) {
    var b2 = a2.type;
    return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
  }
  function Ua2(a2) {
    var b2 = Ta2(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d3 = "" + a2[b2];
    if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
      var e2 = c2.get, f2 = c2.set;
      Object.defineProperty(a2, b2, { configurable: true, get: function() {
        return e2.call(this);
      }, set: function(a3) {
        d3 = "" + a3;
        f2.call(this, a3);
      } });
      Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
      return { getValue: function() {
        return d3;
      }, setValue: function(a3) {
        d3 = "" + a3;
      }, stopTracking: function() {
        a2._valueTracker = null;
        delete a2[b2];
      } };
    }
  }
  function Va2(a2) {
    a2._valueTracker || (a2._valueTracker = Ua2(a2));
  }
  function Wa(a2) {
    if (!a2) return false;
    var b2 = a2._valueTracker;
    if (!b2) return true;
    var c2 = b2.getValue();
    var d3 = "";
    a2 && (d3 = Ta2(a2) ? a2.checked ? "true" : "false" : a2.value);
    a2 = d3;
    return a2 !== c2 ? (b2.setValue(a2), true) : false;
  }
  function Xa(a2) {
    a2 = a2 || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a2) return null;
    try {
      return a2.activeElement || a2.body;
    } catch (b2) {
      return a2.body;
    }
  }
  function Ya2(a2, b2) {
    var c2 = b2.checked;
    return A2({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
  }
  function Za(a2, b2) {
    var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d3 = null != b2.checked ? b2.checked : b2.defaultChecked;
    c2 = Sa2(null != b2.value ? b2.value : c2);
    a2._wrapperState = { initialChecked: d3, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
  }
  function ab(a2, b2) {
    b2 = b2.checked;
    null != b2 && ta2(a2, "checked", b2, false);
  }
  function bb(a2, b2) {
    ab(a2, b2);
    var c2 = Sa2(b2.value), d3 = b2.type;
    if (null != c2) if ("number" === d3) {
      if (0 === c2 && "" === a2.value || a2.value != c2) a2.value = "" + c2;
    } else a2.value !== "" + c2 && (a2.value = "" + c2);
    else if ("submit" === d3 || "reset" === d3) {
      a2.removeAttribute("value");
      return;
    }
    b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa2(b2.defaultValue));
    null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
  }
  function db(a2, b2, c2) {
    if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
      var d3 = b2.type;
      if (!("submit" !== d3 && "reset" !== d3 || void 0 !== b2.value && null !== b2.value)) return;
      b2 = "" + a2._wrapperState.initialValue;
      c2 || b2 === a2.value || (a2.value = b2);
      a2.defaultValue = b2;
    }
    c2 = a2.name;
    "" !== c2 && (a2.name = "");
    a2.defaultChecked = !!a2._wrapperState.initialChecked;
    "" !== c2 && (a2.name = c2);
  }
  function cb(a2, b2, c2) {
    if ("number" !== b2 || Xa(a2.ownerDocument) !== a2) null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
  }
  var eb = Array.isArray;
  function fb(a2, b2, c2, d3) {
    a2 = a2.options;
    if (b2) {
      b2 = {};
      for (var e2 = 0; e2 < c2.length; e2++) b2["$" + c2[e2]] = true;
      for (c2 = 0; c2 < a2.length; c2++) e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d3 && (a2[c2].defaultSelected = true);
    } else {
      c2 = "" + Sa2(c2);
      b2 = null;
      for (e2 = 0; e2 < a2.length; e2++) {
        if (a2[e2].value === c2) {
          a2[e2].selected = true;
          d3 && (a2[e2].defaultSelected = true);
          return;
        }
        null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
      }
      null !== b2 && (b2.selected = true);
    }
  }
  function gb(a2, b2) {
    if (null != b2.dangerouslySetInnerHTML) throw Error(p2(91));
    return A2({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
  }
  function hb(a2, b2) {
    var c2 = b2.value;
    if (null == c2) {
      c2 = b2.children;
      b2 = b2.defaultValue;
      if (null != c2) {
        if (null != b2) throw Error(p2(92));
        if (eb(c2)) {
          if (1 < c2.length) throw Error(p2(93));
          c2 = c2[0];
        }
        b2 = c2;
      }
      null == b2 && (b2 = "");
      c2 = b2;
    }
    a2._wrapperState = { initialValue: Sa2(c2) };
  }
  function ib(a2, b2) {
    var c2 = Sa2(b2.value), d3 = Sa2(b2.defaultValue);
    null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
    null != d3 && (a2.defaultValue = "" + d3);
  }
  function jb(a2) {
    var b2 = a2.textContent;
    b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
  }
  function kb(a2) {
    switch (a2) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a2, b2) {
    return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
  }
  var mb, nb = (function(a2) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d3, e2) {
      MSApp.execUnsafeLocalFunction(function() {
        return a2(b2, c2, d3, e2);
      });
    } : a2;
  })(function(a2, b2) {
    if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b2;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
      for (b2 = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
      for (; b2.firstChild; ) a2.appendChild(b2.firstChild);
    }
  });
  function ob(a2, b2) {
    if (b2) {
      var c2 = a2.firstChild;
      if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
        c2.nodeValue = b2;
        return;
      }
    }
    a2.textContent = b2;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a2) {
    qb.forEach(function(b2) {
      b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
      pb[b2] = pb[a2];
    });
  });
  function rb(a2, b2, c2) {
    return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
  }
  function sb(a2, b2) {
    a2 = a2.style;
    for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
      var d3 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d3);
      "float" === c2 && (c2 = "cssFloat");
      d3 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
  }
  var tb = A2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a2, b2) {
    if (b2) {
      if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p2(137, a2));
      if (null != b2.dangerouslySetInnerHTML) {
        if (null != b2.children) throw Error(p2(60));
        if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p2(61));
      }
      if (null != b2.style && "object" !== typeof b2.style) throw Error(p2(62));
    }
  }
  function vb(a2, b2) {
    if (-1 === a2.indexOf("-")) return "string" === typeof b2.is;
    switch (a2) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a2) {
    a2 = a2.target || a2.srcElement || window;
    a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
    return 3 === a2.nodeType ? a2.parentNode : a2;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a2) {
    if (a2 = Cb(a2)) {
      if ("function" !== typeof yb) throw Error(p2(280));
      var b2 = a2.stateNode;
      b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
    }
  }
  function Eb(a2) {
    zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
  }
  function Fb() {
    if (zb) {
      var a2 = zb, b2 = Ab;
      Ab = zb = null;
      Bb(a2);
      if (b2) for (a2 = 0; a2 < b2.length; a2++) Bb(b2[a2]);
    }
  }
  function Gb(a2, b2) {
    return a2(b2);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a2, b2, c2) {
    if (Ib) return a2(b2, c2);
    Ib = true;
    try {
      return Gb(a2, b2, c2);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a2, b2) {
    var c2 = a2.stateNode;
    if (null === c2) return null;
    var d3 = Db(c2);
    if (null === d3) return null;
    c2 = d3[b2];
    a: switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d3 = !d3.disabled) || (a2 = a2.type, d3 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d3;
        break a;
      default:
        a2 = false;
    }
    if (a2) return null;
    if (c2 && "function" !== typeof c2) throw Error(p2(231, b2, typeof c2));
    return c2;
  }
  var Lb = false;
  if (ia2) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
  function Nb(a2, b2, c2, d3, e2, f2, g2, h2, k2) {
    var l2 = Array.prototype.slice.call(arguments, 3);
    try {
      b2.apply(c2, l2);
    } catch (m3) {
      this.onError(m3);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
    Ob = true;
    Pb = a2;
  } };
  function Tb(a2, b2, c2, d3, e2, f2, g2, h2, k2) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a2, b2, c2, d3, e2, f2, g2, h2, k2) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l2 = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p2(198));
      Qb || (Qb = true, Rb = l2);
    }
  }
  function Vb(a2) {
    var b2 = a2, c2 = a2;
    if (a2.alternate) for (; b2.return; ) b2 = b2.return;
    else {
      a2 = b2;
      do
        b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
      while (a2);
    }
    return 3 === b2.tag ? c2 : null;
  }
  function Wb(a2) {
    if (13 === a2.tag) {
      var b2 = a2.memoizedState;
      null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
      if (null !== b2) return b2.dehydrated;
    }
    return null;
  }
  function Xb(a2) {
    if (Vb(a2) !== a2) throw Error(p2(188));
  }
  function Yb(a2) {
    var b2 = a2.alternate;
    if (!b2) {
      b2 = Vb(a2);
      if (null === b2) throw Error(p2(188));
      return b2 !== a2 ? null : a2;
    }
    for (var c2 = a2, d3 = b2; ; ) {
      var e2 = c2.return;
      if (null === e2) break;
      var f2 = e2.alternate;
      if (null === f2) {
        d3 = e2.return;
        if (null !== d3) {
          c2 = d3;
          continue;
        }
        break;
      }
      if (e2.child === f2.child) {
        for (f2 = e2.child; f2; ) {
          if (f2 === c2) return Xb(e2), a2;
          if (f2 === d3) return Xb(e2), b2;
          f2 = f2.sibling;
        }
        throw Error(p2(188));
      }
      if (c2.return !== d3.return) c2 = e2, d3 = f2;
      else {
        for (var g2 = false, h2 = e2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = e2;
            d3 = f2;
            break;
          }
          if (h2 === d3) {
            g2 = true;
            d3 = e2;
            c2 = f2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) {
          for (h2 = f2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = f2;
              d3 = e2;
              break;
            }
            if (h2 === d3) {
              g2 = true;
              d3 = f2;
              c2 = e2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) throw Error(p2(189));
        }
      }
      if (c2.alternate !== d3) throw Error(p2(190));
    }
    if (3 !== c2.tag) throw Error(p2(188));
    return c2.stateNode.current === c2 ? a2 : b2;
  }
  function Zb(a2) {
    a2 = Yb(a2);
    return null !== a2 ? $b(a2) : null;
  }
  function $b(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2;
    for (a2 = a2.child; null !== a2; ) {
      var b2 = $b(a2);
      if (null !== b2) return b2;
      a2 = a2.sibling;
    }
    return null;
  }
  var ac = ca2.unstable_scheduleCallback, bc = ca2.unstable_cancelCallback, cc = ca2.unstable_shouldYield, dc = ca2.unstable_requestPaint, B3 = ca2.unstable_now, ec2 = ca2.unstable_getCurrentPriorityLevel, fc = ca2.unstable_ImmediatePriority, gc = ca2.unstable_UserBlockingPriority, hc = ca2.unstable_NormalPriority, ic = ca2.unstable_LowPriority, jc = ca2.unstable_IdlePriority, kc = null, lc = null;
  function mc(a2) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a2) {
    a2 >>>= 0;
    return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a2) {
    switch (a2 & -a2) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a2 & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a2 & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a2;
    }
  }
  function uc(a2, b2) {
    var c2 = a2.pendingLanes;
    if (0 === c2) return 0;
    var d3 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
    if (0 !== g2) {
      var h2 = g2 & ~e2;
      0 !== h2 ? d3 = tc(h2) : (f2 &= g2, 0 !== f2 && (d3 = tc(f2)));
    } else g2 = c2 & ~e2, 0 !== g2 ? d3 = tc(g2) : 0 !== f2 && (d3 = tc(f2));
    if (0 === d3) return 0;
    if (0 !== b2 && b2 !== d3 && 0 === (b2 & e2) && (e2 = d3 & -d3, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240))) return b2;
    0 !== (d3 & 4) && (d3 |= c2 & 16);
    b2 = a2.entangledLanes;
    if (0 !== b2) for (a2 = a2.entanglements, b2 &= d3; 0 < b2; ) c2 = 31 - oc(b2), e2 = 1 << c2, d3 |= a2[c2], b2 &= ~e2;
    return d3;
  }
  function vc(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 4:
        return b2 + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b2 + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a2, b2) {
    for (var c2 = a2.suspendedLanes, d3 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
      var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
      if (-1 === k2) {
        if (0 === (h2 & c2) || 0 !== (h2 & d3)) e2[g2] = vc(h2, b2);
      } else k2 <= b2 && (a2.expiredLanes |= h2);
      f2 &= ~h2;
    }
  }
  function xc(a2) {
    a2 = a2.pendingLanes & -1073741825;
    return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a2 = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a2;
  }
  function zc(a2) {
    for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a2);
    return b2;
  }
  function Ac(a2, b2, c2) {
    a2.pendingLanes |= b2;
    536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
    a2 = a2.eventTimes;
    b2 = 31 - oc(b2);
    a2[b2] = c2;
  }
  function Bc(a2, b2) {
    var c2 = a2.pendingLanes & ~b2;
    a2.pendingLanes = b2;
    a2.suspendedLanes = 0;
    a2.pingedLanes = 0;
    a2.expiredLanes &= b2;
    a2.mutableReadLanes &= b2;
    a2.entangledLanes &= b2;
    b2 = a2.entanglements;
    var d3 = a2.eventTimes;
    for (a2 = a2.expirationTimes; 0 < c2; ) {
      var e2 = 31 - oc(c2), f2 = 1 << e2;
      b2[e2] = 0;
      d3[e2] = -1;
      a2[e2] = -1;
      c2 &= ~f2;
    }
  }
  function Cc(a2, b2) {
    var c2 = a2.entangledLanes |= b2;
    for (a2 = a2.entanglements; c2; ) {
      var d3 = 31 - oc(c2), e2 = 1 << d3;
      e2 & b2 | a2[d3] & b2 && (a2[d3] |= b2);
      c2 &= ~e2;
    }
  }
  var C2 = 0;
  function Dc(a2) {
    a2 &= -a2;
    return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a2, b2) {
    switch (a2) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b2.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b2.pointerId);
    }
  }
  function Tc(a2, b2, c2, d3, e2, f2) {
    if (null === a2 || a2.nativeEvent !== f2) return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d3, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
    a2.eventSystemFlags |= d3;
    b2 = a2.targetContainers;
    null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
    return a2;
  }
  function Uc(a2, b2, c2, d3, e2) {
    switch (b2) {
      case "focusin":
        return Lc = Tc(Lc, a2, b2, c2, d3, e2), true;
      case "dragenter":
        return Mc = Tc(Mc, a2, b2, c2, d3, e2), true;
      case "mouseover":
        return Nc = Tc(Nc, a2, b2, c2, d3, e2), true;
      case "pointerover":
        var f2 = e2.pointerId;
        Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d3, e2));
        return true;
      case "gotpointercapture":
        return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d3, e2)), true;
    }
    return false;
  }
  function Vc(a2) {
    var b2 = Wc(a2.target);
    if (null !== b2) {
      var c2 = Vb(b2);
      if (null !== c2) {
        if (b2 = c2.tag, 13 === b2) {
          if (b2 = Wb(c2), null !== b2) {
            a2.blockedOn = b2;
            Ic(a2.priority, function() {
              Gc(c2);
            });
            return;
          }
        } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
          a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a2.blockedOn = null;
  }
  function Xc(a2) {
    if (null !== a2.blockedOn) return false;
    for (var b2 = a2.targetContainers; 0 < b2.length; ) {
      var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
      if (null === c2) {
        c2 = a2.nativeEvent;
        var d3 = new c2.constructor(c2.type, c2);
        wb = d3;
        c2.target.dispatchEvent(d3);
        wb = null;
      } else return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
      b2.shift();
    }
    return true;
  }
  function Zc(a2, b2, c2) {
    Xc(a2) && c2.delete(b2);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a2, b2) {
    a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca2.unstable_scheduleCallback(ca2.unstable_NormalPriority, $c)));
  }
  function bd(a2) {
    function b2(b3) {
      return ad(b3, a2);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a2);
      for (var c2 = 1; c2 < Kc.length; c2++) {
        var d3 = Kc[c2];
        d3.blockedOn === a2 && (d3.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a2);
    null !== Mc && ad(Mc, a2);
    null !== Nc && ad(Nc, a2);
    Oc.forEach(b2);
    Pc.forEach(b2);
    for (c2 = 0; c2 < Qc.length; c2++) d3 = Qc[c2], d3.blockedOn === a2 && (d3.blockedOn = null);
    for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
  }
  var cd = ua2.ReactCurrentBatchConfig, dd = true;
  function ed(a2, b2, c2, d3) {
    var e2 = C2, f2 = cd.transition;
    cd.transition = null;
    try {
      C2 = 1, fd(a2, b2, c2, d3);
    } finally {
      C2 = e2, cd.transition = f2;
    }
  }
  function gd(a2, b2, c2, d3) {
    var e2 = C2, f2 = cd.transition;
    cd.transition = null;
    try {
      C2 = 4, fd(a2, b2, c2, d3);
    } finally {
      C2 = e2, cd.transition = f2;
    }
  }
  function fd(a2, b2, c2, d3) {
    if (dd) {
      var e2 = Yc(a2, b2, c2, d3);
      if (null === e2) hd(a2, b2, d3, id, c2), Sc(a2, d3);
      else if (Uc(e2, a2, b2, c2, d3)) d3.stopPropagation();
      else if (Sc(a2, d3), b2 & 4 && -1 < Rc.indexOf(a2)) {
        for (; null !== e2; ) {
          var f2 = Cb(e2);
          null !== f2 && Ec(f2);
          f2 = Yc(a2, b2, c2, d3);
          null === f2 && hd(a2, b2, d3, id, c2);
          if (f2 === e2) break;
          e2 = f2;
        }
        null !== e2 && d3.stopPropagation();
      } else hd(a2, b2, d3, null, c2);
    }
  }
  var id = null;
  function Yc(a2, b2, c2, d3) {
    id = null;
    a2 = xb(d3);
    a2 = Wc(a2);
    if (null !== a2) if (b2 = Vb(a2), null === b2) a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2) return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else b2 !== a2 && (a2 = null);
    id = a2;
    return null;
  }
  function jd(a2) {
    switch (a2) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec2()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a2, b2 = ld, c2 = b2.length, d3, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
    for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++) ;
    var g2 = c2 - a2;
    for (d3 = 1; d3 <= g2 && b2[c2 - d3] === e2[f2 - d3]; d3++) ;
    return md = e2.slice(a2, 1 < d3 ? 1 - d3 : void 0);
  }
  function od(a2) {
    var b2 = a2.keyCode;
    "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
    10 === a2 && (a2 = 13);
    return 32 <= a2 || 13 === a2 ? a2 : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a2) {
    function b2(b3, d3, e2, f2, g2) {
      this._reactName = b3;
      this._targetInst = e2;
      this.type = d3;
      this.nativeEvent = f2;
      this.target = g2;
      this.currentTarget = null;
      for (var c2 in a2) a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
      this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A2(b2.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a3 = this.nativeEvent;
      a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a3 = this.nativeEvent;
      a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b2;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
    return a2.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A2({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
    return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
  }, movementX: function(a2) {
    if ("movementX" in a2) return a2.movementX;
    a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
    return wd;
  }, movementY: function(a2) {
    return "movementY" in a2 ? a2.movementY : xd;
  } }), Bd = rd(Ad), Cd = A2({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A2({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A2({}, sd, { clipboardData: function(a2) {
    return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A2({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a2) {
    var b2 = this.nativeEvent;
    return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A2({}, ud, { key: function(a2) {
    if (a2.key) {
      var b2 = Md[a2.key] || a2.key;
      if ("Unidentified" !== b2) return b2;
    }
    return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
    return "keypress" === a2.type ? od(a2) : 0;
  }, keyCode: function(a2) {
    return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  }, which: function(a2) {
    return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A2({}, Ad, {
    deltaX: function(a2) {
      return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
    },
    deltaY: function(a2) {
      return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae2 = ia2 && "CompositionEvent" in window, be2 = null;
  ia2 && "documentMode" in document && (be2 = document.documentMode);
  var ce2 = ia2 && "TextEvent" in window && !be2, de2 = ia2 && (!ae2 || be2 && 8 < be2 && 11 >= be2), ee2 = String.fromCharCode(32), fe2 = false;
  function ge(a2, b2) {
    switch (a2) {
      case "keyup":
        return -1 !== $d.indexOf(b2.keyCode);
      case "keydown":
        return 229 !== b2.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he2(a2) {
    a2 = a2.detail;
    return "object" === typeof a2 && "data" in a2 ? a2.data : null;
  }
  var ie2 = false;
  function je(a2, b2) {
    switch (a2) {
      case "compositionend":
        return he2(b2);
      case "keypress":
        if (32 !== b2.which) return null;
        fe2 = true;
        return ee2;
      case "textInput":
        return a2 = b2.data, a2 === ee2 && fe2 ? null : a2;
      default:
        return null;
    }
  }
  function ke(a2, b2) {
    if (ie2) return "compositionend" === a2 || !ae2 && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie2 = false, a2) : null;
    switch (a2) {
      case "paste":
        return null;
      case "keypress":
        if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
          if (b2.char && 1 < b2.char.length) return b2.char;
          if (b2.which) return String.fromCharCode(b2.which);
        }
        return null;
      case "compositionend":
        return de2 && "ko" !== b2.locale ? null : b2.data;
      default:
        return null;
    }
  }
  var le2 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a2) {
    var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return "input" === b2 ? !!le2[a2.type] : "textarea" === b2 ? true : false;
  }
  function ne2(a2, b2, c2, d3) {
    Eb(d3);
    b2 = oe2(b2, "onChange");
    0 < b2.length && (c2 = new td("onChange", "change", null, c2, d3), a2.push({ event: c2, listeners: b2 }));
  }
  var pe2 = null, qe = null;
  function re2(a2) {
    se2(a2, 0);
  }
  function te2(a2) {
    var b2 = ue2(a2);
    if (Wa(b2)) return a2;
  }
  function ve(a2, b2) {
    if ("change" === a2) return b2;
  }
  var we2 = false;
  if (ia2) {
    var xe;
    if (ia2) {
      var ye2 = "oninput" in document;
      if (!ye2) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye2 = "function" === typeof ze.oninput;
      }
      xe = ye2;
    } else xe = false;
    we2 = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae2() {
    pe2 && (pe2.detachEvent("onpropertychange", Be2), qe = pe2 = null);
  }
  function Be2(a2) {
    if ("value" === a2.propertyName && te2(qe)) {
      var b2 = [];
      ne2(b2, qe, a2, xb(a2));
      Jb(re2, b2);
    }
  }
  function Ce2(a2, b2, c2) {
    "focusin" === a2 ? (Ae2(), pe2 = b2, qe = c2, pe2.attachEvent("onpropertychange", Be2)) : "focusout" === a2 && Ae2();
  }
  function De(a2) {
    if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te2(qe);
  }
  function Ee(a2, b2) {
    if ("click" === a2) return te2(b2);
  }
  function Fe(a2, b2) {
    if ("input" === a2 || "change" === a2) return te2(b2);
  }
  function Ge(a2, b2) {
    return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a2, b2) {
    if (He(a2, b2)) return true;
    if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2) return false;
    var c2 = Object.keys(a2), d3 = Object.keys(b2);
    if (c2.length !== d3.length) return false;
    for (d3 = 0; d3 < c2.length; d3++) {
      var e2 = c2[d3];
      if (!ja2.call(b2, e2) || !He(a2[e2], b2[e2])) return false;
    }
    return true;
  }
  function Je(a2) {
    for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
    return a2;
  }
  function Ke(a2, b2) {
    var c2 = Je(a2);
    a2 = 0;
    for (var d3; c2; ) {
      if (3 === c2.nodeType) {
        d3 = a2 + c2.textContent.length;
        if (a2 <= b2 && d3 >= b2) return { node: c2, offset: b2 - a2 };
        a2 = d3;
      }
      a: {
        for (; c2; ) {
          if (c2.nextSibling) {
            c2 = c2.nextSibling;
            break a;
          }
          c2 = c2.parentNode;
        }
        c2 = void 0;
      }
      c2 = Je(c2);
    }
  }
  function Le(a2, b2) {
    return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
  }
  function Me() {
    for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
      try {
        var c2 = "string" === typeof b2.contentWindow.location.href;
      } catch (d3) {
        c2 = false;
      }
      if (c2) a2 = b2.contentWindow;
      else break;
      b2 = Xa(a2.document);
    }
    return b2;
  }
  function Ne(a2) {
    var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
  }
  function Oe(a2) {
    var b2 = Me(), c2 = a2.focusedElem, d3 = a2.selectionRange;
    if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
      if (null !== d3 && Ne(c2)) {
        if (b2 = d3.start, a2 = d3.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
        else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
          a2 = a2.getSelection();
          var e2 = c2.textContent.length, f2 = Math.min(d3.start, e2);
          d3 = void 0 === d3.end ? f2 : Math.min(d3.end, e2);
          !a2.extend && f2 > d3 && (e2 = d3, d3 = f2, f2 = e2);
          e2 = Ke(c2, f2);
          var g2 = Ke(
            c2,
            d3
          );
          e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d3 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
        }
      }
      b2 = [];
      for (a2 = c2; a2 = a2.parentNode; ) 1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
      "function" === typeof c2.focus && c2.focus();
      for (c2 = 0; c2 < b2.length; c2++) a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
    }
  }
  var Pe = ia2 && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re2 = null, Se = null, Te = false;
  function Ue(a2, b2, c2) {
    var d3 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
    Te || null == Qe || Qe !== Xa(d3) || (d3 = Qe, "selectionStart" in d3 && Ne(d3) ? d3 = { start: d3.selectionStart, end: d3.selectionEnd } : (d3 = (d3.ownerDocument && d3.ownerDocument.defaultView || window).getSelection(), d3 = { anchorNode: d3.anchorNode, anchorOffset: d3.anchorOffset, focusNode: d3.focusNode, focusOffset: d3.focusOffset }), Se && Ie(Se, d3) || (Se = d3, d3 = oe2(Re2, "onSelect"), 0 < d3.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d3 }), b2.target = Qe)));
  }
  function Ve(a2, b2) {
    var c2 = {};
    c2[a2.toLowerCase()] = b2.toLowerCase();
    c2["Webkit" + a2] = "webkit" + b2;
    c2["Moz" + a2] = "moz" + b2;
    return c2;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe2 = {}, Ye = {};
  ia2 && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze2(a2) {
    if (Xe2[a2]) return Xe2[a2];
    if (!We[a2]) return a2;
    var b2 = We[a2], c2;
    for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye) return Xe2[a2] = b2[c2];
    return a2;
  }
  var $e = Ze2("animationend"), af2 = Ze2("animationiteration"), bf2 = Ze2("animationstart"), cf = Ze2("transitionend"), df2 = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a2, b2) {
    df2.set(a2, b2);
    fa2(b2, [a2]);
  }
  for (var gf2 = 0; gf2 < ef.length; gf2++) {
    var hf = ef[gf2], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af2, "onAnimationIteration");
  ff(bf2, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha2("onMouseEnter", ["mouseout", "mouseover"]);
  ha2("onMouseLeave", ["mouseout", "mouseover"]);
  ha2("onPointerEnter", ["pointerout", "pointerover"]);
  ha2("onPointerLeave", ["pointerout", "pointerover"]);
  fa2("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa2("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa2("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa2("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa2("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa2("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf2 = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf2 = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf2));
  function nf2(a2, b2, c2) {
    var d3 = a2.type || "unknown-event";
    a2.currentTarget = c2;
    Ub(d3, b2, void 0, a2);
    a2.currentTarget = null;
  }
  function se2(a2, b2) {
    b2 = 0 !== (b2 & 4);
    for (var c2 = 0; c2 < a2.length; c2++) {
      var d3 = a2[c2], e2 = d3.event;
      d3 = d3.listeners;
      a: {
        var f2 = void 0;
        if (b2) for (var g2 = d3.length - 1; 0 <= g2; g2--) {
          var h2 = d3[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped()) break a;
          nf2(e2, h2, l2);
          f2 = k2;
        }
        else for (g2 = 0; g2 < d3.length; g2++) {
          h2 = d3[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped()) break a;
          nf2(e2, h2, l2);
          f2 = k2;
        }
      }
    }
    if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
  }
  function D(a2, b2) {
    var c2 = b2[of2];
    void 0 === c2 && (c2 = b2[of2] = /* @__PURE__ */ new Set());
    var d3 = a2 + "__bubble";
    c2.has(d3) || (pf2(b2, a2, 2, false), c2.add(d3));
  }
  function qf2(a2, b2, c2) {
    var d3 = 0;
    b2 && (d3 |= 4);
    pf2(c2, a2, d3, b2);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf2(a2) {
    if (!a2[rf]) {
      a2[rf] = true;
      da2.forEach(function(b3) {
        "selectionchange" !== b3 && (mf2.has(b3) || qf2(b3, false, a2), qf2(b3, true, a2));
      });
      var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
      null === b2 || b2[rf] || (b2[rf] = true, qf2("selectionchange", false, b2));
    }
  }
  function pf2(a2, b2, c2, d3) {
    switch (jd(b2)) {
      case 1:
        var e2 = ed;
        break;
      case 4:
        e2 = gd;
        break;
      default:
        e2 = fd;
    }
    c2 = e2.bind(null, b2, c2, a2);
    e2 = void 0;
    !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
    d3 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
  }
  function hd(a2, b2, c2, d3, e2) {
    var f2 = d3;
    if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d3) a: for (; ; ) {
      if (null === d3) return;
      var g2 = d3.tag;
      if (3 === g2 || 4 === g2) {
        var h2 = d3.stateNode.containerInfo;
        if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2) break;
        if (4 === g2) for (g2 = d3.return; null !== g2; ) {
          var k2 = g2.tag;
          if (3 === k2 || 4 === k2) {
            if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2) return;
          }
          g2 = g2.return;
        }
        for (; null !== h2; ) {
          g2 = Wc(h2);
          if (null === g2) return;
          k2 = g2.tag;
          if (5 === k2 || 6 === k2) {
            d3 = f2 = g2;
            continue a;
          }
          h2 = h2.parentNode;
        }
      }
      d3 = d3.return;
    }
    Jb(function() {
      var d4 = f2, e3 = xb(c2), g3 = [];
      a: {
        var h3 = df2.get(a2);
        if (void 0 !== h3) {
          var k3 = td, n3 = a2;
          switch (a2) {
            case "keypress":
              if (0 === od(c2)) break a;
            case "keydown":
            case "keyup":
              k3 = Rd;
              break;
            case "focusin":
              n3 = "focus";
              k3 = Fd;
              break;
            case "focusout":
              n3 = "blur";
              k3 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k3 = Fd;
              break;
            case "click":
              if (2 === c2.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k3 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k3 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k3 = Vd;
              break;
            case $e:
            case af2:
            case bf2:
              k3 = Hd;
              break;
            case cf:
              k3 = Xd;
              break;
            case "scroll":
              k3 = vd;
              break;
            case "wheel":
              k3 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k3 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k3 = Td;
          }
          var t2 = 0 !== (b2 & 4), J = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
          t2 = [];
          for (var w2 = d4, u2; null !== w2; ) {
            u2 = w2;
            var F = u2.stateNode;
            5 === u2.tag && null !== F && (u2 = F, null !== x2 && (F = Kb(w2, x2), null != F && t2.push(tf2(w2, F, u2))));
            if (J) break;
            w2 = w2.return;
          }
          0 < t2.length && (h3 = new k3(h3, n3, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
        }
      }
      if (0 === (b2 & 7)) {
        a: {
          h3 = "mouseover" === a2 || "pointerover" === a2;
          k3 = "mouseout" === a2 || "pointerout" === a2;
          if (h3 && c2 !== wb && (n3 = c2.relatedTarget || c2.fromElement) && (Wc(n3) || n3[uf])) break a;
          if (k3 || h3) {
            h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
            if (k3) {
              if (n3 = c2.relatedTarget || c2.toElement, k3 = d4, n3 = n3 ? Wc(n3) : null, null !== n3 && (J = Vb(n3), n3 !== J || 5 !== n3.tag && 6 !== n3.tag)) n3 = null;
            } else k3 = null, n3 = d4;
            if (k3 !== n3) {
              t2 = Bd;
              F = "onMouseLeave";
              x2 = "onMouseEnter";
              w2 = "mouse";
              if ("pointerout" === a2 || "pointerover" === a2) t2 = Td, F = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
              J = null == k3 ? h3 : ue2(k3);
              u2 = null == n3 ? h3 : ue2(n3);
              h3 = new t2(F, w2 + "leave", k3, c2, e3);
              h3.target = J;
              h3.relatedTarget = u2;
              F = null;
              Wc(e3) === d4 && (t2 = new t2(x2, w2 + "enter", n3, c2, e3), t2.target = u2, t2.relatedTarget = J, F = t2);
              J = F;
              if (k3 && n3) b: {
                t2 = k3;
                x2 = n3;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf2(u2)) w2++;
                u2 = 0;
                for (F = x2; F; F = vf2(F)) u2++;
                for (; 0 < w2 - u2; ) t2 = vf2(t2), w2--;
                for (; 0 < u2 - w2; ) x2 = vf2(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                  t2 = vf2(t2);
                  x2 = vf2(x2);
                }
                t2 = null;
              }
              else t2 = null;
              null !== k3 && wf2(g3, h3, k3, t2, false);
              null !== n3 && null !== J && wf2(g3, J, n3, t2, true);
            }
          }
        }
        a: {
          h3 = d4 ? ue2(d4) : window;
          k3 = h3.nodeName && h3.nodeName.toLowerCase();
          if ("select" === k3 || "input" === k3 && "file" === h3.type) var na2 = ve;
          else if (me(h3)) if (we2) na2 = Fe;
          else {
            na2 = De;
            var xa2 = Ce2;
          }
          else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na2 = Ee);
          if (na2 && (na2 = na2(a2, d4))) {
            ne2(g3, na2, c2, e3);
            break a;
          }
          xa2 && xa2(a2, h3, d4);
          "focusout" === a2 && (xa2 = h3._wrapperState) && xa2.controlled && "number" === h3.type && cb(h3, "number", h3.value);
        }
        xa2 = d4 ? ue2(d4) : window;
        switch (a2) {
          case "focusin":
            if (me(xa2) || "true" === xa2.contentEditable) Qe = xa2, Re2 = d4, Se = null;
            break;
          case "focusout":
            Se = Re2 = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g3, c2, e3);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g3, c2, e3);
        }
        var $a;
        if (ae2) b: {
          switch (a2) {
            case "compositionstart":
              var ba2 = "onCompositionStart";
              break b;
            case "compositionend":
              ba2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba2 = "onCompositionUpdate";
              break b;
          }
          ba2 = void 0;
        }
        else ie2 ? ge(a2, c2) && (ba2 = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba2 = "onCompositionStart");
        ba2 && (de2 && "ko" !== c2.locale && (ie2 || "onCompositionStart" !== ba2 ? "onCompositionEnd" === ba2 && ie2 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie2 = true)), xa2 = oe2(d4, ba2), 0 < xa2.length && (ba2 = new Ld(ba2, a2, null, c2, e3), g3.push({ event: ba2, listeners: xa2 }), $a ? ba2.data = $a : ($a = he2(c2), null !== $a && (ba2.data = $a))));
        if ($a = ce2 ? je(a2, c2) : ke(a2, c2)) d4 = oe2(d4, "onBeforeInput"), 0 < d4.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d4 }), e3.data = $a);
      }
      se2(g3, b2);
    });
  }
  function tf2(a2, b2, c2) {
    return { instance: a2, listener: b2, currentTarget: c2 };
  }
  function oe2(a2, b2) {
    for (var c2 = b2 + "Capture", d3 = []; null !== a2; ) {
      var e2 = a2, f2 = e2.stateNode;
      5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d3.unshift(tf2(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d3.push(tf2(a2, f2, e2)));
      a2 = a2.return;
    }
    return d3;
  }
  function vf2(a2) {
    if (null === a2) return null;
    do
      a2 = a2.return;
    while (a2 && 5 !== a2.tag);
    return a2 ? a2 : null;
  }
  function wf2(a2, b2, c2, d3, e2) {
    for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d3; ) {
      var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
      if (null !== k2 && k2 === d3) break;
      5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf2(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf2(c2, k2, h2))));
      c2 = c2.return;
    }
    0 !== g2.length && a2.push({ event: b2, listeners: g2 });
  }
  var xf2 = /\r\n?/g, yf2 = /\u0000|\uFFFD/g;
  function zf(a2) {
    return ("string" === typeof a2 ? a2 : "" + a2).replace(xf2, "\n").replace(yf2, "");
  }
  function Af2(a2, b2, c2) {
    b2 = zf(b2);
    if (zf(a2) !== b2 && c2) throw Error(p2(425));
  }
  function Bf2() {
  }
  var Cf2 = null, Df2 = null;
  function Ef2(a2, b2) {
    return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
  }
  var Ff2 = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
    return Hf.resolve(null).then(a2).catch(If2);
  } : Ff2;
  function If2(a2) {
    setTimeout(function() {
      throw a2;
    });
  }
  function Kf(a2, b2) {
    var c2 = b2, d3 = 0;
    do {
      var e2 = c2.nextSibling;
      a2.removeChild(c2);
      if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
        if (0 === d3) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d3--;
      } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d3++;
      c2 = e2;
    } while (c2);
    bd(b2);
  }
  function Lf(a2) {
    for (; null != a2; a2 = a2.nextSibling) {
      var b2 = a2.nodeType;
      if (1 === b2 || 3 === b2) break;
      if (8 === b2) {
        b2 = a2.data;
        if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
        if ("/$" === b2) return null;
      }
    }
    return a2;
  }
  function Mf2(a2) {
    a2 = a2.previousSibling;
    for (var b2 = 0; a2; ) {
      if (8 === a2.nodeType) {
        var c2 = a2.data;
        if ("$" === c2 || "$!" === c2 || "$?" === c2) {
          if (0 === b2) return a2;
          b2--;
        } else "/$" === c2 && b2++;
      }
      a2 = a2.previousSibling;
    }
    return null;
  }
  var Nf2 = Math.random().toString(36).slice(2), Of2 = "__reactFiber$" + Nf2, Pf2 = "__reactProps$" + Nf2, uf = "__reactContainer$" + Nf2, of2 = "__reactEvents$" + Nf2, Qf = "__reactListeners$" + Nf2, Rf2 = "__reactHandles$" + Nf2;
  function Wc(a2) {
    var b2 = a2[Of2];
    if (b2) return b2;
    for (var c2 = a2.parentNode; c2; ) {
      if (b2 = c2[uf] || c2[Of2]) {
        c2 = b2.alternate;
        if (null !== b2.child || null !== c2 && null !== c2.child) for (a2 = Mf2(a2); null !== a2; ) {
          if (c2 = a2[Of2]) return c2;
          a2 = Mf2(a2);
        }
        return b2;
      }
      a2 = c2;
      c2 = a2.parentNode;
    }
    return null;
  }
  function Cb(a2) {
    a2 = a2[Of2] || a2[uf];
    return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
  }
  function ue2(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
    throw Error(p2(33));
  }
  function Db(a2) {
    return a2[Pf2] || null;
  }
  var Sf2 = [], Tf2 = -1;
  function Uf2(a2) {
    return { current: a2 };
  }
  function E2(a2) {
    0 > Tf2 || (a2.current = Sf2[Tf2], Sf2[Tf2] = null, Tf2--);
  }
  function G(a2, b2) {
    Tf2++;
    Sf2[Tf2] = a2.current;
    a2.current = b2;
  }
  var Vf = {}, H2 = Uf2(Vf), Wf = Uf2(false), Xf = Vf;
  function Yf(a2, b2) {
    var c2 = a2.type.contextTypes;
    if (!c2) return Vf;
    var d3 = a2.stateNode;
    if (d3 && d3.__reactInternalMemoizedUnmaskedChildContext === b2) return d3.__reactInternalMemoizedMaskedChildContext;
    var e2 = {}, f2;
    for (f2 in c2) e2[f2] = b2[f2];
    d3 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
    return e2;
  }
  function Zf(a2) {
    a2 = a2.childContextTypes;
    return null !== a2 && void 0 !== a2;
  }
  function $f() {
    E2(Wf);
    E2(H2);
  }
  function ag(a2, b2, c2) {
    if (H2.current !== Vf) throw Error(p2(168));
    G(H2, b2);
    G(Wf, c2);
  }
  function bg(a2, b2, c2) {
    var d3 = a2.stateNode;
    b2 = b2.childContextTypes;
    if ("function" !== typeof d3.getChildContext) return c2;
    d3 = d3.getChildContext();
    for (var e2 in d3) if (!(e2 in b2)) throw Error(p2(108, Ra2(a2) || "Unknown", e2));
    return A2({}, c2, d3);
  }
  function cg(a2) {
    a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H2.current;
    G(H2, a2);
    G(Wf, Wf.current);
    return true;
  }
  function dg(a2, b2, c2) {
    var d3 = a2.stateNode;
    if (!d3) throw Error(p2(169));
    c2 ? (a2 = bg(a2, b2, Xf), d3.__reactInternalMemoizedMergedChildContext = a2, E2(Wf), E2(H2), G(H2, a2)) : E2(Wf);
    G(Wf, c2);
  }
  var eg = null, fg = false, gg = false;
  function hg(a2) {
    null === eg ? eg = [a2] : eg.push(a2);
  }
  function ig(a2) {
    fg = true;
    hg(a2);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a2 = 0, b2 = C2;
      try {
        var c2 = eg;
        for (C2 = 1; a2 < c2.length; a2++) {
          var d3 = c2[a2];
          do
            d3 = d3(true);
          while (null !== d3);
        }
        eg = null;
        fg = false;
      } catch (e2) {
        throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
      } finally {
        C2 = b2, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a2, b2) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a2;
    ng = b2;
  }
  function ug(a2, b2, c2) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a2;
    var d3 = rg;
    a2 = sg;
    var e2 = 32 - oc(d3) - 1;
    d3 &= ~(1 << e2);
    c2 += 1;
    var f2 = 32 - oc(b2) + e2;
    if (30 < f2) {
      var g2 = e2 - e2 % 5;
      f2 = (d3 & (1 << g2) - 1).toString(32);
      d3 >>= g2;
      e2 -= g2;
      rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d3;
      sg = f2 + a2;
    } else rg = 1 << f2 | c2 << e2 | d3, sg = a2;
  }
  function vg(a2) {
    null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
  }
  function wg(a2) {
    for (; a2 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a2 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I2 = false, zg = null;
  function Ag(a2, b2) {
    var c2 = Bg(5, null, null, 0);
    c2.elementType = "DELETED";
    c2.stateNode = b2;
    c2.return = a2;
    b2 = a2.deletions;
    null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
  }
  function Cg(a2, b2) {
    switch (a2.tag) {
      case 5:
        var c2 = a2.type;
        b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
        return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
      case 6:
        return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
      case 13:
        return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a2) {
    return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
  }
  function Eg(a2) {
    if (I2) {
      var b2 = yg;
      if (b2) {
        var c2 = b2;
        if (!Cg(a2, b2)) {
          if (Dg(a2)) throw Error(p2(418));
          b2 = Lf(c2.nextSibling);
          var d3 = xg;
          b2 && Cg(a2, b2) ? Ag(d3, c2) : (a2.flags = a2.flags & -4097 | 2, I2 = false, xg = a2);
        }
      } else {
        if (Dg(a2)) throw Error(p2(418));
        a2.flags = a2.flags & -4097 | 2;
        I2 = false;
        xg = a2;
      }
    }
  }
  function Fg(a2) {
    for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
    xg = a2;
  }
  function Gg(a2) {
    if (a2 !== xg) return false;
    if (!I2) return Fg(a2), I2 = true, false;
    var b2;
    (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef2(a2.type, a2.memoizedProps));
    if (b2 && (b2 = yg)) {
      if (Dg(a2)) throw Hg(), Error(p2(418));
      for (; b2; ) Ag(a2, b2), b2 = Lf(b2.nextSibling);
    }
    Fg(a2);
    if (13 === a2.tag) {
      a2 = a2.memoizedState;
      a2 = null !== a2 ? a2.dehydrated : null;
      if (!a2) throw Error(p2(317));
      a: {
        a2 = a2.nextSibling;
        for (b2 = 0; a2; ) {
          if (8 === a2.nodeType) {
            var c2 = a2.data;
            if ("/$" === c2) {
              if (0 === b2) {
                yg = Lf(a2.nextSibling);
                break a;
              }
              b2--;
            } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
          }
          a2 = a2.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a2.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a2 = yg; a2; ) a2 = Lf(a2.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I2 = false;
  }
  function Jg(a2) {
    null === zg ? zg = [a2] : zg.push(a2);
  }
  var Kg = ua2.ReactCurrentBatchConfig;
  function Lg(a2, b2, c2) {
    a2 = c2.ref;
    if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
      if (c2._owner) {
        c2 = c2._owner;
        if (c2) {
          if (1 !== c2.tag) throw Error(p2(309));
          var d3 = c2.stateNode;
        }
        if (!d3) throw Error(p2(147, a2));
        var e2 = d3, f2 = "" + a2;
        if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
        b2 = function(a3) {
          var b3 = e2.refs;
          null === a3 ? delete b3[f2] : b3[f2] = a3;
        };
        b2._stringRef = f2;
        return b2;
      }
      if ("string" !== typeof a2) throw Error(p2(284));
      if (!c2._owner) throw Error(p2(290, a2));
    }
    return a2;
  }
  function Mg(a2, b2) {
    a2 = Object.prototype.toString.call(b2);
    throw Error(p2(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
  }
  function Ng(a2) {
    var b2 = a2._init;
    return b2(a2._payload);
  }
  function Og(a2) {
    function b2(b3, c3) {
      if (a2) {
        var d4 = b3.deletions;
        null === d4 ? (b3.deletions = [c3], b3.flags |= 16) : d4.push(c3);
      }
    }
    function c2(c3, d4) {
      if (!a2) return null;
      for (; null !== d4; ) b2(c3, d4), d4 = d4.sibling;
      return null;
    }
    function d3(a3, b3) {
      for (a3 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
      return a3;
    }
    function e2(a3, b3) {
      a3 = Pg(a3, b3);
      a3.index = 0;
      a3.sibling = null;
      return a3;
    }
    function f2(b3, c3, d4) {
      b3.index = d4;
      if (!a2) return b3.flags |= 1048576, c3;
      d4 = b3.alternate;
      if (null !== d4) return d4 = d4.index, d4 < c3 ? (b3.flags |= 2, c3) : d4;
      b3.flags |= 2;
      return c3;
    }
    function g2(b3) {
      a2 && null === b3.alternate && (b3.flags |= 2);
      return b3;
    }
    function h2(a3, b3, c3, d4) {
      if (null === b3 || 6 !== b3.tag) return b3 = Qg(c3, a3.mode, d4), b3.return = a3, b3;
      b3 = e2(b3, c3);
      b3.return = a3;
      return b3;
    }
    function k2(a3, b3, c3, d4) {
      var f3 = c3.type;
      if (f3 === ya2) return m3(a3, b3, c3.props.children, d4, c3.key);
      if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha2 && Ng(f3) === b3.type)) return d4 = e2(b3, c3.props), d4.ref = Lg(a3, b3, c3), d4.return = a3, d4;
      d4 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d4);
      d4.ref = Lg(a3, b3, c3);
      d4.return = a3;
      return d4;
    }
    function l2(a3, b3, c3, d4) {
      if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = Sg(c3, a3.mode, d4), b3.return = a3, b3;
      b3 = e2(b3, c3.children || []);
      b3.return = a3;
      return b3;
    }
    function m3(a3, b3, c3, d4, f3) {
      if (null === b3 || 7 !== b3.tag) return b3 = Tg(c3, a3.mode, d4, f3), b3.return = a3, b3;
      b3 = e2(b3, c3);
      b3.return = a3;
      return b3;
    }
    function q(a3, b3, c3) {
      if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = Qg("" + b3, a3.mode, c3), b3.return = a3, b3;
      if ("object" === typeof b3 && null !== b3) {
        switch (b3.$$typeof) {
          case va2:
            return c3 = Rg(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b3), c3.return = a3, c3;
          case wa2:
            return b3 = Sg(b3, a3.mode, c3), b3.return = a3, b3;
          case Ha2:
            var d4 = b3._init;
            return q(a3, d4(b3._payload), c3);
        }
        if (eb(b3) || Ka2(b3)) return b3 = Tg(b3, a3.mode, c3, null), b3.return = a3, b3;
        Mg(a3, b3);
      }
      return null;
    }
    function r2(a3, b3, c3, d4) {
      var e3 = null !== b3 ? b3.key : null;
      if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h2(a3, b3, "" + c3, d4);
      if ("object" === typeof c3 && null !== c3) {
        switch (c3.$$typeof) {
          case va2:
            return c3.key === e3 ? k2(a3, b3, c3, d4) : null;
          case wa2:
            return c3.key === e3 ? l2(a3, b3, c3, d4) : null;
          case Ha2:
            return e3 = c3._init, r2(
              a3,
              b3,
              e3(c3._payload),
              d4
            );
        }
        if (eb(c3) || Ka2(c3)) return null !== e3 ? null : m3(a3, b3, c3, d4, null);
        Mg(a3, c3);
      }
      return null;
    }
    function y3(a3, b3, c3, d4, e3) {
      if ("string" === typeof d4 && "" !== d4 || "number" === typeof d4) return a3 = a3.get(c3) || null, h2(b3, a3, "" + d4, e3);
      if ("object" === typeof d4 && null !== d4) {
        switch (d4.$$typeof) {
          case va2:
            return a3 = a3.get(null === d4.key ? c3 : d4.key) || null, k2(b3, a3, d4, e3);
          case wa2:
            return a3 = a3.get(null === d4.key ? c3 : d4.key) || null, l2(b3, a3, d4, e3);
          case Ha2:
            var f3 = d4._init;
            return y3(a3, b3, c3, f3(d4._payload), e3);
        }
        if (eb(d4) || Ka2(d4)) return a3 = a3.get(c3) || null, m3(b3, a3, d4, e3, null);
        Mg(b3, d4);
      }
      return null;
    }
    function n3(e3, g3, h3, k3) {
      for (var l3 = null, m4 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
        u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
        var n4 = r2(e3, u2, h3[w2], k3);
        if (null === n4) {
          null === u2 && (u2 = x2);
          break;
        }
        a2 && u2 && null === n4.alternate && b2(e3, u2);
        g3 = f2(n4, g3, w2);
        null === m4 ? l3 = n4 : m4.sibling = n4;
        m4 = n4;
        u2 = x2;
      }
      if (w2 === h3.length) return c2(e3, u2), I2 && tg(e3, w2), l3;
      if (null === u2) {
        for (; w2 < h3.length; w2++) u2 = q(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m4 ? l3 = u2 : m4.sibling = u2, m4 = u2);
        I2 && tg(e3, w2);
        return l3;
      }
      for (u2 = d3(e3, u2); w2 < h3.length; w2++) x2 = y3(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m4 ? l3 = x2 : m4.sibling = x2, m4 = x2);
      a2 && u2.forEach(function(a3) {
        return b2(e3, a3);
      });
      I2 && tg(e3, w2);
      return l3;
    }
    function t2(e3, g3, h3, k3) {
      var l3 = Ka2(h3);
      if ("function" !== typeof l3) throw Error(p2(150));
      h3 = l3.call(h3);
      if (null == h3) throw Error(p2(151));
      for (var u2 = l3 = null, m4 = g3, w2 = g3 = 0, x2 = null, n4 = h3.next(); null !== m4 && !n4.done; w2++, n4 = h3.next()) {
        m4.index > w2 ? (x2 = m4, m4 = null) : x2 = m4.sibling;
        var t3 = r2(e3, m4, n4.value, k3);
        if (null === t3) {
          null === m4 && (m4 = x2);
          break;
        }
        a2 && m4 && null === t3.alternate && b2(e3, m4);
        g3 = f2(t3, g3, w2);
        null === u2 ? l3 = t3 : u2.sibling = t3;
        u2 = t3;
        m4 = x2;
      }
      if (n4.done) return c2(
        e3,
        m4
      ), I2 && tg(e3, w2), l3;
      if (null === m4) {
        for (; !n4.done; w2++, n4 = h3.next()) n4 = q(e3, n4.value, k3), null !== n4 && (g3 = f2(n4, g3, w2), null === u2 ? l3 = n4 : u2.sibling = n4, u2 = n4);
        I2 && tg(e3, w2);
        return l3;
      }
      for (m4 = d3(e3, m4); !n4.done; w2++, n4 = h3.next()) n4 = y3(m4, e3, w2, n4.value, k3), null !== n4 && (a2 && null !== n4.alternate && m4.delete(null === n4.key ? w2 : n4.key), g3 = f2(n4, g3, w2), null === u2 ? l3 = n4 : u2.sibling = n4, u2 = n4);
      a2 && m4.forEach(function(a3) {
        return b2(e3, a3);
      });
      I2 && tg(e3, w2);
      return l3;
    }
    function J(a3, d4, f3, h3) {
      "object" === typeof f3 && null !== f3 && f3.type === ya2 && null === f3.key && (f3 = f3.props.children);
      if ("object" === typeof f3 && null !== f3) {
        switch (f3.$$typeof) {
          case va2:
            a: {
              for (var k3 = f3.key, l3 = d4; null !== l3; ) {
                if (l3.key === k3) {
                  k3 = f3.type;
                  if (k3 === ya2) {
                    if (7 === l3.tag) {
                      c2(a3, l3.sibling);
                      d4 = e2(l3, f3.props.children);
                      d4.return = a3;
                      a3 = d4;
                      break a;
                    }
                  } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha2 && Ng(k3) === l3.type) {
                    c2(a3, l3.sibling);
                    d4 = e2(l3, f3.props);
                    d4.ref = Lg(a3, l3, f3);
                    d4.return = a3;
                    a3 = d4;
                    break a;
                  }
                  c2(a3, l3);
                  break;
                } else b2(a3, l3);
                l3 = l3.sibling;
              }
              f3.type === ya2 ? (d4 = Tg(f3.props.children, a3.mode, h3, f3.key), d4.return = a3, a3 = d4) : (h3 = Rg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Lg(a3, d4, f3), h3.return = a3, a3 = h3);
            }
            return g2(a3);
          case wa2:
            a: {
              for (l3 = f3.key; null !== d4; ) {
                if (d4.key === l3) if (4 === d4.tag && d4.stateNode.containerInfo === f3.containerInfo && d4.stateNode.implementation === f3.implementation) {
                  c2(a3, d4.sibling);
                  d4 = e2(d4, f3.children || []);
                  d4.return = a3;
                  a3 = d4;
                  break a;
                } else {
                  c2(a3, d4);
                  break;
                }
                else b2(a3, d4);
                d4 = d4.sibling;
              }
              d4 = Sg(f3, a3.mode, h3);
              d4.return = a3;
              a3 = d4;
            }
            return g2(a3);
          case Ha2:
            return l3 = f3._init, J(a3, d4, l3(f3._payload), h3);
        }
        if (eb(f3)) return n3(a3, d4, f3, h3);
        if (Ka2(f3)) return t2(a3, d4, f3, h3);
        Mg(a3, f3);
      }
      return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d4 && 6 === d4.tag ? (c2(a3, d4.sibling), d4 = e2(d4, f3), d4.return = a3, a3 = d4) : (c2(a3, d4), d4 = Qg(f3, a3.mode, h3), d4.return = a3, a3 = d4), g2(a3)) : c2(a3, d4);
    }
    return J;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf2(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a2) {
    var b2 = Wg.current;
    E2(Wg);
    a2._currentValue = b2;
  }
  function bh(a2, b2, c2) {
    for (; null !== a2; ) {
      var d3 = a2.alternate;
      (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d3 && (d3.childLanes |= b2)) : null !== d3 && (d3.childLanes & b2) !== b2 && (d3.childLanes |= b2);
      if (a2 === c2) break;
      a2 = a2.return;
    }
  }
  function ch(a2, b2) {
    Xg = a2;
    Zg = Yg = null;
    a2 = a2.dependencies;
    null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (dh = true), a2.firstContext = null);
  }
  function eh(a2) {
    var b2 = a2._currentValue;
    if (Zg !== a2) if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Yg) {
      if (null === Xg) throw Error(p2(308));
      Yg = a2;
      Xg.dependencies = { lanes: 0, firstContext: a2 };
    } else Yg = Yg.next = a2;
    return b2;
  }
  var fh = null;
  function gh(a2) {
    null === fh ? fh = [a2] : fh.push(a2);
  }
  function hh(a2, b2, c2, d3) {
    var e2 = b2.interleaved;
    null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
    b2.interleaved = c2;
    return ih(a2, d3);
  }
  function ih(a2, b2) {
    a2.lanes |= b2;
    var c2 = a2.alternate;
    null !== c2 && (c2.lanes |= b2);
    c2 = a2;
    for (a2 = a2.return; null !== a2; ) a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
    return 3 === c2.tag ? c2.stateNode : null;
  }
  var jh = false;
  function kh(a2) {
    a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a2, b2) {
    a2 = a2.updateQueue;
    b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
  }
  function mh(a2, b2) {
    return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a2, b2, c2) {
    var d3 = a2.updateQueue;
    if (null === d3) return null;
    d3 = d3.shared;
    if (0 !== (K2 & 2)) {
      var e2 = d3.pending;
      null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
      d3.pending = b2;
      return ih(a2, c2);
    }
    e2 = d3.interleaved;
    null === e2 ? (b2.next = b2, gh(d3)) : (b2.next = e2.next, e2.next = b2);
    d3.interleaved = b2;
    return ih(a2, c2);
  }
  function oh(a2, b2, c2) {
    b2 = b2.updateQueue;
    if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
      var d3 = b2.lanes;
      d3 &= a2.pendingLanes;
      c2 |= d3;
      b2.lanes = c2;
      Cc(a2, c2);
    }
  }
  function ph(a2, b2) {
    var c2 = a2.updateQueue, d3 = a2.alternate;
    if (null !== d3 && (d3 = d3.updateQueue, c2 === d3)) {
      var e2 = null, f2 = null;
      c2 = c2.firstBaseUpdate;
      if (null !== c2) {
        do {
          var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
          null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
          c2 = c2.next;
        } while (null !== c2);
        null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
      } else e2 = f2 = b2;
      c2 = { baseState: d3.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d3.shared, effects: d3.effects };
      a2.updateQueue = c2;
      return;
    }
    a2 = c2.lastBaseUpdate;
    null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
    c2.lastBaseUpdate = b2;
  }
  function qh(a2, b2, c2, d3) {
    var e2 = a2.updateQueue;
    jh = false;
    var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
    if (null !== h2) {
      e2.shared.pending = null;
      var k2 = h2, l2 = k2.next;
      k2.next = null;
      null === g2 ? f2 = l2 : g2.next = l2;
      g2 = k2;
      var m3 = a2.alternate;
      null !== m3 && (m3 = m3.updateQueue, h2 = m3.lastBaseUpdate, h2 !== g2 && (null === h2 ? m3.firstBaseUpdate = l2 : h2.next = l2, m3.lastBaseUpdate = k2));
    }
    if (null !== f2) {
      var q = e2.baseState;
      g2 = 0;
      m3 = l2 = k2 = null;
      h2 = f2;
      do {
        var r2 = h2.lane, y3 = h2.eventTime;
        if ((d3 & r2) === r2) {
          null !== m3 && (m3 = m3.next = {
            eventTime: y3,
            lane: 0,
            tag: h2.tag,
            payload: h2.payload,
            callback: h2.callback,
            next: null
          });
          a: {
            var n3 = a2, t2 = h2;
            r2 = b2;
            y3 = c2;
            switch (t2.tag) {
              case 1:
                n3 = t2.payload;
                if ("function" === typeof n3) {
                  q = n3.call(y3, q, r2);
                  break a;
                }
                q = n3;
                break a;
              case 3:
                n3.flags = n3.flags & -65537 | 128;
              case 0:
                n3 = t2.payload;
                r2 = "function" === typeof n3 ? n3.call(y3, q, r2) : n3;
                if (null === r2 || void 0 === r2) break a;
                q = A2({}, q, r2);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
        } else y3 = { eventTime: y3, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m3 ? (l2 = m3 = y3, k2 = q) : m3 = m3.next = y3, g2 |= r2;
        h2 = h2.next;
        if (null === h2) if (h2 = e2.shared.pending, null === h2) break;
        else r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
      } while (1);
      null === m3 && (k2 = q);
      e2.baseState = k2;
      e2.firstBaseUpdate = l2;
      e2.lastBaseUpdate = m3;
      b2 = e2.shared.interleaved;
      if (null !== b2) {
        e2 = b2;
        do
          g2 |= e2.lane, e2 = e2.next;
        while (e2 !== b2);
      } else null === f2 && (e2.shared.lanes = 0);
      rh |= g2;
      a2.lanes = g2;
      a2.memoizedState = q;
    }
  }
  function sh(a2, b2, c2) {
    a2 = b2.effects;
    b2.effects = null;
    if (null !== a2) for (b2 = 0; b2 < a2.length; b2++) {
      var d3 = a2[b2], e2 = d3.callback;
      if (null !== e2) {
        d3.callback = null;
        d3 = c2;
        if ("function" !== typeof e2) throw Error(p2(191, e2));
        e2.call(d3);
      }
    }
  }
  var th = {}, uh = Uf2(th), vh = Uf2(th), wh = Uf2(th);
  function xh(a2) {
    if (a2 === th) throw Error(p2(174));
    return a2;
  }
  function yh(a2, b2) {
    G(wh, b2);
    G(vh, a2);
    G(uh, th);
    a2 = b2.nodeType;
    switch (a2) {
      case 9:
      case 11:
        b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
        break;
      default:
        a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
    }
    E2(uh);
    G(uh, b2);
  }
  function zh() {
    E2(uh);
    E2(vh);
    E2(wh);
  }
  function Ah(a2) {
    xh(wh.current);
    var b2 = xh(uh.current);
    var c2 = lb(b2, a2.type);
    b2 !== c2 && (G(vh, a2), G(uh, c2));
  }
  function Bh(a2) {
    vh.current === a2 && (E2(uh), E2(vh));
  }
  var L3 = Uf2(0);
  function Ch(a2) {
    for (var b2 = a2; null !== b2; ) {
      if (13 === b2.tag) {
        var c2 = b2.memoizedState;
        if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
      } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
        if (0 !== (b2.flags & 128)) return b2;
      } else if (null !== b2.child) {
        b2.child.return = b2;
        b2 = b2.child;
        continue;
      }
      if (b2 === a2) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2) return null;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a2 = 0; a2 < Dh.length; a2++) Dh[a2]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua2.ReactCurrentDispatcher, Gh = ua2.ReactCurrentBatchConfig, Hh = 0, M2 = null, N2 = null, O2 = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P2() {
    throw Error(p2(321));
  }
  function Mh(a2, b2) {
    if (null === b2) return false;
    for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++) if (!He(a2[c2], b2[c2])) return false;
    return true;
  }
  function Nh(a2, b2, c2, d3, e2, f2) {
    Hh = f2;
    M2 = b2;
    b2.memoizedState = null;
    b2.updateQueue = null;
    b2.lanes = 0;
    Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
    a2 = c2(d3, e2);
    if (Jh) {
      f2 = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f2) throw Error(p2(301));
        f2 += 1;
        O2 = N2 = null;
        b2.updateQueue = null;
        Fh.current = Qh;
        a2 = c2(d3, e2);
      } while (Jh);
    }
    Fh.current = Rh;
    b2 = null !== N2 && null !== N2.next;
    Hh = 0;
    O2 = N2 = M2 = null;
    Ih = false;
    if (b2) throw Error(p2(300));
    return a2;
  }
  function Sh() {
    var a2 = 0 !== Kh;
    Kh = 0;
    return a2;
  }
  function Th() {
    var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O2 ? M2.memoizedState = O2 = a2 : O2 = O2.next = a2;
    return O2;
  }
  function Uh() {
    if (null === N2) {
      var a2 = M2.alternate;
      a2 = null !== a2 ? a2.memoizedState : null;
    } else a2 = N2.next;
    var b2 = null === O2 ? M2.memoizedState : O2.next;
    if (null !== b2) O2 = b2, N2 = a2;
    else {
      if (null === a2) throw Error(p2(310));
      N2 = a2;
      a2 = { memoizedState: N2.memoizedState, baseState: N2.baseState, baseQueue: N2.baseQueue, queue: N2.queue, next: null };
      null === O2 ? M2.memoizedState = O2 = a2 : O2 = O2.next = a2;
    }
    return O2;
  }
  function Vh(a2, b2) {
    return "function" === typeof b2 ? b2(a2) : b2;
  }
  function Wh(a2) {
    var b2 = Uh(), c2 = b2.queue;
    if (null === c2) throw Error(p2(311));
    c2.lastRenderedReducer = a2;
    var d3 = N2, e2 = d3.baseQueue, f2 = c2.pending;
    if (null !== f2) {
      if (null !== e2) {
        var g2 = e2.next;
        e2.next = f2.next;
        f2.next = g2;
      }
      d3.baseQueue = e2 = f2;
      c2.pending = null;
    }
    if (null !== e2) {
      f2 = e2.next;
      d3 = d3.baseState;
      var h2 = g2 = null, k2 = null, l2 = f2;
      do {
        var m3 = l2.lane;
        if ((Hh & m3) === m3) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d3 = l2.hasEagerState ? l2.eagerState : a2(d3, l2.action);
        else {
          var q = {
            lane: m3,
            action: l2.action,
            hasEagerState: l2.hasEagerState,
            eagerState: l2.eagerState,
            next: null
          };
          null === k2 ? (h2 = k2 = q, g2 = d3) : k2 = k2.next = q;
          M2.lanes |= m3;
          rh |= m3;
        }
        l2 = l2.next;
      } while (null !== l2 && l2 !== f2);
      null === k2 ? g2 = d3 : k2.next = h2;
      He(d3, b2.memoizedState) || (dh = true);
      b2.memoizedState = d3;
      b2.baseState = g2;
      b2.baseQueue = k2;
      c2.lastRenderedState = d3;
    }
    a2 = c2.interleaved;
    if (null !== a2) {
      e2 = a2;
      do
        f2 = e2.lane, M2.lanes |= f2, rh |= f2, e2 = e2.next;
      while (e2 !== a2);
    } else null === e2 && (c2.lanes = 0);
    return [b2.memoizedState, c2.dispatch];
  }
  function Xh(a2) {
    var b2 = Uh(), c2 = b2.queue;
    if (null === c2) throw Error(p2(311));
    c2.lastRenderedReducer = a2;
    var d3 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
    if (null !== e2) {
      c2.pending = null;
      var g2 = e2 = e2.next;
      do
        f2 = a2(f2, g2.action), g2 = g2.next;
      while (g2 !== e2);
      He(f2, b2.memoizedState) || (dh = true);
      b2.memoizedState = f2;
      null === b2.baseQueue && (b2.baseState = f2);
      c2.lastRenderedState = f2;
    }
    return [f2, d3];
  }
  function Yh() {
  }
  function Zh(a2, b2) {
    var c2 = M2, d3 = Uh(), e2 = b2(), f2 = !He(d3.memoizedState, e2);
    f2 && (d3.memoizedState = e2, dh = true);
    d3 = d3.queue;
    $h(ai.bind(null, c2, d3, a2), [a2]);
    if (d3.getSnapshot !== b2 || f2 || null !== O2 && O2.memoizedState.tag & 1) {
      c2.flags |= 2048;
      bi(9, ci.bind(null, c2, d3, e2, b2), void 0, null);
      if (null === Q2) throw Error(p2(349));
      0 !== (Hh & 30) || di(c2, b2, e2);
    }
    return e2;
  }
  function di(a2, b2, c2) {
    a2.flags |= 16384;
    a2 = { getSnapshot: b2, value: c2 };
    b2 = M2.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M2.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
  }
  function ci(a2, b2, c2, d3) {
    b2.value = c2;
    b2.getSnapshot = d3;
    ei(b2) && fi(a2);
  }
  function ai(a2, b2, c2) {
    return c2(function() {
      ei(b2) && fi(a2);
    });
  }
  function ei(a2) {
    var b2 = a2.getSnapshot;
    a2 = a2.value;
    try {
      var c2 = b2();
      return !He(a2, c2);
    } catch (d3) {
      return true;
    }
  }
  function fi(a2) {
    var b2 = ih(a2, 1);
    null !== b2 && gi2(b2, a2, 1, -1);
  }
  function hi(a2) {
    var b2 = Th();
    "function" === typeof a2 && (a2 = a2());
    b2.memoizedState = b2.baseState = a2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
    b2.queue = a2;
    a2 = a2.dispatch = ii.bind(null, M2, a2);
    return [b2.memoizedState, a2];
  }
  function bi(a2, b2, c2, d3) {
    a2 = { tag: a2, create: b2, destroy: c2, deps: d3, next: null };
    b2 = M2.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d3 = c2.next, c2.next = a2, a2.next = d3, b2.lastEffect = a2));
    return a2;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki2(a2, b2, c2, d3) {
    var e2 = Th();
    M2.flags |= a2;
    e2.memoizedState = bi(1 | b2, c2, void 0, void 0 === d3 ? null : d3);
  }
  function li(a2, b2, c2, d3) {
    var e2 = Uh();
    d3 = void 0 === d3 ? null : d3;
    var f2 = void 0;
    if (null !== N2) {
      var g2 = N2.memoizedState;
      f2 = g2.destroy;
      if (null !== d3 && Mh(d3, g2.deps)) {
        e2.memoizedState = bi(b2, c2, f2, d3);
        return;
      }
    }
    M2.flags |= a2;
    e2.memoizedState = bi(1 | b2, c2, f2, d3);
  }
  function mi2(a2, b2) {
    return ki2(8390656, 8, a2, b2);
  }
  function $h(a2, b2) {
    return li(2048, 8, a2, b2);
  }
  function ni(a2, b2) {
    return li(4, 2, a2, b2);
  }
  function oi(a2, b2) {
    return li(4, 4, a2, b2);
  }
  function pi(a2, b2) {
    if ("function" === typeof b2) return a2 = a2(), b2(a2), function() {
      b2(null);
    };
    if (null !== b2 && void 0 !== b2) return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
  }
  function qi2(a2, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return li(4, 4, pi.bind(null, b2, a2), c2);
  }
  function ri() {
  }
  function si(a2, b2) {
    var c2 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d3 = c2.memoizedState;
    if (null !== d3 && null !== b2 && Mh(b2, d3[1])) return d3[0];
    c2.memoizedState = [a2, b2];
    return a2;
  }
  function ti(a2, b2) {
    var c2 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d3 = c2.memoizedState;
    if (null !== d3 && null !== b2 && Mh(b2, d3[1])) return d3[0];
    a2 = a2();
    c2.memoizedState = [a2, b2];
    return a2;
  }
  function ui(a2, b2, c2) {
    if (0 === (Hh & 21)) return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
    He(c2, b2) || (c2 = yc(), M2.lanes |= c2, rh |= c2, a2.baseState = true);
    return b2;
  }
  function vi(a2, b2) {
    var c2 = C2;
    C2 = 0 !== c2 && 4 > c2 ? c2 : 4;
    a2(true);
    var d3 = Gh.transition;
    Gh.transition = {};
    try {
      a2(false), b2();
    } finally {
      C2 = c2, Gh.transition = d3;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi2(a2, b2, c2) {
    var d3 = yi(a2);
    c2 = { lane: d3, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi2(a2)) Ai(b2, c2);
    else if (c2 = hh(a2, b2, c2, d3), null !== c2) {
      var e2 = R2();
      gi2(c2, a2, d3, e2);
      Bi(c2, b2, d3);
    }
  }
  function ii(a2, b2, c2) {
    var d3 = yi(a2), e2 = { lane: d3, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi2(a2)) Ai(b2, e2);
    else {
      var f2 = a2.alternate;
      if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
      c2 = hh(a2, b2, e2, d3);
      null !== c2 && (e2 = R2(), gi2(c2, a2, d3, e2), Bi(c2, b2, d3));
    }
  }
  function zi2(a2) {
    var b2 = a2.alternate;
    return a2 === M2 || null !== b2 && b2 === M2;
  }
  function Ai(a2, b2) {
    Jh = Ih = true;
    var c2 = a2.pending;
    null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
    a2.pending = b2;
  }
  function Bi(a2, b2, c2) {
    if (0 !== (c2 & 4194240)) {
      var d3 = b2.lanes;
      d3 &= a2.pendingLanes;
      c2 |= d3;
      b2.lanes = c2;
      Cc(a2, c2);
    }
  }
  var Rh = { readContext: eh, useCallback: P2, useContext: P2, useEffect: P2, useImperativeHandle: P2, useInsertionEffect: P2, useLayoutEffect: P2, useMemo: P2, useReducer: P2, useRef: P2, useState: P2, useDebugValue: P2, useDeferredValue: P2, useTransition: P2, useMutableSource: P2, useSyncExternalStore: P2, useId: P2, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b2) {
    Th().memoizedState = [a2, void 0 === b2 ? null : b2];
    return a2;
  }, useContext: eh, useEffect: mi2, useImperativeHandle: function(a2, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return ki2(
      4194308,
      4,
      pi.bind(null, b2, a2),
      c2
    );
  }, useLayoutEffect: function(a2, b2) {
    return ki2(4194308, 4, a2, b2);
  }, useInsertionEffect: function(a2, b2) {
    return ki2(4, 2, a2, b2);
  }, useMemo: function(a2, b2) {
    var c2 = Th();
    b2 = void 0 === b2 ? null : b2;
    a2 = a2();
    c2.memoizedState = [a2, b2];
    return a2;
  }, useReducer: function(a2, b2, c2) {
    var d3 = Th();
    b2 = void 0 !== c2 ? c2(b2) : b2;
    d3.memoizedState = d3.baseState = b2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
    d3.queue = a2;
    a2 = a2.dispatch = xi2.bind(null, M2, a2);
    return [d3.memoizedState, a2];
  }, useRef: function(a2) {
    var b2 = Th();
    a2 = { current: a2 };
    return b2.memoizedState = a2;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a2) {
    return Th().memoizedState = a2;
  }, useTransition: function() {
    var a2 = hi(false), b2 = a2[0];
    a2 = vi.bind(null, a2[1]);
    Th().memoizedState = a2;
    return [b2, a2];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a2, b2, c2) {
    var d3 = M2, e2 = Th();
    if (I2) {
      if (void 0 === c2) throw Error(p2(407));
      c2 = c2();
    } else {
      c2 = b2();
      if (null === Q2) throw Error(p2(349));
      0 !== (Hh & 30) || di(d3, b2, c2);
    }
    e2.memoizedState = c2;
    var f2 = { value: c2, getSnapshot: b2 };
    e2.queue = f2;
    mi2(ai.bind(
      null,
      d3,
      f2,
      a2
    ), [a2]);
    d3.flags |= 2048;
    bi(9, ci.bind(null, d3, f2, c2, b2), void 0, null);
    return c2;
  }, useId: function() {
    var a2 = Th(), b2 = Q2.identifierPrefix;
    if (I2) {
      var c2 = sg;
      var d3 = rg;
      c2 = (d3 & ~(1 << 32 - oc(d3) - 1)).toString(32) + c2;
      b2 = ":" + b2 + "R" + c2;
      c2 = Kh++;
      0 < c2 && (b2 += "H" + c2.toString(32));
      b2 += ":";
    } else c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
    return a2.memoizedState = b2;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi2,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a2) {
      var b2 = Uh();
      return ui(b2, N2.memoizedState, a2);
    },
    useTransition: function() {
      var a2 = Wh(Vh)[0], b2 = Uh().memoizedState;
      return [a2, b2];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi2, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a2) {
    var b2 = Uh();
    return null === N2 ? b2.memoizedState = a2 : ui(b2, N2.memoizedState, a2);
  }, useTransition: function() {
    var a2 = Xh(Vh)[0], b2 = Uh().memoizedState;
    return [a2, b2];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci2(a2, b2) {
    if (a2 && a2.defaultProps) {
      b2 = A2({}, b2);
      a2 = a2.defaultProps;
      for (var c2 in a2) void 0 === b2[c2] && (b2[c2] = a2[c2]);
      return b2;
    }
    return b2;
  }
  function Di2(a2, b2, c2, d3) {
    b2 = a2.memoizedState;
    c2 = c2(d3, b2);
    c2 = null === c2 || void 0 === c2 ? b2 : A2({}, b2, c2);
    a2.memoizedState = c2;
    0 === a2.lanes && (a2.updateQueue.baseState = c2);
  }
  var Ei2 = { isMounted: function(a2) {
    return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
  }, enqueueSetState: function(a2, b2, c2) {
    a2 = a2._reactInternals;
    var d3 = R2(), e2 = yi(a2), f2 = mh(d3, e2);
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = nh(a2, f2, e2);
    null !== b2 && (gi2(b2, a2, e2, d3), oh(b2, a2, e2));
  }, enqueueReplaceState: function(a2, b2, c2) {
    a2 = a2._reactInternals;
    var d3 = R2(), e2 = yi(a2), f2 = mh(d3, e2);
    f2.tag = 1;
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = nh(a2, f2, e2);
    null !== b2 && (gi2(b2, a2, e2, d3), oh(b2, a2, e2));
  }, enqueueForceUpdate: function(a2, b2) {
    a2 = a2._reactInternals;
    var c2 = R2(), d3 = yi(a2), e2 = mh(c2, d3);
    e2.tag = 2;
    void 0 !== b2 && null !== b2 && (e2.callback = b2);
    b2 = nh(a2, e2, d3);
    null !== b2 && (gi2(b2, a2, d3, c2), oh(b2, a2, d3));
  } };
  function Fi2(a2, b2, c2, d3, e2, f2, g2) {
    a2 = a2.stateNode;
    return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d3, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d3) || !Ie(e2, f2) : true;
  }
  function Gi2(a2, b2, c2) {
    var d3 = false, e2 = Vf;
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H2.current, d3 = b2.contextTypes, f2 = (d3 = null !== d3 && void 0 !== d3) ? Yf(a2, e2) : Vf);
    b2 = new b2(c2, f2);
    a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
    b2.updater = Ei2;
    a2.stateNode = b2;
    b2._reactInternals = a2;
    d3 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
    return b2;
  }
  function Hi2(a2, b2, c2, d3) {
    a2 = b2.state;
    "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d3);
    "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d3);
    b2.state !== a2 && Ei2.enqueueReplaceState(b2, b2.state, null);
  }
  function Ii2(a2, b2, c2, d3) {
    var e2 = a2.stateNode;
    e2.props = c2;
    e2.state = a2.memoizedState;
    e2.refs = {};
    kh(a2);
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H2.current, e2.context = Yf(a2, f2));
    e2.state = a2.memoizedState;
    f2 = b2.getDerivedStateFromProps;
    "function" === typeof f2 && (Di2(a2, b2, f2, c2), e2.state = a2.memoizedState);
    "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei2.enqueueReplaceState(e2, e2.state, null), qh(a2, c2, e2, d3), e2.state = a2.memoizedState);
    "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
  }
  function Ji(a2, b2) {
    try {
      var c2 = "", d3 = b2;
      do
        c2 += Pa2(d3), d3 = d3.return;
      while (d3);
      var e2 = c2;
    } catch (f2) {
      e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
    }
    return { value: a2, source: b2, stack: e2, digest: null };
  }
  function Ki2(a2, b2, c2) {
    return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
  }
  function Li2(a2, b2) {
    try {
      console.error(b2.value);
    } catch (c2) {
      setTimeout(function() {
        throw c2;
      });
    }
  }
  var Mi2 = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni2(a2, b2, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    c2.payload = { element: null };
    var d3 = b2.value;
    c2.callback = function() {
      Oi2 || (Oi2 = true, Pi2 = d3);
      Li2(a2, b2);
    };
    return c2;
  }
  function Qi(a2, b2, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    var d3 = a2.type.getDerivedStateFromError;
    if ("function" === typeof d3) {
      var e2 = b2.value;
      c2.payload = function() {
        return d3(e2);
      };
      c2.callback = function() {
        Li2(a2, b2);
      };
    }
    var f2 = a2.stateNode;
    null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
      Li2(a2, b2);
      "function" !== typeof d3 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c3 = b2.stack;
      this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
    });
    return c2;
  }
  function Si(a2, b2, c2) {
    var d3 = a2.pingCache;
    if (null === d3) {
      d3 = a2.pingCache = new Mi2();
      var e2 = /* @__PURE__ */ new Set();
      d3.set(b2, e2);
    } else e2 = d3.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d3.set(b2, e2));
    e2.has(c2) || (e2.add(c2), a2 = Ti2.bind(null, a2, b2, c2), b2.then(a2, a2));
  }
  function Ui2(a2) {
    do {
      var b2;
      if (b2 = 13 === a2.tag) b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
      if (b2) return a2;
      a2 = a2.return;
    } while (null !== a2);
    return null;
  }
  function Vi(a2, b2, c2, d3, e2) {
    if (0 === (a2.mode & 1)) return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a2;
    a2.flags |= 65536;
    a2.lanes = e2;
    return a2;
  }
  var Wi = ua2.ReactCurrentOwner, dh = false;
  function Xi(a2, b2, c2, d3) {
    b2.child = null === a2 ? Vg(b2, null, c2, d3) : Ug(b2, a2.child, c2, d3);
  }
  function Yi2(a2, b2, c2, d3, e2) {
    c2 = c2.render;
    var f2 = b2.ref;
    ch(b2, e2);
    d3 = Nh(a2, b2, c2, d3, f2, e2);
    c2 = Sh();
    if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
    I2 && c2 && vg(b2);
    b2.flags |= 1;
    Xi(a2, b2, d3, e2);
    return b2.child;
  }
  function $i(a2, b2, c2, d3, e2) {
    if (null === a2) {
      var f2 = c2.type;
      if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f2, bj(a2, b2, f2, d3, e2);
      a2 = Rg(c2.type, null, d3, b2, b2.mode, e2);
      a2.ref = b2.ref;
      a2.return = b2;
      return b2.child = a2;
    }
    f2 = a2.child;
    if (0 === (a2.lanes & e2)) {
      var g2 = f2.memoizedProps;
      c2 = c2.compare;
      c2 = null !== c2 ? c2 : Ie;
      if (c2(g2, d3) && a2.ref === b2.ref) return Zi(a2, b2, e2);
    }
    b2.flags |= 1;
    a2 = Pg(f2, d3);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  function bj(a2, b2, c2, d3, e2) {
    if (null !== a2) {
      var f2 = a2.memoizedProps;
      if (Ie(f2, d3) && a2.ref === b2.ref) if (dh = false, b2.pendingProps = d3 = f2, 0 !== (a2.lanes & e2)) 0 !== (a2.flags & 131072) && (dh = true);
      else return b2.lanes = a2.lanes, Zi(a2, b2, e2);
    }
    return cj(a2, b2, c2, d3, e2);
  }
  function dj(a2, b2, c2) {
    var d3 = b2.pendingProps, e2 = d3.children, f2 = null !== a2 ? a2.memoizedState : null;
    if ("hidden" === d3.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
    else {
      if (0 === (c2 & 1073741824)) return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d3 = null !== f2 ? f2.baseLanes : c2;
      G(ej, fj);
      fj |= d3;
    }
    else null !== f2 ? (d3 = f2.baseLanes | c2, b2.memoizedState = null) : d3 = c2, G(ej, fj), fj |= d3;
    Xi(a2, b2, e2, c2);
    return b2.child;
  }
  function gj(a2, b2) {
    var c2 = b2.ref;
    if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
  }
  function cj(a2, b2, c2, d3, e2) {
    var f2 = Zf(c2) ? Xf : H2.current;
    f2 = Yf(b2, f2);
    ch(b2, e2);
    c2 = Nh(a2, b2, c2, d3, f2, e2);
    d3 = Sh();
    if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
    I2 && d3 && vg(b2);
    b2.flags |= 1;
    Xi(a2, b2, c2, e2);
    return b2.child;
  }
  function hj(a2, b2, c2, d3, e2) {
    if (Zf(c2)) {
      var f2 = true;
      cg(b2);
    } else f2 = false;
    ch(b2, e2);
    if (null === b2.stateNode) ij(a2, b2), Gi2(b2, c2, d3), Ii2(b2, c2, d3, e2), d3 = true;
    else if (null === a2) {
      var g2 = b2.stateNode, h2 = b2.memoizedProps;
      g2.props = h2;
      var k2 = g2.context, l2 = c2.contextType;
      "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H2.current, l2 = Yf(b2, l2));
      var m3 = c2.getDerivedStateFromProps, q = "function" === typeof m3 || "function" === typeof g2.getSnapshotBeforeUpdate;
      q || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d3 || k2 !== l2) && Hi2(b2, g2, d3, l2);
      jh = false;
      var r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d3, g2, e2);
      k2 = b2.memoizedState;
      h2 !== d3 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m3 && (Di2(b2, c2, m3, d3), k2 = b2.memoizedState), (h2 = jh || Fi2(b2, c2, h2, d3, r2, k2, l2)) ? (q || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d3, b2.memoizedState = k2), g2.props = d3, g2.state = k2, g2.context = l2, d3 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d3 = false);
    } else {
      g2 = b2.stateNode;
      lh(a2, b2);
      h2 = b2.memoizedProps;
      l2 = b2.type === b2.elementType ? h2 : Ci2(b2.type, h2);
      g2.props = l2;
      q = b2.pendingProps;
      r2 = g2.context;
      k2 = c2.contextType;
      "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H2.current, k2 = Yf(b2, k2));
      var y3 = c2.getDerivedStateFromProps;
      (m3 = "function" === typeof y3 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q || r2 !== k2) && Hi2(b2, g2, d3, k2);
      jh = false;
      r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d3, g2, e2);
      var n3 = b2.memoizedState;
      h2 !== q || r2 !== n3 || Wf.current || jh ? ("function" === typeof y3 && (Di2(b2, c2, y3, d3), n3 = b2.memoizedState), (l2 = jh || Fi2(b2, c2, l2, d3, r2, n3, k2) || false) ? (m3 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d3, n3, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d3, n3, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d3, b2.memoizedState = n3), g2.props = d3, g2.state = n3, g2.context = k2, d3 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d3 = false);
    }
    return jj(a2, b2, c2, d3, f2, e2);
  }
  function jj(a2, b2, c2, d3, e2, f2) {
    gj(a2, b2);
    var g2 = 0 !== (b2.flags & 128);
    if (!d3 && !g2) return e2 && dg(b2, c2, false), Zi(a2, b2, f2);
    d3 = b2.stateNode;
    Wi.current = b2;
    var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d3.render();
    b2.flags |= 1;
    null !== a2 && g2 ? (b2.child = Ug(b2, a2.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a2, b2, h2, f2);
    b2.memoizedState = d3.state;
    e2 && dg(b2, c2, true);
    return b2.child;
  }
  function kj(a2) {
    var b2 = a2.stateNode;
    b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
    yh(a2, b2.containerInfo);
  }
  function lj(a2, b2, c2, d3, e2) {
    Ig();
    Jg(e2);
    b2.flags |= 256;
    Xi(a2, b2, c2, d3);
    return b2.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a2) {
    return { baseLanes: a2, cachePool: null, transitions: null };
  }
  function oj(a2, b2, c2) {
    var d3 = b2.pendingProps, e2 = L3.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
    (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
    if (h2) f2 = true, b2.flags &= -129;
    else if (null === a2 || null !== a2.memoizedState) e2 |= 1;
    G(L3, e2 & 1);
    if (null === a2) {
      Eg(b2);
      a2 = b2.memoizedState;
      if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
      g2 = d3.children;
      a2 = d3.fallback;
      return f2 ? (d3 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d3 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d3, 0, null), a2 = Tg(a2, d3, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a2) : qj(b2, g2);
    }
    e2 = a2.memoizedState;
    if (null !== e2 && (h2 = e2.dehydrated, null !== h2)) return rj(a2, b2, g2, d3, h2, e2, c2);
    if (f2) {
      f2 = d3.fallback;
      g2 = b2.mode;
      e2 = a2.child;
      h2 = e2.sibling;
      var k2 = { mode: "hidden", children: d3.children };
      0 === (g2 & 1) && b2.child !== e2 ? (d3 = b2.child, d3.childLanes = 0, d3.pendingProps = k2, b2.deletions = null) : (d3 = Pg(e2, k2), d3.subtreeFlags = e2.subtreeFlags & 14680064);
      null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
      f2.return = b2;
      d3.return = b2;
      d3.sibling = f2;
      b2.child = d3;
      d3 = f2;
      f2 = b2.child;
      g2 = a2.child.memoizedState;
      g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
      f2.memoizedState = g2;
      f2.childLanes = a2.childLanes & ~c2;
      b2.memoizedState = mj;
      return d3;
    }
    f2 = a2.child;
    a2 = f2.sibling;
    d3 = Pg(f2, { mode: "visible", children: d3.children });
    0 === (b2.mode & 1) && (d3.lanes = c2);
    d3.return = b2;
    d3.sibling = null;
    null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
    b2.child = d3;
    b2.memoizedState = null;
    return d3;
  }
  function qj(a2, b2) {
    b2 = pj({ mode: "visible", children: b2 }, a2.mode, 0, null);
    b2.return = a2;
    return a2.child = b2;
  }
  function sj(a2, b2, c2, d3) {
    null !== d3 && Jg(d3);
    Ug(b2, a2.child, null, c2);
    a2 = qj(b2, b2.pendingProps.children);
    a2.flags |= 2;
    b2.memoizedState = null;
    return a2;
  }
  function rj(a2, b2, c2, d3, e2, f2, g2) {
    if (c2) {
      if (b2.flags & 256) return b2.flags &= -257, d3 = Ki2(Error(p2(422))), sj(a2, b2, g2, d3);
      if (null !== b2.memoizedState) return b2.child = a2.child, b2.flags |= 128, null;
      f2 = d3.fallback;
      e2 = b2.mode;
      d3 = pj({ mode: "visible", children: d3.children }, e2, 0, null);
      f2 = Tg(f2, e2, g2, null);
      f2.flags |= 2;
      d3.return = b2;
      f2.return = b2;
      d3.sibling = f2;
      b2.child = d3;
      0 !== (b2.mode & 1) && Ug(b2, a2.child, null, g2);
      b2.child.memoizedState = nj(g2);
      b2.memoizedState = mj;
      return f2;
    }
    if (0 === (b2.mode & 1)) return sj(a2, b2, g2, null);
    if ("$!" === e2.data) {
      d3 = e2.nextSibling && e2.nextSibling.dataset;
      if (d3) var h2 = d3.dgst;
      d3 = h2;
      f2 = Error(p2(419));
      d3 = Ki2(f2, d3, void 0);
      return sj(a2, b2, g2, d3);
    }
    h2 = 0 !== (g2 & a2.childLanes);
    if (dh || h2) {
      d3 = Q2;
      if (null !== d3) {
        switch (g2 & -g2) {
          case 4:
            e2 = 2;
            break;
          case 16:
            e2 = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e2 = 32;
            break;
          case 536870912:
            e2 = 268435456;
            break;
          default:
            e2 = 0;
        }
        e2 = 0 !== (e2 & (d3.suspendedLanes | g2)) ? 0 : e2;
        0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a2, e2), gi2(d3, a2, e2, -1));
      }
      tj();
      d3 = Ki2(Error(p2(421)));
      return sj(a2, b2, g2, d3);
    }
    if ("$?" === e2.data) return b2.flags |= 128, b2.child = a2.child, b2 = uj.bind(null, a2), e2._reactRetry = b2, null;
    a2 = f2.treeContext;
    yg = Lf(e2.nextSibling);
    xg = b2;
    I2 = true;
    zg = null;
    null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
    b2 = qj(b2, d3.children);
    b2.flags |= 4096;
    return b2;
  }
  function vj(a2, b2, c2) {
    a2.lanes |= b2;
    var d3 = a2.alternate;
    null !== d3 && (d3.lanes |= b2);
    bh(a2.return, b2, c2);
  }
  function wj(a2, b2, c2, d3, e2) {
    var f2 = a2.memoizedState;
    null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d3, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d3, f2.tail = c2, f2.tailMode = e2);
  }
  function xj(a2, b2, c2) {
    var d3 = b2.pendingProps, e2 = d3.revealOrder, f2 = d3.tail;
    Xi(a2, b2, d3.children, c2);
    d3 = L3.current;
    if (0 !== (d3 & 2)) d3 = d3 & 1 | 2, b2.flags |= 128;
    else {
      if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b2.child; null !== a2; ) {
        if (13 === a2.tag) null !== a2.memoizedState && vj(a2, c2, b2);
        else if (19 === a2.tag) vj(a2, c2, b2);
        else if (null !== a2.child) {
          a2.child.return = a2;
          a2 = a2.child;
          continue;
        }
        if (a2 === b2) break a;
        for (; null === a2.sibling; ) {
          if (null === a2.return || a2.return === b2) break a;
          a2 = a2.return;
        }
        a2.sibling.return = a2.return;
        a2 = a2.sibling;
      }
      d3 &= 1;
    }
    G(L3, d3);
    if (0 === (b2.mode & 1)) b2.memoizedState = null;
    else switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        wj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Ch(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        wj(b2, true, c2, null, f2);
        break;
      case "together":
        wj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
    return b2.child;
  }
  function ij(a2, b2) {
    0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
  }
  function Zi(a2, b2, c2) {
    null !== a2 && (b2.dependencies = a2.dependencies);
    rh |= b2.lanes;
    if (0 === (c2 & b2.childLanes)) return null;
    if (null !== a2 && b2.child !== a2.child) throw Error(p2(153));
    if (null !== b2.child) {
      a2 = b2.child;
      c2 = Pg(a2, a2.pendingProps);
      b2.child = c2;
      for (c2.return = b2; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b2;
      c2.sibling = null;
    }
    return b2.child;
  }
  function yj(a2, b2, c2) {
    switch (b2.tag) {
      case 3:
        kj(b2);
        Ig();
        break;
      case 5:
        Ah(b2);
        break;
      case 1:
        Zf(b2.type) && cg(b2);
        break;
      case 4:
        yh(b2, b2.stateNode.containerInfo);
        break;
      case 10:
        var d3 = b2.type._context, e2 = b2.memoizedProps.value;
        G(Wg, d3._currentValue);
        d3._currentValue = e2;
        break;
      case 13:
        d3 = b2.memoizedState;
        if (null !== d3) {
          if (null !== d3.dehydrated) return G(L3, L3.current & 1), b2.flags |= 128, null;
          if (0 !== (c2 & b2.child.childLanes)) return oj(a2, b2, c2);
          G(L3, L3.current & 1);
          a2 = Zi(a2, b2, c2);
          return null !== a2 ? a2.sibling : null;
        }
        G(L3, L3.current & 1);
        break;
      case 19:
        d3 = 0 !== (c2 & b2.childLanes);
        if (0 !== (a2.flags & 128)) {
          if (d3) return xj(a2, b2, c2);
          b2.flags |= 128;
        }
        e2 = b2.memoizedState;
        null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
        G(L3, L3.current);
        if (d3) break;
        else return null;
      case 22:
      case 23:
        return b2.lanes = 0, dj(a2, b2, c2);
    }
    return Zi(a2, b2, c2);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a2, b2) {
    for (var c2 = b2.child; null !== c2; ) {
      if (5 === c2.tag || 6 === c2.tag) a2.appendChild(c2.stateNode);
      else if (4 !== c2.tag && null !== c2.child) {
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
      if (c2 === b2) break;
      for (; null === c2.sibling; ) {
        if (null === c2.return || c2.return === b2) return;
        c2 = c2.return;
      }
      c2.sibling.return = c2.return;
      c2 = c2.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a2, b2, c2, d3) {
    var e2 = a2.memoizedProps;
    if (e2 !== d3) {
      a2 = b2.stateNode;
      xh(uh.current);
      var f2 = null;
      switch (c2) {
        case "input":
          e2 = Ya2(a2, e2);
          d3 = Ya2(a2, d3);
          f2 = [];
          break;
        case "select":
          e2 = A2({}, e2, { value: void 0 });
          d3 = A2({}, d3, { value: void 0 });
          f2 = [];
          break;
        case "textarea":
          e2 = gb(a2, e2);
          d3 = gb(a2, d3);
          f2 = [];
          break;
        default:
          "function" !== typeof e2.onClick && "function" === typeof d3.onClick && (a2.onclick = Bf2);
      }
      ub(c2, d3);
      var g2;
      c2 = null;
      for (l2 in e2) if (!d3.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
        var h2 = e2[l2];
        for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
      } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea2.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
      for (l2 in d3) {
        var k2 = d3[l2];
        h2 = null != e2 ? e2[l2] : void 0;
        if (d3.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
          for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
          for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
        } else c2 || (f2 || (f2 = []), f2.push(
          l2,
          c2
        )), c2 = k2;
        else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea2.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
      }
      c2 && (f2 = f2 || []).push("style", c2);
      var l2 = f2;
      if (b2.updateQueue = l2) b2.flags |= 4;
    }
  };
  Cj = function(a2, b2, c2, d3) {
    c2 !== d3 && (b2.flags |= 4);
  };
  function Dj(a2, b2) {
    if (!I2) switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d3 = null; null !== c2; ) null !== c2.alternate && (d3 = c2), c2 = c2.sibling;
        null === d3 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d3.sibling = null;
    }
  }
  function S2(a2) {
    var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d3 = 0;
    if (b2) for (var e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d3 |= e2.subtreeFlags & 14680064, d3 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
    else for (e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d3 |= e2.subtreeFlags, d3 |= e2.flags, e2.return = a2, e2 = e2.sibling;
    a2.subtreeFlags |= d3;
    a2.childLanes = c2;
    return b2;
  }
  function Ej(a2, b2, c2) {
    var d3 = b2.pendingProps;
    wg(b2);
    switch (b2.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S2(b2), null;
      case 1:
        return Zf(b2.type) && $f(), S2(b2), null;
      case 3:
        d3 = b2.stateNode;
        zh();
        E2(Wf);
        E2(H2);
        Eh();
        d3.pendingContext && (d3.context = d3.pendingContext, d3.pendingContext = null);
        if (null === a2 || null === a2.child) Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a2, b2);
        S2(b2);
        return null;
      case 5:
        Bh(b2);
        var e2 = xh(wh.current);
        c2 = b2.type;
        if (null !== a2 && null != b2.stateNode) Bj(a2, b2, c2, d3, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        else {
          if (!d3) {
            if (null === b2.stateNode) throw Error(p2(166));
            S2(b2);
            return null;
          }
          a2 = xh(uh.current);
          if (Gg(b2)) {
            d3 = b2.stateNode;
            c2 = b2.type;
            var f2 = b2.memoizedProps;
            d3[Of2] = b2;
            d3[Pf2] = f2;
            a2 = 0 !== (b2.mode & 1);
            switch (c2) {
              case "dialog":
                D("cancel", d3);
                D("close", d3);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d3);
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf2.length; e2++) D(lf2[e2], d3);
                break;
              case "source":
                D("error", d3);
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  d3
                );
                D("load", d3);
                break;
              case "details":
                D("toggle", d3);
                break;
              case "input":
                Za(d3, f2);
                D("invalid", d3);
                break;
              case "select":
                d3._wrapperState = { wasMultiple: !!f2.multiple };
                D("invalid", d3);
                break;
              case "textarea":
                hb(d3, f2), D("invalid", d3);
            }
            ub(c2, f2);
            e2 = null;
            for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d3.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af2(d3.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d3.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af2(
                d3.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea2.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d3);
            }
            switch (c2) {
              case "input":
                Va2(d3);
                db(d3, f2, true);
                break;
              case "textarea":
                Va2(d3);
                jb(d3);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f2.onClick && (d3.onclick = Bf2);
            }
            d3 = e2;
            b2.updateQueue = d3;
            null !== d3 && (b2.flags |= 4);
          } else {
            g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
            "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d3.is ? a2 = g2.createElement(c2, { is: d3.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d3.multiple ? g2.multiple = true : d3.size && (g2.size = d3.size))) : a2 = g2.createElementNS(a2, c2);
            a2[Of2] = b2;
            a2[Pf2] = d3;
            zj(a2, b2, false, false);
            b2.stateNode = a2;
            a: {
              g2 = vb(c2, d3);
              switch (c2) {
                case "dialog":
                  D("cancel", a2);
                  D("close", a2);
                  e2 = d3;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a2);
                  e2 = d3;
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf2.length; e2++) D(lf2[e2], a2);
                  e2 = d3;
                  break;
                case "source":
                  D("error", a2);
                  e2 = d3;
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    a2
                  );
                  D("load", a2);
                  e2 = d3;
                  break;
                case "details":
                  D("toggle", a2);
                  e2 = d3;
                  break;
                case "input":
                  Za(a2, d3);
                  e2 = Ya2(a2, d3);
                  D("invalid", a2);
                  break;
                case "option":
                  e2 = d3;
                  break;
                case "select":
                  a2._wrapperState = { wasMultiple: !!d3.multiple };
                  e2 = A2({}, d3, { value: void 0 });
                  D("invalid", a2);
                  break;
                case "textarea":
                  hb(a2, d3);
                  e2 = gb(a2, d3);
                  D("invalid", a2);
                  break;
                default:
                  e2 = d3;
              }
              ub(c2, e2);
              h2 = e2;
              for (f2 in h2) if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea2.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a2) : null != k2 && ta2(a2, f2, k2, g2));
              }
              switch (c2) {
                case "input":
                  Va2(a2);
                  db(a2, d3, false);
                  break;
                case "textarea":
                  Va2(a2);
                  jb(a2);
                  break;
                case "option":
                  null != d3.value && a2.setAttribute("value", "" + Sa2(d3.value));
                  break;
                case "select":
                  a2.multiple = !!d3.multiple;
                  f2 = d3.value;
                  null != f2 ? fb(a2, !!d3.multiple, f2, false) : null != d3.defaultValue && fb(
                    a2,
                    !!d3.multiple,
                    d3.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e2.onClick && (a2.onclick = Bf2);
              }
              switch (c2) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d3 = !!d3.autoFocus;
                  break a;
                case "img":
                  d3 = true;
                  break a;
                default:
                  d3 = false;
              }
            }
            d3 && (b2.flags |= 4);
          }
          null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        }
        S2(b2);
        return null;
      case 6:
        if (a2 && null != b2.stateNode) Cj(a2, b2, a2.memoizedProps, d3);
        else {
          if ("string" !== typeof d3 && null === b2.stateNode) throw Error(p2(166));
          c2 = xh(wh.current);
          xh(uh.current);
          if (Gg(b2)) {
            d3 = b2.stateNode;
            c2 = b2.memoizedProps;
            d3[Of2] = b2;
            if (f2 = d3.nodeValue !== c2) {
              if (a2 = xg, null !== a2) switch (a2.tag) {
                case 3:
                  Af2(d3.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af2(d3.nodeValue, c2, 0 !== (a2.mode & 1));
              }
            }
            f2 && (b2.flags |= 4);
          } else d3 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d3), d3[Of2] = b2, b2.stateNode = d3;
        }
        S2(b2);
        return null;
      case 13:
        E2(L3);
        d3 = b2.memoizedState;
        if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
          if (I2 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
          else if (f2 = Gg(b2), null !== d3 && null !== d3.dehydrated) {
            if (null === a2) {
              if (!f2) throw Error(p2(318));
              f2 = b2.memoizedState;
              f2 = null !== f2 ? f2.dehydrated : null;
              if (!f2) throw Error(p2(317));
              f2[Of2] = b2;
            } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
            S2(b2);
            f2 = false;
          } else null !== zg && (Fj(zg), zg = null), f2 = true;
          if (!f2) return b2.flags & 65536 ? b2 : null;
        }
        if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
        d3 = null !== d3;
        d3 !== (null !== a2 && null !== a2.memoizedState) && d3 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (L3.current & 1) ? 0 === T2 && (T2 = 3) : tj()));
        null !== b2.updateQueue && (b2.flags |= 4);
        S2(b2);
        return null;
      case 4:
        return zh(), Aj(a2, b2), null === a2 && sf2(b2.stateNode.containerInfo), S2(b2), null;
      case 10:
        return ah(b2.type._context), S2(b2), null;
      case 17:
        return Zf(b2.type) && $f(), S2(b2), null;
      case 19:
        E2(L3);
        f2 = b2.memoizedState;
        if (null === f2) return S2(b2), null;
        d3 = 0 !== (b2.flags & 128);
        g2 = f2.rendering;
        if (null === g2) if (d3) Dj(f2, false);
        else {
          if (0 !== T2 || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b2.child; null !== a2; ) {
            g2 = Ch(a2);
            if (null !== g2) {
              b2.flags |= 128;
              Dj(f2, false);
              d3 = g2.updateQueue;
              null !== d3 && (b2.updateQueue = d3, b2.flags |= 4);
              b2.subtreeFlags = 0;
              d3 = c2;
              for (c2 = b2.child; null !== c2; ) f2 = c2, a2 = d3, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
              G(L3, L3.current & 1 | 2);
              return b2.child;
            }
            a2 = a2.sibling;
          }
          null !== f2.tail && B3() > Gj && (b2.flags |= 128, d3 = true, Dj(f2, false), b2.lanes = 4194304);
        }
        else {
          if (!d3) if (a2 = Ch(g2), null !== a2) {
            if (b2.flags |= 128, d3 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I2) return S2(b2), null;
          } else 2 * B3() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d3 = true, Dj(f2, false), b2.lanes = 4194304);
          f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
        }
        if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B3(), b2.sibling = null, c2 = L3.current, G(L3, d3 ? c2 & 1 | 2 : c2 & 1), b2;
        S2(b2);
        return null;
      case 22:
      case 23:
        return Hj(), d3 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d3 && (b2.flags |= 8192), d3 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S2(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S2(b2), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p2(156, b2.tag));
  }
  function Ij(a2, b2) {
    wg(b2);
    switch (b2.tag) {
      case 1:
        return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 3:
        return zh(), E2(Wf), E2(H2), Eh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 5:
        return Bh(b2), null;
      case 13:
        E2(L3);
        a2 = b2.memoizedState;
        if (null !== a2 && null !== a2.dehydrated) {
          if (null === b2.alternate) throw Error(p2(340));
          Ig();
        }
        a2 = b2.flags;
        return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 19:
        return E2(L3), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b2.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V2 = null;
  function Lj(a2, b2) {
    var c2 = a2.ref;
    if (null !== c2) if ("function" === typeof c2) try {
      c2(null);
    } catch (d3) {
      W(a2, b2, d3);
    }
    else c2.current = null;
  }
  function Mj(a2, b2, c2) {
    try {
      c2();
    } catch (d3) {
      W(a2, b2, d3);
    }
  }
  var Nj = false;
  function Oj(a2, b2) {
    Cf2 = dd;
    a2 = Me();
    if (Ne(a2)) {
      if ("selectionStart" in a2) var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
      else a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d3 = c2.getSelection && c2.getSelection();
        if (d3 && 0 !== d3.rangeCount) {
          c2 = d3.anchorNode;
          var e2 = d3.anchorOffset, f2 = d3.focusNode;
          d3 = d3.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m3 = 0, q = a2, r2 = null;
          b: for (; ; ) {
            for (var y3; ; ) {
              q !== c2 || 0 !== e2 && 3 !== q.nodeType || (h2 = g2 + e2);
              q !== f2 || 0 !== d3 && 3 !== q.nodeType || (k2 = g2 + d3);
              3 === q.nodeType && (g2 += q.nodeValue.length);
              if (null === (y3 = q.firstChild)) break;
              r2 = q;
              q = y3;
            }
            for (; ; ) {
              if (q === a2) break b;
              r2 === c2 && ++l2 === e2 && (h2 = g2);
              r2 === f2 && ++m3 === d3 && (k2 = g2);
              if (null !== (y3 = q.nextSibling)) break;
              q = r2;
              r2 = q.parentNode;
            }
            q = y3;
          }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else c2 = null;
      }
      c2 = c2 || { start: 0, end: 0 };
    } else c2 = null;
    Df2 = { focusedElem: a2, selectionRange: c2 };
    dd = false;
    for (V2 = b2; null !== V2; ) if (b2 = V2, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2) a2.return = b2, V2 = a2;
    else for (; null !== V2; ) {
      b2 = V2;
      try {
        var n3 = b2.alternate;
        if (0 !== (b2.flags & 1024)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n3) {
              var t2 = n3.memoizedProps, J = n3.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci2(b2.type, t2), J);
              x2.__reactInternalSnapshotBeforeUpdate = w2;
            }
            break;
          case 3:
            var u2 = b2.stateNode.containerInfo;
            1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p2(163));
        }
      } catch (F) {
        W(b2, b2.return, F);
      }
      a2 = b2.sibling;
      if (null !== a2) {
        a2.return = b2.return;
        V2 = a2;
        break;
      }
      V2 = b2.return;
    }
    n3 = Nj;
    Nj = false;
    return n3;
  }
  function Pj(a2, b2, c2) {
    var d3 = b2.updateQueue;
    d3 = null !== d3 ? d3.lastEffect : null;
    if (null !== d3) {
      var e2 = d3 = d3.next;
      do {
        if ((e2.tag & a2) === a2) {
          var f2 = e2.destroy;
          e2.destroy = void 0;
          void 0 !== f2 && Mj(b2, c2, f2);
        }
        e2 = e2.next;
      } while (e2 !== d3);
    }
  }
  function Qj(a2, b2) {
    b2 = b2.updateQueue;
    b2 = null !== b2 ? b2.lastEffect : null;
    if (null !== b2) {
      var c2 = b2 = b2.next;
      do {
        if ((c2.tag & a2) === a2) {
          var d3 = c2.create;
          c2.destroy = d3();
        }
        c2 = c2.next;
      } while (c2 !== b2);
    }
  }
  function Rj(a2) {
    var b2 = a2.ref;
    if (null !== b2) {
      var c2 = a2.stateNode;
      switch (a2.tag) {
        case 5:
          a2 = c2;
          break;
        default:
          a2 = c2;
      }
      "function" === typeof b2 ? b2(a2) : b2.current = a2;
    }
  }
  function Sj(a2) {
    var b2 = a2.alternate;
    null !== b2 && (a2.alternate = null, Sj(b2));
    a2.child = null;
    a2.deletions = null;
    a2.sibling = null;
    5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of2], delete b2[Pf2], delete b2[of2], delete b2[Qf], delete b2[Rf2]));
    a2.stateNode = null;
    a2.return = null;
    a2.dependencies = null;
    a2.memoizedProps = null;
    a2.memoizedState = null;
    a2.pendingProps = null;
    a2.stateNode = null;
    a2.updateQueue = null;
  }
  function Tj(a2) {
    return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
  }
  function Uj(a2) {
    a: for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Tj(a2.return)) return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2) continue a;
        if (null === a2.child || 4 === a2.tag) continue a;
        else a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2)) return a2.stateNode;
    }
  }
  function Vj(a2, b2, c2) {
    var d3 = a2.tag;
    if (5 === d3 || 6 === d3) a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf2));
    else if (4 !== d3 && (a2 = a2.child, null !== a2)) for (Vj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Vj(a2, b2, c2), a2 = a2.sibling;
  }
  function Wj(a2, b2, c2) {
    var d3 = a2.tag;
    if (5 === d3 || 6 === d3) a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
    else if (4 !== d3 && (a2 = a2.child, null !== a2)) for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Wj(a2, b2, c2), a2 = a2.sibling;
  }
  var X = null, Xj = false;
  function Yj(a2, b2, c2) {
    for (c2 = c2.child; null !== c2; ) Zj(a2, b2, c2), c2 = c2.sibling;
  }
  function Zj(a2, b2, c2) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
    switch (c2.tag) {
      case 5:
        U || Lj(c2, b2);
      case 6:
        var d3 = X, e2 = Xj;
        X = null;
        Yj(a2, b2, c2);
        X = d3;
        Xj = e2;
        null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X.removeChild(c2.stateNode));
        break;
      case 18:
        null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X, c2.stateNode));
        break;
      case 4:
        d3 = X;
        e2 = Xj;
        X = c2.stateNode.containerInfo;
        Xj = true;
        Yj(a2, b2, c2);
        X = d3;
        Xj = e2;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && (d3 = c2.updateQueue, null !== d3 && (d3 = d3.lastEffect, null !== d3))) {
          e2 = d3 = d3.next;
          do {
            var f2 = e2, g2 = f2.destroy;
            f2 = f2.tag;
            void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
            e2 = e2.next;
          } while (e2 !== d3);
        }
        Yj(a2, b2, c2);
        break;
      case 1:
        if (!U && (Lj(c2, b2), d3 = c2.stateNode, "function" === typeof d3.componentWillUnmount)) try {
          d3.props = c2.memoizedProps, d3.state = c2.memoizedState, d3.componentWillUnmount();
        } catch (h2) {
          W(c2, b2, h2);
        }
        Yj(a2, b2, c2);
        break;
      case 21:
        Yj(a2, b2, c2);
        break;
      case 22:
        c2.mode & 1 ? (U = (d3 = U) || null !== c2.memoizedState, Yj(a2, b2, c2), U = d3) : Yj(a2, b2, c2);
        break;
      default:
        Yj(a2, b2, c2);
    }
  }
  function ak(a2) {
    var b2 = a2.updateQueue;
    if (null !== b2) {
      a2.updateQueue = null;
      var c2 = a2.stateNode;
      null === c2 && (c2 = a2.stateNode = new Kj());
      b2.forEach(function(b3) {
        var d3 = bk.bind(null, a2, b3);
        c2.has(b3) || (c2.add(b3), b3.then(d3, d3));
      });
    }
  }
  function ck(a2, b2) {
    var c2 = b2.deletions;
    if (null !== c2) for (var d3 = 0; d3 < c2.length; d3++) {
      var e2 = c2[d3];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a: for (; null !== h2; ) {
          switch (h2.tag) {
            case 5:
              X = h2.stateNode;
              Xj = false;
              break a;
            case 3:
              X = h2.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X = h2.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h2 = h2.return;
        }
        if (null === X) throw Error(p2(160));
        Zj(f2, g2, e2);
        X = null;
        Xj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b2, l2);
      }
    }
    if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a2), b2 = b2.sibling;
  }
  function dk(a2, b2) {
    var c2 = a2.alternate, d3 = a2.flags;
    switch (a2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b2, a2);
        ek(a2);
        if (d3 & 4) {
          try {
            Pj(3, a2, a2.return), Qj(3, a2);
          } catch (t2) {
            W(a2, a2.return, t2);
          }
          try {
            Pj(5, a2, a2.return);
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 1:
        ck(b2, a2);
        ek(a2);
        d3 & 512 && null !== c2 && Lj(c2, c2.return);
        break;
      case 5:
        ck(b2, a2);
        ek(a2);
        d3 & 512 && null !== c2 && Lj(c2, c2.return);
        if (a2.flags & 32) {
          var e2 = a2.stateNode;
          try {
            ob(e2, "");
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        if (d3 & 4 && (e2 = a2.stateNode, null != e2)) {
          var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
          a2.updateQueue = null;
          if (null !== k2) try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m3 = k2[g2], q = k2[g2 + 1];
              "style" === m3 ? sb(e2, q) : "dangerouslySetInnerHTML" === m3 ? nb(e2, q) : "children" === m3 ? ob(e2, q) : ta2(e2, m3, q, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y3 = f2.value;
                null != y3 ? fb(e2, !!f2.multiple, y3, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf2] = f2;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 6:
        ck(b2, a2);
        ek(a2);
        if (d3 & 4) {
          if (null === a2.stateNode) throw Error(p2(162));
          e2 = a2.stateNode;
          f2 = a2.memoizedProps;
          try {
            e2.nodeValue = f2;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 3:
        ck(b2, a2);
        ek(a2);
        if (d3 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
          bd(b2.containerInfo);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
        break;
      case 4:
        ck(b2, a2);
        ek(a2);
        break;
      case 13:
        ck(b2, a2);
        ek(a2);
        e2 = a2.child;
        e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B3()));
        d3 & 4 && ak(a2);
        break;
      case 22:
        m3 = null !== c2 && null !== c2.memoizedState;
        a2.mode & 1 ? (U = (l2 = U) || m3, ck(b2, a2), U = l2) : ck(b2, a2);
        ek(a2);
        if (d3 & 8192) {
          l2 = null !== a2.memoizedState;
          if ((a2.stateNode.isHidden = l2) && !m3 && 0 !== (a2.mode & 1)) for (V2 = a2, m3 = a2.child; null !== m3; ) {
            for (q = V2 = m3; null !== V2; ) {
              r2 = V2;
              y3 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n3 = r2.stateNode;
                  if ("function" === typeof n3.componentWillUnmount) {
                    d3 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d3, n3.props = b2.memoizedProps, n3.state = b2.memoizedState, n3.componentWillUnmount();
                    } catch (t2) {
                      W(d3, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q);
                    continue;
                  }
              }
              null !== y3 ? (y3.return = r2, V2 = y3) : gk(q);
            }
            m3 = m3.sibling;
          }
          a: for (m3 = null, q = a2; ; ) {
            if (5 === q.tag) {
              if (null === m3) {
                m3 = q;
                try {
                  e2 = q.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q.stateNode, k2 = q.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
              }
            } else if (6 === q.tag) {
              if (null === m3) try {
                q.stateNode.nodeValue = l2 ? "" : q.memoizedProps;
              } catch (t2) {
                W(a2, a2.return, t2);
              }
            } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a2) && null !== q.child) {
              q.child.return = q;
              q = q.child;
              continue;
            }
            if (q === a2) break a;
            for (; null === q.sibling; ) {
              if (null === q.return || q.return === a2) break a;
              m3 === q && (m3 = null);
              q = q.return;
            }
            m3 === q && (m3 = null);
            q.sibling.return = q.return;
            q = q.sibling;
          }
        }
        break;
      case 19:
        ck(b2, a2);
        ek(a2);
        d3 & 4 && ak(a2);
        break;
      case 21:
        break;
      default:
        ck(
          b2,
          a2
        ), ek(a2);
    }
  }
  function ek(a2) {
    var b2 = a2.flags;
    if (b2 & 2) {
      try {
        a: {
          for (var c2 = a2.return; null !== c2; ) {
            if (Tj(c2)) {
              var d3 = c2;
              break a;
            }
            c2 = c2.return;
          }
          throw Error(p2(160));
        }
        switch (d3.tag) {
          case 5:
            var e2 = d3.stateNode;
            d3.flags & 32 && (ob(e2, ""), d3.flags &= -33);
            var f2 = Uj(a2);
            Wj(a2, f2, e2);
            break;
          case 3:
          case 4:
            var g2 = d3.stateNode.containerInfo, h2 = Uj(a2);
            Vj(a2, h2, g2);
            break;
          default:
            throw Error(p2(161));
        }
      } catch (k2) {
        W(a2, a2.return, k2);
      }
      a2.flags &= -3;
    }
    b2 & 4096 && (a2.flags &= -4097);
  }
  function hk(a2, b2, c2) {
    V2 = a2;
    ik(a2);
  }
  function ik(a2, b2, c2) {
    for (var d3 = 0 !== (a2.mode & 1); null !== V2; ) {
      var e2 = V2, f2 = e2.child;
      if (22 === e2.tag && d3) {
        var g2 = null !== e2.memoizedState || Jj;
        if (!g2) {
          var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
          h2 = Jj;
          var l2 = U;
          Jj = g2;
          if ((U = k2) && !l2) for (V2 = e2; null !== V2; ) g2 = V2, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V2 = k2) : jk(e2);
          for (; null !== f2; ) V2 = f2, ik(f2), f2 = f2.sibling;
          V2 = e2;
          Jj = h2;
          U = l2;
        }
        kk(a2);
      } else 0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V2 = f2) : kk(a2);
    }
  }
  function kk(a2) {
    for (; null !== V2; ) {
      var b2 = V2;
      if (0 !== (b2.flags & 8772)) {
        var c2 = b2.alternate;
        try {
          if (0 !== (b2.flags & 8772)) switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b2);
              break;
            case 1:
              var d3 = b2.stateNode;
              if (b2.flags & 4 && !U) if (null === c2) d3.componentDidMount();
              else {
                var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci2(b2.type, c2.memoizedProps);
                d3.componentDidUpdate(e2, c2.memoizedState, d3.__reactInternalSnapshotBeforeUpdate);
              }
              var f2 = b2.updateQueue;
              null !== f2 && sh(b2, f2, d3);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child) switch (b2.child.tag) {
                  case 5:
                    c2 = b2.child.stateNode;
                    break;
                  case 1:
                    c2 = b2.child.stateNode;
                }
                sh(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m3 = l2.memoizedState;
                  if (null !== m3) {
                    var q = m3.dehydrated;
                    null !== q && bd(q);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p2(163));
          }
          U || b2.flags & 512 && Rj(b2);
        } catch (r2) {
          W(b2, b2.return, r2);
        }
      }
      if (b2 === a2) {
        V2 = null;
        break;
      }
      c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V2 = c2;
        break;
      }
      V2 = b2.return;
    }
  }
  function gk(a2) {
    for (; null !== V2; ) {
      var b2 = V2;
      if (b2 === a2) {
        V2 = null;
        break;
      }
      var c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V2 = c2;
        break;
      }
      V2 = b2.return;
    }
  }
  function jk(a2) {
    for (; null !== V2; ) {
      var b2 = V2;
      try {
        switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            var c2 = b2.return;
            try {
              Qj(4, b2);
            } catch (k2) {
              W(b2, c2, k2);
            }
            break;
          case 1:
            var d3 = b2.stateNode;
            if ("function" === typeof d3.componentDidMount) {
              var e2 = b2.return;
              try {
                d3.componentDidMount();
              } catch (k2) {
                W(b2, e2, k2);
              }
            }
            var f2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W(b2, f2, k2);
            }
            break;
          case 5:
            var g2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W(b2, g2, k2);
            }
        }
      } catch (k2) {
        W(b2, b2.return, k2);
      }
      if (b2 === a2) {
        V2 = null;
        break;
      }
      var h2 = b2.sibling;
      if (null !== h2) {
        h2.return = b2.return;
        V2 = h2;
        break;
      }
      V2 = b2.return;
    }
  }
  var lk = Math.ceil, mk = ua2.ReactCurrentDispatcher, nk = ua2.ReactCurrentOwner, ok = ua2.ReactCurrentBatchConfig, K2 = 0, Q2 = null, Y = null, Z = 0, fj = 0, ej = Uf2(0), T2 = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi2 = false, Pi2 = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R2() {
    return 0 !== (K2 & 6) ? B3() : -1 !== Ak ? Ak : Ak = B3();
  }
  function yi(a2) {
    if (0 === (a2.mode & 1)) return 1;
    if (0 !== (K2 & 2) && 0 !== Z) return Z & -Z;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a2 = C2;
    if (0 !== a2) return a2;
    a2 = window.event;
    a2 = void 0 === a2 ? 16 : jd(a2.type);
    return a2;
  }
  function gi2(a2, b2, c2, d3) {
    if (50 < yk) throw yk = 0, zk = null, Error(p2(185));
    Ac(a2, c2, d3);
    if (0 === (K2 & 2) || a2 !== Q2) a2 === Q2 && (0 === (K2 & 2) && (qk |= c2), 4 === T2 && Ck(a2, Z)), Dk(a2, d3), 1 === c2 && 0 === K2 && 0 === (b2.mode & 1) && (Gj = B3() + 500, fg && jg());
  }
  function Dk(a2, b2) {
    var c2 = a2.callbackNode;
    wc(a2, b2);
    var d3 = uc(a2, a2 === Q2 ? Z : 0);
    if (0 === d3) null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
    else if (b2 = d3 & -d3, a2.callbackPriority !== b2) {
      null != c2 && bc(c2);
      if (1 === b2) 0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
        0 === (K2 & 6) && jg();
      }), c2 = null;
      else {
        switch (Dc(d3)) {
          case 1:
            c2 = fc;
            break;
          case 4:
            c2 = gc;
            break;
          case 16:
            c2 = hc;
            break;
          case 536870912:
            c2 = jc;
            break;
          default:
            c2 = hc;
        }
        c2 = Fk(c2, Gk.bind(null, a2));
      }
      a2.callbackPriority = b2;
      a2.callbackNode = c2;
    }
  }
  function Gk(a2, b2) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K2 & 6)) throw Error(p2(327));
    var c2 = a2.callbackNode;
    if (Hk() && a2.callbackNode !== c2) return null;
    var d3 = uc(a2, a2 === Q2 ? Z : 0);
    if (0 === d3) return null;
    if (0 !== (d3 & 30) || 0 !== (d3 & a2.expiredLanes) || b2) b2 = Ik(a2, d3);
    else {
      b2 = d3;
      var e2 = K2;
      K2 |= 2;
      var f2 = Jk();
      if (Q2 !== a2 || Z !== b2) uk = null, Gj = B3() + 500, Kk(a2, b2);
      do
        try {
          Lk();
          break;
        } catch (h2) {
          Mk(a2, h2);
        }
      while (1);
      $g();
      mk.current = f2;
      K2 = e2;
      null !== Y ? b2 = 0 : (Q2 = null, Z = 0, b2 = T2);
    }
    if (0 !== b2) {
      2 === b2 && (e2 = xc(a2), 0 !== e2 && (d3 = e2, b2 = Nk(a2, e2)));
      if (1 === b2) throw c2 = pk, Kk(a2, 0), Ck(a2, d3), Dk(a2, B3()), c2;
      if (6 === b2) Ck(a2, d3);
      else {
        e2 = a2.current.alternate;
        if (0 === (d3 & 30) && !Ok(e2) && (b2 = Ik(a2, d3), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d3 = f2, b2 = Nk(a2, f2))), 1 === b2)) throw c2 = pk, Kk(a2, 0), Ck(a2, d3), Dk(a2, B3()), c2;
        a2.finishedWork = e2;
        a2.finishedLanes = d3;
        switch (b2) {
          case 0:
          case 1:
            throw Error(p2(345));
          case 2:
            Pk(a2, tk, uk);
            break;
          case 3:
            Ck(a2, d3);
            if ((d3 & 130023424) === d3 && (b2 = fk + 500 - B3(), 10 < b2)) {
              if (0 !== uc(a2, 0)) break;
              e2 = a2.suspendedLanes;
              if ((e2 & d3) !== d3) {
                R2();
                a2.pingedLanes |= a2.suspendedLanes & e2;
                break;
              }
              a2.timeoutHandle = Ff2(Pk.bind(null, a2, tk, uk), b2);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 4:
            Ck(a2, d3);
            if ((d3 & 4194240) === d3) break;
            b2 = a2.eventTimes;
            for (e2 = -1; 0 < d3; ) {
              var g2 = 31 - oc(d3);
              f2 = 1 << g2;
              g2 = b2[g2];
              g2 > e2 && (e2 = g2);
              d3 &= ~f2;
            }
            d3 = e2;
            d3 = B3() - d3;
            d3 = (120 > d3 ? 120 : 480 > d3 ? 480 : 1080 > d3 ? 1080 : 1920 > d3 ? 1920 : 3e3 > d3 ? 3e3 : 4320 > d3 ? 4320 : 1960 * lk(d3 / 1960)) - d3;
            if (10 < d3) {
              a2.timeoutHandle = Ff2(Pk.bind(null, a2, tk, uk), d3);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 5:
            Pk(a2, tk, uk);
            break;
          default:
            throw Error(p2(329));
        }
      }
    }
    Dk(a2, B3());
    return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
  }
  function Nk(a2, b2) {
    var c2 = sk;
    a2.current.memoizedState.isDehydrated && (Kk(a2, b2).flags |= 256);
    a2 = Ik(a2, b2);
    2 !== a2 && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
    return a2;
  }
  function Fj(a2) {
    null === tk ? tk = a2 : tk.push.apply(tk, a2);
  }
  function Ok(a2) {
    for (var b2 = a2; ; ) {
      if (b2.flags & 16384) {
        var c2 = b2.updateQueue;
        if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d3 = 0; d3 < c2.length; d3++) {
          var e2 = c2[d3], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2)) return false;
          } catch (g2) {
            return false;
          }
        }
      }
      c2 = b2.child;
      if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
      else {
        if (b2 === a2) break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a2) return true;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
    }
    return true;
  }
  function Ck(a2, b2) {
    b2 &= ~rk;
    b2 &= ~qk;
    a2.suspendedLanes |= b2;
    a2.pingedLanes &= ~b2;
    for (a2 = a2.expirationTimes; 0 < b2; ) {
      var c2 = 31 - oc(b2), d3 = 1 << c2;
      a2[c2] = -1;
      b2 &= ~d3;
    }
  }
  function Ek(a2) {
    if (0 !== (K2 & 6)) throw Error(p2(327));
    Hk();
    var b2 = uc(a2, 0);
    if (0 === (b2 & 1)) return Dk(a2, B3()), null;
    var c2 = Ik(a2, b2);
    if (0 !== a2.tag && 2 === c2) {
      var d3 = xc(a2);
      0 !== d3 && (b2 = d3, c2 = Nk(a2, d3));
    }
    if (1 === c2) throw c2 = pk, Kk(a2, 0), Ck(a2, b2), Dk(a2, B3()), c2;
    if (6 === c2) throw Error(p2(345));
    a2.finishedWork = a2.current.alternate;
    a2.finishedLanes = b2;
    Pk(a2, tk, uk);
    Dk(a2, B3());
    return null;
  }
  function Qk(a2, b2) {
    var c2 = K2;
    K2 |= 1;
    try {
      return a2(b2);
    } finally {
      K2 = c2, 0 === K2 && (Gj = B3() + 500, fg && jg());
    }
  }
  function Rk(a2) {
    null !== wk && 0 === wk.tag && 0 === (K2 & 6) && Hk();
    var b2 = K2;
    K2 |= 1;
    var c2 = ok.transition, d3 = C2;
    try {
      if (ok.transition = null, C2 = 1, a2) return a2();
    } finally {
      C2 = d3, ok.transition = c2, K2 = b2, 0 === (K2 & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E2(ej);
  }
  function Kk(a2, b2) {
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    var c2 = a2.timeoutHandle;
    -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
    if (null !== Y) for (c2 = Y.return; null !== c2; ) {
      var d3 = c2;
      wg(d3);
      switch (d3.tag) {
        case 1:
          d3 = d3.type.childContextTypes;
          null !== d3 && void 0 !== d3 && $f();
          break;
        case 3:
          zh();
          E2(Wf);
          E2(H2);
          Eh();
          break;
        case 5:
          Bh(d3);
          break;
        case 4:
          zh();
          break;
        case 13:
          E2(L3);
          break;
        case 19:
          E2(L3);
          break;
        case 10:
          ah(d3.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c2 = c2.return;
    }
    Q2 = a2;
    Y = a2 = Pg(a2.current, null);
    Z = fj = b2;
    T2 = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b2 = 0; b2 < fh.length; b2++) if (c2 = fh[b2], d3 = c2.interleaved, null !== d3) {
        c2.interleaved = null;
        var e2 = d3.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d3.next = g2;
        }
        c2.pending = d3;
      }
      fh = null;
    }
    return a2;
  }
  function Mk(a2, b2) {
    do {
      var c2 = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d3 = M2.memoizedState; null !== d3; ) {
            var e2 = d3.queue;
            null !== e2 && (e2.pending = null);
            d3 = d3.next;
          }
          Ih = false;
        }
        Hh = 0;
        O2 = N2 = M2 = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c2 || null === c2.return) {
          T2 = 1;
          pk = b2;
          Y = null;
          break;
        }
        a: {
          var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
          b2 = Z;
          h2.flags |= 32768;
          if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
            var l2 = k2, m3 = h2, q = m3.tag;
            if (0 === (m3.mode & 1) && (0 === q || 11 === q || 15 === q)) {
              var r2 = m3.alternate;
              r2 ? (m3.updateQueue = r2.updateQueue, m3.memoizedState = r2.memoizedState, m3.lanes = r2.lanes) : (m3.updateQueue = null, m3.memoizedState = null);
            }
            var y3 = Ui2(g2);
            if (null !== y3) {
              y3.flags &= -257;
              Vi(y3, g2, h2, f2, b2);
              y3.mode & 1 && Si(f2, l2, b2);
              b2 = y3;
              k2 = l2;
              var n3 = b2.updateQueue;
              if (null === n3) {
                var t2 = /* @__PURE__ */ new Set();
                t2.add(k2);
                b2.updateQueue = t2;
              } else n3.add(k2);
              break a;
            } else {
              if (0 === (b2 & 1)) {
                Si(f2, l2, b2);
                tj();
                break a;
              }
              k2 = Error(p2(426));
            }
          } else if (I2 && h2.mode & 1) {
            var J = Ui2(g2);
            if (null !== J) {
              0 === (J.flags & 65536) && (J.flags |= 256);
              Vi(J, g2, h2, f2, b2);
              Jg(Ji(k2, h2));
              break a;
            }
          }
          f2 = k2 = Ji(k2, h2);
          4 !== T2 && (T2 = 2);
          null === sk ? sk = [f2] : sk.push(f2);
          f2 = g2;
          do {
            switch (f2.tag) {
              case 3:
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var x2 = Ni2(f2, k2, b2);
                ph(f2, x2);
                break a;
              case 1:
                h2 = k2;
                var w2 = f2.type, u2 = f2.stateNode;
                if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var F = Qi(f2, h2, b2);
                  ph(f2, F);
                  break a;
                }
            }
            f2 = f2.return;
          } while (null !== f2);
        }
        Sk(c2);
      } catch (na2) {
        b2 = na2;
        Y === c2 && null !== c2 && (Y = c2 = c2.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a2 = mk.current;
    mk.current = Rh;
    return null === a2 ? Rh : a2;
  }
  function tj() {
    if (0 === T2 || 3 === T2 || 2 === T2) T2 = 4;
    null === Q2 || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q2, Z);
  }
  function Ik(a2, b2) {
    var c2 = K2;
    K2 |= 2;
    var d3 = Jk();
    if (Q2 !== a2 || Z !== b2) uk = null, Kk(a2, b2);
    do
      try {
        Tk();
        break;
      } catch (e2) {
        Mk(a2, e2);
      }
    while (1);
    $g();
    K2 = c2;
    mk.current = d3;
    if (null !== Y) throw Error(p2(261));
    Q2 = null;
    Z = 0;
    return T2;
  }
  function Tk() {
    for (; null !== Y; ) Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); ) Uk(Y);
  }
  function Uk(a2) {
    var b2 = Vk(a2.alternate, a2, fj);
    a2.memoizedProps = a2.pendingProps;
    null === b2 ? Sk(a2) : Y = b2;
    nk.current = null;
  }
  function Sk(a2) {
    var b2 = a2;
    do {
      var c2 = b2.alternate;
      a2 = b2.return;
      if (0 === (b2.flags & 32768)) {
        if (c2 = Ej(c2, b2, fj), null !== c2) {
          Y = c2;
          return;
        }
      } else {
        c2 = Ij(c2, b2);
        if (null !== c2) {
          c2.flags &= 32767;
          Y = c2;
          return;
        }
        if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
        else {
          T2 = 6;
          Y = null;
          return;
        }
      }
      b2 = b2.sibling;
      if (null !== b2) {
        Y = b2;
        return;
      }
      Y = b2 = a2;
    } while (null !== b2);
    0 === T2 && (T2 = 5);
  }
  function Pk(a2, b2, c2) {
    var d3 = C2, e2 = ok.transition;
    try {
      ok.transition = null, C2 = 1, Wk(a2, b2, c2, d3);
    } finally {
      ok.transition = e2, C2 = d3;
    }
    return null;
  }
  function Wk(a2, b2, c2, d3) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K2 & 6)) throw Error(p2(327));
    c2 = a2.finishedWork;
    var e2 = a2.finishedLanes;
    if (null === c2) return null;
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    if (c2 === a2.current) throw Error(p2(177));
    a2.callbackNode = null;
    a2.callbackPriority = 0;
    var f2 = c2.lanes | c2.childLanes;
    Bc(a2, f2);
    a2 === Q2 && (Y = Q2 = null, Z = 0);
    0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f2 = 0 !== (c2.flags & 15990);
    if (0 !== (c2.subtreeFlags & 15990) || f2) {
      f2 = ok.transition;
      ok.transition = null;
      var g2 = C2;
      C2 = 1;
      var h2 = K2;
      K2 |= 4;
      nk.current = null;
      Oj(a2, c2);
      dk(c2, a2);
      Oe(Df2);
      dd = !!Cf2;
      Df2 = Cf2 = null;
      a2.current = c2;
      hk(c2);
      dc();
      K2 = h2;
      C2 = g2;
      ok.transition = f2;
    } else a2.current = c2;
    vk && (vk = false, wk = a2, xk = e2);
    f2 = a2.pendingLanes;
    0 === f2 && (Ri = null);
    mc(c2.stateNode);
    Dk(a2, B3());
    if (null !== b2) for (d3 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e2 = b2[c2], d3(e2.value, { componentStack: e2.stack, digest: e2.digest });
    if (Oi2) throw Oi2 = false, a2 = Pi2, Pi2 = null, a2;
    0 !== (xk & 1) && 0 !== a2.tag && Hk();
    f2 = a2.pendingLanes;
    0 !== (f2 & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a2 = Dc(xk), b2 = ok.transition, c2 = C2;
      try {
        ok.transition = null;
        C2 = 16 > a2 ? 16 : a2;
        if (null === wk) var d3 = false;
        else {
          a2 = wk;
          wk = null;
          xk = 0;
          if (0 !== (K2 & 6)) throw Error(p2(331));
          var e2 = K2;
          K2 |= 4;
          for (V2 = a2.current; null !== V2; ) {
            var f2 = V2, g2 = f2.child;
            if (0 !== (V2.flags & 16)) {
              var h2 = f2.deletions;
              if (null !== h2) {
                for (var k2 = 0; k2 < h2.length; k2++) {
                  var l2 = h2[k2];
                  for (V2 = l2; null !== V2; ) {
                    var m3 = V2;
                    switch (m3.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m3, f2);
                    }
                    var q = m3.child;
                    if (null !== q) q.return = m3, V2 = q;
                    else for (; null !== V2; ) {
                      m3 = V2;
                      var r2 = m3.sibling, y3 = m3.return;
                      Sj(m3);
                      if (m3 === l2) {
                        V2 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y3;
                        V2 = r2;
                        break;
                      }
                      V2 = y3;
                    }
                  }
                }
                var n3 = f2.alternate;
                if (null !== n3) {
                  var t2 = n3.child;
                  if (null !== t2) {
                    n3.child = null;
                    do {
                      var J = t2.sibling;
                      t2.sibling = null;
                      t2 = J;
                    } while (null !== t2);
                  }
                }
                V2 = f2;
              }
            }
            if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V2 = g2;
            else b: for (; null !== V2; ) {
              f2 = V2;
              if (0 !== (f2.flags & 2048)) switch (f2.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f2, f2.return);
              }
              var x2 = f2.sibling;
              if (null !== x2) {
                x2.return = f2.return;
                V2 = x2;
                break b;
              }
              V2 = f2.return;
            }
          }
          var w2 = a2.current;
          for (V2 = w2; null !== V2; ) {
            g2 = V2;
            var u2 = g2.child;
            if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V2 = u2;
            else b: for (g2 = w2; null !== V2; ) {
              h2 = V2;
              if (0 !== (h2.flags & 2048)) try {
                switch (h2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h2);
                }
              } catch (na2) {
                W(h2, h2.return, na2);
              }
              if (h2 === g2) {
                V2 = null;
                break b;
              }
              var F = h2.sibling;
              if (null !== F) {
                F.return = h2.return;
                V2 = F;
                break b;
              }
              V2 = h2.return;
            }
          }
          K2 = e2;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na2) {
          }
          d3 = true;
        }
        return d3;
      } finally {
        C2 = c2, ok.transition = b2;
      }
    }
    return false;
  }
  function Xk(a2, b2, c2) {
    b2 = Ji(c2, b2);
    b2 = Ni2(a2, b2, 1);
    a2 = nh(a2, b2, 1);
    b2 = R2();
    null !== a2 && (Ac(a2, 1, b2), Dk(a2, b2));
  }
  function W(a2, b2, c2) {
    if (3 === a2.tag) Xk(a2, a2, c2);
    else for (; null !== b2; ) {
      if (3 === b2.tag) {
        Xk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d3 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d3.componentDidCatch && (null === Ri || !Ri.has(d3))) {
          a2 = Ji(c2, a2);
          a2 = Qi(b2, a2, 1);
          b2 = nh(b2, a2, 1);
          a2 = R2();
          null !== b2 && (Ac(b2, 1, a2), Dk(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
  }
  function Ti2(a2, b2, c2) {
    var d3 = a2.pingCache;
    null !== d3 && d3.delete(b2);
    b2 = R2();
    a2.pingedLanes |= a2.suspendedLanes & c2;
    Q2 === a2 && (Z & c2) === c2 && (4 === T2 || 3 === T2 && (Z & 130023424) === Z && 500 > B3() - fk ? Kk(a2, 0) : rk |= c2);
    Dk(a2, b2);
  }
  function Yk(a2, b2) {
    0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c2 = R2();
    a2 = ih(a2, b2);
    null !== a2 && (Ac(a2, b2, c2), Dk(a2, c2));
  }
  function uj(a2) {
    var b2 = a2.memoizedState, c2 = 0;
    null !== b2 && (c2 = b2.retryLane);
    Yk(a2, c2);
  }
  function bk(a2, b2) {
    var c2 = 0;
    switch (a2.tag) {
      case 13:
        var d3 = a2.stateNode;
        var e2 = a2.memoizedState;
        null !== e2 && (c2 = e2.retryLane);
        break;
      case 19:
        d3 = a2.stateNode;
        break;
      default:
        throw Error(p2(314));
    }
    null !== d3 && d3.delete(b2);
    Yk(a2, c2);
  }
  var Vk;
  Vk = function(a2, b2, c2) {
    if (null !== a2) if (a2.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128)) return dh = false, yj(a2, b2, c2);
      dh = 0 !== (a2.flags & 131072) ? true : false;
    }
    else dh = false, I2 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
    b2.lanes = 0;
    switch (b2.tag) {
      case 2:
        var d3 = b2.type;
        ij(a2, b2);
        a2 = b2.pendingProps;
        var e2 = Yf(b2, H2.current);
        ch(b2, c2);
        e2 = Nh(null, b2, d3, a2, e2, c2);
        var f2 = Sh();
        b2.flags |= 1;
        "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d3) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei2, b2.stateNode = e2, e2._reactInternals = b2, Ii2(b2, d3, a2, c2), b2 = jj(null, b2, d3, true, f2, c2)) : (b2.tag = 0, I2 && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
        return b2;
      case 16:
        d3 = b2.elementType;
        a: {
          ij(a2, b2);
          a2 = b2.pendingProps;
          e2 = d3._init;
          d3 = e2(d3._payload);
          b2.type = d3;
          e2 = b2.tag = Zk(d3);
          a2 = Ci2(d3, a2);
          switch (e2) {
            case 0:
              b2 = cj(null, b2, d3, a2, c2);
              break a;
            case 1:
              b2 = hj(null, b2, d3, a2, c2);
              break a;
            case 11:
              b2 = Yi2(null, b2, d3, a2, c2);
              break a;
            case 14:
              b2 = $i(null, b2, d3, Ci2(d3.type, a2), c2);
              break a;
          }
          throw Error(p2(
            306,
            d3,
            ""
          ));
        }
        return b2;
      case 0:
        return d3 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d3 ? e2 : Ci2(d3, e2), cj(a2, b2, d3, e2, c2);
      case 1:
        return d3 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d3 ? e2 : Ci2(d3, e2), hj(a2, b2, d3, e2, c2);
      case 3:
        a: {
          kj(b2);
          if (null === a2) throw Error(p2(387));
          d3 = b2.pendingProps;
          f2 = b2.memoizedState;
          e2 = f2.element;
          lh(a2, b2);
          qh(b2, d3, null, c2);
          var g2 = b2.memoizedState;
          d3 = g2.element;
          if (f2.isDehydrated) if (f2 = { element: d3, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ji(Error(p2(423)), b2);
            b2 = lj(a2, b2, d3, c2, e2);
            break a;
          } else if (d3 !== e2) {
            e2 = Ji(Error(p2(424)), b2);
            b2 = lj(a2, b2, d3, c2, e2);
            break a;
          } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I2 = true, zg = null, c2 = Vg(b2, null, d3, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
          else {
            Ig();
            if (d3 === e2) {
              b2 = Zi(a2, b2, c2);
              break a;
            }
            Xi(a2, b2, d3, c2);
          }
          b2 = b2.child;
        }
        return b2;
      case 5:
        return Ah(b2), null === a2 && Eg(b2), d3 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef2(d3, e2) ? g2 = null : null !== f2 && Ef2(d3, f2) && (b2.flags |= 32), gj(a2, b2), Xi(a2, b2, g2, c2), b2.child;
      case 6:
        return null === a2 && Eg(b2), null;
      case 13:
        return oj(a2, b2, c2);
      case 4:
        return yh(b2, b2.stateNode.containerInfo), d3 = b2.pendingProps, null === a2 ? b2.child = Ug(b2, null, d3, c2) : Xi(a2, b2, d3, c2), b2.child;
      case 11:
        return d3 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d3 ? e2 : Ci2(d3, e2), Yi2(a2, b2, d3, e2, c2);
      case 7:
        return Xi(a2, b2, b2.pendingProps, c2), b2.child;
      case 8:
        return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
      case 12:
        return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
      case 10:
        a: {
          d3 = b2.type._context;
          e2 = b2.pendingProps;
          f2 = b2.memoizedProps;
          g2 = e2.value;
          G(Wg, d3._currentValue);
          d3._currentValue = g2;
          if (null !== f2) if (He(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = Zi(a2, b2, c2);
              break a;
            }
          } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
            var h2 = f2.dependencies;
            if (null !== h2) {
              g2 = f2.child;
              for (var k2 = h2.firstContext; null !== k2; ) {
                if (k2.context === d3) {
                  if (1 === f2.tag) {
                    k2 = mh(-1, c2 & -c2);
                    k2.tag = 2;
                    var l2 = f2.updateQueue;
                    if (null !== l2) {
                      l2 = l2.shared;
                      var m3 = l2.pending;
                      null === m3 ? k2.next = k2 : (k2.next = m3.next, m3.next = k2);
                      l2.pending = k2;
                    }
                  }
                  f2.lanes |= c2;
                  k2 = f2.alternate;
                  null !== k2 && (k2.lanes |= c2);
                  bh(
                    f2.return,
                    c2,
                    b2
                  );
                  h2.lanes |= c2;
                  break;
                }
                k2 = k2.next;
              }
            } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
            else if (18 === f2.tag) {
              g2 = f2.return;
              if (null === g2) throw Error(p2(341));
              g2.lanes |= c2;
              h2 = g2.alternate;
              null !== h2 && (h2.lanes |= c2);
              bh(g2, c2, b2);
              g2 = f2.sibling;
            } else g2 = f2.child;
            if (null !== g2) g2.return = f2;
            else for (g2 = f2; null !== g2; ) {
              if (g2 === b2) {
                g2 = null;
                break;
              }
              f2 = g2.sibling;
              if (null !== f2) {
                f2.return = g2.return;
                g2 = f2;
                break;
              }
              g2 = g2.return;
            }
            f2 = g2;
          }
          Xi(a2, b2, e2.children, c2);
          b2 = b2.child;
        }
        return b2;
      case 9:
        return e2 = b2.type, d3 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d3 = d3(e2), b2.flags |= 1, Xi(a2, b2, d3, c2), b2.child;
      case 14:
        return d3 = b2.type, e2 = Ci2(d3, b2.pendingProps), e2 = Ci2(d3.type, e2), $i(a2, b2, d3, e2, c2);
      case 15:
        return bj(a2, b2, b2.type, b2.pendingProps, c2);
      case 17:
        return d3 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d3 ? e2 : Ci2(d3, e2), ij(a2, b2), b2.tag = 1, Zf(d3) ? (a2 = true, cg(b2)) : a2 = false, ch(b2, c2), Gi2(b2, d3, e2), Ii2(b2, d3, e2, c2), jj(null, b2, d3, true, a2, c2);
      case 19:
        return xj(a2, b2, c2);
      case 22:
        return dj(a2, b2, c2);
    }
    throw Error(p2(156, b2.tag));
  };
  function Fk(a2, b2) {
    return ac(a2, b2);
  }
  function $k(a2, b2, c2, d3) {
    this.tag = a2;
    this.key = c2;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b2;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d3;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a2, b2, c2, d3) {
    return new $k(a2, b2, c2, d3);
  }
  function aj(a2) {
    a2 = a2.prototype;
    return !(!a2 || !a2.isReactComponent);
  }
  function Zk(a2) {
    if ("function" === typeof a2) return aj(a2) ? 1 : 0;
    if (void 0 !== a2 && null !== a2) {
      a2 = a2.$$typeof;
      if (a2 === Da2) return 11;
      if (a2 === Ga2) return 14;
    }
    return 2;
  }
  function Pg(a2, b2) {
    var c2 = a2.alternate;
    null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
    c2.flags = a2.flags & 14680064;
    c2.childLanes = a2.childLanes;
    c2.lanes = a2.lanes;
    c2.child = a2.child;
    c2.memoizedProps = a2.memoizedProps;
    c2.memoizedState = a2.memoizedState;
    c2.updateQueue = a2.updateQueue;
    b2 = a2.dependencies;
    c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
    c2.sibling = a2.sibling;
    c2.index = a2.index;
    c2.ref = a2.ref;
    return c2;
  }
  function Rg(a2, b2, c2, d3, e2, f2) {
    var g2 = 2;
    d3 = a2;
    if ("function" === typeof a2) aj(a2) && (g2 = 1);
    else if ("string" === typeof a2) g2 = 5;
    else a: switch (a2) {
      case ya2:
        return Tg(c2.children, e2, f2, b2);
      case za2:
        g2 = 8;
        e2 |= 8;
        break;
      case Aa2:
        return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa2, a2.lanes = f2, a2;
      case Ea2:
        return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea2, a2.lanes = f2, a2;
      case Fa2:
        return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa2, a2.lanes = f2, a2;
      case Ia2:
        return pj(c2, e2, f2, b2);
      default:
        if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
          case Ba2:
            g2 = 10;
            break a;
          case Ca2:
            g2 = 9;
            break a;
          case Da2:
            g2 = 11;
            break a;
          case Ga2:
            g2 = 14;
            break a;
          case Ha2:
            g2 = 16;
            d3 = null;
            break a;
        }
        throw Error(p2(130, null == a2 ? a2 : typeof a2, ""));
    }
    b2 = Bg(g2, c2, b2, e2);
    b2.elementType = a2;
    b2.type = d3;
    b2.lanes = f2;
    return b2;
  }
  function Tg(a2, b2, c2, d3) {
    a2 = Bg(7, a2, d3, b2);
    a2.lanes = c2;
    return a2;
  }
  function pj(a2, b2, c2, d3) {
    a2 = Bg(22, a2, d3, b2);
    a2.elementType = Ia2;
    a2.lanes = c2;
    a2.stateNode = { isHidden: false };
    return a2;
  }
  function Qg(a2, b2, c2) {
    a2 = Bg(6, a2, null, b2);
    a2.lanes = c2;
    return a2;
  }
  function Sg(a2, b2, c2) {
    b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
    b2.lanes = c2;
    b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
    return b2;
  }
  function al(a2, b2, c2, d3, e2) {
    this.tag = b2;
    this.containerInfo = a2;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d3;
    this.onRecoverableError = e2;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a2, b2, c2, d3, e2, f2, g2, h2, k2) {
    a2 = new al(a2, b2, c2, h2, k2);
    1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
    f2 = Bg(3, null, null, b2);
    a2.current = f2;
    f2.stateNode = a2;
    f2.memoizedState = { element: d3, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f2);
    return a2;
  }
  function cl(a2, b2, c2) {
    var d3 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa2, key: null == d3 ? null : "" + d3, children: a2, containerInfo: b2, implementation: c2 };
  }
  function dl(a2) {
    if (!a2) return Vf;
    a2 = a2._reactInternals;
    a: {
      if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p2(170));
      var b2 = a2;
      do {
        switch (b2.tag) {
          case 3:
            b2 = b2.stateNode.context;
            break a;
          case 1:
            if (Zf(b2.type)) {
              b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b2 = b2.return;
      } while (null !== b2);
      throw Error(p2(171));
    }
    if (1 === a2.tag) {
      var c2 = a2.type;
      if (Zf(c2)) return bg(a2, c2, b2);
    }
    return b2;
  }
  function el(a2, b2, c2, d3, e2, f2, g2, h2, k2) {
    a2 = bl(c2, d3, true, a2, e2, f2, g2, h2, k2);
    a2.context = dl(null);
    c2 = a2.current;
    d3 = R2();
    e2 = yi(c2);
    f2 = mh(d3, e2);
    f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
    nh(c2, f2, e2);
    a2.current.lanes = e2;
    Ac(a2, e2, d3);
    Dk(a2, d3);
    return a2;
  }
  function fl(a2, b2, c2, d3) {
    var e2 = b2.current, f2 = R2(), g2 = yi(e2);
    c2 = dl(c2);
    null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
    b2 = mh(f2, g2);
    b2.payload = { element: a2 };
    d3 = void 0 === d3 ? null : d3;
    null !== d3 && (b2.callback = d3);
    a2 = nh(e2, b2, g2);
    null !== a2 && (gi2(a2, e2, g2, f2), oh(a2, e2, g2));
    return g2;
  }
  function gl(a2) {
    a2 = a2.current;
    if (!a2.child) return null;
    switch (a2.child.tag) {
      case 5:
        return a2.child.stateNode;
      default:
        return a2.child.stateNode;
    }
  }
  function hl(a2, b2) {
    a2 = a2.memoizedState;
    if (null !== a2 && null !== a2.dehydrated) {
      var c2 = a2.retryLane;
      a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
    }
  }
  function il(a2, b2) {
    hl(a2, b2);
    (a2 = a2.alternate) && hl(a2, b2);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a2) {
    console.error(a2);
  };
  function ll(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.render = ll.prototype.render = function(a2) {
    var b2 = this._internalRoot;
    if (null === b2) throw Error(p2(409));
    fl(a2, b2, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a2 = this._internalRoot;
    if (null !== a2) {
      this._internalRoot = null;
      var b2 = a2.containerInfo;
      Rk(function() {
        fl(null, a2, null, null);
      });
      b2[uf] = null;
    }
  };
  function ml(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.unstable_scheduleHydration = function(a2) {
    if (a2) {
      var b2 = Hc();
      a2 = { blockedOn: null, target: a2, priority: b2 };
      for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
      Qc.splice(c2, 0, a2);
      0 === c2 && Vc(a2);
    }
  };
  function nl(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
  }
  function ol(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
  }
  function pl() {
  }
  function ql(a2, b2, c2, d3, e2) {
    if (e2) {
      if ("function" === typeof d3) {
        var f2 = d3;
        d3 = function() {
          var a3 = gl(g2);
          f2.call(a3);
        };
      }
      var g2 = el(b2, d3, a2, 0, null, false, false, "", pl);
      a2._reactRootContainer = g2;
      a2[uf] = g2.current;
      sf2(8 === a2.nodeType ? a2.parentNode : a2);
      Rk();
      return g2;
    }
    for (; e2 = a2.lastChild; ) a2.removeChild(e2);
    if ("function" === typeof d3) {
      var h2 = d3;
      d3 = function() {
        var a3 = gl(k2);
        h2.call(a3);
      };
    }
    var k2 = bl(a2, 0, false, null, null, false, false, "", pl);
    a2._reactRootContainer = k2;
    a2[uf] = k2.current;
    sf2(8 === a2.nodeType ? a2.parentNode : a2);
    Rk(function() {
      fl(b2, k2, c2, d3);
    });
    return k2;
  }
  function rl(a2, b2, c2, d3, e2) {
    var f2 = c2._reactRootContainer;
    if (f2) {
      var g2 = f2;
      if ("function" === typeof e2) {
        var h2 = e2;
        e2 = function() {
          var a3 = gl(g2);
          h2.call(a3);
        };
      }
      fl(b2, g2, a2, e2);
    } else g2 = ql(c2, b2, a2, e2, d3);
    return gl(g2);
  }
  Ec = function(a2) {
    switch (a2.tag) {
      case 3:
        var b2 = a2.stateNode;
        if (b2.current.memoizedState.isDehydrated) {
          var c2 = tc(b2.pendingLanes);
          0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B3()), 0 === (K2 & 6) && (Gj = B3() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b3 = ih(a2, 1);
          if (null !== b3) {
            var c3 = R2();
            gi2(b3, a2, 1, c3);
          }
        }), il(a2, 1);
    }
  };
  Fc = function(a2) {
    if (13 === a2.tag) {
      var b2 = ih(a2, 134217728);
      if (null !== b2) {
        var c2 = R2();
        gi2(b2, a2, 134217728, c2);
      }
      il(a2, 134217728);
    }
  };
  Gc = function(a2) {
    if (13 === a2.tag) {
      var b2 = yi(a2), c2 = ih(a2, b2);
      if (null !== c2) {
        var d3 = R2();
        gi2(c2, a2, b2, d3);
      }
      il(a2, b2);
    }
  };
  Hc = function() {
    return C2;
  };
  Ic = function(a2, b2) {
    var c2 = C2;
    try {
      return C2 = a2, b2();
    } finally {
      C2 = c2;
    }
  };
  yb = function(a2, b2, c2) {
    switch (b2) {
      case "input":
        bb(a2, c2);
        b2 = c2.name;
        if ("radio" === c2.type && null != b2) {
          for (c2 = a2; c2.parentNode; ) c2 = c2.parentNode;
          c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
          for (b2 = 0; b2 < c2.length; b2++) {
            var d3 = c2[b2];
            if (d3 !== a2 && d3.form === a2.form) {
              var e2 = Db(d3);
              if (!e2) throw Error(p2(90));
              Wa(d3);
              bb(d3, e2);
            }
          }
        }
        break;
      case "textarea":
        ib(a2, c2);
        break;
      case "select":
        b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue2, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua2.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
    a2 = Zb(a2);
    return null === a2 ? null : a2.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a2) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a2, b2) {
    var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b2)) throw Error(p2(200));
    return cl(a2, b2, null, c2);
  };
  reactDom_production_min.createRoot = function(a2, b2) {
    if (!nl(a2)) throw Error(p2(299));
    var c2 = false, d3 = "", e2 = kl;
    null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d3 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
    b2 = bl(a2, 1, false, null, null, c2, false, d3, e2);
    a2[uf] = b2.current;
    sf2(8 === a2.nodeType ? a2.parentNode : a2);
    return new ll(b2);
  };
  reactDom_production_min.findDOMNode = function(a2) {
    if (null == a2) return null;
    if (1 === a2.nodeType) return a2;
    var b2 = a2._reactInternals;
    if (void 0 === b2) {
      if ("function" === typeof a2.render) throw Error(p2(188));
      a2 = Object.keys(a2).join(",");
      throw Error(p2(268, a2));
    }
    a2 = Zb(b2);
    a2 = null === a2 ? null : a2.stateNode;
    return a2;
  };
  reactDom_production_min.flushSync = function(a2) {
    return Rk(a2);
  };
  reactDom_production_min.hydrate = function(a2, b2, c2) {
    if (!ol(b2)) throw Error(p2(200));
    return rl(null, a2, b2, true, c2);
  };
  reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
    if (!nl(a2)) throw Error(p2(405));
    var d3 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
    null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
    b2 = el(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
    a2[uf] = b2.current;
    sf2(a2);
    if (d3) for (a2 = 0; a2 < d3.length; a2++) c2 = d3[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
      c2,
      e2
    );
    return new ml(b2);
  };
  reactDom_production_min.render = function(a2, b2, c2) {
    if (!ol(b2)) throw Error(p2(200));
    return rl(null, a2, b2, false, c2);
  };
  reactDom_production_min.unmountComponentAtNode = function(a2) {
    if (!ol(a2)) throw Error(p2(40));
    return a2._reactRootContainer ? (Rk(function() {
      rl(null, null, a2, false, function() {
        a2._reactRootContainer = null;
        a2[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d3) {
    if (!ol(c2)) throw Error(p2(200));
    if (null == a2 || void 0 === a2._reactInternals) throw Error(p2(38));
    return rl(a2, b2, c2, false, d3);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  return reactDom_production_min;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  return reactDom.exports;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var m3 = requireReactDom();
  {
    client.createRoot = m3.createRoot;
    client.hydrateRoot = m3.hydrateRoot;
  }
  return client;
}
var clientExports = requireClient();
var reactDomExports = requireReactDom();
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location2, index2) {
  return {
    usr: location2.state,
    key: location2.key,
    idx: index2
  };
}
function createLocation(current, to, state2, key2) {
  if (state2 === void 0) {
    state2 = null;
  }
  let location2 = _extends$3({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state: state2,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key2 || createKey()
  });
  return location2;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#") pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$3({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state2 = globalHistory.state || {
      idx: null
    };
    return state2.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state2) {
    action = Action.Push;
    let location2 = createLocation(history.location, to, state2);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location2, index2);
    let url = history.createHref(location2);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace2(to, state2) {
    action = Action.Replace;
    let location2 = createLocation(history.location, to, state2);
    index2 = getIndex();
    let historyState = getHistoryState(location2, index2);
    let url = history.createHref(location2);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base3 = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    href = href.replace(/ $/, "%20");
    invariant(base3, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base3);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn2) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn2;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n3) {
      return globalHistory.go(n3);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  return matchRoutesImpl(routes, locationArg, basename);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location2.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i4 = 0; matches == null && i4 < branches.length; ++i4) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i4], decoded);
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments2 = path.split("/");
  if (segments2.length === 0) return [];
  let [first, ...rest] = segments2;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path, index2) {
  let segments2 = path.split("/");
  let initialScore = segments2.length;
  if (segments2.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments2.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n3, i4) => n3 === b2[i4]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i4 = 0; i4 < routesMeta.length; ++i4) {
    let meta = routesMeta[i4];
    let end2 = i4 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end2
    }, remainingPathname);
    let route = meta.route;
    if (!match2) {
      return null;
    }
    Object.assign(matchedParams, match2.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2) return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = compiledParams.reduce((memo, _ref, index2) => {
    let {
      paramName,
      isOptional
    } = _ref;
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index2];
    if (isOptional && !value) {
      memo[paramName] = void 0;
    } else {
      memo[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end2) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end2 === void 0) {
    end2 = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_2, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end2) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments2 = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments2.length > 1) segments2.pop();
    } else if (segment !== ".") {
      segments2.push(segment);
    }
  });
  return segments2.length > 1 ? segments2.join("/") : "/";
}
function getInvalidPathError(char2, field, dest, path) {
  return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0);
}
function getResolveToMatches(matches, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches);
  if (v7_relativeSplatPath) {
    return pathMatches.map((match2, idx) => idx === pathMatches.length - 1 ? match2.pathname : match2.pathnameBase);
  }
  return pathMatches.map((match2) => match2.pathnameBase);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$3({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect(cb) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    future,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    future
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location2;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location2 = parsedLocationArg;
  } else {
    location2 = locationFromContext;
  }
  let pathname = location2.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments2 = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments2.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
    ]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
    ])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$2({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location2),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state2) {
    if (state2.location !== props.location || state2.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state2.error,
      location: state2.location,
      revalidation: props.revalidation || state2.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState, future) {
  var _dataRouterState;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches == null) {
    var _future;
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m3) => m3.route.id && (errors == null ? void 0 : errors[m3.route.id]) !== void 0);
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i4 = 0; i4 < renderedMatches.length; i4++) {
      let match2 = renderedMatches[i4];
      if (match2.route.HydrateFallback || match2.route.hydrateFallbackElement) {
        fallbackIndex = i4;
      }
      if (match2.route.id) {
        let {
          loaderData,
          errors: errors2
        } = dataRouterState;
        let needsToRunLoader = match2.route.loader && loaderData[match2.route.id] === void 0 && (!errors2 || errors2[match2.route.id] === void 0);
        if (match2.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match2, index2) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match2.route.id ? errors[match2.route.id] : void 0;
      errorElement = match2.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index2 === 0) {
          warningOnce("route-fallback");
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index2) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match2.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match2.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
      } else if (match2.route.element) {
        children = match2.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match: match2,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ (function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
})(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ (function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
})(DataRouterStateHook$1 || {});
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state2 = reactExports.useContext(DataRouterStateContext);
  !state2 ? invariant(false) : void 0;
  return state2;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state2 = useDataRouterState();
  let routeId = useCurrentRouteId();
  if (error !== void 0) {
    return error;
  }
  return (_state$errors = state2.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
  let id = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      router.navigate(to, _extends$2({
        fromRouteId: id
      }, options));
    }
  }, [router, id]);
  return navigate;
}
const alreadyWarned$1 = {};
function warningOnce(key2, cond, message) {
  if (!alreadyWarned$1[key2]) {
    alreadyWarned$1[key2] = true;
  }
}
function logV6DeprecationWarnings(renderFuture, routerFuture) {
  if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === void 0) ;
  if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === void 0 && true) ;
}
function Navigate(_ref4) {
  let {
    to,
    replace: replace2,
    state: state2,
    relative
  } = _ref4;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    future,
    static: isStatic
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let navigate = useNavigate();
  let path = resolveTo(to, getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === "path");
  let jsonPath = JSON.stringify(path);
  reactExports.useEffect(() => navigate(JSON.parse(jsonPath), {
    replace: replace2,
    state: state2,
    relative
  }), [navigate, jsonPath, relative, replace2, state2]);
  return null;
}
function Route(_props) {
  invariant(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends$2({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state: state2 = null,
    key: key2 = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state: state2,
        key: key2
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state2, key2, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location: location2
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location2);
}
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index2];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var source = arguments[i4];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$1(source, excluded2) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i4;
  for (i4 = 0; i4 < sourceKeys.length; i4++) {
    key2 = sourceKeys[i4];
    if (excluded2.indexOf(key2) >= 0) continue;
    target[key2] = source[key2];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"];
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e2) {
}
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$1[START_TRANSITION];
function BrowserRouter(_ref4) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref4;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state2, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  reactExports.useEffect(() => logV6DeprecationWarnings(future), [future]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state2.location,
    navigationType: state2.action,
    navigator: history,
    future
  });
}
const isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const Link$1 = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref7, ref2) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state: state2,
    target,
    to,
    preventScrollReset,
    viewTransition
  } = _ref7, rest = _objectWithoutPropertiesLoose$1(_ref7, _excluded);
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
    absoluteHref = to;
    if (isBrowser$1) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e2) {
      }
    }
  }
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state: state2,
    target,
    preventScrollReset,
    relative,
    viewTransition
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends$1({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref: ref2,
      target
    }))
  );
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state: state2,
    preventScrollReset,
    relative,
    viewTransition
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location2 = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return reactExports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location2) === createPath(path);
      navigate(to, {
        replace: replace2,
        state: state2,
        preventScrollReset,
        relative,
        viewTransition
      });
    }
  }, [location2, navigate, path, replaceProp, state2, target, to, preventScrollReset, relative, viewTransition]);
}
const common$2 = {
  black: "#000",
  white: "#fff"
};
const red = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
};
const purple = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
};
const blue = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
};
const lightBlue = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
};
const green = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
const orange = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
};
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
function formatMuiErrorMessage(code, ...args) {
  const url = new URL(`https://mui.com/production-error/?code=${code}`);
  args.forEach((arg2) => url.searchParams.append("args[]", arg2));
  return `Minified MUI error #${code}; visit ${url} for the full message.`;
}
const THEME_ID = "$$material";
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n3) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n3[r2] = t2[r2]);
    }
    return n3;
  }, _extends.apply(null, arguments);
}
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i4 = 0; i4 < document.styleSheets.length; i4++) {
    if (document.styleSheets[i4].ownerNode === tag) {
      return document.styleSheets[i4];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ (function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate2(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
})();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from$2 = String.fromCharCode;
var assign = Object.assign;
function hash$5(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim$1(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node$1(value, root, parent2, type, props, children, length2) {
  return { value, root, parent: parent2, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node$1("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice$2(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim$1(slice$2(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice$2(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      // ] ) " '
      case type:
        return position;
      // " '
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice$2(index2, position - 1) + "*" + from$2(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice$2(index2, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent2, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent2), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset2:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent2, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent2, length2 - 2), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference2 = ruleset(characters2, root, parent2, index2, offset2, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse(characters2, root, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from$2(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent2, index2, offset2, rules, points, type, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size2 = sizeof(rule);
  for (var i4 = 0, j2 = 0, k2 = 0; i4 < index2; ++i4)
    for (var x2 = 0, y3 = substr(value, post + 1, post = abs(j2 = points[i4])), z3 = value; x2 < size2; ++x2)
      if (z3 = trim$1(j2 > 0 ? rule[x2] + " " + y3 : replace(y3, /&\f/g, rule[x2])))
        props[k2++] = z3;
  return node$1(value, root, parent2, offset2 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent2) {
  return node$1(value, root, parent2, COMMENT, from$2(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent2, length2) {
  return node$1(value, root, parent2, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize$1(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i4 = 0; i4 < length2; i4++)
    output += callback(children[i4], i4, children, callback) || "";
  return output;
}
function stringify$2(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i4 = 0; i4 < length2; i4++)
      output += collection[i4](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function memoize$1(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg2) {
    if (cache[arg2] === void 0) cache[arg2] = fn2(arg2);
    return cache[arg2];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice$2(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      // fallthrough
      default:
        parsed[index2] += from$2(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent2 = element.parent;
  var isImplicitRule = element.column === parent2.column && element.line === parent2.line;
  while (parent2.type !== "rule") {
    parent2 = parent2.parent;
    if (!parent2) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent2)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent2.props;
  for (var i4 = 0, k2 = 0; i4 < rules.length; i4++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i4] ? rules[i4].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i4];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash$5(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        // (s)tretch
        case 115:
          return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    // position: sticky
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        // (inline-)?fl(e)x
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize$1([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return serialize$1([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            // :placeholder
            case "::placeholder":
              return serialize$1([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key2 = options.key;
  if (key2 === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key2 + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i4 = 1; i4 < attrib.length; i4++) {
          inserted[attrib[i4]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$2, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize$1(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key: key2,
    sheet: new StyleSheet({
      key: key2,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b2 = "function" === typeof Symbol && Symbol.for, c2 = b2 ? Symbol.for("react.element") : 60103, d3 = b2 ? Symbol.for("react.portal") : 60106, e2 = b2 ? Symbol.for("react.fragment") : 60107, f2 = b2 ? Symbol.for("react.strict_mode") : 60108, g2 = b2 ? Symbol.for("react.profiler") : 60114, h2 = b2 ? Symbol.for("react.provider") : 60109, k2 = b2 ? Symbol.for("react.context") : 60110, l2 = b2 ? Symbol.for("react.async_mode") : 60111, m3 = b2 ? Symbol.for("react.concurrent_mode") : 60111, n3 = b2 ? Symbol.for("react.forward_ref") : 60112, p2 = b2 ? Symbol.for("react.suspense") : 60113, q = b2 ? Symbol.for("react.suspense_list") : 60120, r2 = b2 ? Symbol.for("react.memo") : 60115, t2 = b2 ? Symbol.for("react.lazy") : 60116, v2 = b2 ? Symbol.for("react.block") : 60121, w2 = b2 ? Symbol.for("react.fundamental") : 60117, x2 = b2 ? Symbol.for("react.responder") : 60118, y3 = b2 ? Symbol.for("react.scope") : 60119;
  function z3(a2) {
    if ("object" === typeof a2 && null !== a2) {
      var u2 = a2.$$typeof;
      switch (u2) {
        case c2:
          switch (a2 = a2.type, a2) {
            case l2:
            case m3:
            case e2:
            case g2:
            case f2:
            case p2:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k2:
                case n3:
                case t2:
                case r2:
                case h2:
                  return a2;
                default:
                  return u2;
              }
          }
        case d3:
          return u2;
      }
    }
  }
  function A2(a2) {
    return z3(a2) === m3;
  }
  reactIs_production_min.AsyncMode = l2;
  reactIs_production_min.ConcurrentMode = m3;
  reactIs_production_min.ContextConsumer = k2;
  reactIs_production_min.ContextProvider = h2;
  reactIs_production_min.Element = c2;
  reactIs_production_min.ForwardRef = n3;
  reactIs_production_min.Fragment = e2;
  reactIs_production_min.Lazy = t2;
  reactIs_production_min.Memo = r2;
  reactIs_production_min.Portal = d3;
  reactIs_production_min.Profiler = g2;
  reactIs_production_min.StrictMode = f2;
  reactIs_production_min.Suspense = p2;
  reactIs_production_min.isAsyncMode = function(a2) {
    return A2(a2) || z3(a2) === l2;
  };
  reactIs_production_min.isConcurrentMode = A2;
  reactIs_production_min.isContextConsumer = function(a2) {
    return z3(a2) === k2;
  };
  reactIs_production_min.isContextProvider = function(a2) {
    return z3(a2) === h2;
  };
  reactIs_production_min.isElement = function(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === c2;
  };
  reactIs_production_min.isForwardRef = function(a2) {
    return z3(a2) === n3;
  };
  reactIs_production_min.isFragment = function(a2) {
    return z3(a2) === e2;
  };
  reactIs_production_min.isLazy = function(a2) {
    return z3(a2) === t2;
  };
  reactIs_production_min.isMemo = function(a2) {
    return z3(a2) === r2;
  };
  reactIs_production_min.isPortal = function(a2) {
    return z3(a2) === d3;
  };
  reactIs_production_min.isProfiler = function(a2) {
    return z3(a2) === g2;
  };
  reactIs_production_min.isStrictMode = function(a2) {
    return z3(a2) === f2;
  };
  reactIs_production_min.isSuspense = function(a2) {
    return z3(a2) === p2;
  };
  reactIs_production_min.isValidElementType = function(a2) {
    return "string" === typeof a2 || "function" === typeof a2 || a2 === e2 || a2 === m3 || a2 === g2 || a2 === f2 || a2 === p2 || a2 === q || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t2 || a2.$$typeof === r2 || a2.$$typeof === h2 || a2.$$typeof === k2 || a2.$$typeof === n3 || a2.$$typeof === w2 || a2.$$typeof === x2 || a2.$$typeof === y3 || a2.$$typeof === v2);
  };
  reactIs_production_min.typeOf = z3;
  return reactIs_production_min;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
  if (hasRequiredReactIs$1) return reactIs$1.exports;
  hasRequiredReactIs$1 = 1;
  {
    reactIs$1.exports = requireReactIs_production_min();
  }
  return reactIs$1.exports;
}
var hoistNonReactStatics_cjs;
var hasRequiredHoistNonReactStatics_cjs;
function requireHoistNonReactStatics_cjs() {
  if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
  hasRequiredHoistNonReactStatics_cjs = 1;
  var reactIs2 = requireReactIs$1();
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs2.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs2.Memo] = MEMO_STATICS;
  function getStatics(component) {
    if (reactIs2.isMemo(component)) {
      return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
  }
  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }
      var keys = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols) {
        keys = keys.concat(getOwnPropertySymbols(sourceComponent));
      }
      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);
      for (var i4 = 0; i4 < keys.length; ++i4) {
        var key2 = keys[i4];
        if (!KNOWN_STATICS[key2] && !(blacklist && blacklist[key2]) && !(sourceStatics && sourceStatics[key2]) && !(targetStatics && targetStatics[key2])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key2);
          try {
            defineProperty(targetComponent, key2, descriptor);
          } catch (e2) {
          }
        }
      }
    }
    return targetComponent;
  }
  hoistNonReactStatics_cjs = hoistNonReactStatics;
  return hoistNonReactStatics_cjs;
}
requireHoistNonReactStatics_cjs();
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
  registerStyles(cache, serialized, isStringTag2);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i4 = 0, len = str.length;
  for (; len >= 4; ++i4, len -= 4) {
    k2 = str.charCodeAt(i4) & 255 | (str.charCodeAt(++i4) & 255) << 8 | (str.charCodeAt(++i4) & 255) << 16 | (str.charCodeAt(++i4) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i4 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i4 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i4) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key2, value) {
  switch (key2) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key2] !== 1 && !isCustomProperty(key2) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i4 = 0; i4 < obj.length; i4++) {
      string += handleInterpolation(mergedProps, registered, obj[i4]) + ";";
    }
  } else {
    for (var key2 in obj) {
      var value = obj[key2];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key2 + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key2) + ":" + processStyleValue(key2, asString) + ";";
        }
      } else {
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i3 = 0; _i3 < value.length; _i3++) {
            if (isProcessableValue(value[_i3])) {
              string += processStyleName(key2) + ":" + processStyleValue(key2, value[_i3]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key2) {
            case "animation":
            case "animationName": {
              string += processStyleName(key2) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += key2 + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles2 += asTemplateStringsArr[0];
  }
  for (var i4 = 1; i4 < args.length; i4++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i4]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles2 += templateStringsArr[i4];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
}
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref2) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref2);
  });
};
var ThemeContext$1 = /* @__PURE__ */ reactExports.createContext({});
var hasOwn$1 = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  var newProps = {};
  for (var _key in props) {
    if (hasOwn$1.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type;
  return newProps;
};
var Insertion$1 = function Insertion(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref2) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext$1));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn$1.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && true) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref2) {
    newProps.ref = ref2;
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion$1, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ reactExports.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwn$1.call(props, "css")) {
    return reactExports.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i4 = 2; i4 < argsLength; i4++) {
    createElementArgArray[i4] = args[i4];
  }
  return reactExports.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext$1));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key2 = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key: key2,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key2 + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key2);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString2() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key2) {
  return key2 !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion2 = function Insertion3(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      var templateStringsArr = args[0];
      styles2.push(templateStringsArr[0]);
      var len = args.length;
      var i4 = 1;
      for (; i4 < len; i4++) {
        styles2.push(args[i4], templateStringsArr[i4]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref2) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key2 in props) {
          mergedProps[key2] = props[key2];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext$1);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as") continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      if (ref2) {
        newProps.ref = ref2;
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion2, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      var newStyled = createStyled(nextTag, _extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      }));
      return newStyled.apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var styled$3 = createStyled$1.bind(null);
tags.forEach(function(tagName) {
  styled$3[tagName] = styled$3(tagName);
});
function isEmpty$2(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles$3(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$2(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: globalStyles
  });
}
function styled$2(tag, options) {
  const stylesFactory = styled$3(tag, options);
  return stylesFactory;
}
function internal_mutateStyles(tag, processor) {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
}
const wrapper = [];
function internal_serializeStyles(styles2) {
  wrapper[0] = styles2;
  return serializeStyles(wrapper);
}
var reactIs = { exports: {} };
var reactIs_production = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf(object) {
    if ("object" === typeof object && null !== object) {
      var $$typeof = object.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object = object.type, object) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
            case REACT_VIEW_TRANSITION_TYPE:
              return object;
            default:
              switch (object = object && object.$$typeof, object) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object;
                case REACT_CONSUMER_TYPE:
                  return object;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
  reactIs_production.Element = REACT_ELEMENT_TYPE;
  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
  reactIs_production.Lazy = REACT_LAZY_TYPE;
  reactIs_production.Memo = REACT_MEMO_TYPE;
  reactIs_production.Portal = REACT_PORTAL_TYPE;
  reactIs_production.Profiler = REACT_PROFILER_TYPE;
  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
  reactIs_production.isContextConsumer = function(object) {
    return typeOf(object) === REACT_CONSUMER_TYPE;
  };
  reactIs_production.isContextProvider = function(object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
  };
  reactIs_production.isElement = function(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  };
  reactIs_production.isForwardRef = function(object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
  };
  reactIs_production.isFragment = function(object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
  };
  reactIs_production.isLazy = function(object) {
    return typeOf(object) === REACT_LAZY_TYPE;
  };
  reactIs_production.isMemo = function(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
  };
  reactIs_production.isPortal = function(object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
  };
  reactIs_production.isProfiler = function(object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
  };
  reactIs_production.isStrictMode = function(object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
  };
  reactIs_production.isSuspense = function(object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
  };
  reactIs_production.isSuspenseList = function(object) {
    return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
  };
  reactIs_production.isValidElementType = function(type) {
    return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
  };
  reactIs_production.typeOf = typeOf;
  return reactIs_production;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  {
    reactIs.exports = /* @__PURE__ */ requireReactIs_production();
  }
  return reactIs.exports;
}
var reactIsExports = /* @__PURE__ */ requireReactIs();
function isPlainObject$2(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
  if (/* @__PURE__ */ reactExports.isValidElement(source) || reactIsExports.isValidElementType(source) || !isPlainObject$2(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key2) => {
    output[key2] = deepClone(source[key2]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? {
    ...target
  } : target;
  if (isPlainObject$2(target) && isPlainObject$2(source)) {
    Object.keys(source).forEach((key2) => {
      if (/* @__PURE__ */ reactExports.isValidElement(source[key2]) || reactIsExports.isValidElementType(source[key2])) {
        output[key2] = source[key2];
      } else if (isPlainObject$2(source[key2]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target, key2) && isPlainObject$2(target[key2])) {
        output[key2] = deepmerge(target[key2], source[key2], options);
      } else if (options.clone) {
        output[key2] = isPlainObject$2(source[key2]) ? deepClone(source[key2]) : source[key2];
      } else {
        output[key2] = source[key2];
      }
    });
  }
  return output;
}
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key2) => ({
    key: key2,
    val: values2[key2]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return {
      ...acc,
      [obj.key]: obj.val
    };
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5,
    ...other
  } = breakpoints;
  const sortedValues = sortBreakpointsValues(values2);
  const keys = Object.keys(sortedValues);
  function up(key2) {
    const value = typeof values2[key2] === "number" ? values2[key2] : key2;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key2) {
    const value = typeof values2[key2] === "number" ? values2[key2] : key2;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start2, end2) {
    const endIndex = keys.indexOf(end2);
    return `@media (min-width:${typeof values2[start2] === "number" ? values2[start2] : start2}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end2) - step / 100}${unit})`;
  }
  function only(key2) {
    if (keys.indexOf(key2) + 1 < keys.length) {
      return between(key2, keys[keys.indexOf(key2) + 1]);
    }
    return up(key2);
  }
  function not(key2) {
    const keyIndex = keys.indexOf(key2);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key2, keys[keys.indexOf(key2) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit,
    ...other
  };
}
function sortContainerQueries(theme2, css2) {
  if (!theme2.containerQueries) {
    return css2;
  }
  const sorted = Object.keys(css2).filter((key2) => key2.startsWith("@container")).sort((a2, b2) => {
    const regex2 = /min-width:\s*([0-9.]+)/;
    return +(a2.match(regex2)?.[1] || 0) - +(b2.match(regex2)?.[1] || 0);
  });
  if (!sorted.length) {
    return css2;
  }
  return sorted.reduce((acc, key2) => {
    const value = css2[key2];
    delete acc[key2];
    acc[key2] = value;
    return acc;
  }, {
    ...css2
  });
}
function isCqShorthand(breakpointKeys, value) {
  return value === "@" || value.startsWith("@") && (breakpointKeys.some((key2) => value.startsWith(`@${key2}`)) || !!value.match(/^@\d/));
}
function getContainerQuery(theme2, shorthand) {
  const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
  if (!matches) {
    return null;
  }
  const [, containerQuery, containerName] = matches;
  const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
  return theme2.containerQueries(containerName).up(value);
}
function cssContainerQueries(themeInput) {
  const toContainerQuery = (mediaQuery, name) => mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
  function attachCq(node22, name) {
    node22.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
    node22.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
    node22.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
    node22.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
    node22.not = (...args) => {
      const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
      if (result.includes("not all and")) {
        return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
      }
      return result;
    };
  }
  const node2 = {};
  const containerQueries = (name) => {
    attachCq(node2, name);
    return node2;
  };
  attachCq(containerQueries);
  return {
    ...themeInput,
    containerQueries
  };
}
const shape = {
  borderRadius: 4
};
function merge(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key2) => `@media (min-width:${values$1[key2]}px)`
};
const defaultContainerQueries = {
  containerQueries: (containerName) => ({
    up: (key2) => {
      let result = typeof key2 === "number" ? key2 : values$1[key2] || key2;
      if (typeof result === "number") {
        result = `${result}px`;
      }
      return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
    }
  })
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme2 = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index2) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
        const containerKey = getContainerQuery(theme2.containerQueries ? theme2 : defaultContainerQueries, breakpoint);
        if (containerKey) {
          acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        }
      } else if (Object.keys(themeBreakpoints.values || values$1).includes(breakpoint)) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  const breakpointsInOrder = breakpointsInput.keys?.reduce((acc, key2) => {
    const breakpointStyleKey = breakpointsInput.up(key2);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key2) => {
    const breakpointOutput = acc[key2];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key2];
    }
    return acc;
  }, style2);
}
function capitalize(string) {
  if (typeof string !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style$1(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn2 = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme2 = props.theme;
    const themeMapping = getPath(theme2, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn2.propTypes = {};
  fn2.filterProps = [prop];
  return fn2;
}
function memoize(fn2) {
  const cache = {};
  return (arg2) => {
    if (cache[arg2] === void 0) {
      cache[arg2] = fn2(arg2);
    }
    return cache[arg2];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a2, b2] = prop.split("");
  const property = properties[a2];
  const direction = directions[b2] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme2, themeKey, defaultValue, propName) {
  const themeSpacing = getPath(theme2, themeKey, true) ?? defaultValue;
  if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      if (typeof themeSpacing === "string") {
        if (themeSpacing.startsWith("var(") && val === 0) {
          return 0;
        }
        if (themeSpacing.startsWith("var(") && val === 1) {
          return themeSpacing;
        }
        return `calc(${val} * ${themeSpacing})`;
      }
      return themeSpacing * val;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (val) => {
      if (typeof val === "string") {
        return val;
      }
      const abs2 = Math.abs(val);
      const transformed = themeSpacing[abs2];
      if (val >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      if (typeof transformed === "string" && transformed.startsWith("var(")) {
        return `calc(-1 * ${transformed})`;
      }
      return `-${transformed}`;
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme2) {
  return createUnaryUnit(theme2, "spacing", 8);
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  return transformer(propValue);
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
  if (!keys.includes(prop)) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
}
function margin(props) {
  return style(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(spacingInput = 8, transform = createUnarySpacing({
  spacing: spacingInput
})) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function compose(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn2 = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn2.propTypes = {};
  fn2.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn2;
}
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop, transform) {
  return style$1({
    prop,
    themeKey: "borders",
    transform
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$1({
  prop: "gridColumn"
});
const gridRow = style$1({
  prop: "gridRow"
});
const gridAutoFlow = style$1({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$1({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$1({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$1({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$1({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$1({
  prop: "gridTemplateAreas"
});
const gridArea = style$1({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color = style$1({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$1({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$1({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$1({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      const breakpoint = props.theme?.breakpoints?.values?.[propValue] || values$1[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (props.theme?.breakpoints?.unit !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$1({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$1({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$1({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$1({
  prop: "minHeight",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$1({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg2) {
  return typeof maybeFn === "function" ? maybeFn(arg2) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme2, config2) {
    const props = {
      [prop]: val,
      theme: theme2
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme2, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    const {
      sx,
      theme: theme2 = {},
      nested: nested2
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = theme2.unstable_sxConfig ?? defaultSxConfig;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme2);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme2.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme2);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config2[styleKey]) {
              css2 = merge(css2, getThemeValue(styleKey, value, theme2, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme: theme2
              }, value, (x2) => ({
                [styleKey]: x2
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme: theme2,
                  nested: true
                });
              } else {
                css2 = merge(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge(css2, getThemeValue(styleKey, value, theme2, config2));
          }
        }
      });
      if (!nested2 && theme2.modularCssLayers) {
        return {
          "@layer sx": sortContainerQueries(theme2, removeUnusedBreakpoints(breakpointsKeys, css2))
        };
      }
      return sortContainerQueries(theme2, removeUnusedBreakpoints(breakpointsKeys, css2));
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
function applyStyles$2(key2, styles2) {
  const theme2 = this;
  if (theme2.vars) {
    if (!theme2.colorSchemes?.[key2] || typeof theme2.getColorSchemeSelector !== "function") {
      return {};
    }
    let selector = theme2.getColorSchemeSelector(key2);
    if (selector === "&") {
      return styles2;
    }
    if (selector.includes("data-") || selector.includes(".")) {
      selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
    }
    return {
      [selector]: styles2
    };
  }
  if (theme2.palette.mode === key2) {
    return styles2;
  }
  return {};
}
function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {},
    ...other
  } = options;
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...paletteInput
    },
    spacing,
    shape: {
      ...shape,
      ...shapeInput
    }
  }, other);
  muiTheme = cssContainerQueries(muiTheme);
  muiTheme.applyStyles = applyStyles$2;
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other?.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function isObjectEmpty$2(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$3(defaultTheme2 = null) {
  const contextTheme = reactExports.useContext(ThemeContext$1);
  return !contextTheme || isObjectEmpty$2(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$2(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$3(defaultTheme2);
}
function wrapGlobalLayer(styles2) {
  const serialized = internal_serializeStyles(styles2);
  if (styles2 !== serialized && serialized.styles) {
    if (!serialized.styles.match(/^@layer\s+[^{]*$/)) {
      serialized.styles = `@layer global{${serialized.styles}}`;
    }
    return serialized;
  }
  return styles2;
}
function GlobalStyles$2({
  styles: styles2,
  themeId,
  defaultTheme: defaultTheme2 = {}
}) {
  const upperTheme = useTheme$2(defaultTheme2);
  const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
  let globalStyles = typeof styles2 === "function" ? styles2(resolvedTheme) : styles2;
  if (resolvedTheme.modularCssLayers) {
    if (Array.isArray(globalStyles)) {
      globalStyles = globalStyles.map((styleArg) => {
        if (typeof styleArg === "function") {
          return wrapGlobalLayer(styleArg(resolvedTheme));
        }
        return wrapGlobalLayer(styleArg);
      });
    } else {
      globalStyles = wrapGlobalLayer(globalStyles);
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$3, {
    styles: globalStyles
  });
}
const splitProps = (props) => {
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config2 = props?.theme?.unstable_sxConfig ?? defaultSxConfig;
  Object.keys(props).forEach((prop) => {
    if (config2[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};
function extendSxProp$1(props) {
  const {
    sx: inSx,
    ...other
  } = props;
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject$2(result)) {
        return systemProps;
      }
      return {
        ...systemProps,
        ...result
      };
    };
  } else {
    finalSx = {
      ...systemProps,
      ...inSx
    };
  }
  return {
    ...otherProps,
    sx: finalSx
  };
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
function r$6(e2) {
  var t2, f2, n3 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n3 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o2 = e2.length;
    for (t2 = 0; t2 < o2; t2++) e2[t2] && (f2 = r$6(e2[t2])) && (n3 && (n3 += " "), n3 += f2);
  } else for (f2 in e2) e2[f2] && (n3 && (n3 += " "), n3 += f2);
  return n3;
}
function clsx() {
  for (var e2, t2, f2 = 0, n3 = "", o2 = arguments.length; f2 < o2; f2++) (e2 = arguments[f2]) && (t2 = r$6(e2)) && (n3 && (n3 += " "), n3 += t2);
  return n3;
}
function createBox(options = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2,
    defaultClassName = "MuiBox-root",
    generateClassName
  } = options;
  const BoxRoot = styled$2("div", {
    shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
  })(styleFunctionSx);
  const Box2 = /* @__PURE__ */ reactExports.forwardRef(function Box3(inProps, ref2) {
    const theme2 = useTheme$2(defaultTheme2);
    const {
      className,
      component = "div",
      ...other
    } = extendSxProp$1(inProps);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BoxRoot, {
      as: component,
      ref: ref2,
      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme: themeId ? theme2[themeId] || theme2 : theme2,
      ...other
    });
  });
  return Box2;
}
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
function preprocessStyles(input) {
  const {
    variants,
    ...style2
  } = input;
  const result = {
    variants,
    style: internal_serializeStyles(style2),
    isProcessed: true
  };
  if (result.style === style2) {
    return result;
  }
  if (variants) {
    variants.forEach((variant) => {
      if (typeof variant.style !== "function") {
        variant.style = internal_serializeStyles(variant.style);
      }
    });
  }
  return result;
}
const systemDefaultTheme = createTheme$1();
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
function shallowLayer(serialized, layerName) {
  if (layerName && serialized && typeof serialized === "object" && serialized.styles && !serialized.styles.startsWith("@layer")) {
    serialized.styles = `@layer ${layerName}{${String(serialized.styles)}}`;
  }
  return serialized;
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (_props, styles2) => styles2[slot];
}
function attachTheme(props, themeId, defaultTheme2) {
  props.theme = isObjectEmpty$1(props.theme) ? defaultTheme2 : props.theme[themeId] || props.theme;
}
function processStyle(props, style2, layerName) {
  const resolvedStyle = typeof style2 === "function" ? style2(props) : style2;
  if (Array.isArray(resolvedStyle)) {
    return resolvedStyle.flatMap((subStyle) => processStyle(props, subStyle, layerName));
  }
  if (Array.isArray(resolvedStyle?.variants)) {
    let rootStyle;
    if (resolvedStyle.isProcessed) {
      rootStyle = layerName ? shallowLayer(resolvedStyle.style, layerName) : resolvedStyle.style;
    } else {
      const {
        variants,
        ...otherStyles
      } = resolvedStyle;
      rootStyle = layerName ? shallowLayer(internal_serializeStyles(otherStyles), layerName) : otherStyles;
    }
    return processStyleVariants(props, resolvedStyle.variants, [rootStyle], layerName);
  }
  if (resolvedStyle?.isProcessed) {
    return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle.style), layerName) : resolvedStyle.style;
  }
  return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle), layerName) : resolvedStyle;
}
function processStyleVariants(props, variants, results = [], layerName = void 0) {
  let mergedState;
  variantLoop: for (let i4 = 0; i4 < variants.length; i4 += 1) {
    const variant = variants[i4];
    if (typeof variant.props === "function") {
      mergedState ?? (mergedState = {
        ...props,
        ...props.ownerState,
        ownerState: props.ownerState
      });
      if (!variant.props(mergedState)) {
        continue;
      }
    } else {
      for (const key2 in variant.props) {
        if (props[key2] !== variant.props[key2] && props.ownerState?.[key2] !== variant.props[key2]) {
          continue variantLoop;
        }
      }
    }
    if (typeof variant.style === "function") {
      mergedState ?? (mergedState = {
        ...props,
        ...props.ownerState,
        ownerState: props.ownerState
      });
      results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style(mergedState)), layerName) : variant.style(mergedState));
    } else {
      results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style), layerName) : variant.style);
    }
  }
  return results;
}
function createStyled2(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  function styleAttachTheme(props) {
    attachTheme(props, themeId, defaultTheme2);
  }
  const styled2 = (tag, inputOptions = {}) => {
    internal_mutateStyles(tag, (styles2) => styles2.filter((style2) => style2 !== styleFunctionSx));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)),
      ...options
    } = inputOptions;
    const layerName = componentName && componentName.startsWith("Mui") || !!componentSlot ? "components" : "custom";
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$2(tag, {
      shouldForwardProp: shouldForwardPropOption,
      label: generateStyledLabel(),
      ...options
    });
    const transformStyle = (style2) => {
      if (style2.__emotion_real === style2) {
        return style2;
      }
      if (typeof style2 === "function") {
        return function styleFunctionProcessor(props) {
          return processStyle(props, style2, props.theme.modularCssLayers ? layerName : void 0);
        };
      }
      if (isPlainObject$2(style2)) {
        const serialized = preprocessStyles(style2);
        return function styleObjectProcessor(props) {
          if (!serialized.variants) {
            return props.theme.modularCssLayers ? shallowLayer(serialized.style, layerName) : serialized.style;
          }
          return processStyle(props, serialized, props.theme.modularCssLayers ? layerName : void 0);
        };
      }
      return style2;
    };
    const muiStyledResolver = (...expressionsInput) => {
      const expressionsHead = [];
      const expressionsBody = expressionsInput.map(transformStyle);
      const expressionsTail = [];
      expressionsHead.push(styleAttachTheme);
      if (componentName && overridesResolver2) {
        expressionsTail.push(function styleThemeOverrides(props) {
          const theme2 = props.theme;
          const styleOverrides = theme2.components?.[componentName]?.styleOverrides;
          if (!styleOverrides) {
            return null;
          }
          const resolvedStyleOverrides = {};
          for (const slotKey in styleOverrides) {
            resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey], props.theme.modularCssLayers ? "theme" : void 0);
          }
          return overridesResolver2(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsTail.push(function styleThemeVariants(props) {
          const theme2 = props.theme;
          const themeVariants = theme2?.components?.[componentName]?.variants;
          if (!themeVariants) {
            return null;
          }
          return processStyleVariants(props, themeVariants, [], props.theme.modularCssLayers ? "theme" : void 0);
        });
      }
      if (!skipSx) {
        expressionsTail.push(styleFunctionSx);
      }
      if (Array.isArray(expressionsBody[0])) {
        const inputStrings = expressionsBody.shift();
        const placeholdersHead = new Array(expressionsHead.length).fill("");
        const placeholdersTail = new Array(expressionsTail.length).fill("");
        let outputStrings;
        {
          outputStrings = [...placeholdersHead, ...inputStrings, ...placeholdersTail];
          outputStrings.raw = [...placeholdersHead, ...inputStrings.raw, ...placeholdersTail];
        }
        expressionsHead.unshift(outputStrings);
      }
      const expressions = [...expressionsHead, ...expressionsBody, ...expressionsTail];
      const Component = defaultStyledResolver(...expressions);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
  return styled2;
}
function generateStyledLabel(componentName, componentSlot) {
  let label;
  return label;
}
function isObjectEmpty$1(object) {
  for (const _2 in object) {
    return false;
  }
  return true;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
function lowercaseFirstLetter(string) {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
}
const styled$1 = createStyled2();
function resolveProps(defaultProps2, props, mergeClassNameAndStyle = false) {
  const output = {
    ...props
  };
  for (const key2 in defaultProps2) {
    if (Object.prototype.hasOwnProperty.call(defaultProps2, key2)) {
      const propName = key2;
      if (propName === "components" || propName === "slots") {
        output[propName] = {
          ...defaultProps2[propName],
          ...output[propName]
        };
      } else if (propName === "componentsProps" || propName === "slotProps") {
        const defaultSlotProps = defaultProps2[propName];
        const slotProps = props[propName];
        if (!slotProps) {
          output[propName] = defaultSlotProps || {};
        } else if (!defaultSlotProps) {
          output[propName] = slotProps;
        } else {
          output[propName] = {
            ...slotProps
          };
          for (const slotKey in defaultSlotProps) {
            if (Object.prototype.hasOwnProperty.call(defaultSlotProps, slotKey)) {
              const slotPropName = slotKey;
              output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName], mergeClassNameAndStyle);
            }
          }
        }
      } else if (propName === "className" && mergeClassNameAndStyle && props.className) {
        output.className = clsx(defaultProps2?.className, props?.className);
      } else if (propName === "style" && mergeClassNameAndStyle && props.style) {
        output.style = {
          ...defaultProps2?.style,
          ...props?.style
        };
      } else if (output[propName] === void 0) {
        output[propName] = defaultProps2[propName];
      }
    }
  }
  return output;
}
function getThemeProps$1(params) {
  const {
    theme: theme2,
    name,
    props
  } = params;
  if (!theme2 || !theme2.components || !theme2.components[name] || !theme2.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme2.components[name].defaultProps, props);
}
function useThemeProps({
  props,
  name,
  defaultTheme: defaultTheme2,
  themeId
}) {
  let theme2 = useTheme$2(defaultTheme2);
  if (themeId) {
    theme2 = theme2[themeId] || theme2;
  }
  return getThemeProps$1({
    theme: theme2,
    name,
    props
  });
}
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useMediaQueryOld(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const [match2, setMatch] = reactExports.useState(() => {
    if (noSsr && matchMedia) {
      return matchMedia(query).matches;
    }
    if (ssrMatchMedia) {
      return ssrMatchMedia(query).matches;
    }
    return defaultMatches;
  });
  useEnhancedEffect(() => {
    if (!matchMedia) {
      return void 0;
    }
    const queryList = matchMedia(query);
    const updateMatch = () => {
      setMatch(queryList.matches);
    };
    updateMatch();
    queryList.addEventListener("change", updateMatch);
    return () => {
      queryList.removeEventListener("change", updateMatch);
    };
  }, [query, matchMedia]);
  return match2;
}
const safeReact$1 = {
  ...React$1
};
const maybeReactUseSyncExternalStore = safeReact$1.useSyncExternalStore;
function useMediaQueryNew(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const getDefaultSnapshot = reactExports.useCallback(() => defaultMatches, [defaultMatches]);
  const getServerSnapshot = reactExports.useMemo(() => {
    if (noSsr && matchMedia) {
      return () => matchMedia(query).matches;
    }
    if (ssrMatchMedia !== null) {
      const {
        matches
      } = ssrMatchMedia(query);
      return () => matches;
    }
    return getDefaultSnapshot;
  }, [getDefaultSnapshot, query, ssrMatchMedia, noSsr, matchMedia]);
  const [getSnapshot, subscribe2] = reactExports.useMemo(() => {
    if (matchMedia === null) {
      return [getDefaultSnapshot, () => () => {
      }];
    }
    const mediaQueryList = matchMedia(query);
    return [() => mediaQueryList.matches, (notify) => {
      mediaQueryList.addEventListener("change", notify);
      return () => {
        mediaQueryList.removeEventListener("change", notify);
      };
    }];
  }, [getDefaultSnapshot, matchMedia, query]);
  const match2 = maybeReactUseSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot);
  return match2;
}
function unstable_createUseMediaQuery(params = {}) {
  const {
    themeId
  } = params;
  return function useMediaQuery2(queryInput, options = {}) {
    let theme2 = useTheme$3();
    if (theme2 && themeId) {
      theme2 = theme2[themeId] || theme2;
    }
    const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
    const {
      defaultMatches = false,
      matchMedia = supportMatchMedia ? window.matchMedia : null,
      ssrMatchMedia = null,
      noSsr = false
    } = getThemeProps$1({
      name: "MuiUseMediaQuery",
      props: options,
      theme: theme2
    });
    let query = typeof queryInput === "function" ? queryInput(theme2) : queryInput;
    query = query.replace(/^@media( ?)/m, "");
    if (query.includes("print")) {
      console.warn([`MUI: You have provided a \`print\` query to the \`useMediaQuery\` hook.`, "Using the print media query to modify print styles can lead to unexpected results.", "Consider using the `displayPrint` field in the `sx` prop instead.", "More information about `displayPrint` on our docs: https://mui.com/system/display/#display-in-print."].join("\n"));
    }
    const useMediaQueryImplementation = maybeReactUseSyncExternalStore !== void 0 ? useMediaQueryNew : useMediaQueryOld;
    const match2 = useMediaQueryImplementation(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr);
    return match2;
  };
}
unstable_createUseMediaQuery();
function clamp(val, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
  return Math.max(min2, Math.min(val, max2));
}
function clampWrapper(value, min2 = 0, max2 = 1) {
  return clamp(value, min2, max2);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re2);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n3) => n3 + n3);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n3, index2) => {
    return index2 < 3 ? parseInt(n3, 16) : Math.round(parseInt(n3, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(type)) {
    throw new Error(formatMuiErrorMessage(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (!["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(colorSpace)) {
      throw new Error(formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type,
    values: values2,
    colorSpace
  };
}
const colorChannel = (color2) => {
  const decomposedColor = decomposeColor(color2);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
};
const private_safeColorChannel = (color2, warning2) => {
  try {
    return colorChannel(color2);
  } catch (error) {
    return color2;
  }
};
function recomposeColor(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type.includes("rgb")) {
    values2 = values2.map((n3, i4) => i4 < 3 ? parseInt(n3, 10) : n3);
  } else if (type.includes("hsl")) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type.includes("color")) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type}(${values2})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h2 = values2[0];
  const s2 = values2[1] / 100;
  const l2 = values2[2] / 100;
  const a2 = s2 * Math.min(l2, 1 - l2);
  const f2 = (n3, k2 = (n3 + h2 / 30) % 12) => l2 - a2 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  let type = "rgb";
  const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
  if (color2.type === "hsla") {
    type += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
  color2 = decomposeColor(color2);
  value = clampWrapper(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function private_safeAlpha(color2, value, warning2) {
  try {
    return alpha(color2, value);
  } catch (error) {
    return color2;
  }
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.includes("rgb") || color2.type.includes("color")) {
    for (let i4 = 0; i4 < 3; i4 += 1) {
      color2.values[i4] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeDarken(color2, coefficient, warning2) {
  try {
    return darken(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.includes("hsl")) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.includes("rgb")) {
    for (let i4 = 0; i4 < 3; i4 += 1) {
      color2.values[i4] += (255 - color2.values[i4]) * coefficient;
    }
  } else if (color2.type.includes("color")) {
    for (let i4 = 0; i4 < 3; i4 += 1) {
      color2.values[i4] += (1 - color2.values[i4]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
function private_safeLighten(color2, coefficient, warning2) {
  try {
    return lighten(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
function emphasize(color2, coefficient = 0.15) {
  return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
}
function private_safeEmphasize(color2, coefficient, warning2) {
  try {
    return emphasize(color2, coefficient);
  } catch (error) {
    return color2;
  }
}
const ThemeContext = /* @__PURE__ */ reactExports.createContext(null);
function useTheme$1() {
  const theme2 = reactExports.useContext(ThemeContext);
  return theme2;
}
const hasSymbol = typeof Symbol === "function" && Symbol.for;
const nested = hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function mergeOuterLocalTheme(outerTheme, localTheme) {
  if (typeof localTheme === "function") {
    const mergedTheme = localTheme(outerTheme);
    return mergedTheme;
  }
  return {
    ...outerTheme,
    ...localTheme
  };
}
function ThemeProvider$2(props) {
  const {
    children,
    theme: localTheme
  } = props;
  const outerTheme = useTheme$1();
  const theme2 = reactExports.useMemo(() => {
    const output = outerTheme === null ? {
      ...localTheme
    } : mergeOuterLocalTheme(outerTheme, localTheme);
    if (output != null) {
      output[nested] = outerTheme !== null;
    }
    return output;
  }, [localTheme, outerTheme]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext.Provider, {
    value: theme2,
    children
  });
}
const RtlContext = /* @__PURE__ */ reactExports.createContext();
function RtlProvider({
  value,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RtlContext.Provider, {
    value: value ?? true,
    ...props
  });
}
const useRtl = () => {
  const value = reactExports.useContext(RtlContext);
  return value ?? false;
};
const PropsContext = /* @__PURE__ */ reactExports.createContext(void 0);
function DefaultPropsProvider({
  value,
  children
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PropsContext.Provider, {
    value,
    children
  });
}
function getThemeProps(params) {
  const {
    theme: theme2,
    name,
    props
  } = params;
  if (!theme2 || !theme2.components || !theme2.components[name]) {
    return props;
  }
  const config2 = theme2.components[name];
  if (config2.defaultProps) {
    return resolveProps(config2.defaultProps, props, theme2.components.mergeClassNameAndStyle);
  }
  if (!config2.styleOverrides && !config2.variants) {
    return resolveProps(config2, props, theme2.components.mergeClassNameAndStyle);
  }
  return props;
}
function useDefaultProps$1({
  props,
  name
}) {
  const ctx = reactExports.useContext(PropsContext);
  return getThemeProps({
    props,
    name,
    theme: {
      components: ctx
    }
  });
}
let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id;
}
const safeReact = {
  ...React$1
};
const maybeReactUseId = safeReact.useId;
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride ?? reactId;
  }
  return useGlobalId(idOverride);
}
function useLayerOrder(theme2) {
  const upperTheme = useTheme$3();
  const id = useId() || "";
  const {
    modularCssLayers
  } = theme2;
  let layerOrder = "mui.global, mui.components, mui.theme, mui.custom, mui.sx";
  if (!modularCssLayers || upperTheme !== null) {
    layerOrder = "";
  } else if (typeof modularCssLayers === "string") {
    layerOrder = modularCssLayers.replace(/mui(?!\.)/g, layerOrder);
  } else {
    layerOrder = `@layer ${layerOrder};`;
  }
  useEnhancedEffect(() => {
    const head = document.querySelector("head");
    if (!head) {
      return;
    }
    const firstChild = head.firstChild;
    if (layerOrder) {
      if (firstChild && firstChild.hasAttribute?.("data-mui-layer-order") && firstChild.getAttribute("data-mui-layer-order") === id) {
        return;
      }
      const styleElement = document.createElement("style");
      styleElement.setAttribute("data-mui-layer-order", id);
      styleElement.textContent = layerOrder;
      head.prepend(styleElement);
    } else {
      head.querySelector(`style[data-mui-layer-order="${id}"]`)?.remove();
    }
  }, [layerOrder, id]);
  if (!layerOrder) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
    styles: layerOrder
  });
}
const EMPTY_THEME = {};
function useThemeScoping(themeId, upperTheme, localTheme, isPrivate = false) {
  return reactExports.useMemo(() => {
    const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
    if (typeof localTheme === "function") {
      const mergedTheme = localTheme(resolvedTheme);
      const result = themeId ? {
        ...upperTheme,
        [themeId]: mergedTheme
      } : mergedTheme;
      if (isPrivate) {
        return () => result;
      }
      return result;
    }
    return themeId ? {
      ...upperTheme,
      [themeId]: localTheme
    } : {
      ...upperTheme,
      ...localTheme
    };
  }, [themeId, upperTheme, localTheme, isPrivate]);
}
function ThemeProvider$1(props) {
  const {
    children,
    theme: localTheme,
    themeId
  } = props;
  const upperTheme = useTheme$3(EMPTY_THEME);
  const upperPrivateTheme = useTheme$1() || EMPTY_THEME;
  const engineTheme = useThemeScoping(themeId, upperTheme, localTheme);
  const privateTheme = useThemeScoping(themeId, upperPrivateTheme, localTheme, true);
  const rtlValue = (themeId ? engineTheme[themeId] : engineTheme).direction === "rtl";
  const layerOrder = useLayerOrder(engineTheme);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$2, {
    theme: privateTheme,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext$1.Provider, {
      value: engineTheme,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(RtlProvider, {
        value: rtlValue,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DefaultPropsProvider, {
          value: themeId ? engineTheme[themeId].components : engineTheme.components,
          children: [layerOrder, children]
        })
      })
    })
  });
}
const arg = {
  theme: void 0
};
function unstable_memoTheme(styleFn) {
  let lastValue;
  let lastTheme;
  return function styleMemoized(props) {
    let value = lastValue;
    if (value === void 0 || props.theme !== lastTheme) {
      arg.theme = props.theme;
      value = preprocessStyles(styleFn(arg));
      lastValue = value;
      lastTheme = props.theme;
    }
    return value;
  };
}
const DEFAULT_MODE_STORAGE_KEY = "mode";
const DEFAULT_COLOR_SCHEME_STORAGE_KEY = "color-scheme";
const DEFAULT_ATTRIBUTE = "data-color-scheme";
function InitColorSchemeScript(options) {
  const {
    defaultMode = "system",
    defaultLightColorScheme = "light",
    defaultDarkColorScheme = "dark",
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    attribute: initialAttribute = DEFAULT_ATTRIBUTE,
    colorSchemeNode = "document.documentElement",
    nonce
  } = options || {};
  let setter = "";
  let attribute = initialAttribute;
  if (initialAttribute === "class") {
    attribute = ".%s";
  }
  if (initialAttribute === "data") {
    attribute = "[data-%s]";
  }
  if (attribute.startsWith(".")) {
    const selector = attribute.substring(1);
    setter += `${colorSchemeNode}.classList.remove('${selector}'.replace('%s', light), '${selector}'.replace('%s', dark));
      ${colorSchemeNode}.classList.add('${selector}'.replace('%s', colorScheme));`;
  }
  const matches = attribute.match(/\[([^[\]]+)\]/);
  if (matches) {
    const [attr, value] = matches[1].split("=");
    if (!value) {
      setter += `${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', light));
      ${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', dark));`;
    }
    setter += `
      ${colorSchemeNode}.setAttribute('${attr}'.replace('%s', colorScheme), ${value ? `${value}.replace('%s', colorScheme)` : '""'});`;
  } else {
    setter += `${colorSchemeNode}.setAttribute('${attribute}', colorScheme);`;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("script", {
    suppressHydrationWarning: true,
    nonce: typeof window === "undefined" ? nonce : "",
    dangerouslySetInnerHTML: {
      __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${modeStorageKey}') || '${defaultMode}';
  const dark = localStorage.getItem('${colorSchemeStorageKey}-dark') || '${defaultDarkColorScheme}';
  const light = localStorage.getItem('${colorSchemeStorageKey}-light') || '${defaultLightColorScheme}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${setter}
  }
} catch(e){}})();`
    }
  }, "mui-color-scheme-init");
}
function noop$4() {
}
const localStorageManager = ({
  key: key2,
  storageWindow
}) => {
  if (!storageWindow && typeof window !== "undefined") {
    storageWindow = window;
  }
  return {
    get(defaultValue) {
      if (typeof window === "undefined") {
        return void 0;
      }
      if (!storageWindow) {
        return defaultValue;
      }
      let value;
      try {
        value = storageWindow.localStorage.getItem(key2);
      } catch {
      }
      return value || defaultValue;
    },
    set: (value) => {
      if (storageWindow) {
        try {
          storageWindow.localStorage.setItem(key2, value);
        } catch {
        }
      }
    },
    subscribe: (handler) => {
      if (!storageWindow) {
        return noop$4;
      }
      const listener = (event) => {
        const value = event.newValue;
        if (event.key === key2) {
          handler(value);
        }
      };
      storageWindow.addEventListener("storage", listener);
      return () => {
        storageWindow.removeEventListener("storage", listener);
      };
    }
  };
};
function noop$3() {
}
function getSystemMode(mode2) {
  if (typeof window !== "undefined" && typeof window.matchMedia === "function" && mode2 === "system") {
    const mql = window.matchMedia("(prefers-color-scheme: dark)");
    if (mql.matches) {
      return "dark";
    }
    return "light";
  }
  return void 0;
}
function processState(state2, callback) {
  if (state2.mode === "light" || state2.mode === "system" && state2.systemMode === "light") {
    return callback("light");
  }
  if (state2.mode === "dark" || state2.mode === "system" && state2.systemMode === "dark") {
    return callback("dark");
  }
  return void 0;
}
function getColorScheme(state2) {
  return processState(state2, (mode2) => {
    if (mode2 === "light") {
      return state2.lightColorScheme;
    }
    if (mode2 === "dark") {
      return state2.darkColorScheme;
    }
    return void 0;
  });
}
function useCurrentColorScheme(options) {
  const {
    defaultMode = "light",
    defaultLightColorScheme,
    defaultDarkColorScheme,
    supportedColorSchemes = [],
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    storageWindow = typeof window === "undefined" ? void 0 : window,
    storageManager = localStorageManager,
    noSsr = false
  } = options;
  const joinedColorSchemes = supportedColorSchemes.join(",");
  const isMultiSchemes = supportedColorSchemes.length > 1;
  const modeStorage = reactExports.useMemo(() => storageManager?.({
    key: modeStorageKey,
    storageWindow
  }), [storageManager, modeStorageKey, storageWindow]);
  const lightStorage = reactExports.useMemo(() => storageManager?.({
    key: `${colorSchemeStorageKey}-light`,
    storageWindow
  }), [storageManager, colorSchemeStorageKey, storageWindow]);
  const darkStorage = reactExports.useMemo(() => storageManager?.({
    key: `${colorSchemeStorageKey}-dark`,
    storageWindow
  }), [storageManager, colorSchemeStorageKey, storageWindow]);
  const [state2, setState] = reactExports.useState(() => {
    const initialMode = modeStorage?.get(defaultMode) || defaultMode;
    const lightColorScheme = lightStorage?.get(defaultLightColorScheme) || defaultLightColorScheme;
    const darkColorScheme = darkStorage?.get(defaultDarkColorScheme) || defaultDarkColorScheme;
    return {
      mode: initialMode,
      systemMode: getSystemMode(initialMode),
      lightColorScheme,
      darkColorScheme
    };
  });
  const [isClient, setIsClient] = reactExports.useState(noSsr || !isMultiSchemes);
  reactExports.useEffect(() => {
    setIsClient(true);
  }, []);
  const colorScheme = getColorScheme(state2);
  const setMode = reactExports.useCallback((mode2) => {
    setState((currentState) => {
      if (mode2 === currentState.mode) {
        return currentState;
      }
      const newMode = mode2 ?? defaultMode;
      modeStorage?.set(newMode);
      return {
        ...currentState,
        mode: newMode,
        systemMode: getSystemMode(newMode)
      };
    });
  }, [modeStorage, defaultMode]);
  const setColorScheme = reactExports.useCallback((value) => {
    if (!value) {
      setState((currentState) => {
        lightStorage?.set(defaultLightColorScheme);
        darkStorage?.set(defaultDarkColorScheme);
        return {
          ...currentState,
          lightColorScheme: defaultLightColorScheme,
          darkColorScheme: defaultDarkColorScheme
        };
      });
    } else if (typeof value === "string") {
      if (value && !joinedColorSchemes.includes(value)) {
        console.error(`\`${value}\` does not exist in \`theme.colorSchemes\`.`);
      } else {
        setState((currentState) => {
          const newState = {
            ...currentState
          };
          processState(currentState, (mode2) => {
            if (mode2 === "light") {
              lightStorage?.set(value);
              newState.lightColorScheme = value;
            }
            if (mode2 === "dark") {
              darkStorage?.set(value);
              newState.darkColorScheme = value;
            }
          });
          return newState;
        });
      }
    } else {
      setState((currentState) => {
        const newState = {
          ...currentState
        };
        const newLightColorScheme = value.light === null ? defaultLightColorScheme : value.light;
        const newDarkColorScheme = value.dark === null ? defaultDarkColorScheme : value.dark;
        if (newLightColorScheme) {
          if (!joinedColorSchemes.includes(newLightColorScheme)) {
            console.error(`\`${newLightColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
          } else {
            newState.lightColorScheme = newLightColorScheme;
            lightStorage?.set(newLightColorScheme);
          }
        }
        if (newDarkColorScheme) {
          if (!joinedColorSchemes.includes(newDarkColorScheme)) {
            console.error(`\`${newDarkColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
          } else {
            newState.darkColorScheme = newDarkColorScheme;
            darkStorage?.set(newDarkColorScheme);
          }
        }
        return newState;
      });
    }
  }, [joinedColorSchemes, lightStorage, darkStorage, defaultLightColorScheme, defaultDarkColorScheme]);
  const handleMediaQuery = reactExports.useCallback((event) => {
    if (state2.mode === "system") {
      setState((currentState) => {
        const systemMode = event?.matches ? "dark" : "light";
        if (currentState.systemMode === systemMode) {
          return currentState;
        }
        return {
          ...currentState,
          systemMode
        };
      });
    }
  }, [state2.mode]);
  const mediaListener = reactExports.useRef(handleMediaQuery);
  mediaListener.current = handleMediaQuery;
  reactExports.useEffect(() => {
    if (typeof window.matchMedia !== "function" || !isMultiSchemes) {
      return void 0;
    }
    const handler = (...args) => mediaListener.current(...args);
    const media = window.matchMedia("(prefers-color-scheme: dark)");
    media.addListener(handler);
    handler(media);
    return () => {
      media.removeListener(handler);
    };
  }, [isMultiSchemes]);
  reactExports.useEffect(() => {
    if (isMultiSchemes) {
      const unsubscribeMode = modeStorage?.subscribe((value) => {
        if (!value || ["light", "dark", "system"].includes(value)) {
          setMode(value || defaultMode);
        }
      }) || noop$3;
      const unsubscribeLight = lightStorage?.subscribe((value) => {
        if (!value || joinedColorSchemes.match(value)) {
          setColorScheme({
            light: value
          });
        }
      }) || noop$3;
      const unsubscribeDark = darkStorage?.subscribe((value) => {
        if (!value || joinedColorSchemes.match(value)) {
          setColorScheme({
            dark: value
          });
        }
      }) || noop$3;
      return () => {
        unsubscribeMode();
        unsubscribeLight();
        unsubscribeDark();
      };
    }
    return void 0;
  }, [setColorScheme, setMode, joinedColorSchemes, defaultMode, storageWindow, isMultiSchemes, modeStorage, lightStorage, darkStorage]);
  return {
    ...state2,
    mode: isClient ? state2.mode : void 0,
    systemMode: isClient ? state2.systemMode : void 0,
    colorScheme: isClient ? colorScheme : void 0,
    setMode,
    setColorScheme
  };
}
const DISABLE_CSS_TRANSITION = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function createCssVarsProvider(options) {
  const {
    themeId,
    /**
     * This `theme` object needs to follow a certain structure to
     * be used correctly by the finel `CssVarsProvider`. It should have a
     * `colorSchemes` key with the light and dark (and any other) palette.
     * It should also ideally have a vars object created using `prepareCssVars`.
     */
    theme: defaultTheme2 = {},
    modeStorageKey: defaultModeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey: defaultColorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    disableTransitionOnChange: designSystemTransitionOnChange = false,
    defaultColorScheme,
    resolveTheme
  } = options;
  const defaultContext = {
    allColorSchemes: [],
    colorScheme: void 0,
    darkColorScheme: void 0,
    lightColorScheme: void 0,
    mode: void 0,
    setColorScheme: () => {
    },
    setMode: () => {
    },
    systemMode: void 0
  };
  const ColorSchemeContext = /* @__PURE__ */ reactExports.createContext(void 0);
  const useColorScheme = () => reactExports.useContext(ColorSchemeContext) || defaultContext;
  const defaultColorSchemes = {};
  const defaultComponents = {};
  function CssVarsProvider2(props) {
    const {
      children,
      theme: themeProp,
      modeStorageKey = defaultModeStorageKey,
      colorSchemeStorageKey = defaultColorSchemeStorageKey,
      disableTransitionOnChange = designSystemTransitionOnChange,
      storageManager,
      storageWindow = typeof window === "undefined" ? void 0 : window,
      documentNode = typeof document === "undefined" ? void 0 : document,
      colorSchemeNode = typeof document === "undefined" ? void 0 : document.documentElement,
      disableNestedContext = false,
      disableStyleSheetGeneration = false,
      defaultMode: initialMode = "system",
      forceThemeRerender = false,
      noSsr
    } = props;
    const hasMounted = reactExports.useRef(false);
    const upperTheme = useTheme$1();
    const ctx = reactExports.useContext(ColorSchemeContext);
    const nested2 = !!ctx && !disableNestedContext;
    const initialTheme = reactExports.useMemo(() => {
      if (themeProp) {
        return themeProp;
      }
      return typeof defaultTheme2 === "function" ? defaultTheme2() : defaultTheme2;
    }, [themeProp]);
    const scopedTheme = initialTheme[themeId];
    const restThemeProp = scopedTheme || initialTheme;
    const {
      colorSchemes = defaultColorSchemes,
      components = defaultComponents,
      cssVarPrefix
    } = restThemeProp;
    const joinedColorSchemes = Object.keys(colorSchemes).filter((k2) => !!colorSchemes[k2]).join(",");
    const allColorSchemes = reactExports.useMemo(() => joinedColorSchemes.split(","), [joinedColorSchemes]);
    const defaultLightColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
    const defaultDarkColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
    const defaultMode = colorSchemes[defaultLightColorScheme2] && colorSchemes[defaultDarkColorScheme2] ? initialMode : colorSchemes[restThemeProp.defaultColorScheme]?.palette?.mode || restThemeProp.palette?.mode;
    const {
      mode: stateMode,
      setMode,
      systemMode,
      lightColorScheme,
      darkColorScheme,
      colorScheme: stateColorScheme,
      setColorScheme
    } = useCurrentColorScheme({
      supportedColorSchemes: allColorSchemes,
      defaultLightColorScheme: defaultLightColorScheme2,
      defaultDarkColorScheme: defaultDarkColorScheme2,
      modeStorageKey,
      colorSchemeStorageKey,
      defaultMode,
      storageManager,
      storageWindow,
      noSsr
    });
    let mode2 = stateMode;
    let colorScheme = stateColorScheme;
    if (nested2) {
      mode2 = ctx.mode;
      colorScheme = ctx.colorScheme;
    }
    let calculatedColorScheme = colorScheme || restThemeProp.defaultColorScheme;
    if (restThemeProp.vars && !forceThemeRerender) {
      calculatedColorScheme = restThemeProp.defaultColorScheme;
    }
    const memoTheme2 = reactExports.useMemo(() => {
      const themeVars = restThemeProp.generateThemeVars?.() || restThemeProp.vars;
      const theme2 = {
        ...restThemeProp,
        components,
        colorSchemes,
        cssVarPrefix,
        vars: themeVars
      };
      if (typeof theme2.generateSpacing === "function") {
        theme2.spacing = theme2.generateSpacing();
      }
      if (calculatedColorScheme) {
        const scheme = colorSchemes[calculatedColorScheme];
        if (scheme && typeof scheme === "object") {
          Object.keys(scheme).forEach((schemeKey) => {
            if (scheme[schemeKey] && typeof scheme[schemeKey] === "object") {
              theme2[schemeKey] = {
                ...theme2[schemeKey],
                ...scheme[schemeKey]
              };
            } else {
              theme2[schemeKey] = scheme[schemeKey];
            }
          });
        }
      }
      return resolveTheme ? resolveTheme(theme2) : theme2;
    }, [restThemeProp, calculatedColorScheme, components, colorSchemes, cssVarPrefix]);
    const colorSchemeSelector = restThemeProp.colorSchemeSelector;
    useEnhancedEffect(() => {
      if (colorScheme && colorSchemeNode && colorSchemeSelector && colorSchemeSelector !== "media") {
        const selector = colorSchemeSelector;
        let rule = colorSchemeSelector;
        if (selector === "class") {
          rule = `.%s`;
        }
        if (selector === "data") {
          rule = `[data-%s]`;
        }
        if (selector?.startsWith("data-") && !selector.includes("%s")) {
          rule = `[${selector}="%s"]`;
        }
        if (rule.startsWith(".")) {
          colorSchemeNode.classList.remove(...allColorSchemes.map((scheme) => rule.substring(1).replace("%s", scheme)));
          colorSchemeNode.classList.add(rule.substring(1).replace("%s", colorScheme));
        } else {
          const matches = rule.replace("%s", colorScheme).match(/\[([^\]]+)\]/);
          if (matches) {
            const [attr, value] = matches[1].split("=");
            if (!value) {
              allColorSchemes.forEach((scheme) => {
                colorSchemeNode.removeAttribute(attr.replace(colorScheme, scheme));
              });
            }
            colorSchemeNode.setAttribute(attr, value ? value.replace(/"|'/g, "") : "");
          } else {
            colorSchemeNode.setAttribute(rule, colorScheme);
          }
        }
      }
    }, [colorScheme, colorSchemeSelector, colorSchemeNode, allColorSchemes]);
    reactExports.useEffect(() => {
      let timer;
      if (disableTransitionOnChange && hasMounted.current && documentNode) {
        const css2 = documentNode.createElement("style");
        css2.appendChild(documentNode.createTextNode(DISABLE_CSS_TRANSITION));
        documentNode.head.appendChild(css2);
        (() => window.getComputedStyle(documentNode.body))();
        timer = setTimeout(() => {
          documentNode.head.removeChild(css2);
        }, 1);
      }
      return () => {
        clearTimeout(timer);
      };
    }, [colorScheme, disableTransitionOnChange, documentNode]);
    reactExports.useEffect(() => {
      hasMounted.current = true;
      return () => {
        hasMounted.current = false;
      };
    }, []);
    const contextValue = reactExports.useMemo(() => ({
      allColorSchemes,
      colorScheme,
      darkColorScheme,
      lightColorScheme,
      mode: mode2,
      setColorScheme,
      setMode,
      systemMode
    }), [allColorSchemes, colorScheme, darkColorScheme, lightColorScheme, mode2, setColorScheme, setMode, systemMode, memoTheme2.colorSchemeSelector]);
    let shouldGenerateStyleSheet = true;
    if (disableStyleSheetGeneration || restThemeProp.cssVariables === false || nested2 && upperTheme?.cssVarPrefix === cssVarPrefix) {
      shouldGenerateStyleSheet = false;
    }
    const element = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$1, {
        themeId: scopedTheme ? themeId : void 0,
        theme: memoTheme2,
        children
      }), shouldGenerateStyleSheet && /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$3, {
        styles: memoTheme2.generateStyleSheets?.() || []
      })]
    });
    if (nested2) {
      return element;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ColorSchemeContext.Provider, {
      value: contextValue,
      children: element
    });
  }
  const defaultLightColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
  const defaultDarkColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
  const getInitColorSchemeScript = (params) => InitColorSchemeScript({
    colorSchemeStorageKey: defaultColorSchemeStorageKey,
    defaultLightColorScheme,
    defaultDarkColorScheme,
    modeStorageKey: defaultModeStorageKey,
    ...params
  });
  return {
    CssVarsProvider: CssVarsProvider2,
    useColorScheme,
    getInitColorSchemeScript
  };
}
function createGetCssVar$1(prefix2 = "") {
  function appendVar(...vars) {
    if (!vars.length) {
      return "";
    }
    const value = vars[0];
    if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
      return `, var(--${prefix2 ? `${prefix2}-` : ""}${value}${appendVar(...vars.slice(1))})`;
    }
    return `, ${value}`;
  }
  const getCssVar = (field, ...fallbacks) => {
    return `var(--${prefix2 ? `${prefix2}-` : ""}${field}${appendVar(...fallbacks)})`;
  };
  return getCssVar;
}
const assignNestedKeys = (obj, keys, value, arrayKeys = []) => {
  let temp = obj;
  keys.forEach((k2, index2) => {
    if (index2 === keys.length - 1) {
      if (Array.isArray(temp)) {
        temp[Number(k2)] = value;
      } else if (temp && typeof temp === "object") {
        temp[k2] = value;
      }
    } else if (temp && typeof temp === "object") {
      if (!temp[k2]) {
        temp[k2] = arrayKeys.includes(k2) ? [] : {};
      }
      temp = temp[k2];
    }
  });
};
const walkObjectDeep = (obj, callback, shouldSkipPaths) => {
  function recurse(object, parentKeys = [], arrayKeys = []) {
    Object.entries(object).forEach(([key2, value]) => {
      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key2])) {
        if (value !== void 0 && value !== null) {
          if (typeof value === "object" && Object.keys(value).length > 0) {
            recurse(value, [...parentKeys, key2], Array.isArray(value) ? [...arrayKeys, key2] : arrayKeys);
          } else {
            callback([...parentKeys, key2], value, arrayKeys);
          }
        }
      }
    });
  }
  recurse(obj);
};
const getCssValue = (keys, value) => {
  if (typeof value === "number") {
    if (["lineHeight", "fontWeight", "opacity", "zIndex"].some((prop) => keys.includes(prop))) {
      return value;
    }
    const lastKey = keys[keys.length - 1];
    if (lastKey.toLowerCase().includes("opacity")) {
      return value;
    }
    return `${value}px`;
  }
  return value;
};
function cssVarsParser(theme2, options) {
  const {
    prefix: prefix2,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar2
  } = options || {};
  const css2 = {};
  const vars = {};
  const varsWithDefaults = {};
  walkObjectDeep(
    theme2,
    (keys, value, arrayKeys) => {
      if (typeof value === "string" || typeof value === "number") {
        if (!shouldSkipGeneratingVar2 || !shouldSkipGeneratingVar2(keys, value)) {
          const cssVar = `--${prefix2 ? `${prefix2}-` : ""}${keys.join("-")}`;
          const resolvedValue = getCssValue(keys, value);
          Object.assign(css2, {
            [cssVar]: resolvedValue
          });
          assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
          assignNestedKeys(varsWithDefaults, keys, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
        }
      }
    },
    (keys) => keys[0] === "vars"
    // skip 'vars/*' paths
  );
  return {
    css: css2,
    vars,
    varsWithDefaults
  };
}
function prepareCssVars(theme2, parserConfig = {}) {
  const {
    getSelector = defaultGetSelector2,
    disableCssColorScheme,
    colorSchemeSelector: selector,
    enableContrastVars
  } = parserConfig;
  const {
    colorSchemes = {},
    components,
    defaultColorScheme = "light",
    ...otherTheme
  } = theme2;
  const {
    vars: rootVars,
    css: rootCss,
    varsWithDefaults: rootVarsWithDefaults
  } = cssVarsParser(otherTheme, parserConfig);
  let themeVars = rootVarsWithDefaults;
  const colorSchemesMap = {};
  const {
    [defaultColorScheme]: defaultScheme,
    ...otherColorSchemes
  } = colorSchemes;
  Object.entries(otherColorSchemes || {}).forEach(([key2, scheme]) => {
    const {
      vars,
      css: css2,
      varsWithDefaults
    } = cssVarsParser(scheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[key2] = {
      css: css2,
      vars
    };
  });
  if (defaultScheme) {
    const {
      css: css2,
      vars,
      varsWithDefaults
    } = cssVarsParser(defaultScheme, parserConfig);
    themeVars = deepmerge(themeVars, varsWithDefaults);
    colorSchemesMap[defaultColorScheme] = {
      css: css2,
      vars
    };
  }
  function defaultGetSelector2(colorScheme, cssObject) {
    let rule = selector;
    if (selector === "class") {
      rule = ".%s";
    }
    if (selector === "data") {
      rule = "[data-%s]";
    }
    if (selector?.startsWith("data-") && !selector.includes("%s")) {
      rule = `[${selector}="%s"]`;
    }
    if (colorScheme) {
      if (rule === "media") {
        if (theme2.defaultColorScheme === colorScheme) {
          return ":root";
        }
        const mode2 = colorSchemes[colorScheme]?.palette?.mode || colorScheme;
        return {
          [`@media (prefers-color-scheme: ${mode2})`]: {
            ":root": cssObject
          }
        };
      }
      if (rule) {
        if (theme2.defaultColorScheme === colorScheme) {
          return `:root, ${rule.replace("%s", String(colorScheme))}`;
        }
        return rule.replace("%s", String(colorScheme));
      }
    }
    return ":root";
  }
  const generateThemeVars = () => {
    let vars = {
      ...rootVars
    };
    Object.entries(colorSchemesMap).forEach(([, {
      vars: schemeVars
    }]) => {
      vars = deepmerge(vars, schemeVars);
    });
    return vars;
  };
  const generateStyleSheets = () => {
    const stylesheets = [];
    const colorScheme = theme2.defaultColorScheme || "light";
    function insertStyleSheet(key2, css2) {
      if (Object.keys(css2).length) {
        stylesheets.push(typeof key2 === "string" ? {
          [key2]: {
            ...css2
          }
        } : key2);
      }
    }
    insertStyleSheet(getSelector(void 0, {
      ...rootCss
    }), rootCss);
    const {
      [colorScheme]: defaultSchemeVal,
      ...other
    } = colorSchemesMap;
    if (defaultSchemeVal) {
      const {
        css: css2
      } = defaultSchemeVal;
      const cssColorSheme = colorSchemes[colorScheme]?.palette?.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(colorScheme, {
        ...finalCss
      }), finalCss);
    }
    Object.entries(other).forEach(([key2, {
      css: css2
    }]) => {
      const cssColorSheme = colorSchemes[key2]?.palette?.mode;
      const finalCss = !disableCssColorScheme && cssColorSheme ? {
        colorScheme: cssColorSheme,
        ...css2
      } : {
        ...css2
      };
      insertStyleSheet(getSelector(key2, {
        ...finalCss
      }), finalCss);
    });
    if (enableContrastVars) {
      stylesheets.push({
        ":root": {
          // use double underscore to indicate that these are private variables
          "--__l-threshold": "0.7",
          "--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
          "--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
          // 0.87 is the default alpha value for black text.
        }
      });
    }
    return stylesheets;
  };
  return {
    vars: themeVars,
    generateThemeVars,
    generateStyleSheets
  };
}
function createGetColorSchemeSelector(selector) {
  return function getColorSchemeSelector(colorScheme) {
    if (selector === "media") {
      return `@media (prefers-color-scheme: ${colorScheme})`;
    }
    if (selector) {
      if (selector.startsWith("data-") && !selector.includes("%s")) {
        return `[${selector}="${colorScheme}"] &`;
      }
      if (selector === "class") {
        return `.${colorScheme} &`;
      }
      if (selector === "data") {
        return `[data-${colorScheme}] &`;
      }
      return `${selector.replace("%s", colorScheme)} &`;
    }
    return "&";
  };
}
function composeClasses(slots, getUtilityClass, classes = void 0) {
  const output = {};
  for (const slotName in slots) {
    const slot = slots[slotName];
    let buffer2 = "";
    let start2 = true;
    for (let i4 = 0; i4 < slot.length; i4 += 1) {
      const value = slot[i4];
      if (value) {
        buffer2 += (start2 === true ? "" : " ") + getUtilityClass(value);
        start2 = false;
        if (classes && classes[value]) {
          buffer2 += " " + classes[value];
        }
      }
    }
    output[slotName] = buffer2;
  }
  return output;
}
const defaultTheme$3 = createTheme$1();
const defaultCreateStyledComponent$1 = styled$1("div", {
  name: "MuiContainer",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
  }
});
const useThemePropsDefault$1 = (inProps) => useThemeProps({
  props: inProps,
  name: "MuiContainer",
  defaultTheme: defaultTheme$3
});
const useUtilityClasses$N = (ownerState, componentName) => {
  const getContainerUtilityClass = (slot) => {
    return generateUtilityClass(componentName, slot);
  };
  const {
    classes,
    fixed,
    disableGutters,
    maxWidth: maxWidth2
  } = ownerState;
  const slots = {
    root: ["root", maxWidth2 && `maxWidth${capitalize(String(maxWidth2))}`, fixed && "fixed", disableGutters && "disableGutters"]
  };
  return composeClasses(slots, getContainerUtilityClass, classes);
};
function createContainer(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent$1,
    useThemeProps: useThemeProps2 = useThemePropsDefault$1,
    componentName = "MuiContainer"
  } = options;
  const ContainerRoot = createStyledComponent(({
    theme: theme2,
    ownerState
  }) => ({
    width: "100%",
    marginLeft: "auto",
    boxSizing: "border-box",
    marginRight: "auto",
    ...!ownerState.disableGutters && {
      paddingLeft: theme2.spacing(2),
      paddingRight: theme2.spacing(2),
      // @ts-ignore module augmentation fails if custom breakpoints are used
      [theme2.breakpoints.up("sm")]: {
        paddingLeft: theme2.spacing(3),
        paddingRight: theme2.spacing(3)
      }
    }
  }), ({
    theme: theme2,
    ownerState
  }) => ownerState.fixed && Object.keys(theme2.breakpoints.values).reduce((acc, breakpointValueKey) => {
    const breakpoint = breakpointValueKey;
    const value = theme2.breakpoints.values[breakpoint];
    if (value !== 0) {
      acc[theme2.breakpoints.up(breakpoint)] = {
        maxWidth: `${value}${theme2.breakpoints.unit}`
      };
    }
    return acc;
  }, {}), ({
    theme: theme2,
    ownerState
  }) => ({
    // @ts-ignore module augmentation fails if custom breakpoints are used
    ...ownerState.maxWidth === "xs" && {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      [theme2.breakpoints.up("xs")]: {
        // @ts-ignore module augmentation fails if custom breakpoints are used
        maxWidth: Math.max(theme2.breakpoints.values.xs, 444)
      }
    },
    ...ownerState.maxWidth && // @ts-ignore module augmentation fails if custom breakpoints are used
    ownerState.maxWidth !== "xs" && {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      [theme2.breakpoints.up(ownerState.maxWidth)]: {
        // @ts-ignore module augmentation fails if custom breakpoints are used
        maxWidth: `${theme2.breakpoints.values[ownerState.maxWidth]}${theme2.breakpoints.unit}`
      }
    }
  }));
  const Container2 = /* @__PURE__ */ reactExports.forwardRef(function Container22(inProps, ref2) {
    const props = useThemeProps2(inProps);
    const {
      className,
      component = "div",
      disableGutters = false,
      fixed = false,
      maxWidth: maxWidth2 = "lg",
      classes: classesProp,
      ...other
    } = props;
    const ownerState = {
      ...props,
      component,
      disableGutters,
      fixed,
      maxWidth: maxWidth2
    };
    const classes = useUtilityClasses$N(ownerState, componentName);
    return (
      // @ts-ignore theme is injected by the styled util
      /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerRoot, {
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref: ref2,
        ...other
      })
    );
  });
  return Container2;
}
function isMuiElement(element, muiNames) {
  return /* @__PURE__ */ reactExports.isValidElement(element) && muiNames.indexOf(
    // For server components `muiName` is available in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    element.type.muiName ?? element.type?._payload?.value?.muiName
  ) !== -1;
}
const filterBreakpointKeys = (breakpointsKeys, responsiveKeys) => breakpointsKeys.filter((key2) => responsiveKeys.includes(key2));
const traverseBreakpoints = (breakpoints, responsive, iterator) => {
  const smallestBreakpoint = breakpoints.keys[0];
  if (Array.isArray(responsive)) {
    responsive.forEach((breakpointValue, index2) => {
      iterator((responsiveStyles, style2) => {
        if (index2 <= breakpoints.keys.length - 1) {
          if (index2 === 0) {
            Object.assign(responsiveStyles, style2);
          } else {
            responsiveStyles[breakpoints.up(breakpoints.keys[index2])] = style2;
          }
        }
      }, breakpointValue);
    });
  } else if (responsive && typeof responsive === "object") {
    const keys = Object.keys(responsive).length > breakpoints.keys.length ? breakpoints.keys : filterBreakpointKeys(breakpoints.keys, Object.keys(responsive));
    keys.forEach((key2) => {
      if (breakpoints.keys.includes(key2)) {
        const breakpointValue = responsive[key2];
        if (breakpointValue !== void 0) {
          iterator((responsiveStyles, style2) => {
            if (smallestBreakpoint === key2) {
              Object.assign(responsiveStyles, style2);
            } else {
              responsiveStyles[breakpoints.up(key2)] = style2;
            }
          }, breakpointValue);
        }
      }
    });
  } else if (typeof responsive === "number" || typeof responsive === "string") {
    iterator((responsiveStyles, style2) => {
      Object.assign(responsiveStyles, style2);
    }, responsive);
  }
};
function getSelfSpacingVar(axis) {
  return `--Grid-${axis}Spacing`;
}
function getParentSpacingVar(axis) {
  return `--Grid-parent-${axis}Spacing`;
}
const selfColumnsVar = "--Grid-columns";
const parentColumnsVar = "--Grid-parent-columns";
const generateGridSizeStyles = ({
  theme: theme2,
  ownerState
}) => {
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.size, (appendStyle, value) => {
    let style2 = {};
    if (value === "grow") {
      style2 = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      };
    }
    if (value === "auto") {
      style2 = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      };
    }
    if (typeof value === "number") {
      style2 = {
        flexGrow: 0,
        flexBasis: "auto",
        width: `calc(100% * ${value} / var(${parentColumnsVar}) - (var(${parentColumnsVar}) - ${value}) * (var(${getParentSpacingVar("column")}) / var(${parentColumnsVar})))`
      };
    }
    appendStyle(styles2, style2);
  });
  return styles2;
};
const generateGridOffsetStyles = ({
  theme: theme2,
  ownerState
}) => {
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.offset, (appendStyle, value) => {
    let style2 = {};
    if (value === "auto") {
      style2 = {
        marginLeft: "auto"
      };
    }
    if (typeof value === "number") {
      style2 = {
        marginLeft: value === 0 ? "0px" : `calc(100% * ${value} / var(${parentColumnsVar}) + var(${getParentSpacingVar("column")}) * ${value} / var(${parentColumnsVar}))`
      };
    }
    appendStyle(styles2, style2);
  });
  return styles2;
};
const generateGridColumnsStyles = ({
  theme: theme2,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {
    [selfColumnsVar]: 12
  };
  traverseBreakpoints(theme2.breakpoints, ownerState.columns, (appendStyle, value) => {
    const columns = value ?? 12;
    appendStyle(styles2, {
      [selfColumnsVar]: columns,
      "> *": {
        [parentColumnsVar]: columns
      }
    });
  });
  return styles2;
};
const generateGridRowSpacingStyles = ({
  theme: theme2,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.rowSpacing, (appendStyle, value) => {
    const spacing = typeof value === "string" ? value : theme2.spacing?.(value);
    appendStyle(styles2, {
      [getSelfSpacingVar("row")]: spacing,
      "> *": {
        [getParentSpacingVar("row")]: spacing
      }
    });
  });
  return styles2;
};
const generateGridColumnSpacingStyles = ({
  theme: theme2,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.columnSpacing, (appendStyle, value) => {
    const spacing = typeof value === "string" ? value : theme2.spacing?.(value);
    appendStyle(styles2, {
      [getSelfSpacingVar("column")]: spacing,
      "> *": {
        [getParentSpacingVar("column")]: spacing
      }
    });
  });
  return styles2;
};
const generateGridDirectionStyles = ({
  theme: theme2,
  ownerState
}) => {
  if (!ownerState.container) {
    return {};
  }
  const styles2 = {};
  traverseBreakpoints(theme2.breakpoints, ownerState.direction, (appendStyle, value) => {
    appendStyle(styles2, {
      flexDirection: value
    });
  });
  return styles2;
};
const generateGridStyles = ({
  ownerState
}) => {
  return {
    minWidth: 0,
    boxSizing: "border-box",
    ...ownerState.container && {
      display: "flex",
      flexWrap: "wrap",
      ...ownerState.wrap && ownerState.wrap !== "wrap" && {
        flexWrap: ownerState.wrap
      },
      gap: `var(${getSelfSpacingVar("row")}) var(${getSelfSpacingVar("column")})`
    }
  };
};
const generateSizeClassNames = (size2) => {
  const classNames = [];
  Object.entries(size2).forEach(([key2, value]) => {
    if (value !== false && value !== void 0) {
      classNames.push(`grid-${key2}-${String(value)}`);
    }
  });
  return classNames;
};
const generateSpacingClassNames = (spacing, smallestBreakpoint = "xs") => {
  function isValidSpacing(val) {
    if (val === void 0) {
      return false;
    }
    return typeof val === "string" && !Number.isNaN(Number(val)) || typeof val === "number" && val > 0;
  }
  if (isValidSpacing(spacing)) {
    return [`spacing-${smallestBreakpoint}-${String(spacing)}`];
  }
  if (typeof spacing === "object" && !Array.isArray(spacing)) {
    const classNames = [];
    Object.entries(spacing).forEach(([key2, value]) => {
      if (isValidSpacing(value)) {
        classNames.push(`spacing-${key2}-${String(value)}`);
      }
    });
    return classNames;
  }
  return [];
};
const generateDirectionClasses = (direction) => {
  if (direction === void 0) {
    return [];
  }
  if (typeof direction === "object") {
    return Object.entries(direction).map(([key2, value]) => `direction-${key2}-${value}`);
  }
  return [`direction-xs-${String(direction)}`];
};
function deleteLegacyGridProps(props, breakpoints) {
  if (props.item !== void 0) {
    delete props.item;
  }
  if (props.zeroMinWidth !== void 0) {
    delete props.zeroMinWidth;
  }
  breakpoints.keys.forEach((breakpoint) => {
    if (props[breakpoint] !== void 0) {
      delete props[breakpoint];
    }
  });
}
const defaultTheme$2 = createTheme$1();
const defaultCreateStyledComponent = styled$1("div", {
  name: "MuiGrid",
  slot: "Root"
});
function useThemePropsDefault(props) {
  return useThemeProps({
    props,
    name: "MuiGrid",
    defaultTheme: defaultTheme$2
  });
}
function createGrid(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps: useThemeProps2 = useThemePropsDefault,
    useTheme: useTheme2 = useTheme$2,
    componentName = "MuiGrid"
  } = options;
  const useUtilityClasses2 = (ownerState, theme2) => {
    const {
      container,
      direction,
      spacing,
      wrap,
      size: size2
    } = ownerState;
    const slots = {
      root: ["root", container && "container", wrap !== "wrap" && `wrap-xs-${String(wrap)}`, ...generateDirectionClasses(direction), ...generateSizeClassNames(size2), ...container ? generateSpacingClassNames(spacing, theme2.breakpoints.keys[0]) : []]
    };
    return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
  };
  function parseResponsiveProp(propValue, breakpoints, shouldUseValue = () => true) {
    const parsedProp = {};
    if (propValue === null) {
      return parsedProp;
    }
    if (Array.isArray(propValue)) {
      propValue.forEach((value, index2) => {
        if (value !== null && shouldUseValue(value) && breakpoints.keys[index2]) {
          parsedProp[breakpoints.keys[index2]] = value;
        }
      });
    } else if (typeof propValue === "object") {
      Object.keys(propValue).forEach((key2) => {
        const value = propValue[key2];
        if (value !== null && value !== void 0 && shouldUseValue(value)) {
          parsedProp[key2] = value;
        }
      });
    } else {
      parsedProp[breakpoints.keys[0]] = propValue;
    }
    return parsedProp;
  }
  const GridRoot = createStyledComponent(generateGridColumnsStyles, generateGridColumnSpacingStyles, generateGridRowSpacingStyles, generateGridSizeStyles, generateGridDirectionStyles, generateGridStyles, generateGridOffsetStyles);
  const Grid2 = /* @__PURE__ */ reactExports.forwardRef(function Grid22(inProps, ref2) {
    const theme2 = useTheme2();
    const themeProps = useThemeProps2(inProps);
    const props = extendSxProp$1(themeProps);
    deleteLegacyGridProps(props, theme2.breakpoints);
    const {
      className,
      children,
      columns: columnsProp = 12,
      container = false,
      component = "div",
      direction = "row",
      wrap = "wrap",
      size: sizeProp = {},
      offset: offsetProp = {},
      spacing: spacingProp = 0,
      rowSpacing: rowSpacingProp = spacingProp,
      columnSpacing: columnSpacingProp = spacingProp,
      unstable_level: level = 0,
      ...other
    } = props;
    const size2 = parseResponsiveProp(sizeProp, theme2.breakpoints, (val) => val !== false);
    const offset2 = parseResponsiveProp(offsetProp, theme2.breakpoints);
    const columns = inProps.columns ?? (level ? void 0 : columnsProp);
    const spacing = inProps.spacing ?? (level ? void 0 : spacingProp);
    const rowSpacing = inProps.rowSpacing ?? inProps.spacing ?? (level ? void 0 : rowSpacingProp);
    const columnSpacing = inProps.columnSpacing ?? inProps.spacing ?? (level ? void 0 : columnSpacingProp);
    const ownerState = {
      ...props,
      level,
      columns,
      container,
      direction,
      wrap,
      spacing,
      rowSpacing,
      columnSpacing,
      size: size2,
      offset: offset2
    };
    const classes = useUtilityClasses2(ownerState, theme2);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridRoot, {
      ref: ref2,
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ...other,
      children: reactExports.Children.map(children, (child) => {
        if (/* @__PURE__ */ reactExports.isValidElement(child) && isMuiElement(child, ["Grid"]) && container && child.props.container) {
          return /* @__PURE__ */ reactExports.cloneElement(child, {
            unstable_level: child.props?.unstable_level ?? level + 1
          });
        }
        return child;
      })
    });
  });
  Grid2.muiName = "Grid";
  return Grid2;
}
function getLight() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common$2.white,
      default: common$2.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const light = getLight();
function getDark() {
  return {
    text: {
      primary: common$2.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: common$2.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const dark = getDark();
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function mixLightOrDark(colorSpace, intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = `color-mix(in ${colorSpace}, ${intent.main}, #fff ${(tonalOffsetLight * 100).toFixed(0)}%)`;
    } else if (direction === "dark") {
      intent.dark = `color-mix(in ${colorSpace}, ${intent.main}, #000 ${(tonalOffsetDark * 100).toFixed(0)}%)`;
    }
  }
}
function getDefaultPrimary(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: blue[200],
      light: blue[50],
      dark: blue[400]
    };
  }
  return {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}
function getDefaultSecondary(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: purple[200],
      light: purple[50],
      dark: purple[400]
    };
  }
  return {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}
function getDefaultError(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: red[500],
      light: red[300],
      dark: red[700]
    };
  }
  return {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}
function getDefaultInfo(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: lightBlue[400],
      light: lightBlue[300],
      dark: lightBlue[700]
    };
  }
  return {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}
function getDefaultSuccess(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: green[400],
      light: green[300],
      dark: green[700]
    };
  }
  return {
    main: green[800],
    light: green[500],
    dark: green[900]
  };
}
function getDefaultWarning(mode2 = "light") {
  if (mode2 === "dark") {
    return {
      main: orange[400],
      light: orange[300],
      dark: orange[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}
function contrastColor(background) {
  return `oklch(from ${background} var(--__l) 0 h / var(--__a))`;
}
function createPalette(palette) {
  const {
    mode: mode2 = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2,
    colorSpace,
    ...other
  } = palette;
  const primary = palette.primary || getDefaultPrimary(mode2);
  const secondary = palette.secondary || getDefaultSecondary(mode2);
  const error = palette.error || getDefaultError(mode2);
  const info = palette.info || getDefaultInfo(mode2);
  const success = palette.success || getDefaultSuccess(mode2);
  const warning2 = palette.warning || getDefaultWarning(mode2);
  function getContrastText(background) {
    if (colorSpace) {
      return contrastColor(background);
    }
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = {
      ...color2
    };
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
    }
    if (colorSpace) {
      mixLightOrDark(colorSpace, color2, "light", lightShade, tonalOffset);
      mixLightOrDark(colorSpace, color2, "dark", darkShade, tonalOffset);
    } else {
      addLightOrDark(color2, "light", lightShade, tonalOffset);
      addLightOrDark(color2, "dark", darkShade, tonalOffset);
    }
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  let modeHydrated;
  if (mode2 === "light") {
    modeHydrated = getLight();
  } else if (mode2 === "dark") {
    modeHydrated = getDark();
  }
  const paletteOutput = deepmerge({
    // A collection of common colors.
    common: {
      ...common$2
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: mode2,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning2,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset,
    // The light and dark mode object.
    ...modeHydrated
  }, other);
  return paletteOutput;
}
function prepareTypographyVars(typography) {
  const vars = {};
  const entries2 = Object.entries(typography);
  entries2.forEach((entry) => {
    const [key2, value] = entry;
    if (typeof value === "object") {
      vars[key2] = `${value.fontStyle ? `${value.fontStyle} ` : ""}${value.fontVariant ? `${value.fontVariant} ` : ""}${value.fontWeight ? `${value.fontWeight} ` : ""}${value.fontStretch ? `${value.fontStretch} ` : ""}${value.fontSize || ""}${value.lineHeight ? `/${value.lineHeight} ` : ""}${value.fontFamily || ""}`;
    }
  });
  return vars;
}
function createMixins(breakpoints, mixins) {
  return {
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    },
    ...mixins
  };
}
function round$2(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2,
    ...other
  } = typeof typography === "function" ? typography(palette) : typography;
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size2) => `${size2 / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size2, lineHeight, letterSpacing, casing) => ({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size2),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...fontFamily === defaultFontFamily ? {
      letterSpacing: `${round$2(letterSpacing / size2)}em`
    } : {},
    ...casing,
    ...allVariants
  });
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold,
    ...variants
  }, other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.min(Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10), 3e3);
}
function createTransitions(inputTransitions) {
  const mergedEasing = {
    ...easing,
    ...inputTransitions.easing
  };
  const mergedDuration = {
    ...duration,
    ...inputTransitions.duration
  };
  const create = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay: delay2 = 0,
      ...other
    } = options;
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay2 === "string" ? delay2 : formatMs(delay2)}`).join(",");
  };
  return {
    getAutoHeightDuration,
    create,
    ...inputTransitions,
    easing: mergedEasing,
    duration: mergedDuration
  };
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function isSerializable(val) {
  return isPlainObject$2(val) || typeof val === "undefined" || typeof val === "string" || typeof val === "boolean" || typeof val === "number" || Array.isArray(val);
}
function stringifyTheme(baseTheme = {}) {
  const serializableTheme = {
    ...baseTheme
  };
  function serializeTheme(object) {
    const array = Object.entries(object);
    for (let index2 = 0; index2 < array.length; index2++) {
      const [key2, value] = array[index2];
      if (!isSerializable(value) || key2.startsWith("unstable_")) {
        delete object[key2];
      } else if (isPlainObject$2(value)) {
        object[key2] = {
          ...value
        };
        serializeTheme(object[key2]);
      }
    }
  }
  serializeTheme(serializableTheme);
  return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function coefficientToPercentage(coefficient) {
  if (typeof coefficient === "number") {
    return `${(coefficient * 100).toFixed(0)}%`;
  }
  return `calc((${coefficient}) * 100%)`;
}
const parseAddition = (str) => {
  if (!Number.isNaN(+str)) {
    return +str;
  }
  const numbers = str.match(/\d*\.?\d+/g);
  if (!numbers) {
    return 0;
  }
  let sum = 0;
  for (let i4 = 0; i4 < numbers.length; i4 += 1) {
    sum += +numbers[i4];
  }
  return sum;
};
function attachColorManipulators(theme2) {
  Object.assign(theme2, {
    alpha(color2, coefficient) {
      const obj = this || theme2;
      if (obj.colorSpace) {
        return `oklch(from ${color2} l c h / ${typeof coefficient === "string" ? `calc(${coefficient})` : coefficient})`;
      }
      if (obj.vars) {
        return `rgba(${color2.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof coefficient === "string" ? `calc(${coefficient})` : coefficient})`;
      }
      return alpha(color2, parseAddition(coefficient));
    },
    lighten(color2, coefficient) {
      const obj = this || theme2;
      if (obj.colorSpace) {
        return `color-mix(in ${obj.colorSpace}, ${color2}, #fff ${coefficientToPercentage(coefficient)})`;
      }
      return lighten(color2, coefficient);
    },
    darken(color2, coefficient) {
      const obj = this || theme2;
      if (obj.colorSpace) {
        return `color-mix(in ${obj.colorSpace}, ${color2}, #000 ${coefficientToPercentage(coefficient)})`;
      }
      return darken(color2, coefficient);
    }
  });
}
function createThemeNoVars(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput,
    mixins: mixinsInput = {},
    spacing: spacingInput,
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {},
    shape: shapeInput,
    colorSpace,
    ...other
  } = options;
  if (options.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  options.generateThemeVars === void 0) {
    throw new Error(formatMuiErrorMessage(20));
  }
  const palette = createPalette({
    ...paletteInput,
    colorSpace
  });
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: {
      ...zIndex
    }
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = {
    ...defaultSxConfig,
    ...other?.unstable_sxConfig
  };
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  muiTheme.toRuntimeSource = stringifyTheme;
  attachColorManipulators(muiTheme);
  return muiTheme;
}
function getOverlayAlpha(elevation) {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return Math.round(alphaValue * 10) / 1e3;
}
const defaultDarkOverlays = [...Array(25)].map((_2, index2) => {
  if (index2 === 0) {
    return "none";
  }
  const overlay = getOverlayAlpha(index2);
  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function getOpacity(mode2) {
  return {
    inputPlaceholder: mode2 === "dark" ? 0.5 : 0.42,
    inputUnderline: mode2 === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: mode2 === "dark" ? 0.2 : 0.12,
    switchTrack: mode2 === "dark" ? 0.3 : 0.38
  };
}
function getOverlays(mode2) {
  return mode2 === "dark" ? defaultDarkOverlays : [];
}
function createColorScheme(options) {
  const {
    palette: paletteInput = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity,
    overlays,
    colorSpace,
    ...rest
  } = options;
  const palette = createPalette({
    ...paletteInput,
    colorSpace
  });
  return {
    palette,
    opacity: {
      ...getOpacity(palette.mode),
      ...opacity
    },
    overlays: overlays || getOverlays(palette.mode),
    ...rest
  };
}
function shouldSkipGeneratingVar(keys) {
  return !!keys[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys[0].match(/sxConfig$/) || // ends with sxConfig
  keys[0] === "palette" && !!keys[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
}
const excludeVariablesFromRoot = (cssVarPrefix) => [...[...Array(25)].map((_2, index2) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index2}`), `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`, `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`];
const defaultGetSelector = (theme2) => (colorScheme, css2) => {
  const root = theme2.rootSelector || ":root";
  const selector = theme2.colorSchemeSelector;
  let rule = selector;
  if (selector === "class") {
    rule = ".%s";
  }
  if (selector === "data") {
    rule = "[data-%s]";
  }
  if (selector?.startsWith("data-") && !selector.includes("%s")) {
    rule = `[${selector}="%s"]`;
  }
  if (theme2.defaultColorScheme === colorScheme) {
    if (colorScheme === "dark") {
      const excludedVariables = {};
      excludeVariablesFromRoot(theme2.cssVarPrefix).forEach((cssVar) => {
        excludedVariables[cssVar] = css2[cssVar];
        delete css2[cssVar];
      });
      if (rule === "media") {
        return {
          [root]: css2,
          [`@media (prefers-color-scheme: dark)`]: {
            [root]: excludedVariables
          }
        };
      }
      if (rule) {
        return {
          [rule.replace("%s", colorScheme)]: excludedVariables,
          [`${root}, ${rule.replace("%s", colorScheme)}`]: css2
        };
      }
      return {
        [root]: {
          ...css2,
          ...excludedVariables
        }
      };
    }
    if (rule && rule !== "media") {
      return `${root}, ${rule.replace("%s", String(colorScheme))}`;
    }
  } else if (colorScheme) {
    if (rule === "media") {
      return {
        [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
          [root]: css2
        }
      };
    }
    if (rule) {
      return rule.replace("%s", String(colorScheme));
    }
  }
  return root;
};
function assignNode(obj, keys) {
  keys.forEach((k2) => {
    if (!obj[k2]) {
      obj[k2] = {};
    }
  });
}
function setColor(obj, key2, defaultValue) {
  if (!obj[key2] && defaultValue) {
    obj[key2] = defaultValue;
  }
}
function toRgb(color2) {
  if (typeof color2 !== "string" || !color2.startsWith("hsl")) {
    return color2;
  }
  return hslToRgb(color2);
}
function setColorChannel(obj, key2) {
  if (!(`${key2}Channel` in obj)) {
    obj[`${key2}Channel`] = private_safeColorChannel(toRgb(obj[key2]));
  }
}
function getSpacingVal(spacingInput) {
  if (typeof spacingInput === "number") {
    return `${spacingInput}px`;
  }
  if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) {
    return spacingInput;
  }
  return "8px";
}
const silent = (fn2) => {
  try {
    return fn2();
  } catch (error) {
  }
  return void 0;
};
const createGetCssVar = (cssVarPrefix = "mui") => createGetCssVar$1(cssVarPrefix);
function attachColorScheme$1(colorSpace, colorSchemes, scheme, restTheme, colorScheme) {
  if (!scheme) {
    return void 0;
  }
  scheme = scheme === true ? {} : scheme;
  const mode2 = colorScheme === "dark" ? "dark" : "light";
  if (!restTheme) {
    colorSchemes[colorScheme] = createColorScheme({
      ...scheme,
      palette: {
        mode: mode2,
        ...scheme?.palette
      },
      colorSpace
    });
    return void 0;
  }
  const {
    palette,
    ...muiTheme
  } = createThemeNoVars({
    ...restTheme,
    palette: {
      mode: mode2,
      ...scheme?.palette
    },
    colorSpace
  });
  colorSchemes[colorScheme] = {
    ...scheme,
    palette,
    opacity: {
      ...getOpacity(mode2),
      ...scheme?.opacity
    },
    overlays: scheme?.overlays || getOverlays(mode2)
  };
  return muiTheme;
}
function createThemeWithVars(options = {}, ...args) {
  const {
    colorSchemes: colorSchemesInput = {
      light: true
    },
    defaultColorScheme: defaultColorSchemeInput,
    disableCssColorScheme = false,
    cssVarPrefix = "mui",
    nativeColor = false,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar,
    colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0,
    rootSelector = ":root",
    ...input
  } = options;
  const firstColorScheme = Object.keys(colorSchemesInput)[0];
  const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
  const getCssVar = createGetCssVar(cssVarPrefix);
  const {
    [defaultColorScheme]: defaultSchemeInput,
    light: builtInLight,
    dark: builtInDark,
    ...customColorSchemes
  } = colorSchemesInput;
  const colorSchemes = {
    ...customColorSchemes
  };
  let defaultScheme = defaultSchemeInput;
  if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) {
    defaultScheme = true;
  }
  if (!defaultScheme) {
    throw new Error(formatMuiErrorMessage(21, defaultColorScheme));
  }
  let colorSpace;
  if (nativeColor) {
    colorSpace = "oklch";
  }
  const muiTheme = attachColorScheme$1(colorSpace, colorSchemes, defaultScheme, input, defaultColorScheme);
  if (builtInLight && !colorSchemes.light) {
    attachColorScheme$1(colorSpace, colorSchemes, builtInLight, void 0, "light");
  }
  if (builtInDark && !colorSchemes.dark) {
    attachColorScheme$1(colorSpace, colorSchemes, builtInDark, void 0, "dark");
  }
  let theme2 = {
    defaultColorScheme,
    ...muiTheme,
    cssVarPrefix,
    colorSchemeSelector: selector,
    rootSelector,
    getCssVar,
    colorSchemes,
    font: {
      ...prepareTypographyVars(muiTheme.typography),
      ...muiTheme.font
    },
    spacing: getSpacingVal(input.spacing)
  };
  Object.keys(theme2.colorSchemes).forEach((key2) => {
    const palette = theme2.colorSchemes[key2].palette;
    const setCssVarColor = (cssVar) => {
      const tokens = cssVar.split("-");
      const color2 = tokens[1];
      const colorToken = tokens[2];
      return getCssVar(cssVar, palette[color2][colorToken]);
    };
    if (palette.mode === "light") {
      setColor(palette.common, "background", "#fff");
      setColor(palette.common, "onBackground", "#000");
    }
    if (palette.mode === "dark") {
      setColor(palette.common, "background", "#000");
      setColor(palette.common, "onBackground", "#fff");
    }
    function colorMix(method, color2, coefficient) {
      if (colorSpace) {
        let mixer;
        if (method === private_safeAlpha) {
          mixer = `transparent ${((1 - coefficient) * 100).toFixed(0)}%`;
        }
        if (method === private_safeDarken) {
          mixer = `#000 ${(coefficient * 100).toFixed(0)}%`;
        }
        if (method === private_safeLighten) {
          mixer = `#fff ${(coefficient * 100).toFixed(0)}%`;
        }
        return `color-mix(in ${colorSpace}, ${color2}, ${mixer})`;
      }
      return method(color2, coefficient);
    }
    assignNode(palette, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]);
    if (palette.mode === "light") {
      setColor(palette.Alert, "errorColor", colorMix(private_safeDarken, palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", colorMix(private_safeDarken, palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", colorMix(private_safeDarken, palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", colorMix(private_safeDarken, palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.main)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.main)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.main)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.main)));
      setColor(palette.Alert, "errorStandardBg", colorMix(private_safeLighten, palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", colorMix(private_safeLighten, palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", colorMix(private_safeLighten, palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", colorMix(private_safeLighten, palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
      setColor(palette.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
      setColor(palette.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
      setColor(palette.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", colorMix(private_safeLighten, palette.primary.main, 0.62));
      setColor(palette.LinearProgress, "secondaryBg", colorMix(private_safeLighten, palette.secondary.main, 0.62));
      setColor(palette.LinearProgress, "errorBg", colorMix(private_safeLighten, palette.error.main, 0.62));
      setColor(palette.LinearProgress, "infoBg", colorMix(private_safeLighten, palette.info.main, 0.62));
      setColor(palette.LinearProgress, "successBg", colorMix(private_safeLighten, palette.success.main, 0.62));
      setColor(palette.LinearProgress, "warningBg", colorMix(private_safeLighten, palette.warning.main, 0.62));
      setColor(palette.Skeleton, "bg", colorSpace ? colorMix(private_safeAlpha, palette.text.primary, 0.11) : `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
      setColor(palette.Slider, "primaryTrack", colorMix(private_safeLighten, palette.primary.main, 0.62));
      setColor(palette.Slider, "secondaryTrack", colorMix(private_safeLighten, palette.secondary.main, 0.62));
      setColor(palette.Slider, "errorTrack", colorMix(private_safeLighten, palette.error.main, 0.62));
      setColor(palette.Slider, "infoTrack", colorMix(private_safeLighten, palette.info.main, 0.62));
      setColor(palette.Slider, "successTrack", colorMix(private_safeLighten, palette.success.main, 0.62));
      setColor(palette.Slider, "warningTrack", colorMix(private_safeLighten, palette.warning.main, 0.62));
      const snackbarContentBackground = colorSpace ? colorMix(private_safeDarken, palette.background.default, 0.6825) : private_safeEmphasize(palette.background.default, 0.8);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => colorSpace ? dark.text.primary : palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-400"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-common-white"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
      setColor(palette.Switch, "primaryDisabledColor", colorMix(private_safeLighten, palette.primary.main, 0.62));
      setColor(palette.Switch, "secondaryDisabledColor", colorMix(private_safeLighten, palette.secondary.main, 0.62));
      setColor(palette.Switch, "errorDisabledColor", colorMix(private_safeLighten, palette.error.main, 0.62));
      setColor(palette.Switch, "infoDisabledColor", colorMix(private_safeLighten, palette.info.main, 0.62));
      setColor(palette.Switch, "successDisabledColor", colorMix(private_safeLighten, palette.success.main, 0.62));
      setColor(palette.Switch, "warningDisabledColor", colorMix(private_safeLighten, palette.warning.main, 0.62));
      setColor(palette.TableCell, "border", colorMix(private_safeLighten, colorMix(private_safeAlpha, palette.divider, 1), 0.88));
      setColor(palette.Tooltip, "bg", colorMix(private_safeAlpha, palette.grey[700], 0.92));
    }
    if (palette.mode === "dark") {
      setColor(palette.Alert, "errorColor", colorMix(private_safeLighten, palette.error.light, 0.6));
      setColor(palette.Alert, "infoColor", colorMix(private_safeLighten, palette.info.light, 0.6));
      setColor(palette.Alert, "successColor", colorMix(private_safeLighten, palette.success.light, 0.6));
      setColor(palette.Alert, "warningColor", colorMix(private_safeLighten, palette.warning.light, 0.6));
      setColor(palette.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
      setColor(palette.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
      setColor(palette.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
      setColor(palette.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
      setColor(palette.Alert, "errorFilledColor", silent(() => palette.getContrastText(palette.error.dark)));
      setColor(palette.Alert, "infoFilledColor", silent(() => palette.getContrastText(palette.info.dark)));
      setColor(palette.Alert, "successFilledColor", silent(() => palette.getContrastText(palette.success.dark)));
      setColor(palette.Alert, "warningFilledColor", silent(() => palette.getContrastText(palette.warning.dark)));
      setColor(palette.Alert, "errorStandardBg", colorMix(private_safeDarken, palette.error.light, 0.9));
      setColor(palette.Alert, "infoStandardBg", colorMix(private_safeDarken, palette.info.light, 0.9));
      setColor(palette.Alert, "successStandardBg", colorMix(private_safeDarken, palette.success.light, 0.9));
      setColor(palette.Alert, "warningStandardBg", colorMix(private_safeDarken, palette.warning.light, 0.9));
      setColor(palette.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
      setColor(palette.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
      setColor(palette.Alert, "successIconColor", setCssVarColor("palette-success-main"));
      setColor(palette.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
      setColor(palette.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
      setColor(palette.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
      setColor(palette.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
      setColor(palette.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
      setColor(palette.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
      setColor(palette.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
      setColor(palette.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
      setColor(palette.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
      setColor(palette.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
      setColor(palette.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
      setColor(palette.LinearProgress, "primaryBg", colorMix(private_safeDarken, palette.primary.main, 0.5));
      setColor(palette.LinearProgress, "secondaryBg", colorMix(private_safeDarken, palette.secondary.main, 0.5));
      setColor(palette.LinearProgress, "errorBg", colorMix(private_safeDarken, palette.error.main, 0.5));
      setColor(palette.LinearProgress, "infoBg", colorMix(private_safeDarken, palette.info.main, 0.5));
      setColor(palette.LinearProgress, "successBg", colorMix(private_safeDarken, palette.success.main, 0.5));
      setColor(palette.LinearProgress, "warningBg", colorMix(private_safeDarken, palette.warning.main, 0.5));
      setColor(palette.Skeleton, "bg", colorSpace ? colorMix(private_safeAlpha, palette.text.primary, 0.13) : `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
      setColor(palette.Slider, "primaryTrack", colorMix(private_safeDarken, palette.primary.main, 0.5));
      setColor(palette.Slider, "secondaryTrack", colorMix(private_safeDarken, palette.secondary.main, 0.5));
      setColor(palette.Slider, "errorTrack", colorMix(private_safeDarken, palette.error.main, 0.5));
      setColor(palette.Slider, "infoTrack", colorMix(private_safeDarken, palette.info.main, 0.5));
      setColor(palette.Slider, "successTrack", colorMix(private_safeDarken, palette.success.main, 0.5));
      setColor(palette.Slider, "warningTrack", colorMix(private_safeDarken, palette.warning.main, 0.5));
      const snackbarContentBackground = colorSpace ? colorMix(private_safeLighten, palette.background.default, 0.985) : private_safeEmphasize(palette.background.default, 0.98);
      setColor(palette.SnackbarContent, "bg", snackbarContentBackground);
      setColor(palette.SnackbarContent, "color", silent(() => colorSpace ? light.text.primary : palette.getContrastText(snackbarContentBackground)));
      setColor(palette.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette.background.paper, 0.15));
      setColor(palette.StepConnector, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.StepContent, "border", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
      setColor(palette.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
      setColor(palette.Switch, "primaryDisabledColor", colorMix(private_safeDarken, palette.primary.main, 0.55));
      setColor(palette.Switch, "secondaryDisabledColor", colorMix(private_safeDarken, palette.secondary.main, 0.55));
      setColor(palette.Switch, "errorDisabledColor", colorMix(private_safeDarken, palette.error.main, 0.55));
      setColor(palette.Switch, "infoDisabledColor", colorMix(private_safeDarken, palette.info.main, 0.55));
      setColor(palette.Switch, "successDisabledColor", colorMix(private_safeDarken, palette.success.main, 0.55));
      setColor(palette.Switch, "warningDisabledColor", colorMix(private_safeDarken, palette.warning.main, 0.55));
      setColor(palette.TableCell, "border", colorMix(private_safeDarken, colorMix(private_safeAlpha, palette.divider, 1), 0.68));
      setColor(palette.Tooltip, "bg", colorMix(private_safeAlpha, palette.grey[700], 0.92));
    }
    setColorChannel(palette.background, "default");
    setColorChannel(palette.background, "paper");
    setColorChannel(palette.common, "background");
    setColorChannel(palette.common, "onBackground");
    setColorChannel(palette, "divider");
    Object.keys(palette).forEach((color2) => {
      const colors = palette[color2];
      if (color2 !== "tonalOffset" && colors && typeof colors === "object") {
        if (colors.main) {
          setColor(palette[color2], "mainChannel", private_safeColorChannel(toRgb(colors.main)));
        }
        if (colors.light) {
          setColor(palette[color2], "lightChannel", private_safeColorChannel(toRgb(colors.light)));
        }
        if (colors.dark) {
          setColor(palette[color2], "darkChannel", private_safeColorChannel(toRgb(colors.dark)));
        }
        if (colors.contrastText) {
          setColor(palette[color2], "contrastTextChannel", private_safeColorChannel(toRgb(colors.contrastText)));
        }
        if (color2 === "text") {
          setColorChannel(palette[color2], "primary");
          setColorChannel(palette[color2], "secondary");
        }
        if (color2 === "action") {
          if (colors.active) {
            setColorChannel(palette[color2], "active");
          }
          if (colors.selected) {
            setColorChannel(palette[color2], "selected");
          }
        }
      }
    });
  });
  theme2 = args.reduce((acc, argument) => deepmerge(acc, argument), theme2);
  const parserConfig = {
    prefix: cssVarPrefix,
    disableCssColorScheme,
    shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
    getSelector: defaultGetSelector(theme2),
    enableContrastVars: nativeColor
  };
  const {
    vars,
    generateThemeVars,
    generateStyleSheets
  } = prepareCssVars(theme2, parserConfig);
  theme2.vars = vars;
  Object.entries(theme2.colorSchemes[theme2.defaultColorScheme]).forEach(([key2, value]) => {
    theme2[key2] = value;
  });
  theme2.generateThemeVars = generateThemeVars;
  theme2.generateStyleSheets = generateStyleSheets;
  theme2.generateSpacing = function generateSpacing() {
    return createSpacing(input.spacing, createUnarySpacing(this));
  };
  theme2.getColorSchemeSelector = createGetColorSchemeSelector(selector);
  theme2.spacing = theme2.generateSpacing();
  theme2.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
  theme2.unstable_sxConfig = {
    ...defaultSxConfig,
    ...input?.unstable_sxConfig
  };
  theme2.unstable_sx = function sx(props) {
    return styleFunctionSx({
      sx: props,
      theme: this
    });
  };
  theme2.toRuntimeSource = stringifyTheme;
  return theme2;
}
function attachColorScheme(theme2, scheme, colorScheme) {
  if (!theme2.colorSchemes) {
    return void 0;
  }
  if (colorScheme) {
    theme2.colorSchemes[scheme] = {
      ...colorScheme !== true && colorScheme,
      palette: createPalette({
        ...colorScheme === true ? {} : colorScheme.palette,
        mode: scheme
      })
      // cast type to skip module augmentation test
    };
  }
}
function createTheme(options = {}, ...args) {
  const {
    palette,
    cssVariables = false,
    colorSchemes: initialColorSchemes = !palette ? {
      light: true
    } : void 0,
    defaultColorScheme: initialDefaultColorScheme = palette?.mode,
    ...rest
  } = options;
  const defaultColorSchemeInput = initialDefaultColorScheme || "light";
  const defaultScheme = initialColorSchemes?.[defaultColorSchemeInput];
  const colorSchemesInput = {
    ...initialColorSchemes,
    ...palette ? {
      [defaultColorSchemeInput]: {
        ...typeof defaultScheme !== "boolean" && defaultScheme,
        palette
      }
    } : void 0
  };
  if (cssVariables === false) {
    if (!("colorSchemes" in options)) {
      return createThemeNoVars(options, ...args);
    }
    let paletteOptions = palette;
    if (!("palette" in options)) {
      if (colorSchemesInput[defaultColorSchemeInput]) {
        if (colorSchemesInput[defaultColorSchemeInput] !== true) {
          paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
        } else if (defaultColorSchemeInput === "dark") {
          paletteOptions = {
            mode: "dark"
          };
        }
      }
    }
    const theme2 = createThemeNoVars({
      ...options,
      palette: paletteOptions
    }, ...args);
    theme2.defaultColorScheme = defaultColorSchemeInput;
    theme2.colorSchemes = colorSchemesInput;
    if (theme2.palette.mode === "light") {
      theme2.colorSchemes.light = {
        ...colorSchemesInput.light !== true && colorSchemesInput.light,
        palette: theme2.palette
      };
      attachColorScheme(theme2, "dark", colorSchemesInput.dark);
    }
    if (theme2.palette.mode === "dark") {
      theme2.colorSchemes.dark = {
        ...colorSchemesInput.dark !== true && colorSchemesInput.dark,
        palette: theme2.palette
      };
      attachColorScheme(theme2, "light", colorSchemesInput.light);
    }
    return theme2;
  }
  if (!palette && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") {
    colorSchemesInput.light = true;
  }
  return createThemeWithVars({
    ...rest,
    colorSchemes: colorSchemesInput,
    defaultColorScheme: defaultColorSchemeInput,
    ...typeof cssVariables !== "boolean" && cssVariables
  }, ...args);
}
const defaultTheme$1 = createTheme();
function useTheme() {
  const theme2 = useTheme$2(defaultTheme$1);
  return theme2[THEME_ID] || theme2;
}
function slotShouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const rootShouldForwardProp = (prop) => slotShouldForwardProp(prop) && prop !== "classes";
const styled = createStyled2({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$1,
  rootShouldForwardProp
});
function ThemeProviderNoVars({
  theme: themeInput,
  ...props
}) {
  const scopedTheme = THEME_ID in themeInput ? themeInput[THEME_ID] : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$1, {
    ...props,
    themeId: scopedTheme ? THEME_ID : void 0,
    theme: scopedTheme || themeInput
  });
}
const defaultConfig$1 = {
  colorSchemeStorageKey: "mui-color-scheme",
  defaultLightColorScheme: "light",
  defaultDarkColorScheme: "dark",
  modeStorageKey: "mui-mode"
};
const {
  CssVarsProvider: InternalCssVarsProvider
} = createCssVarsProvider({
  themeId: THEME_ID,
  // @ts-ignore ignore module augmentation tests
  theme: () => createTheme({
    cssVariables: true
  }),
  colorSchemeStorageKey: defaultConfig$1.colorSchemeStorageKey,
  modeStorageKey: defaultConfig$1.modeStorageKey,
  defaultColorScheme: {
    light: defaultConfig$1.defaultLightColorScheme,
    dark: defaultConfig$1.defaultDarkColorScheme
  },
  resolveTheme: (theme2) => {
    const newTheme = {
      ...theme2,
      typography: createTypography(theme2.palette, theme2.typography)
    };
    newTheme.unstable_sx = function sx(props) {
      return styleFunctionSx({
        sx: props,
        theme: this
      });
    };
    return newTheme;
  }
});
const CssVarsProvider = InternalCssVarsProvider;
function ThemeProvider({
  theme: theme2,
  ...props
}) {
  const noVarsTheme = reactExports.useMemo(() => {
    if (typeof theme2 === "function") {
      return theme2;
    }
    const muiTheme = THEME_ID in theme2 ? theme2[THEME_ID] : theme2;
    if (!("colorSchemes" in muiTheme)) {
      if (!("vars" in muiTheme)) {
        return {
          ...theme2,
          vars: null
        };
      }
      return theme2;
    }
    return null;
  }, [theme2]);
  if (noVarsTheme) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProviderNoVars, {
      theme: noVarsTheme,
      ...props
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CssVarsProvider, {
    theme: theme2,
    ...props
  });
}
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function GlobalStyles$1(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
    ...props,
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID
  });
}
function globalCss(styles2) {
  return function GlobalStylesWrapper(props) {
    return (
      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
      /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, {
        styles: typeof styles2 === "function" ? (theme2) => styles2({
          theme: theme2,
          ...props
        }) : styles2
      })
    );
  };
}
function internal_createExtendSxProp() {
  return extendSxProp$1;
}
const memoTheme = unstable_memoTheme;
function useDefaultProps(params) {
  return useDefaultProps$1(params);
}
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const useUtilityClasses$M = (ownerState) => {
  const {
    color: color2,
    fontSize,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  userSelect: "none",
  width: "1em",
  height: "1em",
  display: "inline-block",
  flexShrink: 0,
  transition: theme2.transitions?.create?.("fill", {
    duration: (theme2.vars ?? theme2).transitions?.duration?.shorter
  }),
  variants: [
    {
      props: (props) => !props.hasSvgAsChild,
      style: {
        // the <svg> will define the property that has `currentColor`
        // for example heroicons uses fill="none" and stroke="currentColor"
        fill: "currentColor"
      }
    },
    {
      props: {
        fontSize: "inherit"
      },
      style: {
        fontSize: "inherit"
      }
    },
    {
      props: {
        fontSize: "small"
      },
      style: {
        fontSize: theme2.typography?.pxToRem?.(20) || "1.25rem"
      }
    },
    {
      props: {
        fontSize: "medium"
      },
      style: {
        fontSize: theme2.typography?.pxToRem?.(24) || "1.5rem"
      }
    },
    {
      props: {
        fontSize: "large"
      },
      style: {
        fontSize: theme2.typography?.pxToRem?.(35) || "2.1875rem"
      }
    },
    // TODO v5 deprecate color prop, v6 remove for sx
    ...Object.entries((theme2.vars ?? theme2).palette).filter(([, value]) => value && value.main).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        color: (theme2.vars ?? theme2).palette?.[color2]?.main
      }
    })),
    {
      props: {
        color: "action"
      },
      style: {
        color: (theme2.vars ?? theme2).palette?.action?.active
      }
    },
    {
      props: {
        color: "disabled"
      },
      style: {
        color: (theme2.vars ?? theme2).palette?.action?.disabled
      }
    },
    {
      props: {
        color: "inherit"
      },
      style: {
        color: void 0
      }
    }
  ]
})));
const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24",
    ...other
  } = props;
  const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
  const ownerState = {
    ...props,
    color: color2,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  };
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses$M(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, {
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref: ref2,
    ...more,
    ...other,
    ...hasSvgAsChild && children.props,
    ownerState,
    children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  });
});
SvgIcon.muiName = "SvgIcon";
function createSvgIcon(path, displayName) {
  function Component(props, ref2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, {
      "data-testid": void 0,
      ref: ref2,
      ...props,
      children: path
    });
  }
  Component.muiName = SvgIcon.muiName;
  return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
}
function debounce$1(func, wait2 = 166) {
  let timeout;
  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait2);
  }
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2) {
    ref2.current = value;
  }
}
function useControlled(props) {
  const {
    controlled,
    default: defaultProp,
    name,
    state: state2 = "value"
  } = props;
  const {
    current: isControlled
  } = reactExports.useRef(controlled !== void 0);
  const [valueState, setValue] = reactExports.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
function useEventCallback(fn2) {
  const ref2 = reactExports.useRef(fn2);
  useEnhancedEffect(() => {
    ref2.current = fn2;
  });
  return reactExports.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref2.current)(...args)
  )).current;
}
function useForkRef(...refs) {
  const cleanupRef = reactExports.useRef(void 0);
  const refEffect = reactExports.useCallback((instance) => {
    const cleanups = refs.map((ref2) => {
      if (ref2 == null) {
        return null;
      }
      if (typeof ref2 === "function") {
        const refCallback = ref2;
        const refCleanup = refCallback(instance);
        return typeof refCleanup === "function" ? refCleanup : () => {
          refCallback(null);
        };
      }
      ref2.current = instance;
      return () => {
        ref2.current = null;
      };
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup?.());
    };
  }, refs);
  return reactExports.useMemo(() => {
    if (refs.every((ref2) => ref2 == null)) {
      return null;
    }
    return (value) => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value != null) {
        cleanupRef.current = refEffect(value);
      }
    };
  }, refs);
}
function isEventHandler(key2, value) {
  const thirdCharCode = key2.charCodeAt(2);
  return key2[0] === "o" && key2[1] === "n" && thirdCharCode >= 65 && thirdCharCode <= 90 && typeof value === "function";
}
function mergeSlotProps$1(externalSlotProps, defaultSlotProps) {
  if (!externalSlotProps) {
    return defaultSlotProps;
  }
  function extractHandlers(externalSlotPropsValue, defaultSlotPropsValue) {
    const handlers2 = {};
    Object.keys(defaultSlotPropsValue).forEach((key2) => {
      if (isEventHandler(key2, defaultSlotPropsValue[key2]) && typeof externalSlotPropsValue[key2] === "function") {
        handlers2[key2] = (...args) => {
          externalSlotPropsValue[key2](...args);
          defaultSlotPropsValue[key2](...args);
        };
      }
    });
    return handlers2;
  }
  if (typeof externalSlotProps === "function" || typeof defaultSlotProps === "function") {
    return (ownerState) => {
      const defaultSlotPropsValue = typeof defaultSlotProps === "function" ? defaultSlotProps(ownerState) : defaultSlotProps;
      const externalSlotPropsValue = typeof externalSlotProps === "function" ? externalSlotProps({
        ...ownerState,
        ...defaultSlotPropsValue
      }) : externalSlotProps;
      const className2 = clsx(ownerState?.className, defaultSlotPropsValue?.className, externalSlotPropsValue?.className);
      const handlers2 = extractHandlers(externalSlotPropsValue, defaultSlotPropsValue);
      return {
        ...defaultSlotPropsValue,
        ...externalSlotPropsValue,
        ...handlers2,
        ...!!className2 && {
          className: className2
        },
        ...defaultSlotPropsValue?.style && externalSlotPropsValue?.style && {
          style: {
            ...defaultSlotPropsValue.style,
            ...externalSlotPropsValue.style
          }
        },
        ...defaultSlotPropsValue?.sx && externalSlotPropsValue?.sx && {
          sx: [...Array.isArray(defaultSlotPropsValue.sx) ? defaultSlotPropsValue.sx : [defaultSlotPropsValue.sx], ...Array.isArray(externalSlotPropsValue.sx) ? externalSlotPropsValue.sx : [externalSlotPropsValue.sx]]
        }
      };
    };
  }
  const typedDefaultSlotProps = defaultSlotProps;
  const handlers = extractHandlers(externalSlotProps, typedDefaultSlotProps);
  const className = clsx(typedDefaultSlotProps?.className, externalSlotProps?.className);
  return {
    ...defaultSlotProps,
    ...externalSlotProps,
    ...handlers,
    ...!!className && {
      className
    },
    ...typedDefaultSlotProps?.style && externalSlotProps?.style && {
      style: {
        ...typedDefaultSlotProps.style,
        ...externalSlotProps.style
      }
    },
    ...typedDefaultSlotProps?.sx && externalSlotProps?.sx && {
      sx: [...Array.isArray(typedDefaultSlotProps.sx) ? typedDefaultSlotProps.sx : [typedDefaultSlotProps.sx], ...Array.isArray(externalSlotProps.sx) ? externalSlotProps.sx : [externalSlotProps.sx]]
    }
  };
}
function _objectWithoutPropertiesLoose(r2, e2) {
  if (null == r2) return {};
  var t2 = {};
  for (var n3 in r2) if ({}.hasOwnProperty.call(r2, n3)) {
    if (-1 !== e2.indexOf(n3)) continue;
    t2[n3] = r2[n3];
  }
  return t2;
}
function _setPrototypeOf(t2, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf(t2, e2);
}
function _inheritsLoose(t2, o2) {
  t2.prototype = Object.create(o2.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o2);
}
const config$1 = {
  disabled: false
};
const TransitionGroupContext = React.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2) forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config$1.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config$1.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
    );
  };
  return Transition2;
})(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$2() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$2,
  onEntering: noop$2,
  onEntered: noop$2,
  onExit: noop$2,
  onExiting: noop$2,
  onExited: noop$2
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
function _assertThisInitialized(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children) reactExports.Children.map(children, function(c2) {
    return c2;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key2) {
    return key2 in next2 ? next2[key2] : prev2[key2];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i4;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i4 = 0; i4 < nextKeysPending[nextKey].length; i4++) {
        var pendingNextKey = nextKeysPending[nextKey][i4];
        childMapping[nextKeysPending[nextKey][i4]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i4 = 0; i4 < pendingKeys.length; i4++) {
    childMapping[pendingKeys[i4]] = getValueForKey(pendingKeys[i4]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key2) {
    var child = children[key2];
    if (!reactExports.isValidElement(child)) return;
    var hasPrev = key2 in prevChildMapping;
    var hasNext = key2 in nextChildMapping;
    var prevChild = prevChildMapping[key2];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key2] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key2] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key2] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state2) {
        var children = _extends({}, state2.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React.createElement(Component, props, children));
  };
  return TransitionGroup2;
})(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const UNINITIALIZED = {};
function useLazyRef(init2, initArg) {
  const ref2 = reactExports.useRef(UNINITIALIZED);
  if (ref2.current === UNINITIALIZED) {
    ref2.current = init2(initArg);
  }
  return ref2;
}
const EMPTY = [];
function useOnMount(fn2) {
  reactExports.useEffect(fn2, EMPTY);
}
class Timeout {
  constructor() {
    __publicField(this, "currentId", null);
    __publicField(this, "clear", () => {
      if (this.currentId !== null) {
        clearTimeout(this.currentId);
        this.currentId = null;
      }
    });
    __publicField(this, "disposeEffect", () => {
      return this.clear;
    });
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay2, fn2) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = null;
      fn2();
    }, delay2);
  }
}
function useTimeout() {
  const timeout = useLazyRef(Timeout.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: style2.transitionDuration ?? (typeof timeout === "number" ? timeout : timeout[options.mode] || 0),
    easing: style2.transitionTimingFunction ?? (typeof easing2 === "object" ? easing2[options.mode] : easing2),
    delay: style2.transitionDelay
  };
}
function getPaperUtilityClass(slot) {
  return generateUtilityClass("MuiPaper", slot);
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const useUtilityClasses$L = (ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes);
};
const PaperRoot = styled("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  backgroundColor: (theme2.vars || theme2).palette.background.paper,
  color: (theme2.vars || theme2).palette.text.primary,
  transition: theme2.transitions.create("box-shadow"),
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.square,
    style: {
      borderRadius: theme2.shape.borderRadius
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      border: `1px solid ${(theme2.vars || theme2).palette.divider}`
    }
  }, {
    props: {
      variant: "elevation"
    },
    style: {
      boxShadow: "var(--Paper-shadow)",
      backgroundImage: "var(--Paper-overlay)"
    }
  }]
})));
const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPaper"
  });
  const theme2 = useTheme();
  const {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation",
    ...other
  } = props;
  const ownerState = {
    ...props,
    component,
    elevation,
    square,
    variant
  };
  const classes = useUtilityClasses$L(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, {
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref: ref2,
    ...other,
    style: {
      ...variant === "elevation" && {
        "--Paper-shadow": (theme2.vars || theme2).shadows[elevation],
        ...theme2.vars && {
          "--Paper-overlay": theme2.vars.overlays?.[elevation]
        },
        ...!theme2.vars && theme2.palette.mode === "dark" && {
          "--Paper-overlay": `linear-gradient(${alpha("#fff", getOverlayAlpha(elevation))}, ${alpha("#fff", getOverlayAlpha(elevation))})`
        }
      },
      ...other.style
    }
  });
});
function isHostComponent(element) {
  return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return {
    ...otherProps,
    ownerState: {
      ...otherProps.ownerState,
      ...ownerState
    }
  };
}
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps?.className, className, externalForwardedProps?.className, externalSlotProps?.className);
    const mergedStyle2 = {
      ...additionalProps?.style,
      ...externalForwardedProps?.style,
      ...externalSlotProps?.style
    };
    const props2 = {
      ...additionalProps,
      ...externalForwardedProps,
      ...externalSlotProps
    };
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers({
    ...externalForwardedProps,
    ...externalSlotProps
  });
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps?.className, additionalProps?.className, className, externalForwardedProps?.className, externalSlotProps?.className);
  const mergedStyle = {
    ...internalSlotProps?.style,
    ...additionalProps?.style,
    ...externalForwardedProps?.style,
    ...externalSlotProps?.style
  };
  const props = {
    ...internalSlotProps,
    ...additionalProps,
    ...otherPropsWithoutEventHandlers,
    ...componentsPropsWithoutEventHandlers
  };
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
function useSlot(name, parameters) {
  const {
    className,
    elementType: initialElementType,
    ownerState,
    externalForwardedProps,
    internalForwardedProps,
    shouldForwardComponentProp = false,
    ...useSlotPropsParams
  } = parameters;
  const {
    component: rootComponent,
    slots = {
      [name]: void 0
    },
    slotProps = {
      [name]: void 0
    },
    ...other
  } = externalForwardedProps;
  const elementType = slots[name] || initialElementType;
  const resolvedComponentsProps = resolveComponentProps(slotProps[name], ownerState);
  const {
    props: {
      component: slotComponent,
      ...mergedProps
    },
    internalRef
  } = mergeSlotProps({
    className,
    ...useSlotPropsParams,
    externalForwardedProps: name === "root" ? other : void 0,
    externalSlotProps: resolvedComponentsProps
  });
  const ref2 = useForkRef(internalRef, resolvedComponentsProps?.ref, parameters.ref);
  const LeafComponent = name === "root" ? slotComponent || rootComponent : slotComponent;
  const props = appendOwnerState(elementType, {
    ...name === "root" && !rootComponent && !slots[name] && internalForwardedProps,
    ...name !== "root" && !slots[name] && internalForwardedProps,
    ...mergedProps,
    ...LeafComponent && !shouldForwardComponentProp && {
      as: LeafComponent
    },
    ...LeafComponent && shouldForwardComponentProp && {
      component: LeafComponent
    },
    ref: ref2
  }, ownerState);
  return [elementType, props];
}
function isFocusVisible(element) {
  try {
    return element.matches(":focus-visible");
  } catch (error) {
  }
  return false;
}
class LazyRipple {
  constructor() {
    __publicField(this, "mountEffect", () => {
      if (this.shouldMount && !this.didMount) {
        if (this.ref.current !== null) {
          this.didMount = true;
          this.mounted.resolve();
        }
      }
    });
    this.ref = {
      current: null
    };
    this.mounted = null;
    this.didMount = false;
    this.shouldMount = false;
    this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new LazyRipple();
  }
  static use() {
    const ripple = useLazyRef(LazyRipple.create).current;
    const [shouldMount, setShouldMount] = reactExports.useState(false);
    ripple.shouldMount = shouldMount;
    ripple.setShouldMount = setShouldMount;
    reactExports.useEffect(ripple.mountEffect, [shouldMount]);
    return ripple;
  }
  mount() {
    if (!this.mounted) {
      this.mounted = createControlledPromise();
      this.shouldMount = true;
      this.setShouldMount(this.shouldMount);
    }
    return this.mounted;
  }
  /* Ripple API */
  start(...args) {
    this.mount().then(() => this.ref.current?.start(...args));
  }
  stop(...args) {
    this.mount().then(() => this.ref.current?.stop(...args));
  }
  pulsate(...args) {
    this.mount().then(() => this.ref.current?.pulsate(...args));
  }
}
function useLazyRipple() {
  return LazyRipple.use();
}
function createControlledPromise() {
  let resolve;
  let reject;
  const p2 = new Promise((resolveFn, rejectFn) => {
    resolve = resolveFn;
    reject = rejectFn;
  });
  p2.resolve = resolve;
  p2.reject = reject;
  return p2;
}
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = reactExports.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  reactExports.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
const exitKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
const pulsateKeyframe = keyframes`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`;
const TouchRippleRoot = styled("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${touchRippleClasses.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme: theme2
}) => theme2.transitions.easing.easeInOut};
  }

  &.${touchRippleClasses.ripplePulsate} {
    animation-duration: ${({
  theme: theme2
}) => theme2.transitions.duration.shorter}ms;
  }

  & .${touchRippleClasses.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${touchRippleClasses.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
  theme: theme2
}) => theme2.transitions.easing.easeInOut};
  }

  & .${touchRippleClasses.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: theme2
}) => theme2.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;
const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes = {},
    className,
    ...other
  } = props;
  const [ripples, setRipples] = reactExports.useState([]);
  const nextKey = reactExports.useRef(0);
  const rippleCallback = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = reactExports.useRef(false);
  const startTimer = useTimeout();
  const startTimerCommit = reactExports.useRef(null);
  const container = reactExports.useRef(null);
  const startCommit = reactExports.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb;
  }, [classes]);
  const start2 = reactExports.useCallback((event = {}, options = {}, cb = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if (event?.type === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if (event?.type === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event?.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb
          });
        };
        startTimer.start(DELAY_RIPPLE, () => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        });
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb
      });
    }
  }, [centerProp, startCommit, startTimer]);
  const pulsate = reactExports.useCallback(() => {
    start2({}, {
      pulsate: true
    });
  }, [start2]);
  const stop = reactExports.useCallback((event, cb) => {
    startTimer.clear();
    if (event?.type === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.start(0, () => {
        stop(event, cb);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb;
  }, [startTimer]);
  reactExports.useImperativeHandle(ref2, () => ({
    pulsate,
    start: start2,
    stop
  }), [pulsate, start2, stop]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, {
    className: clsx(touchRippleClasses.root, classes.root, className),
    ref: container,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup, {
      component: null,
      exit: true,
      children: ripples
    })
  });
});
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const useUtilityClasses$K = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled("button", {
  name: "MuiButtonBase",
  slot: "Root"
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    focusVisibleClassName,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type,
    ...other
  } = props;
  const buttonRef = reactExports.useRef(null);
  const ripple = useLazyRipple();
  const handleRippleRef = useForkRef(ripple.ref, touchRippleRef);
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  reactExports.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const enableTouchRipple = ripple.shouldMount && !disableRipple && !disabled;
  reactExports.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple) {
      ripple.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, ripple]);
  const handleMouseDown = useRippleHandler(ripple, "start", onMouseDown, disableTouchRipple);
  const handleContextMenu = useRippleHandler(ripple, "stop", onContextMenu, disableTouchRipple);
  const handleDragLeave = useRippleHandler(ripple, "stop", onDragLeave, disableTouchRipple);
  const handleMouseUp = useRippleHandler(ripple, "stop", onMouseUp, disableTouchRipple);
  const handleMouseLeave = useRippleHandler(ripple, "stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  }, disableTouchRipple);
  const handleTouchStart = useRippleHandler(ripple, "start", onTouchStart, disableTouchRipple);
  const handleTouchEnd = useRippleHandler(ripple, "stop", onTouchEnd, disableTouchRipple);
  const handleTouchMove = useRippleHandler(ripple, "stop", onTouchMove, disableTouchRipple);
  const handleBlur = useRippleHandler(ripple, "stop", (event) => {
    if (!isFocusVisible(event.target)) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    if (isFocusVisible(event.target)) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const handleKeyDown = useEventCallback((event) => {
    if (focusRipple && !event.repeat && focusVisible && event.key === " ") {
      ripple.stop(event, () => {
        ripple.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback((event) => {
    if (focusRipple && event.key === " " && focusVisible && !event.defaultPrevented) {
      ripple.stop(event, () => {
        ripple.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef(ref2, buttonRef);
  const ownerState = {
    ...props,
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  };
  const classes = useUtilityClasses$K(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, {
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type,
    ...buttonProps,
    ...other,
    children: [children, enableTouchRipple ? /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple, {
      ref: handleRippleRef,
      center: centerRipple,
      ...TouchRippleProps
    }) : null]
  });
});
function useRippleHandler(ripple, rippleAction, eventCallback, skipRippleAction = false) {
  return useEventCallback((event) => {
    if (eventCallback) {
      eventCallback(event);
    }
    if (!skipRippleAction) {
      ripple[rippleAction](event);
    }
    return true;
  });
}
function hasCorrectMainProperty(obj) {
  return typeof obj.main === "string";
}
function checkSimplePaletteColorValues(obj, additionalPropertiesToCheck = []) {
  if (!hasCorrectMainProperty(obj)) {
    return false;
  }
  for (const value of additionalPropertiesToCheck) {
    if (!obj.hasOwnProperty(value) || typeof obj[value] !== "string") {
      return false;
    }
  }
  return true;
}
function createSimplePaletteValueFilter(additionalPropertiesToCheck = []) {
  return ([, value]) => value && checkSimplePaletteColorValues(value, additionalPropertiesToCheck);
}
function getAlertUtilityClass(slot) {
  return generateUtilityClass("MuiAlert", slot);
}
const alertClasses = generateUtilityClasses("MuiAlert", ["root", "action", "icon", "message", "filled", "colorSuccess", "colorInfo", "colorWarning", "colorError", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
function getCircularProgressUtilityClass(slot) {
  return generateUtilityClass("MuiCircularProgress", slot);
}
generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const SIZE = 44;
const circularRotateKeyframe = keyframes`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`;
const circularDashKeyframe = keyframes`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`;
const rotateAnimation = typeof circularRotateKeyframe !== "string" ? css`
        animation: ${circularRotateKeyframe} 1.4s linear infinite;
      ` : null;
const dashAnimation = typeof circularDashKeyframe !== "string" ? css`
        animation: ${circularDashKeyframe} 1.4s ease-in-out infinite;
      ` : null;
const useUtilityClasses$J = (ownerState) => {
  const {
    classes,
    variant,
    color: color2,
    disableShrink
  } = ownerState;
  const slots = {
    root: ["root", variant, `color${capitalize(color2)}`],
    svg: ["svg"],
    circle: ["circle", `circle${capitalize(variant)}`, disableShrink && "circleDisableShrink"]
  };
  return composeClasses(slots, getCircularProgressUtilityClass, classes);
};
const CircularProgressRoot = styled("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "inline-block",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme2.transitions.create("transform")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: rotateAnimation || {
      animation: `${circularRotateKeyframe} 1.4s linear infinite`
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme2.vars || theme2).palette[color2].main
    }
  }))]
})));
const CircularProgressSVG = styled("svg", {
  name: "MuiCircularProgress",
  slot: "Svg"
})({
  display: "block"
  // Keeps the progress centered
});
const CircularProgressCircle = styled("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.circle, styles2[`circle${capitalize(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  stroke: "currentColor",
  variants: [{
    props: {
      variant: "determinate"
    },
    style: {
      transition: theme2.transitions.create("stroke-dashoffset")
    }
  }, {
    props: {
      variant: "indeterminate"
    },
    style: {
      // Some default value that looks fine waiting for the animation to kicks in.
      strokeDasharray: "80px, 200px",
      strokeDashoffset: 0
      // Add the unit to fix a Edge 16 and below bug.
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" && !ownerState.disableShrink,
    style: dashAnimation || {
      // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
      animation: `${circularDashKeyframe} 1.4s ease-in-out infinite`
    }
  }]
})));
const CircularProgress = /* @__PURE__ */ reactExports.forwardRef(function CircularProgress2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCircularProgress"
  });
  const {
    className,
    color: color2 = "primary",
    disableShrink = false,
    size: size2 = 40,
    style: style2,
    thickness = 3.6,
    value = 0,
    variant = "indeterminate",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    disableShrink,
    size: size2,
    thickness,
    value,
    variant
  };
  const classes = useUtilityClasses$J(ownerState);
  const circleStyle = {};
  const rootStyle = {};
  const rootProps = {};
  if (variant === "determinate") {
    const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
    circleStyle.strokeDasharray = circumference.toFixed(3);
    rootProps["aria-valuenow"] = Math.round(value);
    circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
    rootStyle.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressRoot, {
    className: clsx(classes.root, className),
    style: {
      width: size2,
      height: size2,
      ...rootStyle,
      ...style2
    },
    ownerState,
    ref: ref2,
    role: "progressbar",
    ...rootProps,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressSVG, {
      className: classes.svg,
      ownerState,
      viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCircle, {
        className: classes.circle,
        style: circleStyle,
        ownerState,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - thickness) / 2,
        fill: "none",
        strokeWidth: thickness
      })
    })
  });
});
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass("MuiIconButton", slot);
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]);
const useUtilityClasses$I = (ownerState) => {
  const {
    classes,
    disabled,
    color: color2,
    edge,
    size: size2,
    loading
  } = ownerState;
  const slots = {
    root: ["root", loading && "loading", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size2)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled(ButtonBase, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.loading && styles2.loading, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme2.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  color: (theme2.vars || theme2).palette.action.active,
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.shortest
  }),
  variants: [{
    props: (props) => !props.disableRipple,
    style: {
      "--IconButton-hoverBg": theme2.alpha((theme2.vars || theme2).palette.action.active, (theme2.vars || theme2).palette.action.hoverOpacity),
      "&:hover": {
        backgroundColor: "var(--IconButton-hoverBg)",
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }
    }
  }, {
    props: {
      edge: "start"
    },
    style: {
      marginLeft: -12
    }
  }, {
    props: {
      edge: "start",
      size: "small"
    },
    style: {
      marginLeft: -3
    }
  }, {
    props: {
      edge: "end"
    },
    style: {
      marginRight: -12
    }
  }, {
    props: {
      edge: "end",
      size: "small"
    },
    style: {
      marginRight: -3
    }
  }]
})), memoTheme(({
  theme: theme2
}) => ({
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      color: "inherit"
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme2.vars || theme2).palette[color2].main
    }
  })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      "--IconButton-hoverBg": theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity)
    }
  })), {
    props: {
      size: "small"
    },
    style: {
      padding: 5,
      fontSize: theme2.typography.pxToRem(18)
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      padding: 12,
      fontSize: theme2.typography.pxToRem(28)
    }
  }],
  [`&.${iconButtonClasses.disabled}`]: {
    backgroundColor: "transparent",
    color: (theme2.vars || theme2).palette.action.disabled
  },
  [`&.${iconButtonClasses.loading}`]: {
    color: "transparent"
  }
})));
const IconButtonLoadingIndicator = styled("span", {
  name: "MuiIconButton",
  slot: "LoadingIndicator"
})(({
  theme: theme2
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  color: (theme2.vars || theme2).palette.action.disabled,
  variants: [{
    props: {
      loading: true
    },
    style: {
      display: "flex"
    }
  }]
}));
const IconButton = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiIconButton"
  });
  const {
    edge = false,
    children,
    className,
    color: color2 = "default",
    disabled = false,
    disableFocusRipple = false,
    size: size2 = "medium",
    id: idProp,
    loading = null,
    loadingIndicator: loadingIndicatorProp,
    ...other
  } = props;
  const loadingId = useId(idProp);
  const loadingIndicator = loadingIndicatorProp ?? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {
    "aria-labelledby": loadingId,
    color: "inherit",
    size: 16
  });
  const ownerState = {
    ...props,
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    loading,
    loadingIndicator,
    size: size2
  };
  const classes = useUtilityClasses$I(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(IconButtonRoot, {
    id: loading ? loadingId : idProp,
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled: disabled || loading,
    ref: ref2,
    ...other,
    ownerState,
    children: [typeof loading === "boolean" && // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: classes.loadingWrapper,
      style: {
        display: "contents"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loading && loadingIndicator
      })
    }), children]
  });
});
const SuccessOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
}));
const ReportProblemOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
}));
const ErrorOutlineIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}));
const InfoOutlinedIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
}));
const ClearIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}));
const useUtilityClasses$H = (ownerState) => {
  const {
    variant,
    color: color2,
    severity,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2 || severity)}`, `${variant}${capitalize(color2 || severity)}`, `${variant}`],
    icon: ["icon"],
    message: ["message"],
    action: ["action"]
  };
  return composeClasses(slots, getAlertUtilityClass, classes);
};
const AlertRoot = styled(Paper, {
  name: "MuiAlert",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color || ownerState.severity)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const getColor = theme2.palette.mode === "light" ? theme2.darken : theme2.lighten;
  const getBackgroundColor = theme2.palette.mode === "light" ? theme2.lighten : theme2.darken;
  return {
    ...theme2.typography.body2,
    backgroundColor: "transparent",
    display: "flex",
    padding: "6px 16px",
    variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["light"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "standard"
      },
      style: {
        color: theme2.vars ? theme2.vars.palette.Alert[`${color2}Color`] : getColor(theme2.palette[color2].light, 0.6),
        backgroundColor: theme2.vars ? theme2.vars.palette.Alert[`${color2}StandardBg`] : getBackgroundColor(theme2.palette[color2].light, 0.9),
        [`& .${alertClasses.icon}`]: theme2.vars ? {
          color: theme2.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme2.palette[color2].main
        }
      }
    })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["light"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "outlined"
      },
      style: {
        color: theme2.vars ? theme2.vars.palette.Alert[`${color2}Color`] : getColor(theme2.palette[color2].light, 0.6),
        border: `1px solid ${(theme2.vars || theme2).palette[color2].light}`,
        [`& .${alertClasses.icon}`]: theme2.vars ? {
          color: theme2.vars.palette.Alert[`${color2}IconColor`]
        } : {
          color: theme2.palette[color2].main
        }
      }
    })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["dark"])).map(([color2]) => ({
      props: {
        colorSeverity: color2,
        variant: "filled"
      },
      style: {
        fontWeight: theme2.typography.fontWeightMedium,
        ...theme2.vars ? {
          color: theme2.vars.palette.Alert[`${color2}FilledColor`],
          backgroundColor: theme2.vars.palette.Alert[`${color2}FilledBg`]
        } : {
          backgroundColor: theme2.palette.mode === "dark" ? theme2.palette[color2].dark : theme2.palette[color2].main,
          color: theme2.palette.getContrastText(theme2.palette[color2].main)
        }
      }
    }))]
  };
}));
const AlertIcon = styled("div", {
  name: "MuiAlert",
  slot: "Icon"
})({
  marginRight: 12,
  padding: "7px 0",
  display: "flex",
  fontSize: 22,
  opacity: 0.9
});
const AlertMessage = styled("div", {
  name: "MuiAlert",
  slot: "Message"
})({
  padding: "8px 0",
  minWidth: 0,
  overflow: "auto"
});
const AlertAction = styled("div", {
  name: "MuiAlert",
  slot: "Action"
})({
  display: "flex",
  alignItems: "flex-start",
  padding: "4px 0 0 16px",
  marginLeft: "auto",
  marginRight: -8
});
const defaultIconMapping = {
  success: /* @__PURE__ */ jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
    fontSize: "inherit"
  }),
  warning: /* @__PURE__ */ jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
    fontSize: "inherit"
  }),
  error: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorOutlineIcon, {
    fontSize: "inherit"
  }),
  info: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoOutlinedIcon, {
    fontSize: "inherit"
  })
};
const Alert = /* @__PURE__ */ reactExports.forwardRef(function Alert2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAlert"
  });
  const {
    action,
    children,
    className,
    closeText = "Close",
    color: color2,
    components = {},
    componentsProps = {},
    icon,
    iconMapping = defaultIconMapping,
    onClose,
    role = "alert",
    severity = "success",
    slotProps = {},
    slots = {},
    variant = "standard",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    severity,
    variant,
    colorSeverity: color2 || severity
  };
  const classes = useUtilityClasses$H(ownerState);
  const externalForwardedProps = {
    slots: {
      closeButton: components.CloseButton,
      closeIcon: components.CloseIcon,
      ...slots
    },
    slotProps: {
      ...componentsProps,
      ...slotProps
    }
  };
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref: ref2,
    shouldForwardComponentProp: true,
    className: clsx(classes.root, className),
    elementType: AlertRoot,
    externalForwardedProps: {
      ...externalForwardedProps,
      ...other
    },
    ownerState,
    additionalProps: {
      role,
      elevation: 0
    }
  });
  const [IconSlot, iconSlotProps] = useSlot("icon", {
    className: classes.icon,
    elementType: AlertIcon,
    externalForwardedProps,
    ownerState
  });
  const [MessageSlot, messageSlotProps] = useSlot("message", {
    className: classes.message,
    elementType: AlertMessage,
    externalForwardedProps,
    ownerState
  });
  const [ActionSlot, actionSlotProps] = useSlot("action", {
    className: classes.action,
    elementType: AlertAction,
    externalForwardedProps,
    ownerState
  });
  const [CloseButtonSlot, closeButtonProps] = useSlot("closeButton", {
    elementType: IconButton,
    externalForwardedProps,
    ownerState
  });
  const [CloseIconSlot, closeIconProps] = useSlot("closeIcon", {
    elementType: ClearIcon,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
    ...rootSlotProps,
    children: [icon !== false ? /* @__PURE__ */ jsxRuntimeExports.jsx(IconSlot, {
      ...iconSlotProps,
      children: icon || iconMapping[severity] || defaultIconMapping[severity]
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(MessageSlot, {
      ...messageSlotProps,
      children
    }), action != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(ActionSlot, {
      ...actionSlotProps,
      children: action
    }) : null, action == null && onClose ? /* @__PURE__ */ jsxRuntimeExports.jsx(ActionSlot, {
      ...actionSlotProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseButtonSlot, {
        size: "small",
        "aria-label": closeText,
        title: closeText,
        color: "inherit",
        onClick: onClose,
        ...closeButtonProps,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIconSlot, {
          fontSize: "small",
          ...closeIconProps
        })
      })
    }) : null]
  });
});
function getTypographyUtilityClass(slot) {
  return generateUtilityClass("MuiTypography", slot);
}
generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const v6Colors = {
  primary: true,
  secondary: true,
  error: true,
  info: true,
  success: true,
  warning: true,
  textPrimary: true,
  textSecondary: true,
  textDisabled: true
};
const extendSxProp = internal_createExtendSxProp();
const useUtilityClasses$G = (ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
};
const TypographyRoot = styled("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  margin: 0,
  variants: [{
    props: {
      variant: "inherit"
    },
    style: {
      // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
      font: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  }, ...Object.entries(theme2.typography).filter(([variant, value]) => variant !== "inherit" && value && typeof value === "object").map(([variant, value]) => ({
    props: {
      variant
    },
    style: value
  })), ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      color: (theme2.vars || theme2).palette[color2].main
    }
  })), ...Object.entries(theme2.palette?.text || {}).filter(([, value]) => typeof value === "string").map(([color2]) => ({
    props: {
      color: `text${capitalize(color2)}`
    },
    style: {
      color: (theme2.vars || theme2).palette.text[color2]
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.align !== "inherit",
    style: {
      textAlign: "var(--Typography-textAlign)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.noWrap,
    style: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.gutterBottom,
    style: {
      marginBottom: "0.35em"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.paragraph,
    style: {
      marginBottom: 16
    }
  }]
})));
const defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref2) {
  const {
    color: color2,
    ...themeProps
  } = useDefaultProps({
    props: inProps,
    name: "MuiTypography"
  });
  const isSxColor = !v6Colors[color2];
  const props = extendSxProp({
    ...themeProps,
    ...isSxColor && {
      color: color2
    }
  });
  const {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph = false,
    variant = "body1",
    variantMapping = defaultVariantMapping,
    ...other
  } = props;
  const ownerState = {
    ...props,
    align,
    color: color2,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  };
  const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes = useUtilityClasses$G(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, {
    as: Component,
    ref: ref2,
    className: clsx(classes.root, className),
    ...other,
    ownerState,
    style: {
      ...align !== "inherit" && {
        "--Typography-textAlign": align
      },
      ...other.style
    }
  });
});
function getAppBarUtilityClass(slot) {
  return generateUtilityClass("MuiAppBar", slot);
}
generateUtilityClasses("MuiAppBar", ["root", "positionFixed", "positionAbsolute", "positionSticky", "positionStatic", "positionRelative", "colorDefault", "colorPrimary", "colorSecondary", "colorInherit", "colorTransparent", "colorError", "colorInfo", "colorSuccess", "colorWarning"]);
const useUtilityClasses$F = (ownerState) => {
  const {
    color: color2,
    position: position2,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, `position${capitalize(position2)}`]
  };
  return composeClasses(slots, getAppBarUtilityClass, classes);
};
const joinVars = (var1, var2) => var1 ? `${var1?.replace(")", "")}, ${var2})` : var2;
const AppBarRoot = styled(Paper, {
  name: "MuiAppBar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`position${capitalize(ownerState.position)}`], styles2[`color${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "flex",
  flexDirection: "column",
  width: "100%",
  boxSizing: "border-box",
  // Prevent padding issue with the Modal and fixed positioned AppBar.
  flexShrink: 0,
  variants: [{
    props: {
      position: "fixed"
    },
    style: {
      position: "fixed",
      zIndex: (theme2.vars || theme2).zIndex.appBar,
      top: 0,
      left: "auto",
      right: 0,
      "@media print": {
        // Prevent the app bar to be visible on each printed page.
        position: "absolute"
      }
    }
  }, {
    props: {
      position: "absolute"
    },
    style: {
      position: "absolute",
      zIndex: (theme2.vars || theme2).zIndex.appBar,
      top: 0,
      left: "auto",
      right: 0
    }
  }, {
    props: {
      position: "sticky"
    },
    style: {
      position: "sticky",
      zIndex: (theme2.vars || theme2).zIndex.appBar,
      top: 0,
      left: "auto",
      right: 0
    }
  }, {
    props: {
      position: "static"
    },
    style: {
      position: "static"
    }
  }, {
    props: {
      position: "relative"
    },
    style: {
      position: "relative"
    }
  }, {
    props: {
      color: "inherit"
    },
    style: {
      "--AppBar-color": "inherit"
    }
  }, {
    props: {
      color: "default"
    },
    style: {
      "--AppBar-background": theme2.vars ? theme2.vars.palette.AppBar.defaultBg : theme2.palette.grey[100],
      "--AppBar-color": theme2.vars ? theme2.vars.palette.text.primary : theme2.palette.getContrastText(theme2.palette.grey[100]),
      ...theme2.applyStyles("dark", {
        "--AppBar-background": theme2.vars ? theme2.vars.palette.AppBar.defaultBg : theme2.palette.grey[900],
        "--AppBar-color": theme2.vars ? theme2.vars.palette.text.primary : theme2.palette.getContrastText(theme2.palette.grey[900])
      })
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["contrastText"])).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      "--AppBar-background": (theme2.vars ?? theme2).palette[color2].main,
      "--AppBar-color": (theme2.vars ?? theme2).palette[color2].contrastText
    }
  })), {
    props: (props) => props.enableColorOnDark === true && !["inherit", "transparent"].includes(props.color),
    style: {
      backgroundColor: "var(--AppBar-background)",
      color: "var(--AppBar-color)"
    }
  }, {
    props: (props) => props.enableColorOnDark === false && !["inherit", "transparent"].includes(props.color),
    style: {
      backgroundColor: "var(--AppBar-background)",
      color: "var(--AppBar-color)",
      ...theme2.applyStyles("dark", {
        backgroundColor: theme2.vars ? joinVars(theme2.vars.palette.AppBar.darkBg, "var(--AppBar-background)") : null,
        color: theme2.vars ? joinVars(theme2.vars.palette.AppBar.darkColor, "var(--AppBar-color)") : null
      })
    }
  }, {
    props: {
      color: "transparent"
    },
    style: {
      "--AppBar-background": "transparent",
      "--AppBar-color": "inherit",
      backgroundColor: "var(--AppBar-background)",
      color: "var(--AppBar-color)",
      ...theme2.applyStyles("dark", {
        backgroundImage: "none"
      })
    }
  }]
})));
const AppBar = /* @__PURE__ */ reactExports.forwardRef(function AppBar2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAppBar"
  });
  const {
    className,
    color: color2 = "primary",
    enableColorOnDark = false,
    position: position2 = "fixed",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    position: position2,
    enableColorOnDark
  };
  const classes = useUtilityClasses$F(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AppBarRoot, {
    square: true,
    component: "header",
    ownerState,
    elevation: 4,
    className: clsx(classes.root, className, position2 === "fixed" && "mui-fixed"),
    ref: ref2,
    ...other
  });
});
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument2 = node2.ownerDocument;
    return ownerDocument2 ? ownerDocument2.defaultView || window : window;
  }
  return node2;
}
function isElement(node2) {
  var OwnElement = getWindow(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement$1(node2) {
  var OwnElement = getWindow(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state2 = _ref.state;
  Object.keys(state2.elements).forEach(function(name) {
    var style2 = state2.styles[name] || {};
    var attributes = state2.attributes[name] || {};
    var element = state2.elements[name];
    if (!isHTMLElement$1(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state2 = _ref2.state;
  var initialStyles = {
    popper: {
      position: state2.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state2.elements.popper.style, initialStyles.popper);
  state2.styles = initialStyles;
  if (state2.elements.arrow) {
    Object.assign(state2.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state2.elements).forEach(function(name) {
      var element = state2.elements[name];
      var attributes = state2.attributes[name] || {};
      var styleProperties = Object.keys(state2.styles.hasOwnProperty(name) ? state2.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement$1(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round$1 = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y3 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width2 = clientRect.width / scaleX;
  var height2 = clientRect.height / scaleY;
  return {
    width: width2,
    height: height2,
    top: y3,
    right: x2 + width2,
    bottom: y3 + height2,
    left: x2,
    x: x2,
    y: y3
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width2 = element.offsetWidth;
  var height2 = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height2) <= 1) {
    height2 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height: height2
  };
}
function contains(parent2, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent2.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent2.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement$1(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle$1(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key2) {
    hashMap[key2] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding2, state2) {
  padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : padding2;
  return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state2 = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state2.elements.arrow;
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state2.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state2);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state2.rects.reference[len] + state2.rects.reference[axis] - popperOffsets2[axis] - state2.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state2.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state2.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state2 = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state2.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state2.elements.popper, arrowElement)) {
    return;
  }
  state2.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x2 = _ref.x, y3 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x2 * dpr) / dpr || 0,
    y: round$1(y3 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y3 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y3
  }) : {
    x: x2,
    y: y3
  };
  x2 = _ref3.x;
  y3 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y3 -= offsetY - popperRect.height;
      y3 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y3
  }, getWindow(popper2)) : {
    x: x2,
    y: y3
  };
  x2 = _ref4.x;
  y3 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y3 + "px)" : "translate3d(" + x2 + "px, " + y3 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y3 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state2 = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state2.placement),
    variation: getVariation(state2.placement),
    popper: state2.elements.popper,
    popperRect: state2.rects.popper,
    gpuAcceleration,
    isFixed: state2.options.strategy === "fixed"
  };
  if (state2.modifiersData.popperOffsets != null) {
    state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.popperOffsets,
      position: state2.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state2.modifiersData.arrow != null) {
    state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-placement": state2.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state2 = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state2.elements.popper);
  var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$4 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$4[matched];
  });
}
var hash$3 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash$3[matched];
  });
}
function getWindowScroll(node2) {
  var win = getWindow(node2);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html2 = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width2 = html2.clientWidth;
  var height2 = html2.clientHeight;
  var x2 = 0;
  var y3 = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height2 = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height: height2,
    x: x2 + getWindowScrollBarX(element),
    y: y3
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html2 = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body2 = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width2 = max(html2.scrollWidth, html2.clientWidth, body2 ? body2.scrollWidth : 0, body2 ? body2.clientWidth : 0);
  var height2 = max(html2.scrollHeight, html2.clientHeight, body2 ? body2.scrollHeight : 0, body2 ? body2.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y3 = -winScroll.scrollTop;
  if (getComputedStyle$1(body2 || html2).direction === "rtl") {
    x2 += max(html2.clientWidth, body2 ? body2.clientWidth : 0) - width2;
  }
  return {
    width: width2,
    height: height2,
    x: x2,
    y: y3
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement$1(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode(node2));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state2, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state2.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state2.rects.popper;
  var element = state2.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state2.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state2.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state2.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key2) {
      var multiply = [right, bottom].indexOf(key2) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key2) >= 0 ? "y" : "x";
      overflowOffsets[key2] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state2, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state2 = _ref.state, options = _ref.options, name = _ref.name;
  if (state2.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding2 = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state2.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i4 = 0; i4 < placements2.length; i4++) {
    var placement = placements2[i4];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state2, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding: padding2
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i4) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i4).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i3 = numberOfChecks; _i3 > 0; _i3--) {
      var _ret = _loop(_i3);
      if (_ret === "break") break;
    }
  }
  if (state2.placement !== firstFittingPlacement) {
    state2.modifiersData[name]._skip = true;
    state2.placement = firstFittingPlacement;
    state2.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state2 = _ref.state, name = _ref.name;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var preventedOffsets = state2.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state2, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state2, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state2.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state2 = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data2 = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state2.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data2[state2.placement], x2 = _data$state$placement.x, y3 = _data$state$placement.y;
  if (state2.modifiersData.popperOffsets != null) {
    state2.modifiersData.popperOffsets.x += x2;
    state2.modifiersData.popperOffsets.y += y3;
  }
  state2.modifiersData[name] = data2;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state2 = _ref.state, name = _ref.name;
  state2.modifiersData[name] = computeOffsets({
    reference: state2.rects.reference,
    element: state2.rects.popper,
    placement: state2.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state2 = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding2 = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state2, {
    boundary,
    rootBoundary,
    padding: padding2,
    altBoundary
  });
  var basePlacement = getBasePlacement(state2.placement);
  var variation = getVariation(state2.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
  var data2 = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state2.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state2.elements.arrow && getOffsetParent(state2.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data2[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data2[altAxis] = _preventedOffset - _offset;
  }
  state2.modifiersData[name] = data2;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node2) {
  if (node2 === getWindow(node2) || !isHTMLElement$1(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers2) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key2) {
    return merged[key2];
  });
}
var DEFAULT_OPTIONS$1 = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$1 : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state2 = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS$1, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state2,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
        cleanupModifierEffects();
        state2.options = Object.assign({}, defaultOptions, state2.options, options2);
        state2.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state2.options.modifiers)));
        state2.orderedModifiers = orderedModifiers.filter(function(m3) {
          return m3.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state2.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state2.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state2.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state2.reset = false;
        state2.placement = state2.options.placement;
        state2.orderedModifiers.forEach(function(modifier) {
          return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state2.orderedModifiers.length; index2++) {
          if (state2.reset === true) {
            state2.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state2.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state2 = fn2({
              state: state2,
              options: _options,
              name,
              instance
            }) || state2;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state2);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state3) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state3);
      }
    });
    function runModifierEffects() {
      state2.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state: state2,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
function useSlotProps(parameters) {
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false,
    ...other
  } = parameters;
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps({
    ...other,
    externalSlotProps: resolvedComponentsProps
  });
  const ref2 = useForkRef(internalRef, resolvedComponentsProps?.ref, parameters.additionalProps?.ref);
  const props = appendOwnerState(elementType, {
    ...mergedProps,
    ref: ref2
  }, ownerState);
  return props;
}
function getReactElementRef(element) {
  if (parseInt(reactExports.version, 10) >= 19) {
    return element?.props?.ref || null;
  }
  return element?.ref || null;
}
function getContainer$1(container) {
  return typeof container === "function" ? container() : container;
}
const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = reactExports.useState(null);
  const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? getReactElementRef(children) : null, forwardedRef);
  useEnhancedEffect(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect(() => {
    if (mountNode && !disablePortal) {
      setRef(forwardedRef, mountNode);
      return () => {
        setRef(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ reactExports.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
    }
    return children;
  }
  return mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode;
});
function getPopperUtilityClass(slot) {
  return generateUtilityClass("MuiPopper", slot);
}
generateUtilityClasses("MuiPopper", ["root"]);
function flipPlacement(placement, direction) {
  if (direction === "ltr") {
    return placement;
  }
  switch (placement) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return placement;
  }
}
function resolveAnchorEl$1(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
function isHTMLElement(element) {
  return element.nodeType !== void 0;
}
const useUtilityClasses$E = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getPopperUtilityClass, classes);
};
const defaultPopperOptions = {};
const PopperTooltip = /* @__PURE__ */ reactExports.forwardRef(function PopperTooltip2(props, forwardedRef) {
  const {
    anchorEl,
    children,
    direction,
    disablePortal,
    modifiers: modifiers2,
    open,
    placement: initialPlacement,
    popperOptions,
    popperRef: popperRefProp,
    slotProps = {},
    slots = {},
    TransitionProps,
    // @ts-ignore internal logic
    ownerState: ownerStateProp,
    // prevent from spreading to DOM, it can come from the parent component e.g. Select.
    ...other
  } = props;
  const tooltipRef = reactExports.useRef(null);
  const ownRef = useForkRef(tooltipRef, forwardedRef);
  const popperRef = reactExports.useRef(null);
  const handlePopperRef = useForkRef(popperRef, popperRefProp);
  const handlePopperRefRef = reactExports.useRef(handlePopperRef);
  useEnhancedEffect(() => {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  reactExports.useImperativeHandle(popperRefProp, () => popperRef.current, []);
  const rtlPlacement = flipPlacement(initialPlacement, direction);
  const [placement, setPlacement] = reactExports.useState(rtlPlacement);
  const [resolvedAnchorElement, setResolvedAnchorElement] = reactExports.useState(resolveAnchorEl$1(anchorEl));
  reactExports.useEffect(() => {
    if (popperRef.current) {
      popperRef.current.forceUpdate();
    }
  });
  reactExports.useEffect(() => {
    if (anchorEl) {
      setResolvedAnchorElement(resolveAnchorEl$1(anchorEl));
    }
  }, [anchorEl]);
  useEnhancedEffect(() => {
    if (!resolvedAnchorElement || !open) {
      return void 0;
    }
    const handlePopperUpdate = (data2) => {
      setPlacement(data2.placement);
    };
    let popperModifiers = [{
      name: "preventOverflow",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "flip",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "onUpdate",
      enabled: true,
      phase: "afterWrite",
      fn: ({
        state: state2
      }) => {
        handlePopperUpdate(state2);
      }
    }];
    if (modifiers2 != null) {
      popperModifiers = popperModifiers.concat(modifiers2);
    }
    if (popperOptions && popperOptions.modifiers != null) {
      popperModifiers = popperModifiers.concat(popperOptions.modifiers);
    }
    const popper2 = createPopper(resolvedAnchorElement, tooltipRef.current, {
      placement: rtlPlacement,
      ...popperOptions,
      modifiers: popperModifiers
    });
    handlePopperRefRef.current(popper2);
    return () => {
      popper2.destroy();
      handlePopperRefRef.current(null);
    };
  }, [resolvedAnchorElement, disablePortal, modifiers2, open, popperOptions, rtlPlacement]);
  const childProps = {
    placement
  };
  if (TransitionProps !== null) {
    childProps.TransitionProps = TransitionProps;
  }
  const classes = useUtilityClasses$E(props);
  const Root = slots.root ?? "div";
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      role: "tooltip",
      ref: ownRef
    },
    ownerState: props,
    className: classes.root
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, {
    ...rootProps,
    children: typeof children === "function" ? children(childProps) : children
  });
});
const Popper$1 = /* @__PURE__ */ reactExports.forwardRef(function Popper2(props, forwardedRef) {
  const {
    anchorEl,
    children,
    container: containerProp,
    direction = "ltr",
    disablePortal = false,
    keepMounted = false,
    modifiers: modifiers2,
    open,
    placement = "bottom",
    popperOptions = defaultPopperOptions,
    popperRef,
    style: style2,
    transition = false,
    slotProps = {},
    slots = {},
    ...other
  } = props;
  const [exited, setExited] = reactExports.useState(true);
  const handleEnter = () => {
    setExited(false);
  };
  const handleExited = () => {
    setExited(true);
  };
  if (!keepMounted && !open && (!transition || exited)) {
    return null;
  }
  let container;
  if (containerProp) {
    container = containerProp;
  } else if (anchorEl) {
    const resolvedAnchorEl = resolveAnchorEl$1(anchorEl);
    container = resolvedAnchorEl && isHTMLElement(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
  }
  const display = !open && keepMounted && (!transition || exited) ? "none" : void 0;
  const transitionProps = transition ? {
    in: open,
    onEnter: handleEnter,
    onExited: handleExited
  } : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    disablePortal,
    container,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperTooltip, {
      anchorEl,
      direction,
      disablePortal,
      modifiers: modifiers2,
      ref: forwardedRef,
      open: transition ? !exited : open,
      placement,
      popperOptions,
      popperRef,
      slotProps,
      slots,
      ...other,
      style: {
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display,
        ...style2
      },
      TransitionProps: transitionProps,
      children
    })
  });
});
const PopperRoot = styled(Popper$1, {
  name: "MuiPopper",
  slot: "Root"
})({});
const Popper = /* @__PURE__ */ reactExports.forwardRef(function Popper22(inProps, ref2) {
  const isRtl = useRtl();
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPopper"
  });
  const {
    anchorEl,
    component,
    components,
    componentsProps,
    container,
    disablePortal,
    keepMounted,
    modifiers: modifiers2,
    open,
    placement,
    popperOptions,
    popperRef,
    transition,
    slots,
    slotProps,
    ...other
  } = props;
  const RootComponent = slots?.root ?? components?.Root;
  const otherProps = {
    anchorEl,
    container,
    disablePortal,
    keepMounted,
    modifiers: modifiers2,
    open,
    placement,
    popperOptions,
    popperRef,
    transition,
    ...other
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperRoot, {
    as: component,
    direction: isRtl ? "rtl" : "ltr",
    slots: {
      root: RootComponent
    },
    slotProps: slotProps ?? componentsProps,
    ...otherProps,
    ref: ref2
  });
});
const CancelIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
}));
function getChipUtilityClass(slot) {
  return generateUtilityClass("MuiChip", slot);
}
const chipClasses = generateUtilityClasses("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorDefault", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]);
const useUtilityClasses$D = (ownerState) => {
  const {
    classes,
    disabled,
    size: size2,
    color: color2,
    iconColor,
    onDelete,
    clickable,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant, disabled && "disabled", `size${capitalize(size2)}`, `color${capitalize(color2)}`, clickable && "clickable", clickable && `clickableColor${capitalize(color2)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize(color2)}`, `${variant}${capitalize(color2)}`],
    label: ["label", `label${capitalize(size2)}`],
    avatar: ["avatar", `avatar${capitalize(size2)}`, `avatarColor${capitalize(color2)}`],
    icon: ["icon", `icon${capitalize(size2)}`, `iconColor${capitalize(iconColor)}`],
    deleteIcon: ["deleteIcon", `deleteIcon${capitalize(size2)}`, `deleteIconColor${capitalize(color2)}`, `deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
  };
  return composeClasses(slots, getChipUtilityClass, classes);
};
const ChipRoot = styled("div", {
  name: "MuiChip",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      color: color2,
      iconColor,
      clickable,
      onDelete,
      size: size2,
      variant
    } = ownerState;
    return [{
      [`& .${chipClasses.avatar}`]: styles2.avatar
    }, {
      [`& .${chipClasses.avatar}`]: styles2[`avatar${capitalize(size2)}`]
    }, {
      [`& .${chipClasses.avatar}`]: styles2[`avatarColor${capitalize(color2)}`]
    }, {
      [`& .${chipClasses.icon}`]: styles2.icon
    }, {
      [`& .${chipClasses.icon}`]: styles2[`icon${capitalize(size2)}`]
    }, {
      [`& .${chipClasses.icon}`]: styles2[`iconColor${capitalize(iconColor)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2.deleteIcon
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIcon${capitalize(size2)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIconColor${capitalize(color2)}`]
    }, {
      [`& .${chipClasses.deleteIcon}`]: styles2[`deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
    }, styles2.root, styles2[`size${capitalize(size2)}`], styles2[`color${capitalize(color2)}`], clickable && styles2.clickable, clickable && color2 !== "default" && styles2[`clickableColor${capitalize(color2)})`], onDelete && styles2.deletable, onDelete && color2 !== "default" && styles2[`deletableColor${capitalize(color2)}`], styles2[variant], styles2[`${variant}${capitalize(color2)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const textColor = theme2.palette.mode === "light" ? theme2.palette.grey[700] : theme2.palette.grey[300];
  return {
    maxWidth: "100%",
    fontFamily: theme2.typography.fontFamily,
    fontSize: theme2.typography.pxToRem(13),
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    height: 32,
    lineHeight: 1.5,
    color: (theme2.vars || theme2).palette.text.primary,
    backgroundColor: (theme2.vars || theme2).palette.action.selected,
    borderRadius: 32 / 2,
    whiteSpace: "nowrap",
    transition: theme2.transitions.create(["background-color", "box-shadow"]),
    // reset cursor explicitly in case ButtonBase is used
    cursor: "unset",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    textDecoration: "none",
    border: 0,
    // Remove `button` border
    padding: 0,
    // Remove `button` padding
    verticalAlign: "middle",
    boxSizing: "border-box",
    [`&.${chipClasses.disabled}`]: {
      opacity: (theme2.vars || theme2).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`& .${chipClasses.avatar}`]: {
      marginLeft: 5,
      marginRight: -6,
      width: 24,
      height: 24,
      color: theme2.vars ? theme2.vars.palette.Chip.defaultAvatarColor : textColor,
      fontSize: theme2.typography.pxToRem(12)
    },
    [`& .${chipClasses.avatarColorPrimary}`]: {
      color: (theme2.vars || theme2).palette.primary.contrastText,
      backgroundColor: (theme2.vars || theme2).palette.primary.dark
    },
    [`& .${chipClasses.avatarColorSecondary}`]: {
      color: (theme2.vars || theme2).palette.secondary.contrastText,
      backgroundColor: (theme2.vars || theme2).palette.secondary.dark
    },
    [`& .${chipClasses.avatarSmall}`]: {
      marginLeft: 4,
      marginRight: -4,
      width: 18,
      height: 18,
      fontSize: theme2.typography.pxToRem(10)
    },
    [`& .${chipClasses.icon}`]: {
      marginLeft: 5,
      marginRight: -6
    },
    [`& .${chipClasses.deleteIcon}`]: {
      WebkitTapHighlightColor: "transparent",
      color: theme2.alpha((theme2.vars || theme2).palette.text.primary, 0.26),
      fontSize: 22,
      cursor: "pointer",
      margin: "0 5px 0 -6px",
      "&:hover": {
        color: theme2.alpha((theme2.vars || theme2).palette.text.primary, 0.4)
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        height: 24,
        [`& .${chipClasses.icon}`]: {
          fontSize: 18,
          marginLeft: 4,
          marginRight: -4
        },
        [`& .${chipClasses.deleteIcon}`]: {
          fontSize: 16,
          marginRight: 4,
          marginLeft: -4
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["contrastText"])).map(([color2]) => {
      return {
        props: {
          color: color2
        },
        style: {
          backgroundColor: (theme2.vars || theme2).palette[color2].main,
          color: (theme2.vars || theme2).palette[color2].contrastText,
          [`& .${chipClasses.deleteIcon}`]: {
            color: theme2.alpha((theme2.vars || theme2).palette[color2].contrastText, 0.7),
            "&:hover, &:active": {
              color: (theme2.vars || theme2).palette[color2].contrastText
            }
          }
        }
      };
    }), {
      props: (props) => props.iconColor === props.color,
      style: {
        [`& .${chipClasses.icon}`]: {
          color: theme2.vars ? theme2.vars.palette.Chip.defaultIconColor : textColor
        }
      }
    }, {
      props: (props) => props.iconColor === props.color && props.color !== "default",
      style: {
        [`& .${chipClasses.icon}`]: {
          color: "inherit"
        }
      }
    }, {
      props: {
        onDelete: true
      },
      style: {
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette.action.selected, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.focusOpacity}`)
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["dark"])).map(([color2]) => {
      return {
        props: {
          color: color2,
          onDelete: true
        },
        style: {
          [`&.${chipClasses.focusVisible}`]: {
            background: (theme2.vars || theme2).palette[color2].dark
          }
        }
      };
    }), {
      props: {
        clickable: true
      },
      style: {
        userSelect: "none",
        WebkitTapHighlightColor: "transparent",
        cursor: "pointer",
        "&:hover": {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette.action.selected, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.hoverOpacity}`)
        },
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette.action.selected, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.focusOpacity}`)
        },
        "&:active": {
          boxShadow: (theme2.vars || theme2).shadows[1]
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter(["dark"])).map(([color2]) => ({
      props: {
        color: color2,
        clickable: true
      },
      style: {
        [`&:hover, &.${chipClasses.focusVisible}`]: {
          backgroundColor: (theme2.vars || theme2).palette[color2].dark
        }
      }
    })), {
      props: {
        variant: "outlined"
      },
      style: {
        backgroundColor: "transparent",
        border: theme2.vars ? `1px solid ${theme2.vars.palette.Chip.defaultBorder}` : `1px solid ${theme2.palette.mode === "light" ? theme2.palette.grey[400] : theme2.palette.grey[700]}`,
        [`&.${chipClasses.clickable}:hover`]: {
          backgroundColor: (theme2.vars || theme2).palette.action.hover
        },
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: (theme2.vars || theme2).palette.action.focus
        },
        [`& .${chipClasses.avatar}`]: {
          marginLeft: 4
        },
        [`& .${chipClasses.avatarSmall}`]: {
          marginLeft: 2
        },
        [`& .${chipClasses.icon}`]: {
          marginLeft: 4
        },
        [`& .${chipClasses.iconSmall}`]: {
          marginLeft: 2
        },
        [`& .${chipClasses.deleteIcon}`]: {
          marginRight: 5
        },
        [`& .${chipClasses.deleteIconSmall}`]: {
          marginRight: 3
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        variant: "outlined",
        color: color2
      },
      style: {
        color: (theme2.vars || theme2).palette[color2].main,
        border: `1px solid ${theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.7)}`,
        [`&.${chipClasses.clickable}:hover`]: {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity)
        },
        [`&.${chipClasses.focusVisible}`]: {
          backgroundColor: theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.focusOpacity)
        },
        [`& .${chipClasses.deleteIcon}`]: {
          color: theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.7),
          "&:hover, &:active": {
            color: (theme2.vars || theme2).palette[color2].main
          }
        }
      }
    }))]
  };
}));
const ChipLabel = styled("span", {
  name: "MuiChip",
  slot: "Label",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      size: size2
    } = ownerState;
    return [styles2.label, styles2[`label${capitalize(size2)}`]];
  }
})({
  overflow: "hidden",
  textOverflow: "ellipsis",
  paddingLeft: 12,
  paddingRight: 12,
  whiteSpace: "nowrap",
  variants: [{
    props: {
      variant: "outlined"
    },
    style: {
      paddingLeft: 11,
      paddingRight: 11
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      paddingLeft: 8,
      paddingRight: 8
    }
  }, {
    props: {
      size: "small",
      variant: "outlined"
    },
    style: {
      paddingLeft: 7,
      paddingRight: 7
    }
  }]
});
function isDeleteKeyboardEvent(keyboardEvent) {
  return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
}
const Chip = /* @__PURE__ */ reactExports.forwardRef(function Chip2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiChip"
  });
  const {
    avatar: avatarProp,
    className,
    clickable: clickableProp,
    color: color2 = "default",
    component: ComponentProp,
    deleteIcon: deleteIconProp,
    disabled = false,
    icon: iconProp,
    label,
    onClick,
    onDelete,
    onKeyDown,
    onKeyUp,
    size: size2 = "medium",
    variant = "filled",
    tabIndex,
    skipFocusWhenDisabled = false,
    // TODO v6: Rename to `focusableWhenDisabled`.
    slots = {},
    slotProps = {},
    ...other
  } = props;
  const chipRef = reactExports.useRef(null);
  const handleRef = useForkRef(chipRef, ref2);
  const handleDeleteIconClick = (event) => {
    event.stopPropagation();
    if (onDelete) {
      onDelete(event);
    }
  };
  const handleKeyDown = (event) => {
    if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleKeyUp = (event) => {
    if (event.currentTarget === event.target) {
      if (onDelete && isDeleteKeyboardEvent(event)) {
        onDelete(event);
      }
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
  };
  const clickable = clickableProp !== false && onClick ? true : clickableProp;
  const component = clickable || onDelete ? ButtonBase : ComponentProp || "div";
  const ownerState = {
    ...props,
    component,
    disabled,
    size: size2,
    color: color2,
    iconColor: /* @__PURE__ */ reactExports.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
    onDelete: !!onDelete,
    clickable,
    variant
  };
  const classes = useUtilityClasses$D(ownerState);
  const moreProps = component === ButtonBase ? {
    component: ComponentProp || "div",
    focusVisibleClassName: classes.focusVisible,
    ...onDelete && {
      disableRipple: true
    }
  } : {};
  let deleteIcon = null;
  if (onDelete) {
    deleteIcon = deleteIconProp && /* @__PURE__ */ reactExports.isValidElement(deleteIconProp) ? /* @__PURE__ */ reactExports.cloneElement(deleteIconProp, {
      className: clsx(deleteIconProp.props.className, classes.deleteIcon),
      onClick: handleDeleteIconClick
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CancelIcon, {
      className: classes.deleteIcon,
      onClick: handleDeleteIconClick
    });
  }
  let avatar = null;
  if (avatarProp && /* @__PURE__ */ reactExports.isValidElement(avatarProp)) {
    avatar = /* @__PURE__ */ reactExports.cloneElement(avatarProp, {
      className: clsx(classes.avatar, avatarProp.props.className)
    });
  }
  let icon = null;
  if (iconProp && /* @__PURE__ */ reactExports.isValidElement(iconProp)) {
    icon = /* @__PURE__ */ reactExports.cloneElement(iconProp, {
      className: clsx(classes.icon, iconProp.props.className)
    });
  }
  const externalForwardedProps = {
    slots,
    slotProps
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: ChipRoot,
    externalForwardedProps: {
      ...externalForwardedProps,
      ...other
    },
    ownerState,
    // The `component` prop is preserved because `Chip` relies on it for internal logic. If `shouldForwardComponentProp` were `false`, `useSlot` would remove the `component` prop, potentially breaking the component's behavior.
    shouldForwardComponentProp: true,
    ref: handleRef,
    className: clsx(classes.root, className),
    additionalProps: {
      disabled: clickable && disabled ? true : void 0,
      tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
      ...moreProps
    },
    getSlotProps: (handlers) => ({
      ...handlers,
      onClick: (event) => {
        handlers.onClick?.(event);
        onClick?.(event);
      },
      onKeyDown: (event) => {
        handlers.onKeyDown?.(event);
        handleKeyDown(event);
      },
      onKeyUp: (event) => {
        handlers.onKeyUp?.(event);
        handleKeyUp(event);
      }
    })
  });
  const [LabelSlot, labelProps] = useSlot("label", {
    elementType: ChipLabel,
    externalForwardedProps,
    ownerState,
    className: classes.label
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
    as: component,
    ...rootProps,
    children: [avatar || icon, /* @__PURE__ */ jsxRuntimeExports.jsx(LabelSlot, {
      ...labelProps,
      children: label
    }), deleteIcon]
  });
});
function getStyleValue(value) {
  return parseInt(value, 10) || 0;
}
const styles$2i = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function isObjectEmpty(object) {
  for (const _2 in object) {
    return false;
  }
  return true;
}
function isEmpty$1(obj) {
  return isObjectEmpty(obj) || obj.outerHeightStyle === 0 && !obj.overflowing;
}
const TextareaAutosize = /* @__PURE__ */ reactExports.forwardRef(function TextareaAutosize2(props, forwardedRef) {
  const {
    onChange,
    maxRows,
    minRows = 1,
    style: style2,
    value,
    ...other
  } = props;
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const textareaRef = reactExports.useRef(null);
  const handleRef = useForkRef(forwardedRef, textareaRef);
  const heightRef = reactExports.useRef(null);
  const hiddenTextareaRef = reactExports.useRef(null);
  const calculateTextareaStyles = reactExports.useCallback(() => {
    const textarea = textareaRef.current;
    const hiddenTextarea = hiddenTextareaRef.current;
    if (!textarea || !hiddenTextarea) {
      return void 0;
    }
    const containerWindow = ownerWindow(textarea);
    const computedStyle = containerWindow.getComputedStyle(textarea);
    if (computedStyle.width === "0px") {
      return {
        outerHeightStyle: 0,
        overflowing: false
      };
    }
    hiddenTextarea.style.width = computedStyle.width;
    hiddenTextarea.value = textarea.value || props.placeholder || "x";
    if (hiddenTextarea.value.slice(-1) === "\n") {
      hiddenTextarea.value += " ";
    }
    const boxSizing2 = computedStyle.boxSizing;
    const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
    const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
    const innerHeight = hiddenTextarea.scrollHeight;
    hiddenTextarea.value = "x";
    const singleRowHeight = hiddenTextarea.scrollHeight;
    let outerHeight = innerHeight;
    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }
    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight);
    const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
    const overflowing = Math.abs(outerHeight - innerHeight) <= 1;
    return {
      outerHeightStyle,
      overflowing
    };
  }, [maxRows, minRows, props.placeholder]);
  const didHeightChange = useEventCallback(() => {
    const textarea = textareaRef.current;
    const textareaStyles = calculateTextareaStyles();
    if (!textarea || !textareaStyles || isEmpty$1(textareaStyles)) {
      return false;
    }
    const outerHeightStyle = textareaStyles.outerHeightStyle;
    return heightRef.current != null && heightRef.current !== outerHeightStyle;
  });
  const syncHeight = reactExports.useCallback(() => {
    const textarea = textareaRef.current;
    const textareaStyles = calculateTextareaStyles();
    if (!textarea || !textareaStyles || isEmpty$1(textareaStyles)) {
      return;
    }
    const outerHeightStyle = textareaStyles.outerHeightStyle;
    if (heightRef.current !== outerHeightStyle) {
      heightRef.current = outerHeightStyle;
      textarea.style.height = `${outerHeightStyle}px`;
    }
    textarea.style.overflow = textareaStyles.overflowing ? "hidden" : "";
  }, [calculateTextareaStyles]);
  const frameRef = reactExports.useRef(-1);
  useEnhancedEffect(() => {
    const debouncedHandleResize = debounce$1(syncHeight);
    const textarea = textareaRef?.current;
    if (!textarea) {
      return void 0;
    }
    const containerWindow = ownerWindow(textarea);
    containerWindow.addEventListener("resize", debouncedHandleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(() => {
        if (didHeightChange()) {
          resizeObserver.unobserve(textarea);
          cancelAnimationFrame(frameRef.current);
          syncHeight();
          frameRef.current = requestAnimationFrame(() => {
            resizeObserver.observe(textarea);
          });
        }
      });
      resizeObserver.observe(textarea);
    }
    return () => {
      debouncedHandleResize.clear();
      cancelAnimationFrame(frameRef.current);
      containerWindow.removeEventListener("resize", debouncedHandleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [calculateTextareaStyles, syncHeight, didHeightChange]);
  useEnhancedEffect(() => {
    syncHeight();
  });
  const handleChange = (event) => {
    if (!isControlled) {
      syncHeight();
    }
    const textarea = event.target;
    const countOfCharacters = textarea.value.length;
    const isLastCharacterNewLine = textarea.value.endsWith("\n");
    const isEndOfTheLine = textarea.selectionStart === countOfCharacters;
    if (isLastCharacterNewLine && isEndOfTheLine) {
      textarea.setSelectionRange(countOfCharacters, countOfCharacters);
    }
    if (onChange) {
      onChange(event);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
      value,
      onChange: handleChange,
      ref: handleRef,
      rows: minRows,
      style: style2,
      ...other
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
      "aria-hidden": true,
      className: props.className,
      readOnly: true,
      ref: hiddenTextareaRef,
      tabIndex: -1,
      style: {
        ...styles$2i.shadow,
        ...style2,
        paddingTop: 0,
        paddingBottom: 0
      }
    })]
  });
});
function formControlState({
  props,
  states,
  muiFormControl
}) {
  return states.reduce((acc, state2) => {
    acc[state2] = props[state2];
    if (muiFormControl) {
      if (typeof props[state2] === "undefined") {
        acc[state2] = muiFormControl[state2];
      }
    }
    return acc;
  }, {});
}
const FormControlContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useFormControl() {
  return reactExports.useContext(FormControlContext);
}
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
}
function isFilled(obj, SSR = false) {
  return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
}
function isAdornedStart(obj) {
  return obj.startAdornment;
}
function getInputBaseUtilityClass(slot) {
  return generateUtilityClass("MuiInputBase", slot);
}
const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var _InputGlobalStyles;
const rootOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
};
const inputOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
};
const useUtilityClasses$C = (ownerState) => {
  const {
    classes,
    color: color2,
    disabled,
    error,
    endAdornment,
    focused,
    formControl,
    fullWidth,
    hiddenLabel,
    multiline,
    readOnly,
    size: size2,
    startAdornment,
    type
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size2 && size2 !== "medium" && `size${capitalize(size2)}`, multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
    input: ["input", disabled && "disabled", type === "search" && "inputTypeSearch", multiline && "inputMultiline", size2 === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
  };
  return composeClasses(slots, getInputBaseUtilityClass, classes);
};
const InputBaseRoot = styled("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(memoTheme(({
  theme: theme2
}) => ({
  ...theme2.typography.body1,
  color: (theme2.vars || theme2).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${inputBaseClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled,
    cursor: "default"
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.multiline,
    style: {
      padding: "4px 0 5px"
    }
  }, {
    props: ({
      ownerState,
      size: size2
    }) => ownerState.multiline && size2 === "small",
    style: {
      paddingTop: 1
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.fullWidth,
    style: {
      width: "100%"
    }
  }]
})));
const InputBaseInput = styled("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(memoTheme(({
  theme: theme2
}) => {
  const light2 = theme2.palette.mode === "light";
  const placeholder = {
    color: "currentColor",
    ...theme2.vars ? {
      opacity: theme2.vars.opacity.inputPlaceholder
    } : {
      opacity: light2 ? 0.42 : 0.5
    },
    transition: theme2.transitions.create("opacity", {
      duration: theme2.transitions.duration.shorter
    })
  };
  const placeholderHidden = {
    opacity: "0 !important"
  };
  const placeholderVisible = theme2.vars ? {
    opacity: theme2.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  };
  return {
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    "&::-webkit-input-placeholder": placeholder,
    "&::-moz-placeholder": placeholder,
    // Firefox 19+
    "&::-ms-input-placeholder": placeholder,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${inputBaseClasses.formControl} &`]: {
      "&::-webkit-input-placeholder": placeholderHidden,
      "&::-moz-placeholder": placeholderHidden,
      // Firefox 19+
      "&::-ms-input-placeholder": placeholderHidden,
      // Edge
      "&:focus::-webkit-input-placeholder": placeholderVisible,
      "&:focus::-moz-placeholder": placeholderVisible,
      // Firefox 19+
      "&:focus::-ms-input-placeholder": placeholderVisible
      // Edge
    },
    [`&.${inputBaseClasses.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (theme2.vars || theme2).palette.text.disabled
      // Fix opacity Safari bug
    },
    variants: [{
      props: ({
        ownerState
      }) => !ownerState.disableInjectingGlobalStyles,
      style: {
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline,
      style: {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }
    }, {
      props: {
        type: "search"
      },
      style: {
        MozAppearance: "textfield"
        // Improve type search style.
      }
    }]
  };
}));
const InputGlobalStyles = globalCss({
  "@keyframes mui-auto-fill": {
    from: {
      display: "block"
    }
  },
  "@keyframes mui-auto-fill-cancel": {
    from: {
      display: "block"
    }
  }
});
const InputBase = /* @__PURE__ */ reactExports.forwardRef(function InputBase2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInputBase"
  });
  const {
    "aria-describedby": ariaDescribedby,
    autoComplete,
    autoFocus,
    className,
    color: color2,
    components = {},
    componentsProps = {},
    defaultValue,
    disabled,
    disableInjectingGlobalStyles,
    endAdornment,
    error,
    fullWidth = false,
    id,
    inputComponent = "input",
    inputProps: inputPropsProp = {},
    inputRef: inputRefProp,
    margin: margin2,
    maxRows,
    minRows,
    multiline = false,
    name,
    onBlur,
    onChange,
    onClick,
    onFocus,
    onKeyDown,
    onKeyUp,
    placeholder,
    readOnly,
    renderSuffix,
    rows,
    size: size2,
    slotProps = {},
    slots = {},
    startAdornment,
    type = "text",
    value: valueProp,
    ...other
  } = props;
  const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef();
  const handleInputRefWarning = reactExports.useCallback((instance) => {
  }, []);
  const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
  const [focused, setFocused] = reactExports.useState(false);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused;
  reactExports.useEffect(() => {
    if (!muiFormControl && disabled && focused) {
      setFocused(false);
      if (onBlur) {
        onBlur();
      }
    }
  }, [muiFormControl, disabled, focused, onBlur]);
  const onFilled = muiFormControl && muiFormControl.onFilled;
  const onEmpty = muiFormControl && muiFormControl.onEmpty;
  const checkDirty = reactExports.useCallback((obj) => {
    if (isFilled(obj)) {
      if (onFilled) {
        onFilled();
      }
    } else if (onEmpty) {
      onEmpty();
    }
  }, [onFilled, onEmpty]);
  useEnhancedEffect(() => {
    if (isControlled) {
      checkDirty({
        value
      });
    }
  }, [value, checkDirty, isControlled]);
  const handleFocus = (event) => {
    if (onFocus) {
      onFocus(event);
    }
    if (inputPropsProp.onFocus) {
      inputPropsProp.onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    } else {
      setFocused(true);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (inputPropsProp.onBlur) {
      inputPropsProp.onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    } else {
      setFocused(false);
    }
  };
  const handleChange = (event, ...args) => {
    if (!isControlled) {
      const element = event.target || inputRef.current;
      if (element == null) {
        throw new Error(formatMuiErrorMessage(1));
      }
      checkDirty({
        value: element.value
      });
    }
    if (inputPropsProp.onChange) {
      inputPropsProp.onChange(event, ...args);
    }
    if (onChange) {
      onChange(event, ...args);
    }
  };
  reactExports.useEffect(() => {
    checkDirty(inputRef.current);
  }, []);
  const handleClick = (event) => {
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  let InputComponent = inputComponent;
  let inputProps = inputPropsProp;
  if (multiline && InputComponent === "input") {
    if (rows) {
      inputProps = {
        type: void 0,
        minRows: rows,
        maxRows: rows,
        ...inputProps
      };
    } else {
      inputProps = {
        type: void 0,
        maxRows,
        minRows,
        ...inputProps
      };
    }
    InputComponent = TextareaAutosize;
  }
  const handleAutoFill = (event) => {
    checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
      value: "x"
    });
  };
  reactExports.useEffect(() => {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  const ownerState = {
    ...props,
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    endAdornment,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    startAdornment,
    type
  };
  const classes = useUtilityClasses$C(ownerState);
  const Root = slots.root || components.Root || InputBaseRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const Input3 = slots.input || components.Input || InputBaseInput;
  inputProps = {
    ...inputProps,
    ...slotProps.input ?? componentsProps.input
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [!disableInjectingGlobalStyles && typeof InputGlobalStyles === "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
    // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
    (_InputGlobalStyles || (_InputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(InputGlobalStyles, {}))), /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, {
      ...rootProps,
      ref: ref2,
      onClick: handleClick,
      ...other,
      ...!isHostComponent(Root) && {
        ownerState: {
          ...ownerState,
          ...rootProps.ownerState
        }
      },
      className: clsx(classes.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
      children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
        value: null,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input3, {
          "aria-invalid": fcs.error,
          "aria-describedby": ariaDescribedby,
          autoComplete,
          autoFocus,
          defaultValue,
          disabled: fcs.disabled,
          id,
          onAnimationStart: handleAutoFill,
          name,
          placeholder,
          readOnly,
          required: fcs.required,
          rows,
          value,
          onKeyDown,
          onKeyUp,
          type,
          ...inputProps,
          ...!isHostComponent(Input3) && {
            as: InputComponent,
            ownerState: {
              ...ownerState,
              ...inputProps.ownerState
            }
          },
          ref: handleInputRef,
          className: clsx(classes.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
          onBlur: handleBlur,
          onChange: handleChange,
          onFocus: handleFocus
        })
      }), endAdornment, renderSuffix ? renderSuffix({
        ...fcs,
        startAdornment
      }) : null]
    })]
  });
});
function getInputUtilityClass(slot) {
  return generateUtilityClass("MuiInput", slot);
}
const inputClasses = {
  ...inputBaseClasses,
  ...generateUtilityClasses("MuiInput", ["root", "underline", "input"])
};
function getOutlinedInputUtilityClass(slot) {
  return generateUtilityClass("MuiOutlinedInput", slot);
}
const outlinedInputClasses = {
  ...inputBaseClasses,
  ...generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"])
};
function getFilledInputUtilityClass(slot) {
  return generateUtilityClass("MuiFilledInput", slot);
}
const filledInputClasses = {
  ...inputBaseClasses,
  ...generateUtilityClasses("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
};
const ArrowDropDownIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M7 10l5 5 5-5z"
}));
const Person = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
}));
function getAvatarUtilityClass(slot) {
  return generateUtilityClass("MuiAvatar", slot);
}
generateUtilityClasses("MuiAvatar", ["root", "colorDefault", "circular", "rounded", "square", "img", "fallback"]);
const useUtilityClasses$B = (ownerState) => {
  const {
    classes,
    variant,
    colorDefault
  } = ownerState;
  const slots = {
    root: ["root", variant, colorDefault && "colorDefault"],
    img: ["img"],
    fallback: ["fallback"]
  };
  return composeClasses(slots, getAvatarUtilityClass, classes);
};
const AvatarRoot = styled("div", {
  name: "MuiAvatar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], ownerState.colorDefault && styles2.colorDefault];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "relative",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0,
  width: 40,
  height: 40,
  fontFamily: theme2.typography.fontFamily,
  fontSize: theme2.typography.pxToRem(20),
  lineHeight: 1,
  borderRadius: "50%",
  overflow: "hidden",
  userSelect: "none",
  variants: [{
    props: {
      variant: "rounded"
    },
    style: {
      borderRadius: (theme2.vars || theme2).shape.borderRadius
    }
  }, {
    props: {
      variant: "square"
    },
    style: {
      borderRadius: 0
    }
  }, {
    props: {
      colorDefault: true
    },
    style: {
      color: (theme2.vars || theme2).palette.background.default,
      ...theme2.vars ? {
        backgroundColor: theme2.vars.palette.Avatar.defaultBg
      } : {
        backgroundColor: theme2.palette.grey[400],
        ...theme2.applyStyles("dark", {
          backgroundColor: theme2.palette.grey[600]
        })
      }
    }
  }]
})));
const AvatarImg = styled("img", {
  name: "MuiAvatar",
  slot: "Img"
})({
  width: "100%",
  height: "100%",
  textAlign: "center",
  // Handle non-square image.
  objectFit: "cover",
  // Hide alt text.
  color: "transparent",
  // Hide the image broken icon, only works on Chrome.
  textIndent: 1e4
});
const AvatarFallback = styled(Person, {
  name: "MuiAvatar",
  slot: "Fallback"
})({
  width: "75%",
  height: "75%"
});
function useLoaded({
  crossOrigin,
  referrerPolicy,
  src: src2,
  srcSet
}) {
  const [loaded, setLoaded] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!src2 && !srcSet) {
      return void 0;
    }
    setLoaded(false);
    let active = true;
    const image = new Image();
    image.onload = () => {
      if (!active) {
        return;
      }
      setLoaded("loaded");
    };
    image.onerror = () => {
      if (!active) {
        return;
      }
      setLoaded("error");
    };
    image.crossOrigin = crossOrigin;
    image.referrerPolicy = referrerPolicy;
    image.src = src2;
    if (srcSet) {
      image.srcset = srcSet;
    }
    return () => {
      active = false;
    };
  }, [crossOrigin, referrerPolicy, src2, srcSet]);
  return loaded;
}
const Avatar = /* @__PURE__ */ reactExports.forwardRef(function Avatar2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiAvatar"
  });
  const {
    alt,
    children: childrenProp,
    className,
    component = "div",
    slots = {},
    slotProps = {},
    imgProps,
    sizes,
    src: src2,
    srcSet,
    variant = "circular",
    ...other
  } = props;
  let children = null;
  const ownerState = {
    ...props,
    component,
    variant
  };
  const loaded = useLoaded({
    ...imgProps,
    ...typeof slotProps.img === "function" ? slotProps.img(ownerState) : slotProps.img,
    src: src2,
    srcSet
  });
  const hasImg = src2 || srcSet;
  const hasImgNotFailing = hasImg && loaded !== "error";
  ownerState.colorDefault = !hasImgNotFailing;
  delete ownerState.ownerState;
  const classes = useUtilityClasses$B(ownerState);
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref: ref2,
    className: clsx(classes.root, className),
    elementType: AvatarRoot,
    externalForwardedProps: {
      slots,
      slotProps,
      component,
      ...other
    },
    ownerState
  });
  const [ImgSlot, imgSlotProps] = useSlot("img", {
    className: classes.img,
    elementType: AvatarImg,
    externalForwardedProps: {
      slots,
      slotProps: {
        img: {
          ...imgProps,
          ...slotProps.img
        }
      }
    },
    additionalProps: {
      alt,
      src: src2,
      srcSet,
      sizes
    },
    ownerState
  });
  const [FallbackSlot, fallbackSlotProps] = useSlot("fallback", {
    className: classes.fallback,
    elementType: AvatarFallback,
    externalForwardedProps: {
      slots,
      slotProps
    },
    shouldForwardComponentProp: true,
    ownerState
  });
  if (hasImgNotFailing) {
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(ImgSlot, {
      ...imgSlotProps
    });
  } else if (!!childrenProp || childrenProp === 0) {
    children = childrenProp;
  } else if (hasImg && alt) {
    children = alt[0];
  } else {
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackSlot, {
      ...fallbackSlotProps
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, {
    ...rootSlotProps,
    children
  });
});
const styles$2h = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref2) {
  const theme2 = useTheme();
  const defaultTimeout = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition,
    ...other
  } = props;
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, getReactElementRef(children), ref2);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout,
    ...other,
    children: (state2, {
      ownerState,
      ...restChildProps
    }) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, {
        style: {
          opacity: 0,
          visibility: state2 === "exited" && !inProp ? "hidden" : void 0,
          ...styles$2h[state2],
          ...style2,
          ...children.props.style
        },
        ref: handleRef,
        ...restChildProps
      });
    }
  });
});
function getBackdropUtilityClass(slot) {
  return generateUtilityClass("MuiBackdrop", slot);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const useUtilityClasses$A = (ownerState) => {
  const {
    classes,
    invisible
  } = ownerState;
  const slots = {
    root: ["root", invisible && "invisible"]
  };
  return composeClasses(slots, getBackdropUtilityClass, classes);
};
const BackdropRoot = styled("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.invisible && styles2.invisible];
  }
})({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent",
  variants: [{
    props: {
      invisible: true
    },
    style: {
      backgroundColor: "transparent"
    }
  }]
});
const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBackdrop"
  });
  const {
    children,
    className,
    component = "div",
    invisible = false,
    open,
    components = {},
    componentsProps = {},
    slotProps = {},
    slots = {},
    TransitionComponent: TransitionComponentProp,
    transitionDuration,
    ...other
  } = props;
  const ownerState = {
    ...props,
    component,
    invisible
  };
  const classes = useUtilityClasses$A(ownerState);
  const backwardCompatibleSlots = {
    transition: TransitionComponentProp,
    root: components.Root,
    ...slots
  };
  const backwardCompatibleSlotProps = {
    ...componentsProps,
    ...slotProps
  };
  const externalForwardedProps = {
    component,
    slots: backwardCompatibleSlots,
    slotProps: backwardCompatibleSlotProps
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: BackdropRoot,
    externalForwardedProps,
    className: clsx(classes.root, className),
    ownerState
  });
  const [TransitionSlot, transitionProps] = useSlot("transition", {
    elementType: Fade,
    externalForwardedProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, {
    in: open,
    timeout: transitionDuration,
    ...other,
    ...transitionProps,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, {
      "aria-hidden": true,
      ...rootProps,
      classes,
      ref: ref2,
      children
    })
  });
});
function getBottomNavigationUtilityClass(slot) {
  return generateUtilityClass("MuiBottomNavigation", slot);
}
generateUtilityClasses("MuiBottomNavigation", ["root"]);
const useUtilityClasses$z = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getBottomNavigationUtilityClass, classes);
};
const BottomNavigationRoot = styled("div", {
  name: "MuiBottomNavigation",
  slot: "Root"
})(memoTheme(({
  theme: theme2
}) => ({
  display: "flex",
  justifyContent: "center",
  height: 56,
  backgroundColor: (theme2.vars || theme2).palette.background.paper
})));
const BottomNavigation = /* @__PURE__ */ reactExports.forwardRef(function BottomNavigation2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBottomNavigation"
  });
  const {
    children,
    className,
    component = "div",
    onChange,
    showLabels = false,
    value,
    ...other
  } = props;
  const ownerState = {
    ...props,
    component,
    showLabels
  };
  const classes = useUtilityClasses$z(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BottomNavigationRoot, {
    as: component,
    className: clsx(classes.root, className),
    ref: ref2,
    ownerState,
    ...other,
    children: reactExports.Children.map(children, (child, childIndex) => {
      if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
        return null;
      }
      const childValue = child.props.value === void 0 ? childIndex : child.props.value;
      return /* @__PURE__ */ reactExports.cloneElement(child, {
        selected: childValue === value,
        showLabel: child.props.showLabel !== void 0 ? child.props.showLabel : showLabels,
        value: childValue,
        onChange
      });
    })
  });
});
function getBottomNavigationActionUtilityClass(slot) {
  return generateUtilityClass("MuiBottomNavigationAction", slot);
}
const bottomNavigationActionClasses = generateUtilityClasses("MuiBottomNavigationAction", ["root", "iconOnly", "selected", "label"]);
const useUtilityClasses$y = (ownerState) => {
  const {
    classes,
    showLabel,
    selected
  } = ownerState;
  const slots = {
    root: ["root", !showLabel && !selected && "iconOnly", selected && "selected"],
    label: ["label", !showLabel && !selected && "iconOnly", selected && "selected"]
  };
  return composeClasses(slots, getBottomNavigationActionUtilityClass, classes);
};
const BottomNavigationActionRoot = styled(ButtonBase, {
  name: "MuiBottomNavigationAction",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.showLabel && !ownerState.selected && styles2.iconOnly];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  transition: theme2.transitions.create(["color", "padding-top"], {
    duration: theme2.transitions.duration.short
  }),
  padding: "0px 12px",
  minWidth: 80,
  maxWidth: 168,
  color: (theme2.vars || theme2).palette.text.secondary,
  flexDirection: "column",
  flex: "1",
  [`&.${bottomNavigationActionClasses.selected}`]: {
    color: (theme2.vars || theme2).palette.primary.main
  },
  variants: [{
    props: ({
      showLabel,
      selected
    }) => !showLabel && !selected,
    style: {
      paddingTop: 14
    }
  }, {
    props: ({
      showLabel,
      selected,
      label
    }) => !showLabel && !selected && !label,
    style: {
      paddingTop: 0
    }
  }]
})));
const BottomNavigationActionLabel = styled("span", {
  name: "MuiBottomNavigationAction",
  slot: "Label"
})(memoTheme(({
  theme: theme2
}) => ({
  fontFamily: theme2.typography.fontFamily,
  fontSize: theme2.typography.pxToRem(12),
  opacity: 1,
  transition: "font-size 0.2s, opacity 0.2s",
  transitionDelay: "0.1s",
  [`&.${bottomNavigationActionClasses.selected}`]: {
    fontSize: theme2.typography.pxToRem(14)
  },
  variants: [{
    props: ({
      showLabel,
      selected
    }) => !showLabel && !selected,
    style: {
      opacity: 0,
      transitionDelay: "0s"
    }
  }]
})));
const BottomNavigationAction = /* @__PURE__ */ reactExports.forwardRef(function BottomNavigationAction2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiBottomNavigationAction"
  });
  const {
    className,
    icon,
    label,
    onChange,
    onClick,
    // eslint-disable-next-line react/prop-types -- private, always overridden by BottomNavigation
    selected,
    showLabel,
    value,
    slots = {},
    slotProps = {},
    ...other
  } = props;
  const ownerState = props;
  const classes = useUtilityClasses$y(ownerState);
  const handleChange = (event) => {
    if (onChange) {
      onChange(event, value);
    }
    if (onClick) {
      onClick(event);
    }
  };
  const externalForwardedProps = {
    slots,
    slotProps
  };
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: BottomNavigationActionRoot,
    externalForwardedProps: {
      ...externalForwardedProps,
      ...other
    },
    shouldForwardComponentProp: true,
    ownerState,
    ref: ref2,
    className: clsx(classes.root, className),
    additionalProps: {
      focusRipple: true
    },
    getSlotProps: (handlers) => ({
      ...handlers,
      onClick: (event) => {
        handlers.onClick?.(event);
        handleChange(event);
      }
    })
  });
  const [LabelSlot, labelProps] = useSlot("label", {
    elementType: BottomNavigationActionLabel,
    externalForwardedProps,
    ownerState,
    className: classes.label
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
    ...rootProps,
    children: [icon, /* @__PURE__ */ jsxRuntimeExports.jsx(LabelSlot, {
      ...labelProps,
      children: label
    })]
  });
});
const boxClasses = generateUtilityClasses("MuiBox", ["root"]);
const defaultTheme = createTheme();
const Box = createBox({
  themeId: THEME_ID,
  defaultTheme,
  defaultClassName: boxClasses.root,
  generateClassName: ClassNameGenerator.generate
});
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]);
const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
const ButtonGroupButtonContext = /* @__PURE__ */ reactExports.createContext(void 0);
const useUtilityClasses$x = (ownerState) => {
  const {
    color: color2,
    disableElevation,
    fullWidth,
    size: size2,
    variant,
    loading,
    loadingPosition,
    classes
  } = ownerState;
  const slots = {
    root: ["root", loading && "loading", variant, `${variant}${capitalize(color2)}`, `size${capitalize(size2)}`, `${variant}Size${capitalize(size2)}`, `color${capitalize(color2)}`, disableElevation && "disableElevation", fullWidth && "fullWidth", loading && `loadingPosition${capitalize(loadingPosition)}`],
    startIcon: ["icon", "startIcon", `iconSize${capitalize(size2)}`],
    endIcon: ["icon", "endIcon", `iconSize${capitalize(size2)}`],
    loadingIndicator: ["loadingIndicator"],
    loadingWrapper: ["loadingWrapper"]
  };
  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
  return {
    ...classes,
    // forward the focused, disabled, etc. classes to the ButtonBase
    ...composedClasses
  };
};
const commonIconStyles = [{
  props: {
    size: "small"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }
}, {
  props: {
    size: "medium"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }
}, {
  props: {
    size: "large"
  },
  style: {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }
}];
const ButtonRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color)}`], styles2[`size${capitalize(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth, ownerState.loading && styles2.loading];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const inheritContainedBackgroundColor = theme2.palette.mode === "light" ? theme2.palette.grey[300] : theme2.palette.grey[800];
  const inheritContainedHoverBackgroundColor = theme2.palette.mode === "light" ? theme2.palette.grey.A100 : theme2.palette.grey[700];
  return {
    ...theme2.typography.button,
    minWidth: 64,
    padding: "6px 16px",
    border: 0,
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme2.transitions.duration.short
    }),
    "&:hover": {
      textDecoration: "none"
    },
    [`&.${buttonClasses.disabled}`]: {
      color: (theme2.vars || theme2).palette.action.disabled
    },
    variants: [{
      props: {
        variant: "contained"
      },
      style: {
        color: `var(--variant-containedColor)`,
        backgroundColor: `var(--variant-containedBg)`,
        boxShadow: (theme2.vars || theme2).shadows[2],
        "&:hover": {
          boxShadow: (theme2.vars || theme2).shadows[4],
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            boxShadow: (theme2.vars || theme2).shadows[2]
          }
        },
        "&:active": {
          boxShadow: (theme2.vars || theme2).shadows[8]
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: (theme2.vars || theme2).shadows[6]
        },
        [`&.${buttonClasses.disabled}`]: {
          color: (theme2.vars || theme2).palette.action.disabled,
          boxShadow: (theme2.vars || theme2).shadows[0],
          backgroundColor: (theme2.vars || theme2).palette.action.disabledBackground
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        padding: "5px 15px",
        border: "1px solid currentColor",
        borderColor: `var(--variant-outlinedBorder, currentColor)`,
        backgroundColor: `var(--variant-outlinedBg)`,
        color: `var(--variant-outlinedColor)`,
        [`&.${buttonClasses.disabled}`]: {
          border: `1px solid ${(theme2.vars || theme2).palette.action.disabledBackground}`
        }
      }
    }, {
      props: {
        variant: "text"
      },
      style: {
        padding: "6px 8px",
        color: `var(--variant-textColor)`,
        backgroundColor: `var(--variant-textBg)`
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        "--variant-textColor": (theme2.vars || theme2).palette[color2].main,
        "--variant-outlinedColor": (theme2.vars || theme2).palette[color2].main,
        "--variant-outlinedBorder": theme2.alpha((theme2.vars || theme2).palette[color2].main, 0.5),
        "--variant-containedColor": (theme2.vars || theme2).palette[color2].contrastText,
        "--variant-containedBg": (theme2.vars || theme2).palette[color2].main,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": (theme2.vars || theme2).palette[color2].dark,
            "--variant-textBg": theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity),
            "--variant-outlinedBorder": (theme2.vars || theme2).palette[color2].main,
            "--variant-outlinedBg": theme2.alpha((theme2.vars || theme2).palette[color2].main, (theme2.vars || theme2).palette.action.hoverOpacity)
          }
        }
      }
    })), {
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit",
        borderColor: "currentColor",
        "--variant-containedBg": theme2.vars ? theme2.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
        "@media (hover: hover)": {
          "&:hover": {
            "--variant-containedBg": theme2.vars ? theme2.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
            "--variant-textBg": theme2.alpha((theme2.vars || theme2).palette.text.primary, (theme2.vars || theme2).palette.action.hoverOpacity),
            "--variant-outlinedBg": theme2.alpha((theme2.vars || theme2).palette.text.primary, (theme2.vars || theme2).palette.action.hoverOpacity)
          }
        }
      }
    }, {
      props: {
        size: "small",
        variant: "text"
      },
      style: {
        padding: "4px 5px",
        fontSize: theme2.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "text"
      },
      style: {
        padding: "8px 11px",
        fontSize: theme2.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "outlined"
      },
      style: {
        padding: "3px 9px",
        fontSize: theme2.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "outlined"
      },
      style: {
        padding: "7px 21px",
        fontSize: theme2.typography.pxToRem(15)
      }
    }, {
      props: {
        size: "small",
        variant: "contained"
      },
      style: {
        padding: "4px 10px",
        fontSize: theme2.typography.pxToRem(13)
      }
    }, {
      props: {
        size: "large",
        variant: "contained"
      },
      style: {
        padding: "8px 22px",
        fontSize: theme2.typography.pxToRem(15)
      }
    }, {
      props: {
        disableElevation: true
      },
      style: {
        boxShadow: "none",
        "&:hover": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.focusVisible}`]: {
          boxShadow: "none"
        },
        "&:active": {
          boxShadow: "none"
        },
        [`&.${buttonClasses.disabled}`]: {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        fullWidth: true
      },
      style: {
        width: "100%"
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        transition: theme2.transitions.create(["background-color", "box-shadow", "border-color"], {
          duration: theme2.transitions.duration.short
        }),
        [`&.${buttonClasses.loading}`]: {
          color: "transparent"
        }
      }
    }]
  };
}));
const ButtonStartIcon = styled("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.startIcon, ownerState.loading && styles2.startIconLoadingStart, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  theme: theme2
}) => ({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginLeft: -2
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: true
    },
    style: {
      transition: theme2.transitions.create(["opacity"], {
        duration: theme2.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "start",
      loading: true,
      fullWidth: true
    },
    style: {
      marginRight: -8
    }
  }, ...commonIconStyles]
}));
const ButtonEndIcon = styled("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.endIcon, ownerState.loading && styles2.endIconLoadingEnd, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  theme: theme2
}) => ({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8,
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginRight: -2
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: true
    },
    style: {
      transition: theme2.transitions.create(["opacity"], {
        duration: theme2.transitions.duration.short
      }),
      opacity: 0
    }
  }, {
    props: {
      loadingPosition: "end",
      loading: true,
      fullWidth: true
    },
    style: {
      marginLeft: -8
    }
  }, ...commonIconStyles]
}));
const ButtonLoadingIndicator = styled("span", {
  name: "MuiButton",
  slot: "LoadingIndicator"
})(({
  theme: theme2
}) => ({
  display: "none",
  position: "absolute",
  visibility: "visible",
  variants: [{
    props: {
      loading: true
    },
    style: {
      display: "flex"
    }
  }, {
    props: {
      loadingPosition: "start"
    },
    style: {
      left: 14
    }
  }, {
    props: {
      loadingPosition: "start",
      size: "small"
    },
    style: {
      left: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "start"
    },
    style: {
      left: 6
    }
  }, {
    props: {
      loadingPosition: "center"
    },
    style: {
      left: "50%",
      transform: "translate(-50%)",
      color: (theme2.vars || theme2).palette.action.disabled
    }
  }, {
    props: {
      loadingPosition: "end"
    },
    style: {
      right: 14
    }
  }, {
    props: {
      loadingPosition: "end",
      size: "small"
    },
    style: {
      right: 10
    }
  }, {
    props: {
      variant: "text",
      loadingPosition: "end"
    },
    style: {
      right: 6
    }
  }, {
    props: {
      loadingPosition: "start",
      fullWidth: true
    },
    style: {
      position: "relative",
      left: -10
    }
  }, {
    props: {
      loadingPosition: "end",
      fullWidth: true
    },
    style: {
      position: "relative",
      right: -10
    }
  }]
}));
const ButtonLoadingIconPlaceholder = styled("span", {
  name: "MuiButton",
  slot: "LoadingIconPlaceholder"
})({
  display: "inline-block",
  width: "1em",
  height: "1em"
});
const Button = /* @__PURE__ */ reactExports.forwardRef(function Button2(inProps, ref2) {
  const contextProps = reactExports.useContext(ButtonGroupContext);
  const buttonGroupButtonContextPositionClassName = reactExports.useContext(ButtonGroupButtonContext);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useDefaultProps({
    props: resolvedProps,
    name: "MuiButton"
  });
  const {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    id: idProp,
    loading = null,
    loadingIndicator: loadingIndicatorProp,
    loadingPosition = "center",
    size: size2 = "medium",
    startIcon: startIconProp,
    type,
    variant = "text",
    ...other
  } = props;
  const loadingId = useId(idProp);
  const loadingIndicator = loadingIndicatorProp ?? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {
    "aria-labelledby": loadingId,
    color: "inherit",
    size: 16
  });
  const ownerState = {
    ...props,
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    loading,
    loadingIndicator,
    loadingPosition,
    size: size2,
    type,
    variant
  };
  const classes = useUtilityClasses$x(ownerState);
  const startIcon = (startIconProp || loading && loadingPosition === "start") && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp || /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
      className: classes.loadingIconPlaceholder,
      ownerState
    })
  });
  const endIcon = (endIconProp || loading && loadingPosition === "end") && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp || /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
      className: classes.loadingIconPlaceholder,
      ownerState
    })
  });
  const positionClassName = buttonGroupButtonContextPositionClassName || "";
  const loader = typeof loading === "boolean" ? (
    // use plain HTML span to minimize the runtime overhead
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: classes.loadingWrapper,
      style: {
        display: "contents"
      },
      children: loading && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonLoadingIndicator, {
        className: classes.loadingIndicator,
        ownerState,
        children: loadingIndicator
      })
    })
  ) : null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, {
    ownerState,
    className: clsx(contextProps.className, classes.root, className, positionClassName),
    component,
    disabled: disabled || loading,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref: ref2,
    type,
    id: loading ? loadingId : idProp,
    ...other,
    classes,
    children: [startIcon, loadingPosition !== "end" && loader, children, loadingPosition === "end" && loader, endIcon]
  });
});
function getCardUtilityClass(slot) {
  return generateUtilityClass("MuiCard", slot);
}
generateUtilityClasses("MuiCard", ["root"]);
const useUtilityClasses$w = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getCardUtilityClass, classes);
};
const CardRoot = styled(Paper, {
  name: "MuiCard",
  slot: "Root"
})({
  overflow: "hidden"
});
const Card = /* @__PURE__ */ reactExports.forwardRef(function Card2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCard"
  });
  const {
    className,
    raised = false,
    ...other
  } = props;
  const ownerState = {
    ...props,
    raised
  };
  const classes = useUtilityClasses$w(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CardRoot, {
    className: clsx(classes.root, className),
    elevation: raised ? 8 : void 0,
    ref: ref2,
    ownerState,
    ...other
  });
});
function getCardContentUtilityClass(slot) {
  return generateUtilityClass("MuiCardContent", slot);
}
generateUtilityClasses("MuiCardContent", ["root"]);
const useUtilityClasses$v = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getCardContentUtilityClass, classes);
};
const CardContentRoot = styled("div", {
  name: "MuiCardContent",
  slot: "Root"
})({
  padding: 16,
  "&:last-child": {
    paddingBottom: 24
  }
});
const CardContent = /* @__PURE__ */ reactExports.forwardRef(function CardContent2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCardContent"
  });
  const {
    className,
    component = "div",
    ...other
  } = props;
  const ownerState = {
    ...props,
    component
  };
  const classes = useUtilityClasses$v(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CardContentRoot, {
    as: component,
    className: clsx(classes.root, className),
    ownerState,
    ref: ref2,
    ...other
  });
});
function mapEventPropToEvent(eventProp) {
  return eventProp.substring(2).toLowerCase();
}
function clickedRootScrollbar(event, doc) {
  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
}
function ClickAwayListener(props) {
  const {
    children,
    disableReactTree = false,
    mouseEvent = "onClick",
    onClickAway,
    touchEvent = "onTouchEnd"
  } = props;
  const movedRef = reactExports.useRef(false);
  const nodeRef = reactExports.useRef(null);
  const activatedRef = reactExports.useRef(false);
  const syntheticEventRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    setTimeout(() => {
      activatedRef.current = true;
    }, 0);
    return () => {
      activatedRef.current = false;
    };
  }, []);
  const handleRef = useForkRef(getReactElementRef(children), nodeRef);
  const handleClickAway = useEventCallback((event) => {
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc = ownerDocument(nodeRef.current);
    if (!activatedRef.current || !nodeRef.current || "clientX" in event && clickedRootScrollbar(event, doc)) {
      return;
    }
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    let insideDOM;
    if (event.composedPath) {
      insideDOM = event.composedPath().includes(nodeRef.current);
    } else {
      insideDOM = !doc.documentElement.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      ) || nodeRef.current.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      );
    }
    if (!insideDOM && (disableReactTree || !insideReactTree)) {
      onClickAway(event);
    }
  });
  const createHandleSynthetic = (handlerName) => (event) => {
    syntheticEventRef.current = true;
    const childrenPropsHandler = children.props[handlerName];
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const childrenProps = {
    ref: handleRef
  };
  if (touchEvent !== false) {
    childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
  }
  reactExports.useEffect(() => {
    if (touchEvent !== false) {
      const mappedTouchEvent = mapEventPropToEvent(touchEvent);
      const doc = ownerDocument(nodeRef.current);
      const handleTouchMove = () => {
        movedRef.current = true;
      };
      doc.addEventListener(mappedTouchEvent, handleClickAway);
      doc.addEventListener("touchmove", handleTouchMove);
      return () => {
        doc.removeEventListener(mappedTouchEvent, handleClickAway);
        doc.removeEventListener("touchmove", handleTouchMove);
      };
    }
    return void 0;
  }, [handleClickAway, touchEvent]);
  if (mouseEvent !== false) {
    childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
  }
  reactExports.useEffect(() => {
    if (mouseEvent !== false) {
      const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
      const doc = ownerDocument(nodeRef.current);
      doc.addEventListener(mappedMouseEvent, handleClickAway);
      return () => {
        doc.removeEventListener(mappedMouseEvent, handleClickAway);
      };
    }
    return void 0;
  }, [handleClickAway, mouseEvent]);
  return /* @__PURE__ */ reactExports.cloneElement(children, childrenProps);
}
const Container = createContainer({
  createStyledComponent: styled("div", {
    name: "MuiContainer",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
    }
  }),
  useThemeProps: (inProps) => useDefaultProps({
    props: inProps,
    name: "MuiContainer"
  })
});
const isDynamicSupport = typeof globalCss({}) === "function";
const html = (theme2, enableColorScheme) => ({
  WebkitFontSmoothing: "antialiased",
  // Antialiasing.
  MozOsxFontSmoothing: "grayscale",
  // Antialiasing.
  // Change from `box-sizing: content-box` so that `width`
  // is not affected by `padding` or `border`.
  boxSizing: "border-box",
  // Fix font resize problem in iOS
  WebkitTextSizeAdjust: "100%",
  // When used under CssVarsProvider, colorScheme should not be applied dynamically because it will generate the stylesheet twice for server-rendered applications.
  ...enableColorScheme && !theme2.vars && {
    colorScheme: theme2.palette.mode
  }
});
const body = (theme2) => ({
  color: (theme2.vars || theme2).palette.text.primary,
  ...theme2.typography.body1,
  backgroundColor: (theme2.vars || theme2).palette.background.default,
  "@media print": {
    // Save printer ink.
    backgroundColor: (theme2.vars || theme2).palette.common.white
  }
});
const styles$2g = (theme2, enableColorScheme = false) => {
  const colorSchemeStyles = {};
  if (enableColorScheme && theme2.colorSchemes && typeof theme2.getColorSchemeSelector === "function") {
    Object.entries(theme2.colorSchemes).forEach(([key2, scheme]) => {
      const selector = theme2.getColorSchemeSelector(key2);
      if (selector.startsWith("@")) {
        colorSchemeStyles[selector] = {
          ":root": {
            colorScheme: scheme.palette?.mode
          }
        };
      } else {
        colorSchemeStyles[selector.replace(/\s*&/, "")] = {
          colorScheme: scheme.palette?.mode
        };
      }
    });
  }
  let defaultStyles = {
    html: html(theme2, enableColorScheme),
    "*, *::before, *::after": {
      boxSizing: "inherit"
    },
    "strong, b": {
      fontWeight: theme2.typography.fontWeightBold
    },
    body: {
      margin: 0,
      // Remove the margin in all browsers.
      ...body(theme2),
      // Add support for document.body.requestFullScreen().
      // Other elements, if background transparent, are not supported.
      "&::backdrop": {
        backgroundColor: (theme2.vars || theme2).palette.background.default
      }
    },
    ...colorSchemeStyles
  };
  const themeOverrides = theme2.components?.MuiCssBaseline?.styleOverrides;
  if (themeOverrides) {
    defaultStyles = [defaultStyles, themeOverrides];
  }
  return defaultStyles;
};
const SELECTOR = "mui-ecs";
const staticStyles = (theme2) => {
  const result = styles$2g(theme2, false);
  const baseStyles = Array.isArray(result) ? result[0] : result;
  if (!theme2.vars && baseStyles) {
    baseStyles.html[`:root:has(${SELECTOR})`] = {
      colorScheme: theme2.palette.mode
    };
  }
  if (theme2.colorSchemes) {
    Object.entries(theme2.colorSchemes).forEach(([key2, scheme]) => {
      const selector = theme2.getColorSchemeSelector(key2);
      if (selector.startsWith("@")) {
        baseStyles[selector] = {
          [`:root:not(:has(.${SELECTOR}))`]: {
            colorScheme: scheme.palette?.mode
          }
        };
      } else {
        baseStyles[selector.replace(/\s*&/, "")] = {
          [`&:not(:has(.${SELECTOR}))`]: {
            colorScheme: scheme.palette?.mode
          }
        };
      }
    });
  }
  return result;
};
const GlobalStyles = globalCss(isDynamicSupport ? ({
  theme: theme2,
  enableColorScheme
}) => styles$2g(theme2, enableColorScheme) : ({
  theme: theme2
}) => staticStyles(theme2));
function CssBaseline(inProps) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCssBaseline"
  });
  const {
    children,
    enableColorScheme = false
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [isDynamicSupport && /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
      enableColorScheme
    }), !isDynamicSupport && !enableColorScheme && /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: SELECTOR,
      style: {
        display: "none"
      }
    }), children]
  });
}
function getScrollbarSize(win = window) {
  const documentWidth = win.document.documentElement.clientWidth;
  return win.innerWidth - documentWidth;
}
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, hide2) {
  if (hide2) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.includes(element.tagName);
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, hide2) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = !blacklist.includes(element);
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, hide2);
    }
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index2) => {
    if (callback(item)) {
      idx = index2;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerWindow(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent2 = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = parent2?.nodeName === "HTML" && containerWindow.getComputedStyle(parent2).overflowY === "scroll" ? parent2 : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el,
      property
    }) => {
      if (value) {
        el.style.setProperty(property, value);
      } else {
        el.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
class ModalManager {
  constructor() {
    this.modals = [];
    this.containers = [];
  }
  add(modal2, container) {
    let modalIndex = this.modals.indexOf(modal2);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal2);
    if (modal2.modalRef) {
      ariaHidden(modal2.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal2.mount, modal2.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal2);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal2],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal2, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.includes(modal2));
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal2, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal2);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.includes(modal2));
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal2), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal2.modalRef) {
        ariaHidden(modal2.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal2.mount, modal2.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal2) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal2;
  }
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
function isNonTabbableRadio(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
function isNodeMatchingSelectorFocusable(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node2, i4) => {
    const nodeTabIndex = getTabIndex(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i4,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a2, b2) => a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex).map((a2) => a2.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = reactExports.useRef(false);
  const sentinelStart = reactExports.useRef(null);
  const sentinelEnd = reactExports.useRef(null);
  const nodeToRestore = reactExports.useRef(null);
  const reactFocusEventTarget = reactExports.useRef(null);
  const activated = reactExports.useRef(false);
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef(getReactElementRef(children), rootRef);
  const lastKeydown = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", "-1");
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    };
    const contain = () => {
      const rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootElement.contains(doc.activeElement)) {
        return;
      }
      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
        return;
      }
      if (doc.activeElement !== reactFocusEventTarget.current) {
        reactFocusEventTarget.current = null;
      } else if (reactFocusEventTarget.current !== null) {
        return;
      }
      if (!activated.current) {
        return;
      }
      let tabbable = [];
      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
        tabbable = getTabbable(rootRef.current);
      }
      if (tabbable.length > 0) {
        const isShiftTab = Boolean(lastKeydown.current?.shiftKey && lastKeydown.current?.key === "Tab");
        const focusNext = tabbable[0];
        const focusPrevious = tabbable[tabbable.length - 1];
        if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        }
      } else {
        rootElement.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  const onFocus = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ reactExports.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
function getHasTransition(children) {
  return children ? children.props.hasOwnProperty("in") : false;
}
const noop$1 = () => {
};
const manager = new ModalManager();
function useModal(parameters) {
  const {
    container,
    disableEscapeKeyDown = false,
    disableScrollLock = false,
    closeAfterTransition = false,
    onTransitionEnter,
    onTransitionExited,
    children,
    onClose,
    open,
    rootRef
  } = parameters;
  const modal2 = reactExports.useRef({});
  const mountNodeRef = reactExports.useRef(null);
  const modalRef = reactExports.useRef(null);
  const handleRef = useForkRef(modalRef, rootRef);
  const [exited, setExited] = reactExports.useState(!open);
  const hasTransition = getHasTransition(children);
  let ariaHiddenProp = true;
  if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
    ariaHiddenProp = false;
  }
  const getDoc = () => ownerDocument(mountNodeRef.current);
  const getModal = () => {
    modal2.current.modalRef = modalRef.current;
    modal2.current.mount = mountNodeRef.current;
    return modal2.current;
  };
  const handleMounted = () => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  };
  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = () => manager.isTopModal(getModal());
  const handlePortalRef = useEventCallback((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open && isTopModal()) {
      handleMounted();
    } else if (modalRef.current) {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = reactExports.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [ariaHiddenProp]);
  reactExports.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  reactExports.useEffect(() => {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const createHandleKeyDown = (otherHandlers) => (event) => {
    otherHandlers.onKeyDown?.(event);
    if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
    !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  };
  const createHandleBackdropClick = (otherHandlers) => (event) => {
    otherHandlers.onClick?.(event);
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);
    delete propsEventHandlers.onTransitionEnter;
    delete propsEventHandlers.onTransitionExited;
    const externalEventHandlers = {
      ...propsEventHandlers,
      ...otherHandlers
    };
    return {
      /*
       * Marking an element with the role presentation indicates to assistive technology
       * that this element should be ignored; it exists to support the web application and
       * is not meant for humans to interact with directly.
       * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
       */
      role: "presentation",
      ...externalEventHandlers,
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      ref: handleRef
    };
  };
  const getBackdropProps = (otherHandlers = {}) => {
    const externalEventHandlers = otherHandlers;
    return {
      "aria-hidden": true,
      ...externalEventHandlers,
      onClick: createHandleBackdropClick(externalEventHandlers),
      open
    };
  };
  const getTransitionProps2 = () => {
    const handleEnter = () => {
      setExited(false);
      if (onTransitionEnter) {
        onTransitionEnter();
      }
    };
    const handleExited = () => {
      setExited(true);
      if (onTransitionExited) {
        onTransitionExited();
      }
      if (closeAfterTransition) {
        handleClose();
      }
    };
    return {
      onEnter: createChainedFunction(handleEnter, children?.props.onEnter ?? noop$1),
      onExited: createChainedFunction(handleExited, children?.props.onExited ?? noop$1)
    };
  };
  return {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    rootRef: handleRef,
    portalRef: handlePortalRef,
    isTopModal,
    exited,
    hasTransition
  };
}
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const useUtilityClasses$u = (ownerState) => {
  const {
    open,
    exited,
    classes
  } = ownerState;
  const slots = {
    root: ["root", !open && exited && "hidden"],
    backdrop: ["backdrop"]
  };
  return composeClasses(slots, getModalUtilityClass, classes);
};
const ModalRoot = styled("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "fixed",
  zIndex: (theme2.vars || theme2).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.open && ownerState.exited,
    style: {
      visibility: "hidden"
    }
  }]
})));
const ModalBackdrop = styled(Backdrop, {
  name: "MuiModal",
  slot: "Backdrop"
})({
  zIndex: -1
});
const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref2) {
  const props = useDefaultProps({
    name: "MuiModal",
    props: inProps
  });
  const {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    classes: classesProp,
    className,
    closeAfterTransition = false,
    children,
    container,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    onClose,
    onTransitionEnter,
    onTransitionExited,
    open,
    slotProps = {},
    slots = {},
    // eslint-disable-next-line react/prop-types
    theme: theme2,
    ...other
  } = props;
  const propsWithDefaults = {
    ...props,
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  };
  const {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    portalRef,
    isTopModal,
    exited,
    hasTransition
  } = useModal({
    ...propsWithDefaults,
    rootRef: ref2
  });
  const ownerState = {
    ...propsWithDefaults,
    exited
  };
  const classes = useUtilityClasses$u(ownerState);
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    const {
      onEnter,
      onExited
    } = getTransitionProps2();
    childProps.onEnter = onEnter;
    childProps.onExited = onExited;
  }
  const externalForwardedProps = {
    slots: {
      root: components.Root,
      backdrop: components.Backdrop,
      ...slots
    },
    slotProps: {
      ...componentsProps,
      ...slotProps
    }
  };
  const [RootSlot, rootProps] = useSlot("root", {
    ref: ref2,
    elementType: ModalRoot,
    externalForwardedProps: {
      ...externalForwardedProps,
      ...other,
      component
    },
    getSlotProps: getRootProps,
    ownerState,
    className: clsx(className, classes?.root, !ownerState.open && ownerState.exited && classes?.hidden)
  });
  const [BackdropSlot, backdropProps] = useSlot("backdrop", {
    ref: BackdropProps?.ref,
    elementType: BackdropComponent,
    externalForwardedProps,
    shouldForwardComponentProp: true,
    additionalProps: BackdropProps,
    getSlotProps: (otherHandlers) => {
      return getBackdropProps({
        ...otherHandlers,
        onClick: (event) => {
          if (otherHandlers?.onClick) {
            otherHandlers.onClick(event);
          }
        }
      });
    },
    className: clsx(BackdropProps?.className, classes?.backdrop),
    ownerState
  });
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    ref: portalRef,
    container,
    disablePortal,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
      ...rootProps,
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, {
        ...backdropProps
      }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open,
        children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
      })]
    })
  });
});
function getDividerUtilityClass(slot) {
  return generateUtilityClass("MuiDivider", slot);
}
generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
const useUtilityClasses$t = (ownerState) => {
  const {
    absolute,
    children,
    classes,
    flexItem,
    light: light2,
    orientation,
    textAlign,
    variant
  } = ownerState;
  const slots = {
    root: ["root", absolute && "absolute", variant, light2 && "light", orientation === "vertical" && "vertical", flexItem && "flexItem", children && "withChildren", children && orientation === "vertical" && "withChildrenVertical", textAlign === "right" && orientation !== "vertical" && "textAlignRight", textAlign === "left" && orientation !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", orientation === "vertical" && "wrapperVertical"]
  };
  return composeClasses(slots, getDividerUtilityClass, classes);
};
const DividerRoot = styled("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.absolute && styles2.absolute, styles2[ownerState.variant], ownerState.light && styles2.light, ownerState.orientation === "vertical" && styles2.vertical, ownerState.flexItem && styles2.flexItem, ownerState.children && styles2.withChildren, ownerState.children && ownerState.orientation === "vertical" && styles2.withChildrenVertical, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && styles2.textAlignRight, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && styles2.textAlignLeft];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (theme2.vars || theme2).palette.divider,
  borderBottomWidth: "thin",
  variants: [{
    props: {
      absolute: true
    },
    style: {
      position: "absolute",
      bottom: 0,
      left: 0,
      width: "100%"
    }
  }, {
    props: {
      light: true
    },
    style: {
      borderColor: theme2.alpha((theme2.vars || theme2).palette.divider, 0.08)
    }
  }, {
    props: {
      variant: "inset"
    },
    style: {
      marginLeft: 72
    }
  }, {
    props: {
      variant: "middle",
      orientation: "horizontal"
    },
    style: {
      marginLeft: theme2.spacing(2),
      marginRight: theme2.spacing(2)
    }
  }, {
    props: {
      variant: "middle",
      orientation: "vertical"
    },
    style: {
      marginTop: theme2.spacing(1),
      marginBottom: theme2.spacing(1)
    }
  }, {
    props: {
      orientation: "vertical"
    },
    style: {
      height: "100%",
      borderBottomWidth: 0,
      borderRightWidth: "thin"
    }
  }, {
    props: {
      flexItem: true
    },
    style: {
      alignSelf: "stretch",
      height: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.children,
    style: {
      display: "flex",
      textAlign: "center",
      border: 0,
      borderTopStyle: "solid",
      borderLeftStyle: "solid",
      "&::before, &::after": {
        content: '""',
        alignSelf: "center"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.children && ownerState.orientation !== "vertical",
    style: {
      "&::before, &::after": {
        width: "100%",
        borderTop: `thin solid ${(theme2.vars || theme2).palette.divider}`,
        borderTopStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.orientation === "vertical" && ownerState.children,
    style: {
      flexDirection: "column",
      "&::before, &::after": {
        height: "100%",
        borderLeft: `thin solid ${(theme2.vars || theme2).palette.divider}`,
        borderLeftStyle: "inherit"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.textAlign === "right" && ownerState.orientation !== "vertical",
    style: {
      "&::before": {
        width: "90%"
      },
      "&::after": {
        width: "10%"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.textAlign === "left" && ownerState.orientation !== "vertical",
    style: {
      "&::before": {
        width: "10%"
      },
      "&::after": {
        width: "90%"
      }
    }
  }]
})));
const DividerWrapper = styled("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.wrapper, ownerState.orientation === "vertical" && styles2.wrapperVertical];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "inline-block",
  paddingLeft: `calc(${theme2.spacing(1)} * 1.2)`,
  paddingRight: `calc(${theme2.spacing(1)} * 1.2)`,
  whiteSpace: "nowrap",
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      paddingTop: `calc(${theme2.spacing(1)} * 1.2)`,
      paddingBottom: `calc(${theme2.spacing(1)} * 1.2)`
    }
  }]
})));
const Divider = /* @__PURE__ */ reactExports.forwardRef(function Divider2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiDivider"
  });
  const {
    absolute = false,
    children,
    className,
    orientation = "horizontal",
    component = children || orientation === "vertical" ? "div" : "hr",
    flexItem = false,
    light: light2 = false,
    role = component !== "hr" ? "separator" : void 0,
    textAlign = "center",
    variant = "fullWidth",
    ...other
  } = props;
  const ownerState = {
    ...props,
    absolute,
    component,
    flexItem,
    light: light2,
    orientation,
    role,
    textAlign,
    variant
  };
  const classes = useUtilityClasses$t(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DividerRoot, {
    as: component,
    className: clsx(classes.root, className),
    role,
    ref: ref2,
    ownerState,
    "aria-orientation": role === "separator" && (component !== "hr" || orientation === "vertical") ? orientation : void 0,
    ...other,
    children: children ? /* @__PURE__ */ jsxRuntimeExports.jsx(DividerWrapper, {
      className: classes.wrapper,
      ownerState,
      children
    }) : null
  });
});
if (Divider) {
  Divider.muiSkipListHighlight = true;
}
function getTranslateValue(direction, node2, resolvedContainer) {
  const rect = node2.getBoundingClientRect();
  const containerRect = resolvedContainer && resolvedContainer.getBoundingClientRect();
  const containerWindow = ownerWindow(node2);
  let transform;
  if (node2.fakeTransform) {
    transform = node2.fakeTransform;
  } else {
    const computedStyle = containerWindow.getComputedStyle(node2);
    transform = computedStyle.getPropertyValue("-webkit-transform") || computedStyle.getPropertyValue("transform");
  }
  let offsetX = 0;
  let offsetY = 0;
  if (transform && transform !== "none" && typeof transform === "string") {
    const transformValues = transform.split("(")[1].split(")")[0].split(",");
    offsetX = parseInt(transformValues[4], 10);
    offsetY = parseInt(transformValues[5], 10);
  }
  if (direction === "left") {
    if (containerRect) {
      return `translateX(${containerRect.right + offsetX - rect.left}px)`;
    }
    return `translateX(${containerWindow.innerWidth + offsetX - rect.left}px)`;
  }
  if (direction === "right") {
    if (containerRect) {
      return `translateX(-${rect.right - containerRect.left - offsetX}px)`;
    }
    return `translateX(-${rect.left + rect.width - offsetX}px)`;
  }
  if (direction === "up") {
    if (containerRect) {
      return `translateY(${containerRect.bottom + offsetY - rect.top}px)`;
    }
    return `translateY(${containerWindow.innerHeight + offsetY - rect.top}px)`;
  }
  if (containerRect) {
    return `translateY(-${rect.top - containerRect.top + rect.height - offsetY}px)`;
  }
  return `translateY(-${rect.top + rect.height - offsetY}px)`;
}
function resolveContainer(containerPropProp) {
  return typeof containerPropProp === "function" ? containerPropProp() : containerPropProp;
}
function setTranslateValue(direction, node2, containerProp) {
  const resolvedContainer = resolveContainer(containerProp);
  const transform = getTranslateValue(direction, node2, resolvedContainer);
  if (transform) {
    node2.style.webkitTransform = transform;
    node2.style.transform = transform;
  }
}
const Slide = /* @__PURE__ */ reactExports.forwardRef(function Slide2(props, ref2) {
  const theme2 = useTheme();
  const defaultEasing = {
    enter: theme2.transitions.easing.easeOut,
    exit: theme2.transitions.easing.sharp
  };
  const defaultTimeout = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    container: containerProp,
    direction = "down",
    easing: easingProp = defaultEasing,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition,
    ...other
  } = props;
  const childrenRef = reactExports.useRef(null);
  const handleRef = useForkRef(getReactElementRef(children), childrenRef, ref2);
  const normalizedTransitionCallback = (callback) => (isAppearing) => {
    if (callback) {
      if (isAppearing === void 0) {
        callback(childrenRef.current);
      } else {
        callback(childrenRef.current, isAppearing);
      }
    }
  };
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    setTranslateValue(direction, node2, containerProp);
    reflow(node2);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntering = normalizedTransitionCallback((node2, isAppearing) => {
    const transitionProps = getTransitionProps({
      timeout,
      style: style2,
      easing: easingProp
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme2.transitions.create("-webkit-transform", {
      ...transitionProps
    });
    node2.style.transition = theme2.transitions.create("transform", {
      ...transitionProps
    });
    node2.style.webkitTransform = "none";
    node2.style.transform = "none";
    if (onEntering) {
      onEntering(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      timeout,
      style: style2,
      easing: easingProp
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme2.transitions.create("-webkit-transform", transitionProps);
    node2.style.transition = theme2.transitions.create("transform", transitionProps);
    setTranslateValue(direction, node2, containerProp);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback((node2) => {
    node2.style.webkitTransition = "";
    node2.style.transition = "";
    if (onExited) {
      onExited(node2);
    }
  });
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(childrenRef.current, next2);
    }
  };
  const updatePosition = reactExports.useCallback(() => {
    if (childrenRef.current) {
      setTranslateValue(direction, childrenRef.current, containerProp);
    }
  }, [direction, containerProp]);
  reactExports.useEffect(() => {
    if (inProp || direction === "down" || direction === "right") {
      return void 0;
    }
    const handleResize = debounce$1(() => {
      if (childrenRef.current) {
        setTranslateValue(direction, childrenRef.current, containerProp);
      }
    });
    const containerWindow = ownerWindow(childrenRef.current);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [direction, inProp, containerProp]);
  reactExports.useEffect(() => {
    if (!inProp) {
      updatePosition();
    }
  }, [inProp, updatePosition]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
    nodeRef: childrenRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    appear,
    in: inProp,
    timeout,
    ...other,
    children: (state2, {
      ownerState,
      ...restChildProps
    }) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, {
        ref: handleRef,
        style: {
          visibility: state2 === "exited" && !inProp ? "hidden" : void 0,
          ...style2,
          ...children.props.style
        },
        ...restChildProps
      });
    }
  });
});
const useUtilityClasses$s = (ownerState) => {
  const {
    classes,
    disableUnderline,
    startAdornment,
    endAdornment,
    size: size2,
    hiddenLabel,
    multiline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline", startAdornment && "adornedStart", endAdornment && "adornedEnd", size2 === "small" && `size${capitalize(size2)}`, hiddenLabel && "hiddenLabel", multiline && "multiline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
  return {
    ...classes,
    // forward classes to the InputBase
    ...composedClasses
  };
};
const FilledInputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const light2 = theme2.palette.mode === "light";
  const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
  const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
  const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return {
    position: "relative",
    backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2,
    borderTopLeftRadius: (theme2.vars || theme2).shape.borderRadius,
    borderTopRightRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create("background-color", {
      duration: theme2.transitions.duration.shorter,
      easing: theme2.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.hoverBg : hoverBackground,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
      }
    },
    [`&.${filledInputClasses.focused}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
    },
    [`&.${filledInputClasses.disabled}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.disabledBg : disabledBackground
    },
    variants: [{
      props: ({
        ownerState
      }) => !ownerState.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme2.transitions.create("transform", {
            duration: theme2.transitions.duration.shorter,
            easing: theme2.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${filledInputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${filledInputClasses.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (theme2.vars || theme2).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${theme2.vars ? theme2.alpha(theme2.vars.palette.common.onBackground, theme2.vars.opacity.inputUnderline) : bottomLineColor}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme2.transitions.create("border-bottom-color", {
            duration: theme2.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${filledInputClasses.disabled}, .${filledInputClasses.error}):before`]: {
          borderBottom: `1px solid ${(theme2.vars || theme2).palette.text.primary}`
        },
        [`&.${filledInputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        disableUnderline: false,
        color: color2
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(theme2.vars || theme2).palette[color2]?.main}`
        }
      }
    })), {
      props: ({
        ownerState
      }) => ownerState.startAdornment,
      style: {
        paddingLeft: 12
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.endAdornment,
      style: {
        paddingRight: 12
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline,
      style: {
        padding: "25px 12px 8px"
      }
    }, {
      props: ({
        ownerState,
        size: size2
      }) => ownerState.multiline && size2 === "small",
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline && ownerState.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline && ownerState.hiddenLabel && ownerState.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }]
  };
}));
const FilledInputInput = styled(InputBaseInput, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(memoTheme(({
  theme: theme2
}) => ({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12,
  ...!theme2.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
      caretColor: theme2.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  },
  ...theme2.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [theme2.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      paddingTop: 21,
      paddingBottom: 4
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hiddenLabel,
    style: {
      paddingTop: 16,
      paddingBottom: 17
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.endAdornment,
    style: {
      paddingRight: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hiddenLabel && ownerState.size === "small",
    style: {
      paddingTop: 8,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.multiline,
    style: {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }
  }]
})));
const FilledInput = /* @__PURE__ */ reactExports.forwardRef(function FilledInput2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFilledInput"
  });
  const {
    disableUnderline = false,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    hiddenLabel,
    // declare here to prevent spreading to DOM
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text",
    ...other
  } = props;
  const ownerState = {
    ...props,
    disableUnderline,
    fullWidth,
    inputComponent,
    multiline,
    type
  };
  const classes = useUtilityClasses$s(props);
  const filledInputComponentsProps = {
    root: {
      ownerState
    },
    input: {
      ownerState
    }
  };
  const componentsProps = slotProps ?? componentsPropsProp ? deepmerge(filledInputComponentsProps, slotProps ?? componentsPropsProp) : filledInputComponentsProps;
  const RootSlot = slots.root ?? components.Root ?? FilledInputRoot;
  const InputSlot = slots.input ?? components.Input ?? FilledInputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase, {
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps: componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref: ref2,
    type,
    ...other,
    classes
  });
});
FilledInput.muiName = "Input";
function getFormControlUtilityClasses(slot) {
  return generateUtilityClass("MuiFormControl", slot);
}
generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const useUtilityClasses$r = (ownerState) => {
  const {
    classes,
    margin: margin2,
    fullWidth
  } = ownerState;
  const slots = {
    root: ["root", margin2 !== "none" && `margin${capitalize(margin2)}`, fullWidth && "fullWidth"]
  };
  return composeClasses(slots, getFormControlUtilityClasses, classes);
};
const FormControlRoot = styled("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`margin${capitalize(ownerState.margin)}`], ownerState.fullWidth && styles2.fullWidth];
  }
})({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top",
  // Fix alignment issue on Safari.
  variants: [{
    props: {
      margin: "normal"
    },
    style: {
      marginTop: 16,
      marginBottom: 8
    }
  }, {
    props: {
      margin: "dense"
    },
    style: {
      marginTop: 8,
      marginBottom: 4
    }
  }, {
    props: {
      fullWidth: true
    },
    style: {
      width: "100%"
    }
  }]
});
const FormControl = /* @__PURE__ */ reactExports.forwardRef(function FormControl2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormControl"
  });
  const {
    children,
    className,
    color: color2 = "primary",
    component = "div",
    disabled = false,
    error = false,
    focused: visuallyFocused,
    fullWidth = false,
    hiddenLabel = false,
    margin: margin2 = "none",
    required = false,
    size: size2 = "medium",
    variant = "outlined",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    component,
    disabled,
    error,
    fullWidth,
    hiddenLabel,
    margin: margin2,
    required,
    size: size2,
    variant
  };
  const classes = useUtilityClasses$r(ownerState);
  const [adornedStart, setAdornedStart] = reactExports.useState(() => {
    let initialAdornedStart = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
        if (input && isAdornedStart(input.props)) {
          initialAdornedStart = true;
        }
      });
    }
    return initialAdornedStart;
  });
  const [filled, setFilled] = reactExports.useState(() => {
    let initialFilled = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        if (isFilled(child.props, true) || isFilled(child.props.inputProps, true)) {
          initialFilled = true;
        }
      });
    }
    return initialFilled;
  });
  const [focusedState, setFocused] = reactExports.useState(false);
  if (disabled && focusedState) {
    setFocused(false);
  }
  const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
  let registerEffect;
  reactExports.useRef(false);
  const onFilled = reactExports.useCallback(() => {
    setFilled(true);
  }, []);
  const onEmpty = reactExports.useCallback(() => {
    setFilled(false);
  }, []);
  const childContext = reactExports.useMemo(() => {
    return {
      adornedStart,
      setAdornedStart,
      color: color2,
      disabled,
      error,
      filled,
      focused,
      fullWidth,
      hiddenLabel,
      size: size2,
      onBlur: () => {
        setFocused(false);
      },
      onFocus: () => {
        setFocused(true);
      },
      onEmpty,
      onFilled,
      registerEffect,
      required,
      variant
    };
  }, [adornedStart, color2, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, onEmpty, onFilled, required, size2, variant]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlRoot, {
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref: ref2,
      ...other,
      children
    })
  });
});
function getFormHelperTextUtilityClasses(slot) {
  return generateUtilityClass("MuiFormHelperText", slot);
}
const formHelperTextClasses = generateUtilityClasses("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var _span$3;
const useUtilityClasses$q = (ownerState) => {
  const {
    classes,
    contained,
    size: size2,
    disabled,
    error,
    filled,
    focused,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", error && "error", size2 && `size${capitalize(size2)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
  };
  return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
};
const FormHelperTextRoot = styled("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.size && styles2[`size${capitalize(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  color: (theme2.vars || theme2).palette.text.secondary,
  ...theme2.typography.caption,
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${formHelperTextClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  },
  [`&.${formHelperTextClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      marginTop: 4
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.contained,
    style: {
      marginLeft: 14,
      marginRight: 14
    }
  }]
})));
const FormHelperText = /* @__PURE__ */ reactExports.forwardRef(function FormHelperText2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormHelperText"
  });
  const {
    children,
    className,
    component = "p",
    disabled,
    error,
    filled,
    focused,
    margin: margin2,
    required,
    variant,
    ...other
  } = props;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  });
  const ownerState = {
    ...props,
    component,
    contained: fcs.variant === "filled" || fcs.variant === "outlined",
    variant: fcs.variant,
    size: fcs.size,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  };
  delete ownerState.ownerState;
  const classes = useUtilityClasses$q(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextRoot, {
    as: component,
    className: clsx(classes.root, className),
    ref: ref2,
    ...other,
    ownerState,
    children: children === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      _span$3 || (_span$3 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: "notranslate",
        "aria-hidden": true,
        children: ""
      }))
    ) : children
  });
});
function getFormLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiFormLabel", slot);
}
const formLabelClasses = generateUtilityClasses("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
const useUtilityClasses$p = (ownerState) => {
  const {
    classes,
    color: color2,
    focused,
    disabled,
    error,
    filled,
    required
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
    asterisk: ["asterisk", error && "error"]
  };
  return composeClasses(slots, getFormLabelUtilityClasses, classes);
};
const FormLabelRoot = styled("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color === "secondary" && styles2.colorSecondary, ownerState.filled && styles2.filled];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  color: (theme2.vars || theme2).palette.text.secondary,
  ...theme2.typography.body1,
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      [`&.${formLabelClasses.focused}`]: {
        color: (theme2.vars || theme2).palette[color2].main
      }
    }
  })), {
    props: {},
    style: {
      [`&.${formLabelClasses.disabled}`]: {
        color: (theme2.vars || theme2).palette.text.disabled
      },
      [`&.${formLabelClasses.error}`]: {
        color: (theme2.vars || theme2).palette.error.main
      }
    }
  }]
})));
const AsteriskComponent = styled("span", {
  name: "MuiFormLabel",
  slot: "Asterisk"
})(memoTheme(({
  theme: theme2
}) => ({
  [`&.${formLabelClasses.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
})));
const FormLabel = /* @__PURE__ */ reactExports.forwardRef(function FormLabel2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiFormLabel"
  });
  const {
    children,
    className,
    color: color2,
    component = "label",
    disabled,
    error,
    filled,
    focused,
    required,
    ...other
  } = props;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  });
  const ownerState = {
    ...props,
    color: fcs.color || "primary",
    component,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  };
  const classes = useUtilityClasses$p(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormLabelRoot, {
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref: ref2,
    ...other,
    children: [children, fcs.required && /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent, {
      ownerState,
      "aria-hidden": true,
      className: classes.asterisk,
      children: ["", "*"]
    })]
  });
});
const Grid = createGrid({
  createStyledComponent: styled("div", {
    name: "MuiGrid",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.container && styles2.container];
    }
  }),
  componentName: "MuiGrid",
  useThemeProps: (inProps) => useDefaultProps({
    props: inProps,
    name: "MuiGrid"
  }),
  useTheme
});
function getScale(value) {
  return `scale(${value}, ${value ** 2})`;
}
const styles$2f = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref2) {
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition,
    ...other
  } = props;
  const timer = useTimeout();
  const autoTimeout = reactExports.useRef();
  const theme2 = useTheme();
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, getReactElementRef(children), ref2);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const {
      duration: transitionDuration,
      delay: delay2,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay: delay2
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: delay2,
      easing: transitionTimingFunction
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const {
      duration: transitionDuration,
      delay: delay2,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay: delay2
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: isWebKit154 ? delay2 : delay2 || duration2 * 0.333,
      easing: transitionTimingFunction
    })].join(",");
    node2.style.opacity = 0;
    node2.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.start(autoTimeout.current || 0, next2);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, {
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === "auto" ? null : timeout,
    ...other,
    children: (state2, {
      ownerState,
      ...restChildProps
    }) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, {
        style: {
          opacity: 0,
          transform: getScale(0.75),
          visibility: state2 === "exited" && !inProp ? "hidden" : void 0,
          ...styles$2f[state2],
          ...style2,
          ...children.props.style
        },
        ref: handleRef,
        ...restChildProps
      });
    }
  });
});
if (Grow) {
  Grow.muiSupportAuto = true;
}
const useUtilityClasses$o = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
  return {
    ...classes,
    // forward classes to the InputBase
    ...composedClasses
  };
};
const InputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(memoTheme(({
  theme: theme2
}) => {
  const light2 = theme2.palette.mode === "light";
  let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  if (theme2.vars) {
    bottomLineColor = theme2.alpha(theme2.vars.palette.common.onBackground, theme2.vars.opacity.inputUnderline);
  }
  return {
    position: "relative",
    variants: [{
      props: ({
        ownerState
      }) => ownerState.formControl,
      style: {
        "label + &": {
          marginTop: 16
        }
      }
    }, {
      props: ({
        ownerState
      }) => !ownerState.disableUnderline,
      style: {
        "&::after": {
          left: 0,
          bottom: 0,
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme2.transitions.create("transform", {
            duration: theme2.transitions.duration.shorter,
            easing: theme2.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${inputClasses.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${inputClasses.error}`]: {
          "&::before, &::after": {
            borderBottomColor: (theme2.vars || theme2).palette.error.main
          }
        },
        "&::before": {
          borderBottom: `1px solid ${bottomLineColor}`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme2.transitions.create("border-bottom-color", {
            duration: theme2.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${inputClasses.disabled}, .${inputClasses.error}):before`]: {
          borderBottom: `2px solid ${(theme2.vars || theme2).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${bottomLineColor}`
          }
        },
        [`&.${inputClasses.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }
    }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2,
        disableUnderline: false
      },
      style: {
        "&::after": {
          borderBottom: `2px solid ${(theme2.vars || theme2).palette[color2].main}`
        }
      }
    }))]
  };
}));
const InputInput = styled(InputBaseInput, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})({});
const Input = /* @__PURE__ */ reactExports.forwardRef(function Input2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInput"
  });
  const {
    disableUnderline = false,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text",
    ...other
  } = props;
  const classes = useUtilityClasses$o(props);
  const ownerState = {
    disableUnderline
  };
  const inputComponentsProps = {
    root: {
      ownerState
    }
  };
  const componentsProps = slotProps ?? componentsPropsProp ? deepmerge(slotProps ?? componentsPropsProp, inputComponentsProps) : inputComponentsProps;
  const RootSlot = slots.root ?? components.Root ?? InputRoot;
  const InputSlot = slots.input ?? components.Input ?? InputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase, {
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps: componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref: ref2,
    type,
    ...other,
    classes
  });
});
Input.muiName = "Input";
function getInputAdornmentUtilityClass(slot) {
  return generateUtilityClass("MuiInputAdornment", slot);
}
const inputAdornmentClasses = generateUtilityClasses("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]);
var _span$2;
const overridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, styles2[`position${capitalize(ownerState.position)}`], ownerState.disablePointerEvents === true && styles2.disablePointerEvents, styles2[ownerState.variant]];
};
const useUtilityClasses$n = (ownerState) => {
  const {
    classes,
    disablePointerEvents,
    hiddenLabel,
    position: position2,
    size: size2,
    variant
  } = ownerState;
  const slots = {
    root: ["root", disablePointerEvents && "disablePointerEvents", position2 && `position${capitalize(position2)}`, variant, hiddenLabel && "hiddenLabel", size2 && `size${capitalize(size2)}`]
  };
  return composeClasses(slots, getInputAdornmentUtilityClass, classes);
};
const InputAdornmentRoot = styled("div", {
  name: "MuiInputAdornment",
  slot: "Root",
  overridesResolver
})(memoTheme(({
  theme: theme2
}) => ({
  display: "flex",
  maxHeight: "2em",
  alignItems: "center",
  whiteSpace: "nowrap",
  color: (theme2.vars || theme2).palette.action.active,
  variants: [{
    props: {
      variant: "filled"
    },
    style: {
      [`&.${inputAdornmentClasses.positionStart}&:not(.${inputAdornmentClasses.hiddenLabel})`]: {
        marginTop: 16
      }
    }
  }, {
    props: {
      position: "start"
    },
    style: {
      marginRight: 8
    }
  }, {
    props: {
      position: "end"
    },
    style: {
      marginLeft: 8
    }
  }, {
    props: {
      disablePointerEvents: true
    },
    style: {
      pointerEvents: "none"
    }
  }]
})));
const InputAdornment = /* @__PURE__ */ reactExports.forwardRef(function InputAdornment2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiInputAdornment"
  });
  const {
    children,
    className,
    component = "div",
    disablePointerEvents = false,
    disableTypography = false,
    position: position2,
    variant: variantProp,
    ...other
  } = props;
  const muiFormControl = useFormControl() || {};
  let variant = variantProp;
  if (variantProp && muiFormControl.variant) ;
  if (muiFormControl && !variant) {
    variant = muiFormControl.variant;
  }
  const ownerState = {
    ...props,
    hiddenLabel: muiFormControl.hiddenLabel,
    size: muiFormControl.size,
    disablePointerEvents,
    position: position2,
    variant
  };
  const classes = useUtilityClasses$n(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext.Provider, {
    value: null,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornmentRoot, {
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref: ref2,
      ...other,
      children: typeof children === "string" && !disableTypography ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, {
        color: "textSecondary",
        children
      }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [position2 === "start" ? (
          /* notranslate needed while Google Translate will not fix zero-width space issue */
          _span$2 || (_span$2 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            className: "notranslate",
            "aria-hidden": true,
            children: ""
          }))
        ) : null, children]
      })
    })
  });
});
function getInputLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiInputLabel", slot);
}
generateUtilityClasses("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const useUtilityClasses$m = (ownerState) => {
  const {
    classes,
    formControl,
    size: size2,
    shrink,
    disableAnimation,
    variant,
    required
  } = ownerState;
  const slots = {
    root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size2 && size2 !== "medium" && `size${capitalize(size2)}`, variant],
    asterisk: [required && "asterisk"]
  };
  const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
  return {
    ...classes,
    // forward the focused, disabled, etc. classes to the FormLabel
    ...composedClasses
  };
};
const InputLabelRoot = styled(FormLabel, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formLabelClasses.asterisk}`]: styles2.asterisk
    }, styles2.root, ownerState.formControl && styles2.formControl, ownerState.size === "small" && styles2.sizeSmall, ownerState.shrink && styles2.shrink, !ownerState.disableAnimation && styles2.animated, ownerState.focused && styles2.focused, styles2[ownerState.variant]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.formControl,
    style: {
      position: "absolute",
      left: 0,
      top: 0,
      // slight alteration to spec spacing to match visual spec result
      transform: "translate(0, 20px) scale(1)"
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      // Compensation for the `Input.inputSizeSmall` style.
      transform: "translate(0, 17px) scale(1)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.shrink,
    style: {
      transform: "translate(0, -1.5px) scale(0.75)",
      transformOrigin: "top left",
      maxWidth: "133%"
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.disableAnimation,
    style: {
      transition: theme2.transitions.create(["color", "transform", "max-width"], {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      })
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      // Chrome's autofill feature gives the input field a yellow background.
      // Since the input field is behind the label in the HTML tree,
      // the input field is drawn last and hides the label with an opaque background color.
      // zIndex: 1 will raise the label above opaque background-colors of input.
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(12px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "filled",
      size: "small"
    },
    style: {
      transform: "translate(12px, 13px) scale(1)"
    }
  }, {
    props: ({
      variant,
      ownerState
    }) => variant === "filled" && ownerState.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      transform: "translate(12px, 7px) scale(0.75)",
      maxWidth: "calc(133% - 24px)"
    }
  }, {
    props: ({
      variant,
      ownerState,
      size: size2
    }) => variant === "filled" && ownerState.shrink && size2 === "small",
    style: {
      transform: "translate(12px, 4px) scale(0.75)"
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      // see comment above on filled.zIndex
      zIndex: 1,
      pointerEvents: "none",
      transform: "translate(14px, 16px) scale(1)",
      maxWidth: "calc(100% - 24px)"
    }
  }, {
    props: {
      variant: "outlined",
      size: "small"
    },
    style: {
      transform: "translate(14px, 9px) scale(1)"
    }
  }, {
    props: ({
      variant,
      ownerState
    }) => variant === "outlined" && ownerState.shrink,
    style: {
      userSelect: "none",
      pointerEvents: "auto",
      // Theoretically, we should have (8+5)*2/0.75 = 34px
      // but it feels a better when it bleeds a bit on the left, so 32px.
      maxWidth: "calc(133% - 32px)",
      transform: "translate(14px, -9px) scale(0.75)"
    }
  }]
})));
const InputLabel = /* @__PURE__ */ reactExports.forwardRef(function InputLabel2(inProps, ref2) {
  const props = useDefaultProps({
    name: "MuiInputLabel",
    props: inProps
  });
  const {
    disableAnimation = false,
    margin: margin2,
    shrink: shrinkProp,
    variant,
    className,
    ...other
  } = props;
  const muiFormControl = useFormControl();
  let shrink = shrinkProp;
  if (typeof shrink === "undefined" && muiFormControl) {
    shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
  }
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["size", "variant", "required", "focused"]
  });
  const ownerState = {
    ...props,
    disableAnimation,
    formControl: muiFormControl,
    shrink,
    size: fcs.size,
    variant: fcs.variant,
    required: fcs.required,
    focused: fcs.focused
  };
  const classes = useUtilityClasses$m(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelRoot, {
    "data-shrink": shrink,
    ref: ref2,
    className: clsx(classes.root, className),
    ...other,
    ownerState,
    classes
  });
});
function getLinearProgressUtilityClass(slot) {
  return generateUtilityClass("MuiLinearProgress", slot);
}
generateUtilityClasses("MuiLinearProgress", ["root", "colorPrimary", "colorSecondary", "determinate", "indeterminate", "buffer", "query", "dashed", "dashedColorPrimary", "dashedColorSecondary", "bar", "bar1", "bar2", "barColorPrimary", "barColorSecondary", "bar1Indeterminate", "bar1Determinate", "bar1Buffer", "bar2Indeterminate", "bar2Buffer"]);
const TRANSITION_DURATION = 4;
const indeterminate1Keyframe = keyframes`
  0% {
    left: -35%;
    right: 100%;
  }

  60% {
    left: 100%;
    right: -90%;
  }

  100% {
    left: 100%;
    right: -90%;
  }
`;
const indeterminate1Animation = typeof indeterminate1Keyframe !== "string" ? css`
        animation: ${indeterminate1Keyframe} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
      ` : null;
const indeterminate2Keyframe = keyframes`
  0% {
    left: -200%;
    right: 100%;
  }

  60% {
    left: 107%;
    right: -8%;
  }

  100% {
    left: 107%;
    right: -8%;
  }
`;
const indeterminate2Animation = typeof indeterminate2Keyframe !== "string" ? css`
        animation: ${indeterminate2Keyframe} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite;
      ` : null;
const bufferKeyframe = keyframes`
  0% {
    opacity: 1;
    background-position: 0 -23px;
  }

  60% {
    opacity: 0;
    background-position: 0 -23px;
  }

  100% {
    opacity: 1;
    background-position: -200px -23px;
  }
`;
const bufferAnimation = typeof bufferKeyframe !== "string" ? css`
        animation: ${bufferKeyframe} 3s infinite linear;
      ` : null;
const useUtilityClasses$l = (ownerState) => {
  const {
    classes,
    variant,
    color: color2
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, variant],
    dashed: ["dashed", `dashedColor${capitalize(color2)}`],
    bar1: ["bar", "bar1", `barColor${capitalize(color2)}`, (variant === "indeterminate" || variant === "query") && "bar1Indeterminate", variant === "determinate" && "bar1Determinate", variant === "buffer" && "bar1Buffer"],
    bar2: ["bar", "bar2", variant !== "buffer" && `barColor${capitalize(color2)}`, variant === "buffer" && `color${capitalize(color2)}`, (variant === "indeterminate" || variant === "query") && "bar2Indeterminate", variant === "buffer" && "bar2Buffer"]
  };
  return composeClasses(slots, getLinearProgressUtilityClass, classes);
};
const getColorShade = (theme2, color2) => {
  if (theme2.vars) {
    return theme2.vars.palette.LinearProgress[`${color2}Bg`];
  }
  return theme2.palette.mode === "light" ? theme2.lighten(theme2.palette[color2].main, 0.62) : theme2.darken(theme2.palette[color2].main, 0.5);
};
const LinearProgressRoot = styled("span", {
  name: "MuiLinearProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize(ownerState.color)}`], styles2[ownerState.variant]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "relative",
  overflow: "hidden",
  display: "block",
  height: 4,
  // Fix Safari's bug during composition of different paint.
  zIndex: 0,
  "@media print": {
    colorAdjust: "exact"
  },
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      backgroundColor: getColorShade(theme2, color2)
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.color === "inherit" && ownerState.variant !== "buffer",
    style: {
      "&::before": {
        content: '""',
        position: "absolute",
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "currentColor",
        opacity: 0.3
      }
    }
  }, {
    props: {
      variant: "buffer"
    },
    style: {
      backgroundColor: "transparent"
    }
  }, {
    props: {
      variant: "query"
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
})));
const LinearProgressDashed = styled("span", {
  name: "MuiLinearProgress",
  slot: "Dashed",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.dashed, styles2[`dashedColor${capitalize(ownerState.color)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "absolute",
  marginTop: 0,
  height: "100%",
  width: "100%",
  backgroundSize: "10px 10px",
  backgroundPosition: "0 -23px",
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      opacity: 0.3,
      backgroundImage: `radial-gradient(currentColor 0%, currentColor 16%, transparent 42%)`
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => {
    const backgroundColor2 = getColorShade(theme2, color2);
    return {
      props: {
        color: color2
      },
      style: {
        backgroundImage: `radial-gradient(${backgroundColor2} 0%, ${backgroundColor2} 16%, transparent 42%)`
      }
    };
  })]
})), bufferAnimation || {
  // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
  animation: `${bufferKeyframe} 3s infinite linear`
});
const LinearProgressBar1 = styled("span", {
  name: "MuiLinearProgress",
  slot: "Bar1",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.bar, styles2.bar1, styles2[`barColor${capitalize(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar1Indeterminate, ownerState.variant === "determinate" && styles2.bar1Determinate, ownerState.variant === "buffer" && styles2.bar1Buffer];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  width: "100%",
  position: "absolute",
  left: 0,
  bottom: 0,
  top: 0,
  transition: "transform 0.2s linear",
  transformOrigin: "left",
  variants: [{
    props: {
      color: "inherit"
    },
    style: {
      backgroundColor: "currentColor"
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      backgroundColor: (theme2.vars || theme2).palette[color2].main
    }
  })), {
    props: {
      variant: "determinate"
    },
    style: {
      transition: `transform .${TRANSITION_DURATION}s linear`
    }
  }, {
    props: {
      variant: "buffer"
    },
    style: {
      zIndex: 1,
      transition: `transform .${TRANSITION_DURATION}s linear`
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: {
      width: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: indeterminate1Animation || {
      animation: `${indeterminate1Keyframe} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite`
    }
  }]
})));
const LinearProgressBar2 = styled("span", {
  name: "MuiLinearProgress",
  slot: "Bar2",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.bar, styles2.bar2, styles2[`barColor${capitalize(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar2Indeterminate, ownerState.variant === "buffer" && styles2.bar2Buffer];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  width: "100%",
  position: "absolute",
  left: 0,
  bottom: 0,
  top: 0,
  transition: "transform 0.2s linear",
  transformOrigin: "left",
  variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2
    },
    style: {
      "--LinearProgressBar2-barColor": (theme2.vars || theme2).palette[color2].main
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.variant !== "buffer" && ownerState.color !== "inherit",
    style: {
      backgroundColor: "var(--LinearProgressBar2-barColor, currentColor)"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant !== "buffer" && ownerState.color === "inherit",
    style: {
      backgroundColor: "currentColor"
    }
  }, {
    props: {
      color: "inherit"
    },
    style: {
      opacity: 0.3
    }
  }, ...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
    props: {
      color: color2,
      variant: "buffer"
    },
    style: {
      backgroundColor: getColorShade(theme2, color2),
      transition: `transform .${TRANSITION_DURATION}s linear`
    }
  })), {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: {
      width: "auto"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.variant === "indeterminate" || ownerState.variant === "query",
    style: indeterminate2Animation || {
      animation: `${indeterminate2Keyframe} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite`
    }
  }]
})));
const LinearProgress = /* @__PURE__ */ reactExports.forwardRef(function LinearProgress2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiLinearProgress"
  });
  const {
    className,
    color: color2 = "primary",
    value,
    valueBuffer,
    variant = "indeterminate",
    ...other
  } = props;
  const ownerState = {
    ...props,
    color: color2,
    variant
  };
  const classes = useUtilityClasses$l(ownerState);
  const isRtl = useRtl();
  const rootProps = {};
  const inlineStyles = {
    bar1: {},
    bar2: {}
  };
  if (variant === "determinate" || variant === "buffer") {
    if (value !== void 0) {
      rootProps["aria-valuenow"] = Math.round(value);
      rootProps["aria-valuemin"] = 0;
      rootProps["aria-valuemax"] = 100;
      let transform = value - 100;
      if (isRtl) {
        transform = -transform;
      }
      inlineStyles.bar1.transform = `translateX(${transform}%)`;
    }
  }
  if (variant === "buffer") {
    if (valueBuffer !== void 0) {
      let transform = (valueBuffer || 0) - 100;
      if (isRtl) {
        transform = -transform;
      }
      inlineStyles.bar2.transform = `translateX(${transform}%)`;
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(LinearProgressRoot, {
    className: clsx(classes.root, className),
    ownerState,
    role: "progressbar",
    ...rootProps,
    ref: ref2,
    ...other,
    children: [variant === "buffer" ? /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressDashed, {
      className: classes.dashed,
      ownerState
    }) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressBar1, {
      className: classes.bar1,
      ownerState,
      style: inlineStyles.bar1
    }), variant === "determinate" ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(LinearProgressBar2, {
      className: classes.bar2,
      ownerState,
      style: inlineStyles.bar2
    })]
  });
});
const ListContext = /* @__PURE__ */ reactExports.createContext({});
function getListUtilityClass(slot) {
  return generateUtilityClass("MuiList", slot);
}
generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
const useUtilityClasses$k = (ownerState) => {
  const {
    classes,
    disablePadding,
    dense,
    subheader
  } = ownerState;
  const slots = {
    root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
  };
  return composeClasses(slots, getListUtilityClass, classes);
};
const ListRoot = styled("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
  }
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disablePadding,
    style: {
      paddingTop: 8,
      paddingBottom: 8
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.subheader,
    style: {
      paddingTop: 0
    }
  }]
});
const List$1 = /* @__PURE__ */ reactExports.forwardRef(function List2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiList"
  });
  const {
    children,
    className,
    component = "ul",
    dense = false,
    disablePadding = false,
    subheader,
    ...other
  } = props;
  const context = reactExports.useMemo(() => ({
    dense
  }), [dense]);
  const ownerState = {
    ...props,
    component,
    dense,
    disablePadding
  };
  const classes = useUtilityClasses$k(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: context,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, {
      as: component,
      className: clsx(classes.root, className),
      ref: ref2,
      ownerState,
      ...other,
      children: [subheader, children]
    })
  });
});
function nextItem$1(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list.firstChild;
}
function previousItem$1(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === void 0) {
    return true;
  }
  let text = nextFocus.innerText;
  if (text === void 0) {
    text = nextFocus.textContent;
  }
  text = text.trim().toLowerCase();
  if (text.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }
  return text.startsWith(textCriteria.keys.join(""));
}
function moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return false;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }
  return false;
}
const MenuList = /* @__PURE__ */ reactExports.forwardRef(function MenuList2(props, ref2) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions,
    autoFocus = false,
    autoFocusItem = false,
    children,
    className,
    disabledItemsFocusable = false,
    disableListWrap = false,
    onKeyDown,
    variant = "selectedMenu",
    ...other
  } = props;
  const listRef = reactExports.useRef(null);
  const textCriteriaRef = reactExports.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect(() => {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useImperativeHandle(actions, () => ({
    adjustStyleForScrollbar: (containerElement, {
      direction
    }) => {
      const noExplicitWidth = !listRef.current.style.width;
      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
        const scrollbarSize = `${getScrollbarSize(ownerWindow(containerElement))}px`;
        listRef.current.style[direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
      }
      return listRef.current;
    }
  }), []);
  const handleKeyDown = (event) => {
    const list = listRef.current;
    const key2 = event.key;
    const isModifierKeyPressed = event.ctrlKey || event.metaKey || event.altKey;
    if (isModifierKeyPressed) {
      if (onKeyDown) {
        onKeyDown(event);
      }
      return;
    }
    const currentFocus = ownerDocument(list).activeElement;
    if (key2 === "ArrowDown") {
      event.preventDefault();
      moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem$1);
    } else if (key2 === "ArrowUp") {
      event.preventDefault();
      moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem$1);
    } else if (key2 === "Home") {
      event.preventDefault();
      moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, nextItem$1);
    } else if (key2 === "End") {
      event.preventDefault();
      moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, previousItem$1);
    } else if (key2.length === 1) {
      const criteria = textCriteriaRef.current;
      const lowerKey = key2.toLowerCase();
      const currTime = performance.now();
      if (criteria.keys.length > 0) {
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus$1(list, currentFocus, false, disabledItemsFocusable, nextItem$1, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleRef = useForkRef(listRef, ref2);
  let activeItemIndex = -1;
  reactExports.Children.forEach(children, (child, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      if (activeItemIndex === index2) {
        activeItemIndex += 1;
        if (activeItemIndex >= children.length) {
          activeItemIndex = -1;
        }
      }
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
    if (activeItemIndex === index2 && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
      activeItemIndex += 1;
      if (activeItemIndex >= children.length) {
        activeItemIndex = -1;
      }
    }
  });
  const items = reactExports.Children.map(children, (child, index2) => {
    if (index2 === activeItemIndex) {
      const newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
        newChildProps.tabIndex = 0;
      }
      return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
    }
    return child;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, {
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown,
    tabIndex: autoFocus ? 0 : -1,
    ...other,
    children: items
  });
});
function getPopoverUtilityClass(slot) {
  return generateUtilityClass("MuiPopover", slot);
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
function getOffsetTop(rect, vertical) {
  let offset2 = 0;
  if (typeof vertical === "number") {
    offset2 = vertical;
  } else if (vertical === "center") {
    offset2 = rect.height / 2;
  } else if (vertical === "bottom") {
    offset2 = rect.height;
  }
  return offset2;
}
function getOffsetLeft(rect, horizontal) {
  let offset2 = 0;
  if (typeof horizontal === "number") {
    offset2 = horizontal;
  } else if (horizontal === "center") {
    offset2 = rect.width / 2;
  } else if (horizontal === "right") {
    offset2 = rect.width;
  }
  return offset2;
}
function getTransformOriginValue(transformOrigin) {
  return [transformOrigin.horizontal, transformOrigin.vertical].map((n3) => typeof n3 === "number" ? `${n3}px` : n3).join(" ");
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
const useUtilityClasses$j = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"]
  };
  return composeClasses(slots, getPopoverUtilityClass, classes);
};
const PopoverRoot = styled(Modal, {
  name: "MuiPopover",
  slot: "Root"
})({});
const PopoverPaper = styled(Paper, {
  name: "MuiPopover",
  slot: "Paper"
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Popover = /* @__PURE__ */ reactExports.forwardRef(function Popover2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiPopover"
  });
  const {
    action,
    anchorEl,
    anchorOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition,
    anchorReference = "anchorEl",
    children,
    className,
    container: containerProp,
    elevation = 8,
    marginThreshold = 16,
    open,
    PaperProps: PaperPropsProp = {},
    // TODO: remove in v7
    slots = {},
    slotProps = {},
    transformOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent,
    // TODO: remove in v7
    transitionDuration: transitionDurationProp = "auto",
    TransitionProps = {},
    // TODO: remove in v7
    disableScrollLock = false,
    ...other
  } = props;
  const paperRef = reactExports.useRef();
  const ownerState = {
    ...props,
    anchorOrigin,
    anchorReference,
    elevation,
    marginThreshold,
    transformOrigin,
    TransitionComponent,
    transitionDuration: transitionDurationProp,
    TransitionProps
  };
  const classes = useUtilityClasses$j(ownerState);
  const getAnchorOffset = reactExports.useCallback(() => {
    if (anchorReference === "anchorPosition") {
      return anchorPosition;
    }
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
    const anchorRect = anchorElement.getBoundingClientRect();
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
  const getTransformOrigin = reactExports.useCallback((elemRect) => {
    return {
      vertical: getOffsetTop(elemRect, transformOrigin.vertical),
      horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
    };
  }, [transformOrigin.horizontal, transformOrigin.vertical]);
  const getPositioningStyle = reactExports.useCallback((element) => {
    const elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
    const elemTransformOrigin = getTransformOrigin(elemRect);
    if (anchorReference === "none") {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }
    const anchorOffset = getAnchorOffset();
    let top2 = anchorOffset.top - elemTransformOrigin.vertical;
    let left2 = anchorOffset.left - elemTransformOrigin.horizontal;
    const bottom2 = top2 + elemRect.height;
    const right2 = left2 + elemRect.width;
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
    const heightThreshold = containerWindow.innerHeight - marginThreshold;
    const widthThreshold = containerWindow.innerWidth - marginThreshold;
    if (marginThreshold !== null && top2 < marginThreshold) {
      const diff = top2 - marginThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (marginThreshold !== null && bottom2 > heightThreshold) {
      const diff = bottom2 - heightThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    }
    if (marginThreshold !== null && left2 < marginThreshold) {
      const diff = left2 - marginThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    } else if (right2 > widthThreshold) {
      const diff = right2 - widthThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    }
    return {
      top: `${Math.round(top2)}px`,
      left: `${Math.round(left2)}px`,
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
  const [isPositioned, setIsPositioned] = reactExports.useState(open);
  const setPositioningStyles = reactExports.useCallback(() => {
    const element = paperRef.current;
    if (!element) {
      return;
    }
    const positioning = getPositioningStyle(element);
    if (positioning.top !== null) {
      element.style.setProperty("top", positioning.top);
    }
    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }
    element.style.transformOrigin = positioning.transformOrigin;
    setIsPositioned(true);
  }, [getPositioningStyle]);
  reactExports.useEffect(() => {
    if (disableScrollLock) {
      window.addEventListener("scroll", setPositioningStyles);
    }
    return () => window.removeEventListener("scroll", setPositioningStyles);
  }, [anchorEl, disableScrollLock, setPositioningStyles]);
  const handleEntering = () => {
    setPositioningStyles();
  };
  const handleExited = () => {
    setIsPositioned(false);
  };
  reactExports.useEffect(() => {
    if (open) {
      setPositioningStyles();
    }
  });
  reactExports.useImperativeHandle(action, () => open ? {
    updatePosition: () => {
      setPositioningStyles();
    }
  } : null, [open, setPositioningStyles]);
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    const handleResize = debounce$1(() => {
      setPositioningStyles();
    });
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [anchorEl, open, setPositioningStyles]);
  let transitionDuration = transitionDurationProp;
  const externalForwardedProps = {
    slots: {
      transition: TransitionComponent,
      ...slots
    },
    slotProps: {
      transition: TransitionProps,
      paper: PaperPropsProp,
      ...slotProps
    }
  };
  const [TransitionSlot, transitionSlotProps] = useSlot("transition", {
    elementType: Grow,
    externalForwardedProps,
    ownerState,
    getSlotProps: (handlers) => ({
      ...handlers,
      onEntering: (element, isAppearing) => {
        handlers.onEntering?.(element, isAppearing);
        handleEntering();
      },
      onExited: (element) => {
        handlers.onExited?.(element);
        handleExited();
      }
    }),
    additionalProps: {
      appear: true,
      in: open
    }
  });
  if (transitionDurationProp === "auto" && !TransitionSlot.muiSupportAuto) {
    transitionDuration = void 0;
  }
  const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
  const [RootSlot, {
    slots: rootSlotsProp,
    slotProps: rootSlotPropsProp,
    ...rootProps
  }] = useSlot("root", {
    ref: ref2,
    elementType: PopoverRoot,
    externalForwardedProps: {
      ...externalForwardedProps,
      ...other
    },
    shouldForwardComponentProp: true,
    additionalProps: {
      slots: {
        backdrop: slots.backdrop
      },
      slotProps: {
        backdrop: mergeSlotProps$1(typeof slotProps.backdrop === "function" ? slotProps.backdrop(ownerState) : slotProps.backdrop, {
          invisible: true
        })
      },
      container,
      open
    },
    ownerState,
    className: clsx(classes.root, className)
  });
  const [PaperSlot, paperProps] = useSlot("paper", {
    ref: paperRef,
    className: classes.paper,
    elementType: PopoverPaper,
    externalForwardedProps,
    shouldForwardComponentProp: true,
    additionalProps: {
      elevation,
      style: isPositioned ? void 0 : {
        opacity: 0
      }
    },
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, {
    ...rootProps,
    ...!isHostComponent(RootSlot) && {
      slots: rootSlotsProp,
      slotProps: rootSlotPropsProp,
      disableScrollLock
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, {
      ...transitionSlotProps,
      timeout: transitionDuration,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, {
        ...paperProps,
        children
      })
    })
  });
});
function getMenuUtilityClass(slot) {
  return generateUtilityClass("MuiMenu", slot);
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
};
const LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
};
const useUtilityClasses$i = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  };
  return composeClasses(slots, getMenuUtilityClass, classes);
};
const MenuRoot = styled(Popover, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenu",
  slot: "Root"
})({});
const MenuPaper = styled(PopoverPaper, {
  name: "MuiMenu",
  slot: "Paper"
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
});
const MenuMenuList = styled(MenuList, {
  name: "MuiMenu",
  slot: "List"
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Menu = /* @__PURE__ */ reactExports.forwardRef(function Menu2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiMenu"
  });
  const {
    autoFocus = true,
    children,
    className,
    disableAutoFocusItem = false,
    MenuListProps = {},
    onClose,
    open,
    PaperProps = {},
    PopoverClasses,
    transitionDuration = "auto",
    TransitionProps: {
      onEntering,
      ...TransitionProps
    } = {},
    variant = "selectedMenu",
    slots = {},
    slotProps = {},
    ...other
  } = props;
  const isRtl = useRtl();
  const ownerState = {
    ...props,
    autoFocus,
    disableAutoFocusItem,
    MenuListProps,
    onEntering,
    PaperProps,
    transitionDuration,
    TransitionProps,
    variant
  };
  const classes = useUtilityClasses$i(ownerState);
  const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
  const menuListActionsRef = reactExports.useRef(null);
  const handleEntering = (element, isAppearing) => {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, {
        direction: isRtl ? "rtl" : "ltr"
      });
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };
  const handleListKeyDown = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      if (onClose) {
        onClose(event, "tabKeyDown");
      }
    }
  };
  let activeItemIndex = -1;
  reactExports.Children.map(children, (child, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
  });
  const externalForwardedProps = {
    slots,
    slotProps: {
      list: MenuListProps,
      transition: TransitionProps,
      paper: PaperProps,
      ...slotProps
    }
  };
  const rootSlotProps = useSlotProps({
    elementType: slots.root,
    externalSlotProps: slotProps.root,
    ownerState,
    className: [classes.root, className]
  });
  const [PaperSlot, paperSlotProps] = useSlot("paper", {
    className: classes.paper,
    elementType: MenuPaper,
    externalForwardedProps,
    shouldForwardComponentProp: true,
    ownerState
  });
  const [ListSlot, listSlotProps] = useSlot("list", {
    className: clsx(classes.list, MenuListProps.className),
    elementType: MenuMenuList,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    getSlotProps: (handlers) => ({
      ...handlers,
      onKeyDown: (event) => {
        handleListKeyDown(event);
        handlers.onKeyDown?.(event);
      }
    }),
    ownerState
  });
  const resolvedTransitionProps = typeof externalForwardedProps.slotProps.transition === "function" ? externalForwardedProps.slotProps.transition(ownerState) : externalForwardedProps.slotProps.transition;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, {
    onClose,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: isRtl ? "right" : "left"
    },
    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
    slots: {
      root: slots.root,
      paper: PaperSlot,
      backdrop: slots.backdrop,
      ...slots.transition && {
        // TODO: pass `slots.transition` directly once `TransitionComponent` is removed from Popover
        transition: slots.transition
      }
    },
    slotProps: {
      root: rootSlotProps,
      paper: paperSlotProps,
      backdrop: typeof slotProps.backdrop === "function" ? slotProps.backdrop(ownerState) : slotProps.backdrop,
      transition: {
        ...resolvedTransitionProps,
        onEntering: (...args) => {
          handleEntering(...args);
          resolvedTransitionProps?.onEntering?.(...args);
        }
      }
    },
    open,
    ref: ref2,
    transitionDuration,
    ownerState,
    ...other,
    classes: PopoverClasses,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListSlot, {
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem,
      variant,
      ...listSlotProps,
      children
    })
  });
});
function getNativeSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiNativeSelect", slot);
}
const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
const useUtilityClasses$h = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"]
  };
  return composeClasses(slots, getNativeSelectUtilityClasses, classes);
};
const StyledSelectSelect = styled("select", {
  name: "MuiNativeSelect"
})(({
  theme: theme2
}) => ({
  // Reset
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  // Reset
  borderRadius: 0,
  cursor: "pointer",
  "&:focus": {
    // Reset Chrome style
    borderRadius: 0
  },
  [`&.${nativeSelectClasses.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (theme2.vars || theme2).palette.background.paper
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.variant !== "filled" && ownerState.variant !== "outlined",
    style: {
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      "&&&": {
        paddingRight: 32
      }
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      borderRadius: (theme2.vars || theme2).shape.borderRadius,
      "&:focus": {
        borderRadius: (theme2.vars || theme2).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    }
  }]
}));
const NativeSelectSelect = styled(StyledSelectSelect, {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: rootShouldForwardProp,
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.select, styles2[ownerState.variant], ownerState.error && styles2.error, {
      [`&.${nativeSelectClasses.multiple}`]: styles2.multiple
    }];
  }
})({});
const StyledSelectIcon = styled("svg", {
  name: "MuiNativeSelect"
})(({
  theme: theme2
}) => ({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  // Center vertically, height is 1em
  top: "calc(50% - .5em)",
  // Don't block pointer events on the select under the icon.
  pointerEvents: "none",
  color: (theme2.vars || theme2).palette.action.active,
  [`&.${nativeSelectClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.open,
    style: {
      transform: "rotate(180deg)"
    }
  }, {
    props: {
      variant: "filled"
    },
    style: {
      right: 7
    }
  }, {
    props: {
      variant: "outlined"
    },
    style: {
      right: 7
    }
  }]
}));
const NativeSelectIcon = styled(StyledSelectIcon, {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})({});
const NativeSelectInput = /* @__PURE__ */ reactExports.forwardRef(function NativeSelectInput2(props, ref2) {
  const {
    className,
    disabled,
    error,
    IconComponent,
    inputRef,
    variant = "standard",
    ...other
  } = props;
  const ownerState = {
    ...props,
    disabled,
    variant,
    error
  };
  const classes = useUtilityClasses$h(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectSelect, {
      ownerState,
      className: clsx(classes.select, className),
      disabled,
      ref: inputRef || ref2,
      ...other
    }), props.multiple ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
      as: IconComponent,
      ownerState,
      className: classes.icon
    })]
  });
});
var _span$1;
const NotchedOutlineRoot$1 = styled("fieldset", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: rootShouldForwardProp
})({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
});
const NotchedOutlineLegend = styled("legend", {
  name: "MuiNotchedOutlined",
  shouldForwardProp: rootShouldForwardProp
})(memoTheme(({
  theme: theme2
}) => ({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden",
  // Fix Horizontal scroll when label too long
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.withLabel,
    style: {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: theme2.transitions.create("width", {
        duration: 150,
        easing: theme2.transitions.easing.easeOut
      })
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.withLabel,
    style: {
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: theme2.transitions.create("max-width", {
        duration: 50,
        easing: theme2.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.withLabel && ownerState.notched,
    style: {
      maxWidth: "100%",
      transition: theme2.transitions.create("max-width", {
        duration: 100,
        easing: theme2.transitions.easing.easeOut,
        delay: 50
      })
    }
  }]
})));
function NotchedOutline(props) {
  const {
    children,
    classes,
    className,
    label,
    notched,
    ...other
  } = props;
  const withLabel = label != null && label !== "";
  const ownerState = {
    ...props,
    notched,
    withLabel
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot$1, {
    "aria-hidden": true,
    className,
    ownerState,
    ...other,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
      ownerState,
      children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        children: label
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span$1 || (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          "aria-hidden": true,
          children: ""
        }))
      )
    })
  });
}
const useUtilityClasses$g = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
  return {
    ...classes,
    // forward classes to the InputBase
    ...composedClasses
  };
};
const OutlinedInputRoot = styled(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(memoTheme(({
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    position: "relative",
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
        borderColor: theme2.vars ? theme2.alpha(theme2.vars.palette.common.onBackground, 0.23) : borderColor2
      }
    },
    [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
      borderWidth: 2
    },
    variants: [...Object.entries(theme2.palette).filter(createSimplePaletteValueFilter()).map(([color2]) => ({
      props: {
        color: color2
      },
      style: {
        [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (theme2.vars || theme2).palette[color2].main
        }
      }
    })), {
      props: {},
      // to override the above style
      style: {
        [`&.${outlinedInputClasses.error} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (theme2.vars || theme2).palette.error.main
        },
        [`&.${outlinedInputClasses.disabled} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (theme2.vars || theme2).palette.action.disabled
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.startAdornment,
      style: {
        paddingLeft: 14
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.endAdornment,
      style: {
        paddingRight: 14
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.multiline,
      style: {
        padding: "16.5px 14px"
      }
    }, {
      props: ({
        ownerState,
        size: size2
      }) => ownerState.multiline && size2 === "small",
      style: {
        padding: "8.5px 14px"
      }
    }]
  };
}));
const NotchedOutlineRoot = styled(NotchedOutline, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline"
})(memoTheme(({
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: theme2.vars ? theme2.alpha(theme2.vars.palette.common.onBackground, 0.23) : borderColor2
  };
}));
const OutlinedInputInput = styled(InputBaseInput, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(memoTheme(({
  theme: theme2
}) => ({
  padding: "16.5px 14px",
  ...!theme2.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
      caretColor: theme2.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  },
  ...theme2.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [theme2.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  },
  variants: [{
    props: {
      size: "small"
    },
    style: {
      padding: "8.5px 14px"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.multiline,
    style: {
      padding: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.startAdornment,
    style: {
      paddingLeft: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.endAdornment,
    style: {
      paddingRight: 0
    }
  }]
})));
const OutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function OutlinedInput2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiOutlinedInput"
  });
  const {
    components = {},
    fullWidth = false,
    inputComponent = "input",
    label,
    multiline = false,
    notched,
    slots = {},
    slotProps = {},
    type = "text",
    ...other
  } = props;
  const classes = useUtilityClasses$g(props);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  });
  const ownerState = {
    ...props,
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    type
  };
  const RootSlot = slots.root ?? components.Root ?? OutlinedInputRoot;
  const InputSlot = slots.input ?? components.Input ?? OutlinedInputInput;
  const [NotchedSlot, notchedProps] = useSlot("notchedOutline", {
    elementType: NotchedOutlineRoot,
    className: classes.notchedOutline,
    shouldForwardComponentProp: true,
    ownerState,
    externalForwardedProps: {
      slots,
      slotProps
    },
    additionalProps: {
      label: label != null && label !== "" && fcs.required ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [label, "", "*"]
      }) : label
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase, {
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps,
    renderSuffix: (state2) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedSlot, {
      ...notchedProps,
      notched: typeof notched !== "undefined" ? notched : Boolean(state2.startAdornment || state2.filled || state2.focused)
    }),
    fullWidth,
    inputComponent,
    multiline,
    ref: ref2,
    type,
    ...other,
    classes: {
      ...classes,
      notchedOutline: null
    }
  });
});
OutlinedInput.muiName = "Input";
function getSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiSelect", slot);
}
const selectClasses = generateUtilityClasses("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var _span;
const SelectSelect = styled(StyledSelectSelect, {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [
      // Win specificity over the input base
      {
        [`&.${selectClasses.select}`]: styles2.select
      },
      {
        [`&.${selectClasses.select}`]: styles2[ownerState.variant]
      },
      {
        [`&.${selectClasses.error}`]: styles2.error
      },
      {
        [`&.${selectClasses.multiple}`]: styles2.multiple
      }
    ];
  }
})({
  // Win specificity over the input base
  [`&.${selectClasses.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
});
const SelectIcon = styled(StyledSelectIcon, {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})({});
const SelectNativeInput = styled("input", {
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
  name: "MuiSelect",
  slot: "NativeInput"
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function areEqualValues(a2, b2) {
  if (typeof b2 === "object" && b2 !== null) {
    return a2 === b2;
  }
  return String(a2) === String(b2);
}
function isEmpty(display) {
  return display == null || typeof display === "string" && !display.trim();
}
const useUtilityClasses$f = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return composeClasses(slots, getSelectUtilityClasses, classes);
};
const SelectInput = /* @__PURE__ */ reactExports.forwardRef(function SelectInput2(props, ref2) {
  const {
    "aria-describedby": ariaDescribedby,
    "aria-label": ariaLabel,
    autoFocus,
    autoWidth,
    children,
    className,
    defaultOpen,
    defaultValue,
    disabled,
    displayEmpty,
    error = false,
    IconComponent,
    inputRef: inputRefProp,
    labelId,
    MenuProps = {},
    multiple,
    name,
    onBlur,
    onChange,
    onClose,
    onFocus,
    onOpen,
    open: openProp,
    readOnly,
    renderValue,
    required,
    SelectDisplayProps = {},
    tabIndex: tabIndexProp,
    // catching `type` from Input which makes no sense for SelectInput
    type,
    value: valueProp,
    variant = "standard",
    ...other
  } = props;
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Select"
  });
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: defaultOpen,
    name: "Select"
  });
  const inputRef = reactExports.useRef(null);
  const displayRef = reactExports.useRef(null);
  const [displayNode, setDisplayNode] = reactExports.useState(null);
  const {
    current: isOpenControlled
  } = reactExports.useRef(openProp != null);
  const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
  const handleRef = useForkRef(ref2, inputRefProp);
  const handleDisplayRef = reactExports.useCallback((node2) => {
    displayRef.current = node2;
    if (node2) {
      setDisplayNode(node2);
    }
  }, []);
  const anchorElement = displayNode?.parentNode;
  reactExports.useImperativeHandle(handleRef, () => ({
    focus: () => {
      displayRef.current.focus();
    },
    node: inputRef.current,
    value
  }), [value]);
  reactExports.useEffect(() => {
    if (defaultOpen && openState && displayNode && !isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      displayRef.current.focus();
    }
  }, [displayNode, autoWidth]);
  reactExports.useEffect(() => {
    if (autoFocus) {
      displayRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useEffect(() => {
    if (!labelId) {
      return void 0;
    }
    const label = ownerDocument(displayRef.current).getElementById(labelId);
    if (label) {
      const handler = () => {
        if (getSelection().isCollapsed) {
          displayRef.current.focus();
        }
      };
      label.addEventListener("click", handler);
      return () => {
        label.removeEventListener("click", handler);
      };
    }
    return void 0;
  }, [labelId]);
  const update = (open2, event) => {
    if (open2) {
      if (onOpen) {
        onOpen(event);
      }
    } else if (onClose) {
      onClose(event);
    }
    if (!isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      setOpenState(open2);
    }
  };
  const handleMouseDown = (event) => {
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    displayRef.current.focus();
    update(true, event);
  };
  const handleClose = (event) => {
    update(false, event);
  };
  const childrenArray = reactExports.Children.toArray(children);
  const handleChange = (event) => {
    const child = childrenArray.find((childItem) => childItem.props.value === event.target.value);
    if (child === void 0) {
      return;
    }
    setValueState(child.props.value);
    if (onChange) {
      onChange(event, child);
    }
  };
  const handleItemClick = (child) => (event) => {
    let newValue;
    if (!event.currentTarget.hasAttribute("tabindex")) {
      return;
    }
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = value.indexOf(child.props.value);
      if (itemIndex === -1) {
        newValue.push(child.props.value);
      } else {
        newValue.splice(itemIndex, 1);
      }
    } else {
      newValue = child.props.value;
    }
    if (child.props.onClick) {
      child.props.onClick(event);
    }
    if (value !== newValue) {
      setValueState(newValue);
      if (onChange) {
        const nativeEvent = event.nativeEvent || event;
        const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
        Object.defineProperty(clonedEvent, "target", {
          writable: true,
          value: {
            value: newValue,
            name
          }
        });
        onChange(clonedEvent, child);
      }
    }
    if (!multiple) {
      update(false, event);
    }
  };
  const handleKeyDown = (event) => {
    if (!readOnly) {
      const validKeys = [
        " ",
        "ArrowUp",
        "ArrowDown",
        // The native select doesn't respond to enter on macOS, but it's recommended by
        // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
        "Enter"
      ];
      if (validKeys.includes(event.key)) {
        event.preventDefault();
        update(true, event);
      }
    }
  };
  const open = displayNode !== null && openState;
  const handleBlur = (event) => {
    if (!open && onBlur) {
      Object.defineProperty(event, "target", {
        writable: true,
        value: {
          value,
          name
        }
      });
      onBlur(event);
    }
  };
  delete other["aria-invalid"];
  let display;
  let displaySingle;
  const displayMultiple = [];
  let computeDisplay = false;
  if (isFilled({
    value
  }) || displayEmpty) {
    if (renderValue) {
      display = renderValue(value);
    } else {
      computeDisplay = true;
    }
  }
  const items = childrenArray.map((child) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return null;
    }
    let selected;
    if (multiple) {
      if (!Array.isArray(value)) {
        throw new Error(formatMuiErrorMessage(2));
      }
      selected = value.some((v2) => areEqualValues(v2, child.props.value));
      if (selected && computeDisplay) {
        displayMultiple.push(child.props.children);
      }
    } else {
      selected = areEqualValues(value, child.props.value);
      if (selected && computeDisplay) {
        displaySingle = child.props.children;
      }
    }
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      "aria-selected": selected ? "true" : "false",
      onClick: handleItemClick(child),
      onKeyUp: (event) => {
        if (event.key === " ") {
          event.preventDefault();
        }
        if (child.props.onKeyUp) {
          child.props.onKeyUp(event);
        }
      },
      role: "option",
      selected,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": child.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  if (computeDisplay) {
    if (multiple) {
      if (displayMultiple.length === 0) {
        display = null;
      } else {
        display = displayMultiple.reduce((output, child, index2) => {
          output.push(child);
          if (index2 < displayMultiple.length - 1) {
            output.push(", ");
          }
          return output;
        }, []);
      }
    } else {
      display = displaySingle;
    }
  }
  let menuMinWidth = menuMinWidthState;
  if (!autoWidth && isOpenControlled && displayNode) {
    menuMinWidth = anchorElement.clientWidth;
  }
  let tabIndex;
  if (typeof tabIndexProp !== "undefined") {
    tabIndex = tabIndexProp;
  } else {
    tabIndex = disabled ? null : 0;
  }
  const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
  const ownerState = {
    ...props,
    variant,
    value,
    open,
    error
  };
  const classes = useUtilityClasses$f(ownerState);
  const paperProps = {
    ...MenuProps.PaperProps,
    ...typeof MenuProps.slotProps?.paper === "function" ? MenuProps.slotProps.paper(ownerState) : MenuProps.slotProps?.paper
  };
  const listProps = {
    ...MenuProps.MenuListProps,
    ...typeof MenuProps.slotProps?.list === "function" ? MenuProps.slotProps.list(ownerState) : MenuProps.slotProps?.list
  };
  const listboxId = useId();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SelectSelect, {
      as: "div",
      ref: handleDisplayRef,
      tabIndex,
      role: "combobox",
      "aria-controls": open ? listboxId : void 0,
      "aria-disabled": disabled ? "true" : void 0,
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": ariaLabel,
      "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
      "aria-describedby": ariaDescribedby,
      "aria-required": required ? "true" : void 0,
      "aria-invalid": error ? "true" : void 0,
      onKeyDown: handleKeyDown,
      onMouseDown: disabled || readOnly ? null : handleMouseDown,
      onBlur: handleBlur,
      onFocus,
      ...SelectDisplayProps,
      ownerState,
      className: clsx(SelectDisplayProps.className, classes.select, className),
      id: buttonId,
      children: isEmpty(display) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span || (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          "aria-hidden": true,
          children: ""
        }))
      ) : display
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectNativeInput, {
      "aria-invalid": error,
      value: Array.isArray(value) ? value.join(",") : value,
      name,
      ref: inputRef,
      "aria-hidden": true,
      onChange: handleChange,
      tabIndex: -1,
      disabled,
      className: classes.nativeInput,
      autoFocus,
      required,
      ...other,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {
      as: IconComponent,
      className: classes.icon,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, {
      id: `menu-${name || ""}`,
      anchorEl: anchorElement,
      open,
      onClose: handleClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      ...MenuProps,
      slotProps: {
        ...MenuProps.slotProps,
        list: {
          "aria-labelledby": labelId,
          role: "listbox",
          "aria-multiselectable": multiple ? "true" : void 0,
          disableListWrap: true,
          id: listboxId,
          ...listProps
        },
        paper: {
          ...paperProps,
          style: {
            minWidth: menuMinWidth,
            ...paperProps != null ? paperProps.style : null
          }
        }
      },
      children: items
    })]
  });
});
const useUtilityClasses$e = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  const composedClasses = composeClasses(slots, getSelectUtilityClasses, classes);
  return {
    ...classes,
    ...composedClasses
  };
};
const styledRootConfig = {
  name: "MuiSelect",
  slot: "Root",
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant"
};
const StyledInput = styled(Input, styledRootConfig)("");
const StyledOutlinedInput = styled(OutlinedInput, styledRootConfig)("");
const StyledFilledInput = styled(FilledInput, styledRootConfig)("");
const Select = /* @__PURE__ */ reactExports.forwardRef(function Select2(inProps, ref2) {
  const props = useDefaultProps({
    name: "MuiSelect",
    props: inProps
  });
  const {
    autoWidth = false,
    children,
    classes: classesProp = {},
    className,
    defaultOpen = false,
    displayEmpty = false,
    IconComponent = ArrowDropDownIcon,
    id,
    input,
    inputProps,
    label,
    labelId,
    MenuProps,
    multiple = false,
    native = false,
    onClose,
    onOpen,
    open,
    renderValue,
    SelectDisplayProps,
    variant: variantProp = "outlined",
    ...other
  } = props;
  const inputComponent = native ? NativeSelectInput : SelectInput;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "error"]
  });
  const variant = fcs.variant || variantProp;
  const ownerState = {
    ...props,
    variant,
    classes: classesProp
  };
  const classes = useUtilityClasses$e(ownerState);
  const {
    root,
    ...restOfClasses
  } = classes;
  const InputComponent = input || {
    standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
      ownerState
    }),
    outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
      label,
      ownerState
    }),
    filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
      ownerState
    })
  }[variant];
  const inputComponentRef = useForkRef(ref2, getReactElementRef(InputComponent));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: /* @__PURE__ */ reactExports.cloneElement(InputComponent, {
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent,
      inputProps: {
        children,
        error: fcs.error,
        IconComponent,
        variant,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple,
        ...native ? {
          id
        } : {
          autoWidth,
          defaultOpen,
          displayEmpty,
          labelId,
          MenuProps,
          onClose,
          onOpen,
          open,
          renderValue,
          SelectDisplayProps: {
            id,
            ...SelectDisplayProps
          }
        },
        ...inputProps,
        classes: inputProps ? deepmerge(restOfClasses, inputProps.classes) : restOfClasses,
        ...input ? input.props.inputProps : {}
      },
      ...(multiple && native || displayEmpty) && variant === "outlined" ? {
        notched: true
      } : {},
      ref: inputComponentRef,
      className: clsx(InputComponent.props.className, className, classes.root),
      // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
      ...!input && {
        variant
      },
      ...other
    })
  });
});
Select.muiName = "Select";
function useSnackbar(parameters = {}) {
  const {
    autoHideDuration = null,
    disableWindowBlurListener = false,
    onClose,
    open,
    resumeHideDuration
  } = parameters;
  const timerAutoHide = useTimeout();
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    function handleKeyDown(nativeEvent) {
      if (!nativeEvent.defaultPrevented) {
        if (nativeEvent.key === "Escape") {
          onClose?.(nativeEvent, "escapeKeyDown");
        }
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [open, onClose]);
  const handleClose = useEventCallback((event, reason) => {
    onClose?.(event, reason);
  });
  const setAutoHideTimer = useEventCallback((autoHideDurationParam) => {
    if (!onClose || autoHideDurationParam == null) {
      return;
    }
    timerAutoHide.start(autoHideDurationParam, () => {
      handleClose(null, "timeout");
    });
  });
  reactExports.useEffect(() => {
    if (open) {
      setAutoHideTimer(autoHideDuration);
    }
    return timerAutoHide.clear;
  }, [open, autoHideDuration, setAutoHideTimer, timerAutoHide]);
  const handleClickAway = (event) => {
    onClose?.(event, "clickaway");
  };
  const handlePause = timerAutoHide.clear;
  const handleResume = reactExports.useCallback(() => {
    if (autoHideDuration != null) {
      setAutoHideTimer(resumeHideDuration != null ? resumeHideDuration : autoHideDuration * 0.5);
    }
  }, [autoHideDuration, resumeHideDuration, setAutoHideTimer]);
  const createHandleBlur = (otherHandlers) => (event) => {
    const onBlurCallback = otherHandlers.onBlur;
    onBlurCallback?.(event);
    handleResume();
  };
  const createHandleFocus = (otherHandlers) => (event) => {
    const onFocusCallback = otherHandlers.onFocus;
    onFocusCallback?.(event);
    handlePause();
  };
  const createMouseEnter = (otherHandlers) => (event) => {
    const onMouseEnterCallback = otherHandlers.onMouseEnter;
    onMouseEnterCallback?.(event);
    handlePause();
  };
  const createMouseLeave = (otherHandlers) => (event) => {
    const onMouseLeaveCallback = otherHandlers.onMouseLeave;
    onMouseLeaveCallback?.(event);
    handleResume();
  };
  reactExports.useEffect(() => {
    if (!disableWindowBlurListener && open) {
      window.addEventListener("focus", handleResume);
      window.addEventListener("blur", handlePause);
      return () => {
        window.removeEventListener("focus", handleResume);
        window.removeEventListener("blur", handlePause);
      };
    }
    return void 0;
  }, [disableWindowBlurListener, open, handleResume, handlePause]);
  const getRootProps = (externalProps = {}) => {
    const externalEventHandlers = {
      ...extractEventHandlers(parameters),
      ...extractEventHandlers(externalProps)
    };
    return {
      // ClickAwayListener adds an `onClick` prop which results in the alert not being announced.
      // See https://github.com/mui/material-ui/issues/29080
      role: "presentation",
      ...externalProps,
      ...externalEventHandlers,
      onBlur: createHandleBlur(externalEventHandlers),
      onFocus: createHandleFocus(externalEventHandlers),
      onMouseEnter: createMouseEnter(externalEventHandlers),
      onMouseLeave: createMouseLeave(externalEventHandlers)
    };
  };
  return {
    getRootProps,
    onClickAway: handleClickAway
  };
}
function getSnackbarContentUtilityClass(slot) {
  return generateUtilityClass("MuiSnackbarContent", slot);
}
generateUtilityClasses("MuiSnackbarContent", ["root", "message", "action"]);
const useUtilityClasses$d = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    action: ["action"],
    message: ["message"]
  };
  return composeClasses(slots, getSnackbarContentUtilityClass, classes);
};
const SnackbarContentRoot = styled(Paper, {
  name: "MuiSnackbarContent",
  slot: "Root"
})(memoTheme(({
  theme: theme2
}) => {
  const emphasis = theme2.palette.mode === "light" ? 0.8 : 0.98;
  return {
    ...theme2.typography.body2,
    color: theme2.vars ? theme2.vars.palette.SnackbarContent.color : theme2.palette.getContrastText(emphasize(theme2.palette.background.default, emphasis)),
    backgroundColor: theme2.vars ? theme2.vars.palette.SnackbarContent.bg : emphasize(theme2.palette.background.default, emphasis),
    display: "flex",
    alignItems: "center",
    flexWrap: "wrap",
    padding: "6px 16px",
    flexGrow: 1,
    [theme2.breakpoints.up("sm")]: {
      flexGrow: "initial",
      minWidth: 288
    }
  };
}));
const SnackbarContentMessage = styled("div", {
  name: "MuiSnackbarContent",
  slot: "Message"
})({
  padding: "8px 0"
});
const SnackbarContentAction = styled("div", {
  name: "MuiSnackbarContent",
  slot: "Action"
})({
  display: "flex",
  alignItems: "center",
  marginLeft: "auto",
  paddingLeft: 16,
  marginRight: -8
});
const SnackbarContent = /* @__PURE__ */ reactExports.forwardRef(function SnackbarContent2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSnackbarContent"
  });
  const {
    action,
    className,
    message,
    role = "alert",
    ...other
  } = props;
  const ownerState = props;
  const classes = useUtilityClasses$d(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SnackbarContentRoot, {
    role,
    elevation: 6,
    className: clsx(classes.root, className),
    ownerState,
    ref: ref2,
    ...other,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentMessage, {
      className: classes.message,
      ownerState,
      children: message
    }), action ? /* @__PURE__ */ jsxRuntimeExports.jsx(SnackbarContentAction, {
      className: classes.action,
      ownerState,
      children: action
    }) : null]
  });
});
function getSnackbarUtilityClass(slot) {
  return generateUtilityClass("MuiSnackbar", slot);
}
generateUtilityClasses("MuiSnackbar", ["root", "anchorOriginTopCenter", "anchorOriginBottomCenter", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft"]);
const useUtilityClasses$c = (ownerState) => {
  const {
    classes,
    anchorOrigin
  } = ownerState;
  const slots = {
    root: ["root", `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`]
  };
  return composeClasses(slots, getSnackbarUtilityClass, classes);
};
const SnackbarRoot = styled("div", {
  name: "MuiSnackbar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`anchorOrigin${capitalize(ownerState.anchorOrigin.vertical)}${capitalize(ownerState.anchorOrigin.horizontal)}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  zIndex: (theme2.vars || theme2).zIndex.snackbar,
  position: "fixed",
  display: "flex",
  left: 8,
  right: 8,
  justifyContent: "center",
  alignItems: "center",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical === "top",
    style: {
      top: 8,
      [theme2.breakpoints.up("sm")]: {
        top: 24
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.vertical !== "top",
    style: {
      bottom: 8,
      [theme2.breakpoints.up("sm")]: {
        bottom: 24
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "left",
    style: {
      justifyContent: "flex-start",
      [theme2.breakpoints.up("sm")]: {
        left: 24,
        right: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "right",
    style: {
      justifyContent: "flex-end",
      [theme2.breakpoints.up("sm")]: {
        right: 24,
        left: "auto"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.anchorOrigin.horizontal === "center",
    style: {
      [theme2.breakpoints.up("sm")]: {
        left: "50%",
        right: "auto",
        transform: "translateX(-50%)"
      }
    }
  }]
})));
const Snackbar = /* @__PURE__ */ reactExports.forwardRef(function Snackbar2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSnackbar"
  });
  const theme2 = useTheme();
  const defaultTransitionDuration = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    action,
    anchorOrigin: {
      vertical,
      horizontal
    } = {
      vertical: "bottom",
      horizontal: "left"
    },
    autoHideDuration = null,
    children,
    className,
    ClickAwayListenerProps: ClickAwayListenerPropsProp,
    ContentProps: ContentPropsProp,
    disableWindowBlurListener = false,
    message,
    onBlur,
    onClose,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    open,
    resumeHideDuration,
    slots = {},
    slotProps = {},
    TransitionComponent: TransitionComponentProp,
    transitionDuration = defaultTransitionDuration,
    TransitionProps: {
      onEnter,
      onExited,
      ...TransitionPropsProp
    } = {},
    ...other
  } = props;
  const ownerState = {
    ...props,
    anchorOrigin: {
      vertical,
      horizontal
    },
    autoHideDuration,
    disableWindowBlurListener,
    TransitionComponent: TransitionComponentProp,
    transitionDuration
  };
  const classes = useUtilityClasses$c(ownerState);
  const {
    getRootProps,
    onClickAway
  } = useSnackbar({
    ...ownerState
  });
  const [exited, setExited] = reactExports.useState(true);
  const handleExited = (node2) => {
    setExited(true);
    if (onExited) {
      onExited(node2);
    }
  };
  const handleEnter = (node2, isAppearing) => {
    setExited(false);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  };
  const externalForwardedProps = {
    slots: {
      transition: TransitionComponentProp,
      ...slots
    },
    slotProps: {
      content: ContentPropsProp,
      clickAwayListener: ClickAwayListenerPropsProp,
      transition: TransitionPropsProp,
      ...slotProps
    }
  };
  const [Root, rootProps] = useSlot("root", {
    ref: ref2,
    className: [classes.root, className],
    elementType: SnackbarRoot,
    getSlotProps: getRootProps,
    externalForwardedProps: {
      ...externalForwardedProps,
      ...other
    },
    ownerState
  });
  const [ClickAwaySlot, {
    ownerState: clickAwayOwnerStateProp,
    ...clickAwayListenerProps
  }] = useSlot("clickAwayListener", {
    elementType: ClickAwayListener,
    externalForwardedProps,
    getSlotProps: (handlers) => ({
      onClickAway: (...params) => {
        const event = params[0];
        handlers.onClickAway?.(...params);
        if (event?.defaultMuiPrevented) {
          return;
        }
        onClickAway(...params);
      }
    }),
    ownerState
  });
  const [ContentSlot, contentSlotProps] = useSlot("content", {
    elementType: SnackbarContent,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    additionalProps: {
      message,
      action
    },
    ownerState
  });
  const [TransitionSlot, transitionProps] = useSlot("transition", {
    elementType: Grow,
    externalForwardedProps,
    getSlotProps: (handlers) => ({
      onEnter: (...params) => {
        handlers.onEnter?.(...params);
        handleEnter(...params);
      },
      onExited: (...params) => {
        handlers.onExited?.(...params);
        handleExited(...params);
      }
    }),
    additionalProps: {
      appear: true,
      in: open,
      timeout: transitionDuration,
      direction: vertical === "top" ? "down" : "up"
    },
    ownerState
  });
  if (!open && exited) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClickAwaySlot, {
    ...clickAwayListenerProps,
    ...slots.clickAwayListener && {
      ownerState: clickAwayOwnerStateProp
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root, {
      ...rootProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, {
        ...transitionProps,
        children: children || /* @__PURE__ */ jsxRuntimeExports.jsx(ContentSlot, {
          ...contentSlotProps
        })
      })
    })
  });
});
function getTooltipUtilityClass(slot) {
  return generateUtilityClass("MuiTooltip", slot);
}
const tooltipClasses = generateUtilityClasses("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
const useUtilityClasses$b = (ownerState) => {
  const {
    classes,
    disableInteractive,
    arrow: arrow2,
    touch,
    placement
  } = ownerState;
  const slots = {
    popper: ["popper", !disableInteractive && "popperInteractive", arrow2 && "popperArrow"],
    tooltip: ["tooltip", arrow2 && "tooltipArrow", touch && "touch", `tooltipPlacement${capitalize(placement.split("-")[0])}`],
    arrow: ["arrow"]
  };
  return composeClasses(slots, getTooltipUtilityClass, classes);
};
const TooltipPopper = styled(Popper, {
  name: "MuiTooltip",
  slot: "Popper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.popper, !ownerState.disableInteractive && styles2.popperInteractive, ownerState.arrow && styles2.popperArrow, !ownerState.open && styles2.popperClose];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  zIndex: (theme2.vars || theme2).zIndex.tooltip,
  pointerEvents: "none",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disableInteractive,
    style: {
      pointerEvents: "auto"
    }
  }, {
    props: ({
      open
    }) => !open,
    style: {
      pointerEvents: "none"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow,
    style: {
      [`&[data-popper-placement*="bottom"] .${tooltipClasses.arrow}`]: {
        top: 0,
        marginTop: "-0.71em",
        "&::before": {
          transformOrigin: "0 100%"
        }
      },
      [`&[data-popper-placement*="top"] .${tooltipClasses.arrow}`]: {
        bottom: 0,
        marginBottom: "-0.71em",
        "&::before": {
          transformOrigin: "100% 0"
        }
      },
      [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "100% 100%"
        }
      },
      [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: {
        height: "1em",
        width: "0.71em",
        "&::before": {
          transformOrigin: "0 0"
        }
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !!ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: {
        right: 0,
        marginRight: "-0.71em"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.arrow && !!ownerState.isRtl,
    style: {
      [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: {
        left: 0,
        marginLeft: "-0.71em"
      }
    }
  }]
})));
const TooltipTooltip = styled("div", {
  name: "MuiTooltip",
  slot: "Tooltip",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.tooltip, ownerState.touch && styles2.touch, ownerState.arrow && styles2.tooltipArrow, styles2[`tooltipPlacement${capitalize(ownerState.placement.split("-")[0])}`]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  backgroundColor: theme2.vars ? theme2.vars.palette.Tooltip.bg : theme2.alpha(theme2.palette.grey[700], 0.92),
  borderRadius: (theme2.vars || theme2).shape.borderRadius,
  color: (theme2.vars || theme2).palette.common.white,
  fontFamily: theme2.typography.fontFamily,
  padding: "4px 8px",
  fontSize: theme2.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: "break-word",
  fontWeight: theme2.typography.fontWeightMedium,
  [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
    transformOrigin: "right center"
  },
  [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
    transformOrigin: "left center"
  },
  [`.${tooltipClasses.popper}[data-popper-placement*="top"] &`]: {
    transformOrigin: "center bottom",
    marginBottom: "14px"
  },
  [`.${tooltipClasses.popper}[data-popper-placement*="bottom"] &`]: {
    transformOrigin: "center top",
    marginTop: "14px"
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.arrow,
    style: {
      position: "relative",
      margin: 0
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.touch,
    style: {
      padding: "8px 16px",
      fontSize: theme2.typography.pxToRem(14),
      lineHeight: `${round(16 / 14)}em`,
      fontWeight: theme2.typography.fontWeightRegular
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.isRtl,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "14px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "14px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => !ownerState.isRtl && ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginRight: "24px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginLeft: "24px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.isRtl,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "14px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "14px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => !!ownerState.isRtl && ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: {
        marginLeft: "24px"
      },
      [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: {
        marginRight: "24px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="top"] &`]: {
        marginBottom: "24px"
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.touch,
    style: {
      [`.${tooltipClasses.popper}[data-popper-placement*="bottom"] &`]: {
        marginTop: "24px"
      }
    }
  }]
})));
const TooltipArrow = styled("span", {
  name: "MuiTooltip",
  slot: "Arrow"
})(memoTheme(({
  theme: theme2
}) => ({
  overflow: "hidden",
  position: "absolute",
  width: "1em",
  height: "0.71em",
  boxSizing: "border-box",
  color: theme2.vars ? theme2.vars.palette.Tooltip.bg : theme2.alpha(theme2.palette.grey[700], 0.9),
  "&::before": {
    content: '""',
    margin: "auto",
    display: "block",
    width: "100%",
    height: "100%",
    backgroundColor: "currentColor",
    transform: "rotate(45deg)"
  }
})));
let hystersisOpen = false;
const hystersisTimer = new Timeout();
let cursorPosition = {
  x: 0,
  y: 0
};
function composeEventHandler(handler, eventHandler) {
  return (event, ...params) => {
    if (eventHandler) {
      eventHandler(event, ...params);
    }
    handler(event, ...params);
  };
}
const Tooltip = /* @__PURE__ */ reactExports.forwardRef(function Tooltip2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTooltip"
  });
  const {
    arrow: arrow2 = false,
    children: childrenProp,
    classes: classesProp,
    components = {},
    componentsProps = {},
    describeChild = false,
    disableFocusListener = false,
    disableHoverListener = false,
    disableInteractive: disableInteractiveProp = false,
    disableTouchListener = false,
    enterDelay = 100,
    enterNextDelay = 0,
    enterTouchDelay = 700,
    followCursor = false,
    id: idProp,
    leaveDelay = 0,
    leaveTouchDelay = 1500,
    onClose,
    onOpen,
    open: openProp,
    placement = "bottom",
    PopperComponent: PopperComponentProp,
    PopperProps = {},
    slotProps = {},
    slots = {},
    title,
    TransitionComponent: TransitionComponentProp,
    TransitionProps,
    ...other
  } = props;
  const children = /* @__PURE__ */ reactExports.isValidElement(childrenProp) ? childrenProp : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    children: childrenProp
  });
  const theme2 = useTheme();
  const isRtl = useRtl();
  const [childNode, setChildNode] = reactExports.useState();
  const [arrowRef, setArrowRef] = reactExports.useState(null);
  const ignoreNonTouchEvents = reactExports.useRef(false);
  const disableInteractive = disableInteractiveProp || followCursor;
  const closeTimer = useTimeout();
  const enterTimer = useTimeout();
  const leaveTimer = useTimeout();
  const touchTimer = useTimeout();
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: "Tooltip",
    state: "open"
  });
  let open = openState;
  const id = useId(idProp);
  const prevUserSelect = reactExports.useRef();
  const stopTouchInteraction = useEventCallback(() => {
    if (prevUserSelect.current !== void 0) {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      prevUserSelect.current = void 0;
    }
    touchTimer.clear();
  });
  reactExports.useEffect(() => stopTouchInteraction, [stopTouchInteraction]);
  const handleOpen = (event) => {
    hystersisTimer.clear();
    hystersisOpen = true;
    setOpenState(true);
    if (onOpen && !open) {
      onOpen(event);
    }
  };
  const handleClose = useEventCallback(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    (event) => {
      hystersisTimer.start(800 + leaveDelay, () => {
        hystersisOpen = false;
      });
      setOpenState(false);
      if (onClose && open) {
        onClose(event);
      }
      closeTimer.start(theme2.transitions.duration.shortest, () => {
        ignoreNonTouchEvents.current = false;
      });
    }
  );
  const handleMouseOver = (event) => {
    if (ignoreNonTouchEvents.current && event.type !== "touchstart") {
      return;
    }
    if (childNode) {
      childNode.removeAttribute("title");
    }
    enterTimer.clear();
    leaveTimer.clear();
    if (enterDelay || hystersisOpen && enterNextDelay) {
      enterTimer.start(hystersisOpen ? enterNextDelay : enterDelay, () => {
        handleOpen(event);
      });
    } else {
      handleOpen(event);
    }
  };
  const handleMouseLeave = (event) => {
    enterTimer.clear();
    leaveTimer.start(leaveDelay, () => {
      handleClose(event);
    });
  };
  const [, setChildIsFocusVisible] = reactExports.useState(false);
  const handleBlur = (event) => {
    if (!isFocusVisible(event.target)) {
      setChildIsFocusVisible(false);
      handleMouseLeave(event);
    }
  };
  const handleFocus = (event) => {
    if (!childNode) {
      setChildNode(event.currentTarget);
    }
    if (isFocusVisible(event.target)) {
      setChildIsFocusVisible(true);
      handleMouseOver(event);
    }
  };
  const detectTouchStart = (event) => {
    ignoreNonTouchEvents.current = true;
    const childrenProps2 = children.props;
    if (childrenProps2.onTouchStart) {
      childrenProps2.onTouchStart(event);
    }
  };
  const handleTouchStart = (event) => {
    detectTouchStart(event);
    leaveTimer.clear();
    closeTimer.clear();
    stopTouchInteraction();
    prevUserSelect.current = document.body.style.WebkitUserSelect;
    document.body.style.WebkitUserSelect = "none";
    touchTimer.start(enterTouchDelay, () => {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      handleMouseOver(event);
    });
  };
  const handleTouchEnd = (event) => {
    if (children.props.onTouchEnd) {
      children.props.onTouchEnd(event);
    }
    stopTouchInteraction();
    leaveTimer.start(leaveTouchDelay, () => {
      handleClose(event);
    });
  };
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    function handleKeyDown(nativeEvent) {
      if (nativeEvent.key === "Escape") {
        handleClose(nativeEvent);
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [handleClose, open]);
  const handleRef = useForkRef(getReactElementRef(children), setChildNode, ref2);
  if (!title && title !== 0) {
    open = false;
  }
  const popperRef = reactExports.useRef();
  const handleMouseMove = (event) => {
    const childrenProps2 = children.props;
    if (childrenProps2.onMouseMove) {
      childrenProps2.onMouseMove(event);
    }
    cursorPosition = {
      x: event.clientX,
      y: event.clientY
    };
    if (popperRef.current) {
      popperRef.current.update();
    }
  };
  const nameOrDescProps = {};
  const titleIsString = typeof title === "string";
  if (describeChild) {
    nameOrDescProps.title = !open && titleIsString && !disableHoverListener ? title : null;
    nameOrDescProps["aria-describedby"] = open ? id : null;
  } else {
    nameOrDescProps["aria-label"] = titleIsString ? title : null;
    nameOrDescProps["aria-labelledby"] = open && !titleIsString ? id : null;
  }
  const childrenProps = {
    ...nameOrDescProps,
    ...other,
    ...children.props,
    className: clsx(other.className, children.props.className),
    onTouchStart: detectTouchStart,
    ref: handleRef,
    ...followCursor ? {
      onMouseMove: handleMouseMove
    } : {}
  };
  const interactiveWrapperListeners = {};
  if (!disableTouchListener) {
    childrenProps.onTouchStart = handleTouchStart;
    childrenProps.onTouchEnd = handleTouchEnd;
  }
  if (!disableHoverListener) {
    childrenProps.onMouseOver = composeEventHandler(handleMouseOver, childrenProps.onMouseOver);
    childrenProps.onMouseLeave = composeEventHandler(handleMouseLeave, childrenProps.onMouseLeave);
    if (!disableInteractive) {
      interactiveWrapperListeners.onMouseOver = handleMouseOver;
      interactiveWrapperListeners.onMouseLeave = handleMouseLeave;
    }
  }
  if (!disableFocusListener) {
    childrenProps.onFocus = composeEventHandler(handleFocus, childrenProps.onFocus);
    childrenProps.onBlur = composeEventHandler(handleBlur, childrenProps.onBlur);
    if (!disableInteractive) {
      interactiveWrapperListeners.onFocus = handleFocus;
      interactiveWrapperListeners.onBlur = handleBlur;
    }
  }
  const ownerState = {
    ...props,
    isRtl,
    arrow: arrow2,
    disableInteractive,
    placement,
    PopperComponentProp,
    touch: ignoreNonTouchEvents.current
  };
  const resolvedPopperProps = typeof slotProps.popper === "function" ? slotProps.popper(ownerState) : slotProps.popper;
  const popperOptions = reactExports.useMemo(() => {
    let tooltipModifiers = [{
      name: "arrow",
      enabled: Boolean(arrowRef),
      options: {
        element: arrowRef,
        padding: 4
      }
    }];
    if (PopperProps.popperOptions?.modifiers) {
      tooltipModifiers = tooltipModifiers.concat(PopperProps.popperOptions.modifiers);
    }
    if (resolvedPopperProps?.popperOptions?.modifiers) {
      tooltipModifiers = tooltipModifiers.concat(resolvedPopperProps.popperOptions.modifiers);
    }
    return {
      ...PopperProps.popperOptions,
      ...resolvedPopperProps?.popperOptions,
      modifiers: tooltipModifiers
    };
  }, [arrowRef, PopperProps.popperOptions, resolvedPopperProps?.popperOptions]);
  const classes = useUtilityClasses$b(ownerState);
  const resolvedTransitionProps = typeof slotProps.transition === "function" ? slotProps.transition(ownerState) : slotProps.transition;
  const externalForwardedProps = {
    slots: {
      popper: components.Popper,
      transition: components.Transition ?? TransitionComponentProp,
      tooltip: components.Tooltip,
      arrow: components.Arrow,
      ...slots
    },
    slotProps: {
      arrow: slotProps.arrow ?? componentsProps.arrow,
      popper: {
        ...PopperProps,
        ...resolvedPopperProps ?? componentsProps.popper
      },
      // resolvedPopperProps can be spread because it's already an object
      tooltip: slotProps.tooltip ?? componentsProps.tooltip,
      transition: {
        ...TransitionProps,
        ...resolvedTransitionProps ?? componentsProps.transition
      }
    }
  };
  const [PopperSlot, popperSlotProps] = useSlot("popper", {
    elementType: TooltipPopper,
    externalForwardedProps,
    ownerState,
    className: clsx(classes.popper, PopperProps?.className)
  });
  const [TransitionSlot, transitionSlotProps] = useSlot("transition", {
    elementType: Grow,
    externalForwardedProps,
    ownerState
  });
  const [TooltipSlot, tooltipSlotProps] = useSlot("tooltip", {
    elementType: TooltipTooltip,
    className: classes.tooltip,
    externalForwardedProps,
    ownerState
  });
  const [ArrowSlot, arrowSlotProps] = useSlot("arrow", {
    elementType: TooltipArrow,
    className: classes.arrow,
    externalForwardedProps,
    ownerState,
    ref: setArrowRef
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ reactExports.cloneElement(children, childrenProps), /* @__PURE__ */ jsxRuntimeExports.jsx(PopperSlot, {
      as: PopperComponentProp ?? Popper,
      placement,
      anchorEl: followCursor ? {
        getBoundingClientRect: () => ({
          top: cursorPosition.y,
          left: cursorPosition.x,
          right: cursorPosition.x,
          bottom: cursorPosition.y,
          width: 0,
          height: 0
        })
      } : childNode,
      popperRef,
      open: childNode ? open : false,
      id,
      transition: true,
      ...interactiveWrapperListeners,
      ...popperSlotProps,
      popperOptions,
      children: ({
        TransitionProps: TransitionPropsInner
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, {
        timeout: theme2.transitions.duration.shorter,
        ...TransitionPropsInner,
        ...transitionSlotProps,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipSlot, {
          ...tooltipSlotProps,
          children: [title, arrow2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowSlot, {
            ...arrowSlotProps
          }) : null]
        })
      })
    })]
  });
});
function getTabUtilityClass(slot) {
  return generateUtilityClass("MuiTab", slot);
}
const tabClasses = generateUtilityClasses("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper", "icon"]);
const useUtilityClasses$a = (ownerState) => {
  const {
    classes,
    textColor,
    fullWidth,
    wrapped,
    icon,
    label,
    selected,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", icon && label && "labelIcon", `textColor${capitalize(textColor)}`, fullWidth && "fullWidth", wrapped && "wrapped", selected && "selected", disabled && "disabled"],
    icon: ["iconWrapper", "icon"]
  };
  return composeClasses(slots, getTabUtilityClass, classes);
};
const TabRoot = styled(ButtonBase, {
  name: "MuiTab",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.label && ownerState.icon && styles2.labelIcon, styles2[`textColor${capitalize(ownerState.textColor)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.wrapped && styles2.wrapped, {
      [`& .${tabClasses.iconWrapper}`]: styles2.iconWrapper
    }, {
      [`& .${tabClasses.icon}`]: styles2.icon
    }];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  ...theme2.typography.button,
  maxWidth: 360,
  minWidth: 90,
  position: "relative",
  minHeight: 48,
  flexShrink: 0,
  padding: "12px 16px",
  overflow: "hidden",
  whiteSpace: "normal",
  textAlign: "center",
  lineHeight: 1.25,
  variants: [{
    props: ({
      ownerState
    }) => ownerState.label && (ownerState.iconPosition === "top" || ownerState.iconPosition === "bottom"),
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.label && ownerState.iconPosition !== "top" && ownerState.iconPosition !== "bottom",
    style: {
      flexDirection: "row"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.icon && ownerState.label,
    style: {
      minHeight: 72,
      paddingTop: 9,
      paddingBottom: 9
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "top",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginBottom: 6
      }
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "bottom",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginTop: 6
      }
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "start",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginRight: theme2.spacing(1)
      }
    }
  }, {
    props: ({
      ownerState,
      iconPosition
    }) => ownerState.icon && ownerState.label && iconPosition === "end",
    style: {
      [`& > .${tabClasses.icon}`]: {
        marginLeft: theme2.spacing(1)
      }
    }
  }, {
    props: {
      textColor: "inherit"
    },
    style: {
      color: "inherit",
      opacity: 0.6,
      // same opacity as theme.palette.text.secondary
      [`&.${tabClasses.selected}`]: {
        opacity: 1
      },
      [`&.${tabClasses.disabled}`]: {
        opacity: (theme2.vars || theme2).palette.action.disabledOpacity
      }
    }
  }, {
    props: {
      textColor: "primary"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.secondary,
      [`&.${tabClasses.selected}`]: {
        color: (theme2.vars || theme2).palette.primary.main
      },
      [`&.${tabClasses.disabled}`]: {
        color: (theme2.vars || theme2).palette.text.disabled
      }
    }
  }, {
    props: {
      textColor: "secondary"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.secondary,
      [`&.${tabClasses.selected}`]: {
        color: (theme2.vars || theme2).palette.secondary.main
      },
      [`&.${tabClasses.disabled}`]: {
        color: (theme2.vars || theme2).palette.text.disabled
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.fullWidth,
    style: {
      flexShrink: 1,
      flexGrow: 1,
      flexBasis: 0,
      maxWidth: "none"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.wrapped,
    style: {
      fontSize: theme2.typography.pxToRem(12)
    }
  }]
})));
const Tab = /* @__PURE__ */ reactExports.forwardRef(function Tab2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTab"
  });
  const {
    className,
    disabled = false,
    disableFocusRipple = false,
    // eslint-disable-next-line react/prop-types
    fullWidth,
    icon: iconProp,
    iconPosition = "top",
    // eslint-disable-next-line react/prop-types
    indicator,
    label,
    onChange,
    onClick,
    onFocus,
    // eslint-disable-next-line react/prop-types
    selected,
    // eslint-disable-next-line react/prop-types
    selectionFollowsFocus,
    // eslint-disable-next-line react/prop-types
    textColor = "inherit",
    value,
    wrapped = false,
    ...other
  } = props;
  const ownerState = {
    ...props,
    disabled,
    disableFocusRipple,
    selected,
    icon: !!iconProp,
    iconPosition,
    label: !!label,
    fullWidth,
    textColor,
    wrapped
  };
  const classes = useUtilityClasses$a(ownerState);
  const icon = iconProp && label && /* @__PURE__ */ reactExports.isValidElement(iconProp) ? /* @__PURE__ */ reactExports.cloneElement(iconProp, {
    className: clsx(classes.icon, iconProp.props.className)
  }) : iconProp;
  const handleClick = (event) => {
    if (!selected && onChange) {
      onChange(event, value);
    }
    if (onClick) {
      onClick(event);
    }
  };
  const handleFocus = (event) => {
    if (selectionFollowsFocus && !selected && onChange) {
      onChange(event, value);
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TabRoot, {
    focusRipple: !disableFocusRipple,
    className: clsx(classes.root, className),
    ref: ref2,
    role: "tab",
    "aria-selected": selected,
    disabled,
    onClick: handleClick,
    onFocus: handleFocus,
    ownerState,
    tabIndex: selected ? 0 : -1,
    ...other,
    children: [iconPosition === "top" || iconPosition === "start" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [icon, label]
    }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [label, icon]
    }), indicator]
  });
});
const TableContext = /* @__PURE__ */ reactExports.createContext();
function getTableUtilityClass(slot) {
  return generateUtilityClass("MuiTable", slot);
}
generateUtilityClasses("MuiTable", ["root", "stickyHeader"]);
const useUtilityClasses$9 = (ownerState) => {
  const {
    classes,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", stickyHeader && "stickyHeader"]
  };
  return composeClasses(slots, getTableUtilityClass, classes);
};
const TableRoot = styled("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.stickyHeader && styles2.stickyHeader];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": {
    ...theme2.typography.body2,
    padding: theme2.spacing(2),
    color: (theme2.vars || theme2).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  },
  variants: [{
    props: ({
      ownerState
    }) => ownerState.stickyHeader,
    style: {
      borderCollapse: "separate"
    }
  }]
})));
const defaultComponent$3 = "table";
const Table = /* @__PURE__ */ reactExports.forwardRef(function Table2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTable"
  });
  const {
    className,
    component = defaultComponent$3,
    padding: padding2 = "normal",
    size: size2 = "medium",
    stickyHeader = false,
    ...other
  } = props;
  const ownerState = {
    ...props,
    component,
    padding: padding2,
    size: size2,
    stickyHeader
  };
  const classes = useUtilityClasses$9(ownerState);
  const table = reactExports.useMemo(() => ({
    padding: padding2,
    size: size2,
    stickyHeader
  }), [padding2, size2, stickyHeader]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContext.Provider, {
    value: table,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableRoot, {
      as: component,
      role: component === defaultComponent$3 ? null : "table",
      ref: ref2,
      className: clsx(classes.root, className),
      ownerState,
      ...other
    })
  });
});
const Tablelvl2Context = /* @__PURE__ */ reactExports.createContext();
function getTableBodyUtilityClass(slot) {
  return generateUtilityClass("MuiTableBody", slot);
}
generateUtilityClasses("MuiTableBody", ["root"]);
const useUtilityClasses$8 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableBodyUtilityClass, classes);
};
const TableBodyRoot = styled("tbody", {
  name: "MuiTableBody",
  slot: "Root"
})({
  display: "table-row-group"
});
const tablelvl2$1 = {
  variant: "body"
};
const defaultComponent$2 = "tbody";
const TableBody = /* @__PURE__ */ reactExports.forwardRef(function TableBody2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableBody"
  });
  const {
    className,
    component = defaultComponent$2,
    ...other
  } = props;
  const ownerState = {
    ...props,
    component
  };
  const classes = useUtilityClasses$8(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
    value: tablelvl2$1,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableBodyRoot, {
      className: clsx(classes.root, className),
      as: component,
      ref: ref2,
      role: component === defaultComponent$2 ? null : "rowgroup",
      ownerState,
      ...other
    })
  });
});
function getTableCellUtilityClass(slot) {
  return generateUtilityClass("MuiTableCell", slot);
}
const tableCellClasses = generateUtilityClasses("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]);
const useUtilityClasses$7 = (ownerState) => {
  const {
    classes,
    variant,
    align,
    padding: padding2,
    size: size2,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", variant, stickyHeader && "stickyHeader", align !== "inherit" && `align${capitalize(align)}`, padding2 !== "normal" && `padding${capitalize(padding2)}`, `size${capitalize(size2)}`]
  };
  return composeClasses(slots, getTableCellUtilityClass, classes);
};
const TableCellRoot = styled("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize(ownerState.size)}`], ownerState.padding !== "normal" && styles2[`padding${capitalize(ownerState.padding)}`], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.stickyHeader && styles2.stickyHeader];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  ...theme2.typography.body2,
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: theme2.vars ? `1px solid ${theme2.vars.palette.TableCell.border}` : `1px solid
    ${theme2.palette.mode === "light" ? theme2.lighten(theme2.alpha(theme2.palette.divider, 1), 0.88) : theme2.darken(theme2.alpha(theme2.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16,
  variants: [{
    props: {
      variant: "head"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.primary,
      lineHeight: theme2.typography.pxToRem(24),
      fontWeight: theme2.typography.fontWeightMedium
    }
  }, {
    props: {
      variant: "body"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.primary
    }
  }, {
    props: {
      variant: "footer"
    },
    style: {
      color: (theme2.vars || theme2).palette.text.secondary,
      lineHeight: theme2.typography.pxToRem(21),
      fontSize: theme2.typography.pxToRem(12)
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: "6px 16px",
      [`&.${tableCellClasses.paddingCheckbox}`]: {
        width: 24,
        // prevent the checkbox column from growing
        padding: "0 12px 0 16px",
        "& > *": {
          padding: 0
        }
      }
    }
  }, {
    props: {
      padding: "checkbox"
    },
    style: {
      width: 48,
      // prevent the checkbox column from growing
      padding: "0 0 0 4px"
    }
  }, {
    props: {
      padding: "none"
    },
    style: {
      padding: 0
    }
  }, {
    props: {
      align: "left"
    },
    style: {
      textAlign: "left"
    }
  }, {
    props: {
      align: "center"
    },
    style: {
      textAlign: "center"
    }
  }, {
    props: {
      align: "right"
    },
    style: {
      textAlign: "right",
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      align: "justify"
    },
    style: {
      textAlign: "justify"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.stickyHeader,
    style: {
      position: "sticky",
      top: 0,
      zIndex: 2,
      backgroundColor: (theme2.vars || theme2).palette.background.default
    }
  }]
})));
const TableCell = /* @__PURE__ */ reactExports.forwardRef(function TableCell2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableCell"
  });
  const {
    align = "inherit",
    className,
    component: componentProp,
    padding: paddingProp,
    scope: scopeProp,
    size: sizeProp,
    sortDirection,
    variant: variantProp,
    ...other
  } = props;
  const table = reactExports.useContext(TableContext);
  const tablelvl22 = reactExports.useContext(Tablelvl2Context);
  const isHeadCell = tablelvl22 && tablelvl22.variant === "head";
  let component;
  if (componentProp) {
    component = componentProp;
  } else {
    component = isHeadCell ? "th" : "td";
  }
  let scope = scopeProp;
  if (component === "td") {
    scope = void 0;
  } else if (!scope && isHeadCell) {
    scope = "col";
  }
  const variant = variantProp || tablelvl22 && tablelvl22.variant;
  const ownerState = {
    ...props,
    align,
    component,
    padding: paddingProp || (table && table.padding ? table.padding : "normal"),
    size: sizeProp || (table && table.size ? table.size : "medium"),
    sortDirection,
    stickyHeader: variant === "head" && table && table.stickyHeader,
    variant
  };
  const classes = useUtilityClasses$7(ownerState);
  let ariaSort = null;
  if (sortDirection) {
    ariaSort = sortDirection === "asc" ? "ascending" : "descending";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableCellRoot, {
    as: component,
    ref: ref2,
    className: clsx(classes.root, className),
    "aria-sort": ariaSort,
    scope,
    ownerState,
    ...other
  });
});
function getTableContainerUtilityClass(slot) {
  return generateUtilityClass("MuiTableContainer", slot);
}
generateUtilityClasses("MuiTableContainer", ["root"]);
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableContainerUtilityClass, classes);
};
const TableContainerRoot = styled("div", {
  name: "MuiTableContainer",
  slot: "Root"
})({
  width: "100%",
  overflowX: "auto"
});
const TableContainer = /* @__PURE__ */ reactExports.forwardRef(function TableContainer2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableContainer"
  });
  const {
    className,
    component = "div",
    ...other
  } = props;
  const ownerState = {
    ...props,
    component
  };
  const classes = useUtilityClasses$6(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainerRoot, {
    ref: ref2,
    as: component,
    className: clsx(classes.root, className),
    ownerState,
    ...other
  });
});
function getTableHeadUtilityClass(slot) {
  return generateUtilityClass("MuiTableHead", slot);
}
generateUtilityClasses("MuiTableHead", ["root"]);
const useUtilityClasses$5 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableHeadUtilityClass, classes);
};
const TableHeadRoot = styled("thead", {
  name: "MuiTableHead",
  slot: "Root"
})({
  display: "table-header-group"
});
const tablelvl2 = {
  variant: "head"
};
const defaultComponent$1 = "thead";
const TableHead = /* @__PURE__ */ reactExports.forwardRef(function TableHead2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableHead"
  });
  const {
    className,
    component = defaultComponent$1,
    ...other
  } = props;
  const ownerState = {
    ...props,
    component
  };
  const classes = useUtilityClasses$5(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
    value: tablelvl2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeadRoot, {
      as: component,
      className: clsx(classes.root, className),
      ref: ref2,
      role: component === defaultComponent$1 ? null : "rowgroup",
      ownerState,
      ...other
    })
  });
});
function getToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiToolbar", slot);
}
generateUtilityClasses("MuiToolbar", ["root", "gutters", "regular", "dense"]);
const useUtilityClasses$4 = (ownerState) => {
  const {
    classes,
    disableGutters,
    variant
  } = ownerState;
  const slots = {
    root: ["root", !disableGutters && "gutters", variant]
  };
  return composeClasses(slots, getToolbarUtilityClass, classes);
};
const ToolbarRoot = styled("div", {
  name: "MuiToolbar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableGutters && styles2.gutters, styles2[ownerState.variant]];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  position: "relative",
  display: "flex",
  alignItems: "center",
  variants: [{
    props: ({
      ownerState
    }) => !ownerState.disableGutters,
    style: {
      paddingLeft: theme2.spacing(2),
      paddingRight: theme2.spacing(2),
      [theme2.breakpoints.up("sm")]: {
        paddingLeft: theme2.spacing(3),
        paddingRight: theme2.spacing(3)
      }
    }
  }, {
    props: {
      variant: "dense"
    },
    style: {
      minHeight: 48
    }
  }, {
    props: {
      variant: "regular"
    },
    style: theme2.mixins.toolbar
  }]
})));
const Toolbar = /* @__PURE__ */ reactExports.forwardRef(function Toolbar2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiToolbar"
  });
  const {
    className,
    component = "div",
    disableGutters = false,
    variant = "regular",
    ...other
  } = props;
  const ownerState = {
    ...props,
    component,
    disableGutters,
    variant
  };
  const classes = useUtilityClasses$4(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarRoot, {
    as: component,
    className: clsx(classes.root, className),
    ref: ref2,
    ownerState,
    ...other
  });
});
const KeyboardArrowLeft = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}));
const KeyboardArrowRight = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}));
function getTableRowUtilityClass(slot) {
  return generateUtilityClass("MuiTableRow", slot);
}
const tableRowClasses = generateUtilityClasses("MuiTableRow", ["root", "selected", "hover", "head", "footer"]);
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes,
    selected,
    hover,
    head,
    footer
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected", hover && "hover", head && "head", footer && "footer"]
  };
  return composeClasses(slots, getTableRowUtilityClass, classes);
};
const TableRowRoot = styled("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.head && styles2.head, ownerState.footer && styles2.footer];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${tableRowClasses.hover}:hover`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.hover
  },
  [`&.${tableRowClasses.selected}`]: {
    backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, (theme2.vars || theme2).palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: theme2.alpha((theme2.vars || theme2).palette.primary.main, `${(theme2.vars || theme2).palette.action.selectedOpacity} + ${(theme2.vars || theme2).palette.action.hoverOpacity}`)
    }
  }
})));
const defaultComponent = "tr";
const TableRow = /* @__PURE__ */ reactExports.forwardRef(function TableRow2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTableRow"
  });
  const {
    className,
    component = defaultComponent,
    hover = false,
    selected = false,
    ...other
  } = props;
  const tablelvl22 = reactExports.useContext(Tablelvl2Context);
  const ownerState = {
    ...props,
    component,
    hover,
    selected,
    head: tablelvl22 && tablelvl22.variant === "head",
    footer: tablelvl22 && tablelvl22.variant === "footer"
  };
  const classes = useUtilityClasses$3(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRowRoot, {
    as: component,
    ref: ref2,
    className: clsx(classes.root, className),
    role: component === defaultComponent ? null : "row",
    ownerState,
    ...other
  });
});
function easeInOutSin(time2) {
  return (1 + Math.sin(Math.PI * time2 - Math.PI / 2)) / 2;
}
function animate(property, element, to, options = {}, cb = () => {
}) {
  const {
    ease = easeInOutSin,
    duration: duration2 = 300
    // standard
  } = options;
  let start2 = null;
  const from2 = element[property];
  let cancelled = false;
  const cancel = () => {
    cancelled = true;
  };
  const step = (timestamp) => {
    if (cancelled) {
      cb(new Error("Animation cancelled"));
      return;
    }
    if (start2 === null) {
      start2 = timestamp;
    }
    const time2 = Math.min(1, (timestamp - start2) / duration2);
    element[property] = ease(time2) * (to - from2) + from2;
    if (time2 >= 1) {
      requestAnimationFrame(() => {
        cb(null);
      });
      return;
    }
    requestAnimationFrame(step);
  };
  if (from2 === to) {
    cb(new Error("Element already at target position"));
    return cancel;
  }
  requestAnimationFrame(step);
  return cancel;
}
const styles$2e = {
  width: 99,
  height: 99,
  position: "absolute",
  top: -9999,
  overflow: "scroll"
};
function ScrollbarSize(props) {
  const {
    onChange,
    ...other
  } = props;
  const scrollbarHeight = reactExports.useRef();
  const nodeRef = reactExports.useRef(null);
  const setMeasurements = () => {
    scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;
  };
  useEnhancedEffect(() => {
    const handleResize = debounce$1(() => {
      const prevHeight = scrollbarHeight.current;
      setMeasurements();
      if (prevHeight !== scrollbarHeight.current) {
        onChange(scrollbarHeight.current);
      }
    });
    const containerWindow = ownerWindow(nodeRef.current);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [onChange]);
  reactExports.useEffect(() => {
    setMeasurements();
    onChange(scrollbarHeight.current);
  }, [onChange]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    style: styles$2e,
    ...other,
    ref: nodeRef
  });
}
function getTabScrollButtonUtilityClass(slot) {
  return generateUtilityClass("MuiTabScrollButton", slot);
}
const tabScrollButtonClasses = generateUtilityClasses("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]);
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes,
    orientation,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", orientation, disabled && "disabled"]
  };
  return composeClasses(slots, getTabScrollButtonUtilityClass, classes);
};
const TabScrollButtonRoot = styled(ButtonBase, {
  name: "MuiTabScrollButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.orientation && styles2[ownerState.orientation]];
  }
})({
  width: 40,
  flexShrink: 0,
  opacity: 0.8,
  [`&.${tabScrollButtonClasses.disabled}`]: {
    opacity: 0
  },
  variants: [{
    props: {
      orientation: "vertical"
    },
    style: {
      width: "100%",
      height: 40,
      "& svg": {
        transform: "var(--TabScrollButton-svgRotate)"
      }
    }
  }]
});
const TabScrollButton = /* @__PURE__ */ reactExports.forwardRef(function TabScrollButton2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTabScrollButton"
  });
  const {
    className,
    slots = {},
    slotProps = {},
    direction,
    orientation,
    disabled,
    ...other
  } = props;
  const isRtl = useRtl();
  const ownerState = {
    isRtl,
    ...props
  };
  const classes = useUtilityClasses$2(ownerState);
  const StartButtonIcon = slots.StartScrollButtonIcon ?? KeyboardArrowLeft;
  const EndButtonIcon = slots.EndScrollButtonIcon ?? KeyboardArrowRight;
  const startButtonIconProps = useSlotProps({
    elementType: StartButtonIcon,
    externalSlotProps: slotProps.startScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState
  });
  const endButtonIconProps = useSlotProps({
    elementType: EndButtonIcon,
    externalSlotProps: slotProps.endScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabScrollButtonRoot, {
    component: "div",
    className: clsx(classes.root, className),
    ref: ref2,
    role: null,
    ownerState,
    tabIndex: null,
    ...other,
    style: {
      ...other.style,
      ...orientation === "vertical" && {
        "--TabScrollButton-svgRotate": `rotate(${isRtl ? -90 : 90}deg)`
      }
    },
    children: direction === "left" ? /* @__PURE__ */ jsxRuntimeExports.jsx(StartButtonIcon, {
      ...startButtonIconProps
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(EndButtonIcon, {
      ...endButtonIconProps
    })
  });
});
function getTabsUtilityClass(slot) {
  return generateUtilityClass("MuiTabs", slot);
}
const tabsClasses = generateUtilityClasses("MuiTabs", ["root", "vertical", "list", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]);
const nextItem = (list, item) => {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return list.firstChild;
};
const previousItem = (list, item) => {
  if (list === item) {
    return list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return list.lastChild;
};
const moveFocus = (list, currentFocus, traversalFunction) => {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus);
    } else {
      nextFocus.focus();
      return;
    }
  }
};
const useUtilityClasses$1 = (ownerState) => {
  const {
    vertical,
    fixed,
    hideScrollbar,
    scrollableX,
    scrollableY,
    centered,
    scrollButtonsHideMobile,
    classes
  } = ownerState;
  const slots = {
    root: ["root", vertical && "vertical"],
    scroller: ["scroller", fixed && "fixed", hideScrollbar && "hideScrollbar", scrollableX && "scrollableX", scrollableY && "scrollableY"],
    list: ["list", "flexContainer", vertical && "flexContainerVertical", vertical && "vertical", centered && "centered"],
    indicator: ["indicator"],
    scrollButtons: ["scrollButtons", scrollButtonsHideMobile && "scrollButtonsHideMobile"],
    scrollableX: [scrollableX && "scrollableX"],
    hideScrollbar: [hideScrollbar && "hideScrollbar"]
  };
  return composeClasses(slots, getTabsUtilityClass, classes);
};
const TabsRoot = styled("div", {
  name: "MuiTabs",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${tabsClasses.scrollButtons}`]: styles2.scrollButtons
    }, {
      [`& .${tabsClasses.scrollButtons}`]: ownerState.scrollButtonsHideMobile && styles2.scrollButtonsHideMobile
    }, styles2.root, ownerState.vertical && styles2.vertical];
  }
})(memoTheme(({
  theme: theme2
}) => ({
  overflow: "hidden",
  minHeight: 48,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  display: "flex",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.vertical,
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.scrollButtonsHideMobile,
    style: {
      [`& .${tabsClasses.scrollButtons}`]: {
        [theme2.breakpoints.down("sm")]: {
          display: "none"
        }
      }
    }
  }]
})));
const TabsScroller = styled("div", {
  name: "MuiTabs",
  slot: "Scroller",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.scroller, ownerState.fixed && styles2.fixed, ownerState.hideScrollbar && styles2.hideScrollbar, ownerState.scrollableX && styles2.scrollableX, ownerState.scrollableY && styles2.scrollableY];
  }
})({
  position: "relative",
  display: "inline-block",
  flex: "1 1 auto",
  whiteSpace: "nowrap",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.fixed,
    style: {
      overflowX: "hidden",
      width: "100%"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.hideScrollbar,
    style: {
      // Hide dimensionless scrollbar on macOS
      scrollbarWidth: "none",
      // Firefox
      "&::-webkit-scrollbar": {
        display: "none"
        // Safari + Chrome
      }
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.scrollableX,
    style: {
      overflowX: "auto",
      overflowY: "hidden"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.scrollableY,
    style: {
      overflowY: "auto",
      overflowX: "hidden"
    }
  }]
});
const List = styled("div", {
  name: "MuiTabs",
  slot: "List",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.list, styles2.flexContainer, ownerState.vertical && styles2.flexContainerVertical, ownerState.centered && styles2.centered];
  }
})({
  display: "flex",
  variants: [{
    props: ({
      ownerState
    }) => ownerState.vertical,
    style: {
      flexDirection: "column"
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.centered,
    style: {
      justifyContent: "center"
    }
  }]
});
const TabsIndicator = styled("span", {
  name: "MuiTabs",
  slot: "Indicator"
})(memoTheme(({
  theme: theme2
}) => ({
  position: "absolute",
  height: 2,
  bottom: 0,
  width: "100%",
  transition: theme2.transitions.create(),
  variants: [{
    props: {
      indicatorColor: "primary"
    },
    style: {
      backgroundColor: (theme2.vars || theme2).palette.primary.main
    }
  }, {
    props: {
      indicatorColor: "secondary"
    },
    style: {
      backgroundColor: (theme2.vars || theme2).palette.secondary.main
    }
  }, {
    props: ({
      ownerState
    }) => ownerState.vertical,
    style: {
      height: "100%",
      width: 2,
      right: 0
    }
  }]
})));
const TabsScrollbarSize = styled(ScrollbarSize)({
  overflowX: "auto",
  overflowY: "hidden",
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: "none",
  // Firefox
  "&::-webkit-scrollbar": {
    display: "none"
    // Safari + Chrome
  }
});
const defaultIndicatorStyle = {};
const Tabs = /* @__PURE__ */ reactExports.forwardRef(function Tabs2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTabs"
  });
  const theme2 = useTheme();
  const isRtl = useRtl();
  const {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    action,
    centered = false,
    children: childrenProp,
    className,
    component = "div",
    allowScrollButtonsMobile = false,
    indicatorColor = "primary",
    onChange,
    orientation = "horizontal",
    ScrollButtonComponent,
    // TODO: remove in v7 (deprecated in v6)
    scrollButtons = "auto",
    selectionFollowsFocus,
    slots = {},
    slotProps = {},
    TabIndicatorProps = {},
    // TODO: remove in v7 (deprecated in v6)
    TabScrollButtonProps = {},
    // TODO: remove in v7 (deprecated in v6)
    textColor = "primary",
    value,
    variant = "standard",
    visibleScrollbar = false,
    ...other
  } = props;
  const scrollable = variant === "scrollable";
  const vertical = orientation === "vertical";
  const scrollStart = vertical ? "scrollTop" : "scrollLeft";
  const start2 = vertical ? "top" : "left";
  const end2 = vertical ? "bottom" : "right";
  const clientSize = vertical ? "clientHeight" : "clientWidth";
  const size2 = vertical ? "height" : "width";
  const ownerState = {
    ...props,
    component,
    allowScrollButtonsMobile,
    indicatorColor,
    orientation,
    vertical,
    scrollButtons,
    textColor,
    variant,
    visibleScrollbar,
    fixed: !scrollable,
    hideScrollbar: scrollable && !visibleScrollbar,
    scrollableX: scrollable && !vertical,
    scrollableY: scrollable && vertical,
    centered: centered && !scrollable,
    scrollButtonsHideMobile: !allowScrollButtonsMobile
  };
  const classes = useUtilityClasses$1(ownerState);
  const startScrollButtonIconProps = useSlotProps({
    elementType: slots.StartScrollButtonIcon,
    externalSlotProps: slotProps.startScrollButtonIcon,
    ownerState
  });
  const endScrollButtonIconProps = useSlotProps({
    elementType: slots.EndScrollButtonIcon,
    externalSlotProps: slotProps.endScrollButtonIcon,
    ownerState
  });
  const [mounted, setMounted] = reactExports.useState(false);
  const [indicatorStyle, setIndicatorStyle] = reactExports.useState(defaultIndicatorStyle);
  const [displayStartScroll, setDisplayStartScroll] = reactExports.useState(false);
  const [displayEndScroll, setDisplayEndScroll] = reactExports.useState(false);
  const [updateScrollObserver, setUpdateScrollObserver] = reactExports.useState(false);
  const [scrollerStyle, setScrollerStyle] = reactExports.useState({
    overflow: "hidden",
    scrollbarWidth: 0
  });
  const valueToIndex = /* @__PURE__ */ new Map();
  const tabsRef = reactExports.useRef(null);
  const tabListRef = reactExports.useRef(null);
  const externalForwardedProps = {
    slots,
    slotProps: {
      indicator: TabIndicatorProps,
      scrollButton: TabScrollButtonProps,
      ...slotProps
    }
  };
  const getTabsMeta = () => {
    const tabsNode = tabsRef.current;
    let tabsMeta;
    if (tabsNode) {
      const rect = tabsNode.getBoundingClientRect();
      tabsMeta = {
        clientWidth: tabsNode.clientWidth,
        scrollLeft: tabsNode.scrollLeft,
        scrollTop: tabsNode.scrollTop,
        scrollWidth: tabsNode.scrollWidth,
        top: rect.top,
        bottom: rect.bottom,
        left: rect.left,
        right: rect.right
      };
    }
    let tabMeta;
    if (tabsNode && value !== false) {
      const children2 = tabListRef.current.children;
      if (children2.length > 0) {
        const tab = children2[valueToIndex.get(value)];
        tabMeta = tab ? tab.getBoundingClientRect() : null;
      }
    }
    return {
      tabsMeta,
      tabMeta
    };
  };
  const updateIndicatorState = useEventCallback(() => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    let startValue = 0;
    let startIndicator;
    if (vertical) {
      startIndicator = "top";
      if (tabMeta && tabsMeta) {
        startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;
      }
    } else {
      startIndicator = isRtl ? "right" : "left";
      if (tabMeta && tabsMeta) {
        startValue = (isRtl ? -1 : 1) * (tabMeta[startIndicator] - tabsMeta[startIndicator] + tabsMeta.scrollLeft);
      }
    }
    const newIndicatorStyle = {
      [startIndicator]: startValue,
      // May be wrong until the font is loaded.
      [size2]: tabMeta ? tabMeta[size2] : 0
    };
    if (typeof indicatorStyle[startIndicator] !== "number" || typeof indicatorStyle[size2] !== "number") {
      setIndicatorStyle(newIndicatorStyle);
    } else {
      const dStart = Math.abs(indicatorStyle[startIndicator] - newIndicatorStyle[startIndicator]);
      const dSize = Math.abs(indicatorStyle[size2] - newIndicatorStyle[size2]);
      if (dStart >= 1 || dSize >= 1) {
        setIndicatorStyle(newIndicatorStyle);
      }
    }
  });
  const scroll = (scrollValue, {
    animation = true
  } = {}) => {
    if (animation) {
      animate(scrollStart, tabsRef.current, scrollValue, {
        duration: theme2.transitions.duration.standard
      });
    } else {
      tabsRef.current[scrollStart] = scrollValue;
    }
  };
  const moveTabsScroll = (delta) => {
    let scrollValue = tabsRef.current[scrollStart];
    if (vertical) {
      scrollValue += delta;
    } else {
      scrollValue += delta * (isRtl ? -1 : 1);
    }
    scroll(scrollValue);
  };
  const getScrollSize = () => {
    const containerSize = tabsRef.current[clientSize];
    let totalSize = 0;
    const children2 = Array.from(tabListRef.current.children);
    for (let i4 = 0; i4 < children2.length; i4 += 1) {
      const tab = children2[i4];
      if (totalSize + tab[clientSize] > containerSize) {
        if (i4 === 0) {
          totalSize = containerSize;
        }
        break;
      }
      totalSize += tab[clientSize];
    }
    return totalSize;
  };
  const handleStartScrollClick = () => {
    moveTabsScroll(-1 * getScrollSize());
  };
  const handleEndScrollClick = () => {
    moveTabsScroll(getScrollSize());
  };
  const [ScrollbarSlot, {
    onChange: scrollbarOnChange,
    ...scrollbarSlotProps
  }] = useSlot("scrollbar", {
    className: clsx(classes.scrollableX, classes.hideScrollbar),
    elementType: TabsScrollbarSize,
    shouldForwardComponentProp: true,
    externalForwardedProps,
    ownerState
  });
  const handleScrollbarSizeChange = reactExports.useCallback((scrollbarWidth) => {
    scrollbarOnChange?.(scrollbarWidth);
    setScrollerStyle({
      overflow: null,
      scrollbarWidth
    });
  }, [scrollbarOnChange]);
  const [ScrollButtonsSlot, scrollButtonSlotProps] = useSlot("scrollButtons", {
    className: clsx(classes.scrollButtons, TabScrollButtonProps.className),
    elementType: TabScrollButton,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      orientation,
      slots: {
        StartScrollButtonIcon: slots.startScrollButtonIcon || slots.StartScrollButtonIcon,
        EndScrollButtonIcon: slots.endScrollButtonIcon || slots.EndScrollButtonIcon
      },
      slotProps: {
        startScrollButtonIcon: startScrollButtonIconProps,
        endScrollButtonIcon: endScrollButtonIconProps
      }
    }
  });
  const getConditionalElements = () => {
    const conditionalElements2 = {};
    conditionalElements2.scrollbarSizeListener = scrollable ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollbarSlot, {
      ...scrollbarSlotProps,
      onChange: handleScrollbarSizeChange
    }) : null;
    const scrollButtonsActive = displayStartScroll || displayEndScroll;
    const showScrollButtons = scrollable && (scrollButtons === "auto" && scrollButtonsActive || scrollButtons === true);
    conditionalElements2.scrollButtonStart = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonsSlot, {
      direction: isRtl ? "right" : "left",
      onClick: handleStartScrollClick,
      disabled: !displayStartScroll,
      ...scrollButtonSlotProps
    }) : null;
    conditionalElements2.scrollButtonEnd = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonsSlot, {
      direction: isRtl ? "left" : "right",
      onClick: handleEndScrollClick,
      disabled: !displayEndScroll,
      ...scrollButtonSlotProps
    }) : null;
    return conditionalElements2;
  };
  const scrollSelectedIntoView = useEventCallback((animation) => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    if (!tabMeta || !tabsMeta) {
      return;
    }
    if (tabMeta[start2] < tabsMeta[start2]) {
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start2] - tabsMeta[start2]);
      scroll(nextScrollStart, {
        animation
      });
    } else if (tabMeta[end2] > tabsMeta[end2]) {
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end2] - tabsMeta[end2]);
      scroll(nextScrollStart, {
        animation
      });
    }
  });
  const updateScrollButtonState = useEventCallback(() => {
    if (scrollable && scrollButtons !== false) {
      setUpdateScrollObserver(!updateScrollObserver);
    }
  });
  reactExports.useEffect(() => {
    const handleResize = debounce$1(() => {
      if (tabsRef.current) {
        updateIndicatorState();
      }
    });
    let resizeObserver;
    const handleMutation = (records) => {
      records.forEach((record) => {
        record.removedNodes.forEach((item) => {
          resizeObserver?.unobserve(item);
        });
        record.addedNodes.forEach((item) => {
          resizeObserver?.observe(item);
        });
      });
      handleResize();
      updateScrollButtonState();
    };
    const win = ownerWindow(tabsRef.current);
    win.addEventListener("resize", handleResize);
    let mutationObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      Array.from(tabListRef.current.children).forEach((child) => {
        resizeObserver.observe(child);
      });
    }
    if (typeof MutationObserver !== "undefined") {
      mutationObserver = new MutationObserver(handleMutation);
      mutationObserver.observe(tabListRef.current, {
        childList: true
      });
    }
    return () => {
      handleResize.clear();
      win.removeEventListener("resize", handleResize);
      mutationObserver?.disconnect();
      resizeObserver?.disconnect();
    };
  }, [updateIndicatorState, updateScrollButtonState]);
  reactExports.useEffect(() => {
    const tabListChildren = Array.from(tabListRef.current.children);
    const length2 = tabListChildren.length;
    if (typeof IntersectionObserver !== "undefined" && length2 > 0 && scrollable && scrollButtons !== false) {
      const firstTab = tabListChildren[0];
      const lastTab = tabListChildren[length2 - 1];
      const observerOptions = {
        root: tabsRef.current,
        threshold: 0.99
      };
      const handleScrollButtonStart = (entries2) => {
        setDisplayStartScroll(!entries2[0].isIntersecting);
      };
      const firstObserver = new IntersectionObserver(handleScrollButtonStart, observerOptions);
      firstObserver.observe(firstTab);
      const handleScrollButtonEnd = (entries2) => {
        setDisplayEndScroll(!entries2[0].isIntersecting);
      };
      const lastObserver = new IntersectionObserver(handleScrollButtonEnd, observerOptions);
      lastObserver.observe(lastTab);
      return () => {
        firstObserver.disconnect();
        lastObserver.disconnect();
      };
    }
    return void 0;
  }, [scrollable, scrollButtons, updateScrollObserver, childrenProp?.length]);
  reactExports.useEffect(() => {
    setMounted(true);
  }, []);
  reactExports.useEffect(() => {
    updateIndicatorState();
  });
  reactExports.useEffect(() => {
    scrollSelectedIntoView(defaultIndicatorStyle !== indicatorStyle);
  }, [scrollSelectedIntoView, indicatorStyle]);
  reactExports.useImperativeHandle(action, () => ({
    updateIndicator: updateIndicatorState,
    updateScrollButtons: updateScrollButtonState
  }), [updateIndicatorState, updateScrollButtonState]);
  const [IndicatorSlot, indicatorSlotProps] = useSlot("indicator", {
    className: clsx(classes.indicator, TabIndicatorProps.className),
    elementType: TabsIndicator,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      style: indicatorStyle
    }
  });
  const indicator = /* @__PURE__ */ jsxRuntimeExports.jsx(IndicatorSlot, {
    ...indicatorSlotProps
  });
  let childIndex = 0;
  const children = reactExports.Children.map(childrenProp, (child) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return null;
    }
    const childValue = child.props.value === void 0 ? childIndex : child.props.value;
    valueToIndex.set(childValue, childIndex);
    const selected = childValue === value;
    childIndex += 1;
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      fullWidth: variant === "fullWidth",
      indicator: selected && !mounted && indicator,
      selected,
      selectionFollowsFocus,
      onChange,
      textColor,
      value: childValue,
      ...childIndex === 1 && value === false && !child.props.tabIndex ? {
        tabIndex: 0
      } : {}
    });
  });
  const handleKeyDown = (event) => {
    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
      return;
    }
    const list = tabListRef.current;
    const currentFocus = ownerDocument(list).activeElement;
    const role = currentFocus.getAttribute("role");
    if (role !== "tab") {
      return;
    }
    let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
    let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
    if (orientation === "horizontal" && isRtl) {
      previousItemKey = "ArrowRight";
      nextItemKey = "ArrowLeft";
    }
    switch (event.key) {
      case previousItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, previousItem);
        break;
      case nextItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, nextItem);
        break;
      case "Home":
        event.preventDefault();
        moveFocus(list, null, nextItem);
        break;
      case "End":
        event.preventDefault();
        moveFocus(list, null, previousItem);
        break;
    }
  };
  const conditionalElements = getConditionalElements();
  const [RootSlot, rootSlotProps] = useSlot("root", {
    ref: ref2,
    className: clsx(classes.root, className),
    elementType: TabsRoot,
    externalForwardedProps: {
      ...externalForwardedProps,
      ...other,
      component
    },
    ownerState
  });
  const [ScrollerSlot, scrollerSlotProps] = useSlot("scroller", {
    ref: tabsRef,
    className: classes.scroller,
    elementType: TabsScroller,
    externalForwardedProps,
    ownerState,
    additionalProps: {
      style: {
        overflow: scrollerStyle.overflow,
        [vertical ? `margin${isRtl ? "Left" : "Right"}` : "marginBottom"]: visibleScrollbar ? void 0 : -scrollerStyle.scrollbarWidth
      }
    }
  });
  const [ListSlot, listSlotProps] = useSlot("list", {
    ref: tabListRef,
    className: clsx(classes.list, classes.flexContainer),
    elementType: List,
    externalForwardedProps,
    ownerState,
    getSlotProps: (handlers) => ({
      ...handlers,
      onKeyDown: (event) => {
        handleKeyDown(event);
        handlers.onKeyDown?.(event);
      }
    })
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
    ...rootSlotProps,
    children: [conditionalElements.scrollButtonStart, conditionalElements.scrollbarSizeListener, /* @__PURE__ */ jsxRuntimeExports.jsxs(ScrollerSlot, {
      ...scrollerSlotProps,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListSlot, {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-orientation": orientation === "vertical" ? "vertical" : null,
        role: "tablist",
        ...listSlotProps,
        children
      }), mounted && indicator]
    }), conditionalElements.scrollButtonEnd]
  });
});
function getTextFieldUtilityClass(slot) {
  return generateUtilityClass("MuiTextField", slot);
}
generateUtilityClasses("MuiTextField", ["root"]);
const variantComponent = {
  standard: Input,
  filled: FilledInput,
  outlined: OutlinedInput
};
const useUtilityClasses = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTextFieldUtilityClass, classes);
};
const TextFieldRoot = styled(FormControl, {
  name: "MuiTextField",
  slot: "Root"
})({});
const TextField = /* @__PURE__ */ reactExports.forwardRef(function TextField2(inProps, ref2) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiTextField"
  });
  const {
    autoComplete,
    autoFocus = false,
    children,
    className,
    color: color2 = "primary",
    defaultValue,
    disabled = false,
    error = false,
    FormHelperTextProps: FormHelperTextPropsProp,
    fullWidth = false,
    helperText,
    id: idOverride,
    InputLabelProps: InputLabelPropsProp,
    inputProps: inputPropsProp,
    InputProps: InputPropsProp,
    inputRef,
    label,
    maxRows,
    minRows,
    multiline = false,
    name,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    required = false,
    rows,
    select = false,
    SelectProps: SelectPropsProp,
    slots = {},
    slotProps = {},
    type,
    value,
    variant = "outlined",
    ...other
  } = props;
  const ownerState = {
    ...props,
    autoFocus,
    color: color2,
    disabled,
    error,
    fullWidth,
    multiline,
    required,
    select,
    variant
  };
  const classes = useUtilityClasses(ownerState);
  const id = useId(idOverride);
  const helperTextId = helperText && id ? `${id}-helper-text` : void 0;
  const inputLabelId = label && id ? `${id}-label` : void 0;
  const InputComponent = variantComponent[variant];
  const externalForwardedProps = {
    slots,
    slotProps: {
      input: InputPropsProp,
      inputLabel: InputLabelPropsProp,
      htmlInput: inputPropsProp,
      formHelperText: FormHelperTextPropsProp,
      select: SelectPropsProp,
      ...slotProps
    }
  };
  const inputAdditionalProps = {};
  const inputLabelSlotProps = externalForwardedProps.slotProps.inputLabel;
  if (variant === "outlined") {
    if (inputLabelSlotProps && typeof inputLabelSlotProps.shrink !== "undefined") {
      inputAdditionalProps.notched = inputLabelSlotProps.shrink;
    }
    inputAdditionalProps.label = label;
  }
  if (select) {
    if (!SelectPropsProp || !SelectPropsProp.native) {
      inputAdditionalProps.id = void 0;
    }
    inputAdditionalProps["aria-describedby"] = void 0;
  }
  const [RootSlot, rootProps] = useSlot("root", {
    elementType: TextFieldRoot,
    shouldForwardComponentProp: true,
    externalForwardedProps: {
      ...externalForwardedProps,
      ...other
    },
    ownerState,
    className: clsx(classes.root, className),
    ref: ref2,
    additionalProps: {
      disabled,
      error,
      fullWidth,
      required,
      color: color2,
      variant
    }
  });
  const [InputSlot, inputProps] = useSlot("input", {
    elementType: InputComponent,
    externalForwardedProps,
    additionalProps: inputAdditionalProps,
    ownerState
  });
  const [InputLabelSlot, inputLabelProps] = useSlot("inputLabel", {
    elementType: InputLabel,
    externalForwardedProps,
    ownerState
  });
  const [HtmlInputSlot, htmlInputProps] = useSlot("htmlInput", {
    elementType: "input",
    externalForwardedProps,
    ownerState
  });
  const [FormHelperTextSlot, formHelperTextProps] = useSlot("formHelperText", {
    elementType: FormHelperText,
    externalForwardedProps,
    ownerState
  });
  const [SelectSlot, selectProps] = useSlot("select", {
    elementType: Select,
    externalForwardedProps,
    ownerState
  });
  const InputElement = /* @__PURE__ */ jsxRuntimeExports.jsx(InputSlot, {
    "aria-describedby": helperTextId,
    autoComplete,
    autoFocus,
    defaultValue,
    fullWidth,
    multiline,
    name,
    rows,
    maxRows,
    minRows,
    type,
    value,
    id,
    inputRef,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    inputProps: htmlInputProps,
    slots: {
      input: slots.htmlInput ? HtmlInputSlot : void 0
    },
    ...inputProps
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, {
    ...rootProps,
    children: [label != null && label !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelSlot, {
      htmlFor: id,
      id: inputLabelId,
      ...inputLabelProps,
      children: label
    }), select ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectSlot, {
      "aria-describedby": helperTextId,
      id,
      labelId: inputLabelId,
      value,
      input: InputElement,
      ...selectProps,
      children
    }) : InputElement, helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextSlot, {
      id: helperTextId,
      ...formHelperTextProps,
      children: helperText
    })]
  });
});
const useMediaQuery = unstable_createUseMediaQuery({
  themeId: THEME_ID
});
const multicall3Abi = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockTimestamp",
    outputs: [
      {
        internalType: "uint256",
        name: "timestamp",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const batchGatewayAbi = [
  {
    name: "query",
    type: "function",
    stateMutability: "view",
    inputs: [
      {
        type: "tuple[]",
        name: "queries",
        components: [
          {
            type: "address",
            name: "sender"
          },
          {
            type: "string[]",
            name: "urls"
          },
          {
            type: "bytes",
            name: "data"
          }
        ]
      }
    ],
    outputs: [
      {
        type: "bool[]",
        name: "failures"
      },
      {
        type: "bytes[]",
        name: "responses"
      }
    ]
  },
  {
    name: "HttpError",
    type: "error",
    inputs: [
      {
        type: "uint16",
        name: "status"
      },
      {
        type: "string",
        name: "message"
      }
    ]
  }
];
const universalResolverErrors = [
  {
    inputs: [
      {
        name: "dns",
        type: "bytes"
      }
    ],
    name: "DNSDecodingFailed",
    type: "error"
  },
  {
    inputs: [
      {
        name: "ens",
        type: "string"
      }
    ],
    name: "DNSEncodingFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "EmptyAddress",
    type: "error"
  },
  {
    inputs: [
      {
        name: "status",
        type: "uint16"
      },
      {
        name: "message",
        type: "string"
      }
    ],
    name: "HttpError",
    type: "error"
  },
  {
    inputs: [],
    name: "InvalidBatchGatewayResponse",
    type: "error"
  },
  {
    inputs: [
      {
        name: "errorData",
        type: "bytes"
      }
    ],
    name: "ResolverError",
    type: "error"
  },
  {
    inputs: [
      {
        name: "name",
        type: "bytes"
      },
      {
        name: "resolver",
        type: "address"
      }
    ],
    name: "ResolverNotContract",
    type: "error"
  },
  {
    inputs: [
      {
        name: "name",
        type: "bytes"
      }
    ],
    name: "ResolverNotFound",
    type: "error"
  },
  {
    inputs: [
      {
        name: "primary",
        type: "string"
      },
      {
        name: "primaryAddress",
        type: "bytes"
      }
    ],
    name: "ReverseAddressMismatch",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "selector",
        type: "bytes4"
      }
    ],
    name: "UnsupportedResolverProfile",
    type: "error"
  }
];
const universalResolverResolveAbi = [
  ...universalResolverErrors,
  {
    name: "resolveWithGateways",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" },
      { name: "gateways", type: "string[]" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  }
];
const universalResolverReverseAbi = [
  ...universalResolverErrors,
  {
    name: "reverseWithGateways",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "bytes", name: "reverseName" },
      { type: "uint256", name: "coinType" },
      { type: "string[]", name: "gateways" }
    ],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolver" },
      { type: "address", name: "reverseResolver" }
    ]
  }
];
const textResolverAbi = [
  {
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "key", type: "string" }
    ],
    outputs: [{ name: "", type: "string" }]
  }
];
const addressResolverAbi = [
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "name", type: "bytes32" }],
    outputs: [{ name: "", type: "address" }]
  },
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "coinType", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bytes" }]
  }
];
const erc1271Abi = [
  {
    name: "isValidSignature",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "hash", type: "bytes32" },
      { name: "signature", type: "bytes" }
    ],
    outputs: [{ name: "", type: "bytes4" }]
  }
];
const erc6492SignatureValidatorAbi = [
  {
    inputs: [
      {
        name: "_signer",
        type: "address"
      },
      {
        name: "_hash",
        type: "bytes32"
      },
      {
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        name: "_signer",
        type: "address"
      },
      {
        name: "_hash",
        type: "bytes32"
      },
      {
        name: "_signature",
        type: "bytes"
      }
    ],
    outputs: [
      {
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function",
    name: "isValidSig"
  }
];
const erc20Abi = [
  {
    type: "event",
    name: "Approval",
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "event",
    name: "Transfer",
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "allowance",
    stateMutability: "view",
    inputs: [
      {
        name: "owner",
        type: "address"
      },
      {
        name: "spender",
        type: "address"
      }
    ],
    outputs: [
      {
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "approve",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "spender",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    outputs: [
      {
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        type: "uint8"
      }
    ]
  },
  {
    type: "function",
    name: "name",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        type: "string"
      }
    ]
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        type: "string"
      }
    ]
  },
  {
    type: "function",
    name: "totalSupply",
    stateMutability: "view",
    inputs: [],
    outputs: [
      {
        type: "uint256"
      }
    ]
  },
  {
    type: "function",
    name: "transfer",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        type: "bool"
      }
    ]
  },
  {
    type: "function",
    name: "transferFrom",
    stateMutability: "nonpayable",
    inputs: [
      {
        name: "sender",
        type: "address"
      },
      {
        name: "recipient",
        type: "address"
      },
      {
        name: "amount",
        type: "uint256"
      }
    ],
    outputs: [
      {
        type: "bool"
      }
    ]
  }
];
function formatAbiItem$1(abiItem, { includeName = false } = {}) {
  if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem.type);
  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
  if (!params)
    return "";
  return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
}
function formatAbiParam(param, { includeName }) {
  if (param.type.startsWith("tuple")) {
    return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
  }
  return param.type + (includeName && param.name ? ` ${param.name}` : "");
}
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
function size$3(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
const version$6 = "2.37.6";
let errorConfig = {
  getDocsUrl: ({ docsBaseUrl, docsPath: docsPath2 = "", docsSlug }) => docsPath2 ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath2}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
  version: `viem@${version$6}`
};
let BaseError$4 = class BaseError extends Error {
  constructor(shortMessage, args = {}) {
    const details = (() => {
      if (args.cause instanceof BaseError)
        return args.cause.details;
      if (args.cause?.message)
        return args.cause.message;
      return args.details;
    })();
    const docsPath2 = (() => {
      if (args.cause instanceof BaseError)
        return args.cause.docsPath || args.docsPath;
      return args.docsPath;
    })();
    const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath: docsPath2 });
    const message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsUrl ? [`Docs: ${docsUrl}`] : [],
      ...details ? [`Details: ${details}`] : [],
      ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []
    ].join("\n");
    super(message, args.cause ? { cause: args.cause } : void 0);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    this.details = details;
    this.docsPath = docsPath2;
    this.metaMessages = args.metaMessages;
    this.name = args.name ?? this.name;
    this.shortMessage = shortMessage;
    this.version = version$6;
  }
  walk(fn2) {
    return walk$1(this, fn2);
  }
};
function walk$1(err, fn2) {
  if (fn2?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause !== void 0)
    return walk$1(err.cause, fn2);
  return fn2 ? null : err;
}
class AbiConstructorNotFoundError extends BaseError$4 {
  constructor({ docsPath: docsPath2 }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiConstructorNotFoundError"
    });
  }
}
class AbiConstructorParamsNotFoundError extends BaseError$4 {
  constructor({ docsPath: docsPath2 }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiConstructorParamsNotFoundError"
    });
  }
}
class AbiDecodingDataSizeTooSmallError extends BaseError$4 {
  constructor({ data: data2, params, size: size2 }) {
    super([`Data size of ${size2} bytes is too small for given parameters.`].join("\n"), {
      metaMessages: [
        `Params: (${formatAbiParams(params, { includeName: true })})`,
        `Data:   ${data2} (${size2} bytes)`
      ],
      name: "AbiDecodingDataSizeTooSmallError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "params", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = data2;
    this.params = params;
    this.size = size2;
  }
}
class AbiDecodingZeroDataError extends BaseError$4 {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError"
    });
  }
}
class AbiEncodingArrayLengthMismatchError extends BaseError$4 {
  constructor({ expectedLength, givenLength, type }) {
    super([
      `ABI encoding array length mismatch for type ${type}.`,
      `Expected length: ${expectedLength}`,
      `Given length: ${givenLength}`
    ].join("\n"), { name: "AbiEncodingArrayLengthMismatchError" });
  }
}
class AbiEncodingBytesSizeMismatchError extends BaseError$4 {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size$3(value)}) does not match expected size (bytes${expectedSize}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
}
class AbiEncodingLengthMismatchError extends BaseError$4 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"), { name: "AbiEncodingLengthMismatchError" });
  }
}
class AbiErrorInputsNotFoundError extends BaseError$4 {
  constructor(errorName, { docsPath: docsPath2 }) {
    super([
      `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
      "Cannot encode error result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the inputs exist on it."
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiErrorInputsNotFoundError"
    });
  }
}
class AbiErrorNotFoundError extends BaseError$4 {
  constructor(errorName, { docsPath: docsPath2 } = {}) {
    super([
      `Error ${errorName ? `"${errorName}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it."
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiErrorNotFoundError"
    });
  }
}
class AbiErrorSignatureNotFoundError extends BaseError$4 {
  constructor(signature2, { docsPath: docsPath2 }) {
    super([
      `Encoded error signature "${signature2}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature2}.`
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiErrorSignatureNotFoundError"
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.signature = signature2;
  }
}
class AbiEventSignatureEmptyTopicsError extends BaseError$4 {
  constructor({ docsPath: docsPath2 }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: docsPath2,
      name: "AbiEventSignatureEmptyTopicsError"
    });
  }
}
class AbiEventSignatureNotFoundError extends BaseError$4 {
  constructor(signature2, { docsPath: docsPath2 }) {
    super([
      `Encoded event signature "${signature2}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${signature2}.`
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiEventSignatureNotFoundError"
    });
  }
}
class AbiEventNotFoundError extends BaseError$4 {
  constructor(eventName, { docsPath: docsPath2 } = {}) {
    super([
      `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiEventNotFoundError"
    });
  }
}
class AbiFunctionNotFoundError extends BaseError$4 {
  constructor(functionName, { docsPath: docsPath2 } = {}) {
    super([
      `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiFunctionNotFoundError"
    });
  }
}
class AbiFunctionOutputsNotFoundError extends BaseError$4 {
  constructor(functionName, { docsPath: docsPath2 }) {
    super([
      `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class AbiFunctionSignatureNotFoundError extends BaseError$4 {
  constructor(signature2, { docsPath: docsPath2 }) {
    super([
      `Encoded function signature "${signature2}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${signature2}.`
    ].join("\n"), {
      docsPath: docsPath2,
      name: "AbiFunctionSignatureNotFoundError"
    });
  }
}
class AbiItemAmbiguityError extends BaseError$4 {
  constructor(x2, y3) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${x2.type}\` in \`${formatAbiItem$1(x2.abiItem)}\`, and`,
        `\`${y3.type}\` in \`${formatAbiItem$1(y3.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ],
      name: "AbiItemAmbiguityError"
    });
  }
}
class BytesSizeMismatchError extends BaseError$4 {
  constructor({ expectedSize, givenSize }) {
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class DecodeLogDataMismatch extends BaseError$4 {
  constructor({ abiItem, data: data2, params, size: size2 }) {
    super([
      `Data size of ${size2} bytes is too small for non-indexed event parameters.`
    ].join("\n"), {
      metaMessages: [
        `Params: (${formatAbiParams(params, { includeName: true })})`,
        `Data:   ${data2} (${size2} bytes)`
      ],
      name: "DecodeLogDataMismatch"
    });
    Object.defineProperty(this, "abiItem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "params", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiItem = abiItem;
    this.data = data2;
    this.params = params;
    this.size = size2;
  }
}
class DecodeLogTopicsMismatch extends BaseError$4 {
  constructor({ abiItem, param }) {
    super([
      `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem$1(abiItem, { includeName: true })}".`
    ].join("\n"), { name: "DecodeLogTopicsMismatch" });
    Object.defineProperty(this, "abiItem", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiItem = abiItem;
  }
}
class InvalidAbiEncodingTypeError extends BaseError$4 {
  constructor(type, { docsPath: docsPath2 }) {
    super([
      `Type "${type}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join("\n"), { docsPath: docsPath2, name: "InvalidAbiEncodingType" });
  }
}
class InvalidAbiDecodingTypeError extends BaseError$4 {
  constructor(type, { docsPath: docsPath2 }) {
    super([
      `Type "${type}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join("\n"), { docsPath: docsPath2, name: "InvalidAbiDecodingType" });
  }
}
class InvalidArrayError extends BaseError$4 {
  constructor(value) {
    super([`Value "${value}" is not a valid array.`].join("\n"), {
      name: "InvalidArrayError"
    });
  }
}
class InvalidDefinitionTypeError extends BaseError$4 {
  constructor(type) {
    super([
      `"${type}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join("\n"), { name: "InvalidDefinitionTypeError" });
  }
}
class UnsupportedPackedAbiType extends BaseError$4 {
  constructor(type) {
    super(`Type "${type}" is not supported for packed encoding.`, {
      name: "UnsupportedPackedAbiType"
    });
  }
}
class InvalidAddressError extends BaseError$4 {
  constructor({ address }) {
    super(`Address "${address}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
let SliceOffsetOutOfBoundsError$1 = class SliceOffsetOutOfBoundsError extends BaseError$4 {
  constructor({ offset: offset2, position: position2, size: size2 }) {
    super(`Slice ${position2 === "start" ? "starting" : "ending"} at offset "${offset2}" is out-of-bounds (size: ${size2}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
};
let SizeExceedsPaddingSizeError$1 = class SizeExceedsPaddingSizeError extends BaseError$4 {
  constructor({ size: size2, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
  }
};
class InvalidBytesLengthError extends BaseError$4 {
  constructor({ size: size2, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size2} ${type} long.`, { name: "InvalidBytesLengthError" });
  }
}
function pad$1(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError$1({
      size: Math.ceil(hex.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes(bytes, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes;
  if (bytes.length > size2)
    throw new SizeExceedsPaddingSizeError$1({
      size: bytes.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i4 = 0; i4 < size2; i4++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i4 : size2 - i4 - 1] = bytes[padEnd ? i4 : bytes.length - i4 - 1];
  }
  return paddedBytes;
}
let IntegerOutOfRangeError$1 = class IntegerOutOfRangeError extends BaseError$4 {
  constructor({ max: max2, min: min2, signed: signed2, size: size2, value }) {
    super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed2 ? "signed" : "unsigned"} ` : ""}integer range ${max2 ? `(${min2} to ${max2})` : `(above ${min2})`}`, { name: "IntegerOutOfRangeError" });
  }
};
class InvalidBytesBooleanError extends BaseError$4 {
  constructor(bytes) {
    super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
      name: "InvalidBytesBooleanError"
    });
  }
}
class InvalidHexBooleanError extends BaseError$4 {
  constructor(hex) {
    super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`, { name: "InvalidHexBooleanError" });
  }
}
let SizeOverflowError$1 = class SizeOverflowError extends BaseError$4 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
  }
};
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data2 = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i4 = 0; i4 < data2.length - 1; i4++) {
    if (data2[dir === "left" ? i4 : data2.length - i4 - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data2 = dir === "left" ? data2.slice(sliceLength) : data2.slice(0, data2.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data2.length === 1 && dir === "right")
      data2 = `${data2}0`;
    return `0x${data2.length % 2 === 1 ? `0${data2}` : data2}`;
  }
  return data2;
}
function assertSize$1(hexOrBytes, { size: size2 }) {
  if (size$3(hexOrBytes) > size2)
    throw new SizeOverflowError$1({
      givenSize: size$3(hexOrBytes),
      maxSize: size2
    });
}
function hexToBigInt(hex, opts = {}) {
  const { signed: signed2 } = opts;
  if (opts.size)
    assertSize$1(hex, { size: opts.size });
  const value = BigInt(hex);
  if (!signed2)
    return value;
  const size2 = (hex.length - 2) / 2;
  const max2 = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max2)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToBool(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize$1(hex, { size: opts.size });
    hex = trim(hex);
  }
  if (trim(hex) === "0x00")
    return false;
  if (trim(hex) === "0x01")
    return true;
  throw new InvalidHexBooleanError(hex);
}
function hexToNumber(hex, opts = {}) {
  return Number(hexToBigInt(hex, opts));
}
function hexToString(hex, opts = {}) {
  let bytes = hexToBytes$1(hex);
  if (opts.size) {
    assertSize$1(bytes, { size: opts.size });
    bytes = trim(bytes, { dir: "right" });
  }
  return new TextDecoder().decode(bytes);
}
const hexes$2 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i4) => i4.toString(16).padStart(2, "0"));
function toHex(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex$1(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize$1(hex, { size: opts.size });
    return pad$1(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex$1(value, opts = {}) {
  let string = "";
  for (let i4 = 0; i4 < value.length; i4++) {
    string += hexes$2[value[i4]];
  }
  const hex = `0x${string}`;
  if (typeof opts.size === "number") {
    assertSize$1(hex, { size: opts.size });
    return pad$1(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex(value_, opts = {}) {
  const { signed: signed2, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size2) {
    if (signed2)
      maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed2 ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError$1({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed: signed2,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed2 && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad$1(hex, { size: size2 });
  return hex;
}
const encoder$2 = /* @__PURE__ */ new TextEncoder();
function stringToHex(value_, opts = {}) {
  const value = encoder$2.encode(value_);
  return bytesToHex$1(value, opts);
}
const encoder$1 = /* @__PURE__ */ new TextEncoder();
function toBytes$1(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes$1(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes = new Uint8Array(1);
  bytes[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize$1(bytes, { size: opts.size });
    return pad$1(bytes, { size: opts.size });
  }
  return bytes;
}
const charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char2) {
  if (char2 >= charCodeMap.zero && char2 <= charCodeMap.nine)
    return char2 - charCodeMap.zero;
  if (char2 >= charCodeMap.A && char2 <= charCodeMap.F)
    return char2 - (charCodeMap.A - 10);
  if (char2 >= charCodeMap.a && char2 <= charCodeMap.f)
    return char2 - (charCodeMap.a - 10);
  return void 0;
}
function hexToBytes$1(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize$1(hex, { size: opts.size });
    hex = pad$1(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length2 = hexString.length / 2;
  const bytes = new Uint8Array(length2);
  for (let index2 = 0, j2 = 0; index2 < length2; index2++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j2++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j2++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError$4(`Invalid byte sequence ("${hexString[j2 - 2]}${hexString[j2 - 1]}" in "${hexString}").`);
    }
    bytes[index2] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function numberToBytes(value, opts) {
  const hex = numberToHex(value, opts);
  return hexToBytes$1(hex);
}
function stringToBytes(value, opts = {}) {
  const bytes = encoder$1.encode(value);
  if (typeof opts.size === "number") {
    assertSize$1(bytes, { size: opts.size });
    return pad$1(bytes, { dir: "right", size: opts.size });
  }
  return bytes;
}
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n3, le2 = false) {
  if (le2)
    return { h: Number(n3 & U32_MASK64), l: Number(n3 >> _32n & U32_MASK64) };
  return { h: Number(n3 >> _32n & U32_MASK64) | 0, l: Number(n3 & U32_MASK64) | 0 };
}
function split$1(lst, le2 = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i4 = 0; i4 < len; i4++) {
    const { h: h2, l: l2 } = fromBig(lst[i4], le2);
    [Ah[i4], Al[i4]] = [h2, l2];
  }
  return [Ah, Al];
}
const shrSH = (h2, _l, s2) => h2 >>> s2;
const shrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
const rotrSH = (h2, l2, s2) => h2 >>> s2 | l2 << 32 - s2;
const rotrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
const rotrBH = (h2, l2, s2) => h2 << 64 - s2 | l2 >>> s2 - 32;
const rotrBL = (h2, l2, s2) => h2 >>> s2 - 32 | l2 << 64 - s2;
const rotlSH = (h2, l2, s2) => h2 << s2 | l2 >>> 32 - s2;
const rotlSL = (h2, l2, s2) => l2 << s2 | h2 >>> 32 - s2;
const rotlBH = (h2, l2, s2) => l2 << s2 - 32 | h2 >>> 64 - s2;
const rotlBL = (h2, l2, s2) => h2 << s2 - 32 | l2 >>> 64 - s2;
function add(Ah, Al, Bh, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
const crypto$2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function isBytes(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function anumber(n3) {
  if (!Number.isSafeInteger(n3) || n3 < 0)
    throw new Error("positive integer expected, got " + n3);
}
function abytes(b2, ...lengths) {
  if (!isBytes(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
}
function ahash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h2.outputLen);
  anumber(h2.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error("digestInto() expects output buffer of length at least " + min2);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i4 = 0; i4 < arrays.length; i4++) {
    arrays[i4].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i4 = 0; i4 < arr.length; i4++) {
    arr[i4] = byteSwap(arr[i4]);
  }
  return arr;
}
const swap32IfBE = isLE ? (u2) => u2 : byteSwap32;
const hasHexBuiltin = /* @__PURE__ */ (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
const hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (_2, i4) => i4.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
  abytes(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex = "";
  for (let i4 = 0; i4 < bytes.length; i4++) {
    hex += hexes$1[bytes[i4]];
  }
  return hex;
}
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n22 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n22 === void 0) {
      const char2 = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char2 + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n22;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data2) {
  if (typeof data2 === "string")
    data2 = utf8ToBytes(data2);
  abytes(data2);
  return data2;
}
function concatBytes$1(...arrays) {
  let sum = 0;
  for (let i4 = 0; i4 < arrays.length; i4++) {
    const a2 = arrays[i4];
    abytes(a2);
    sum += a2.length;
  }
  const res = new Uint8Array(sum);
  for (let i4 = 0, pad2 = 0; i4 < arrays.length; i4++) {
    const a2 = arrays[i4];
    res.set(a2, pad2);
    pad2 += a2.length;
  }
  return res;
}
class Hash {
}
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto$2 && typeof crypto$2.getRandomValues === "function") {
    return crypto$2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto$2 && typeof crypto$2.randomBytes === "function") {
    return Uint8Array.from(crypto$2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(113);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for (let round2 = 0, R2 = _1n, x2 = 1, y3 = 0; round2 < 24; round2++) {
  [x2, y3] = [y3, (2 * x2 + 3 * y3) % 5];
  SHA3_PI.push(2 * (5 * y3 + x2));
  SHA3_ROTL.push((round2 + 1) * (round2 + 2) / 2 % 64);
  let t2 = _0n;
  for (let j2 = 0; j2 < 7; j2++) {
    R2 = (R2 << _1n ^ (R2 >> _7n) * _0x71n) % _256n;
    if (R2 & _2n)
      t2 ^= _1n << (_1n << /* @__PURE__ */ BigInt(j2)) - _1n;
  }
  _SHA3_IOTA.push(t2);
}
const IOTAS = split$1(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
const rotlH = (h2, l2, s2) => s2 > 32 ? rotlBH(h2, l2, s2) : rotlSH(h2, l2, s2);
const rotlL = (h2, l2, s2) => s2 > 32 ? rotlBL(h2, l2, s2) : rotlSL(h2, l2, s2);
function keccakP(s2, rounds = 24) {
  const B3 = new Uint32Array(5 * 2);
  for (let round2 = 24 - rounds; round2 < 24; round2++) {
    for (let x2 = 0; x2 < 10; x2++)
      B3[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B02 = B3[idx0];
      const B1 = B3[idx0 + 1];
      const Th = rotlH(B02, B1, 1) ^ B3[idx1];
      const Tl = rotlL(B02, B1, 1) ^ B3[idx1 + 1];
      for (let y3 = 0; y3 < 50; y3 += 10) {
        s2[x2 + y3] ^= Th;
        s2[x2 + y3 + 1] ^= Tl;
      }
    }
    let curH = s2[2];
    let curL = s2[3];
    for (let t2 = 0; t2 < 24; t2++) {
      const shift = SHA3_ROTL[t2];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t2];
      curH = s2[PI];
      curL = s2[PI + 1];
      s2[PI] = Th;
      s2[PI + 1] = Tl;
    }
    for (let y3 = 0; y3 < 50; y3 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B3[x2] = s2[y3 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s2[y3 + x2] ^= ~B3[(x2 + 2) % 10] & B3[(x2 + 4) % 10];
    }
    s2[0] ^= SHA3_IOTA_H[round2];
    s2[1] ^= SHA3_IOTA_L[round2];
  }
  clean(B3);
}
class Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    this.enableXOF = false;
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber(outputLen);
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE(this.state32);
    keccakP(this.state32, this.rounds);
    swap32IfBE(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data2) {
    aexists(this);
    data2 = toBytes(data2);
    abytes(data2);
    const { blockLen, state: state2 } = this;
    const len = data2.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i4 = 0; i4 < take; i4++)
        state2[this.pos++] ^= data2[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: state2, suffix, pos, blockLen } = this;
    state2[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state2[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean(this.state);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
const gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));
const keccak_256 = /* @__PURE__ */ (() => gen(1, 136, 256 / 8))();
function keccak256(value, to_) {
  const to = to_ || "hex";
  const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes$1(value) : value);
  if (to === "bytes")
    return bytes;
  return toHex(bytes);
}
class LruMap extends Map {
  constructor(size2) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size2;
  }
  get(key2) {
    const value = super.get(key2);
    if (super.has(key2) && value !== void 0) {
      this.delete(key2);
      super.set(key2, value);
    }
    return value;
  }
  set(key2, value) {
    super.set(key2, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
}
const addressRegex = /^0x[a-fA-F0-9]{40}$/;
const isAddressCache = /* @__PURE__ */ new LruMap(8192);
function isAddress(address, options) {
  const { strict = true } = options ?? {};
  const cacheKey2 = `${address}.${strict}`;
  if (isAddressCache.has(cacheKey2))
    return isAddressCache.get(cacheKey2);
  const result = (() => {
    if (!addressRegex.test(address))
      return false;
    if (address.toLowerCase() === address)
      return true;
    if (strict)
      return checksumAddress(address) === address;
    return true;
  })();
  isAddressCache.set(cacheKey2, result);
  return result;
}
const checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
function checksumAddress(address_, chainId) {
  if (checksumAddressCache.has(`${address_}.${chainId}`))
    return checksumAddressCache.get(`${address_}.${chainId}`);
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash2 = keccak256(stringToBytes(hexAddress), "bytes");
  const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i4 = 0; i4 < 40; i4 += 2) {
    if (hash2[i4 >> 1] >> 4 >= 8 && address[i4]) {
      address[i4] = address[i4].toUpperCase();
    }
    if ((hash2[i4 >> 1] & 15) >= 8 && address[i4 + 1]) {
      address[i4 + 1] = address[i4 + 1].toUpperCase();
    }
  }
  const result = `0x${address.join("")}`;
  checksumAddressCache.set(`${address_}.${chainId}`, result);
  return result;
}
function getAddress(address, chainId) {
  if (!isAddress(address, { strict: false }))
    throw new InvalidAddressError({ address });
  return checksumAddress(address, chainId);
}
class NegativeOffsetError extends BaseError$4 {
  constructor({ offset: offset2 }) {
    super(`Offset \`${offset2}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class PositionOutOfBoundsError extends BaseError$4 {
  constructor({ length: length2, position: position2 }) {
    super(`Position \`${position2}\` is out of bounds (\`0 < position < ${length2}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class RecursiveReadLimitExceededError extends BaseError$4 {
  constructor({ count, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position2) {
    if (position2 < 0 || position2 > this.bytes.length - 1)
      throw new PositionOutOfBoundsError({
        length: this.bytes.length,
        position: position2
      });
  },
  decrementPosition(offset2) {
    if (offset2 < 0)
      throw new NegativeOffsetError({ offset: offset2 });
    const position2 = this.position - offset2;
    this.assertPosition(position2);
    this.position = position2;
  },
  getReadCount(position2) {
    return this.positionReadCount.get(position2 || this.position) || 0;
  },
  incrementPosition(offset2) {
    if (offset2 < 0)
      throw new NegativeOffsetError({ offset: offset2 });
    const position2 = this.position + offset2;
    this.assertPosition(position2);
    this.position = position2;
  },
  inspectByte(position_) {
    const position2 = position_ ?? this.position;
    this.assertPosition(position2);
    return this.bytes[position2];
  },
  inspectBytes(length2, position_) {
    const position2 = position_ ?? this.position;
    this.assertPosition(position2 + length2 - 1);
    return this.bytes.subarray(position2, position2 + length2);
  },
  inspectUint8(position_) {
    const position2 = position_ ?? this.position;
    this.assertPosition(position2);
    return this.bytes[position2];
  },
  inspectUint16(position_) {
    const position2 = position_ ?? this.position;
    this.assertPosition(position2 + 1);
    return this.dataView.getUint16(position2);
  },
  inspectUint24(position_) {
    const position2 = position_ ?? this.position;
    this.assertPosition(position2 + 2);
    return (this.dataView.getUint16(position2) << 8) + this.dataView.getUint8(position2 + 2);
  },
  inspectUint32(position_) {
    const position2 = position_ ?? this.position;
    this.assertPosition(position2 + 3);
    return this.dataView.getUint32(position2);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & 255);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length2, size2) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length2);
    this.position += size2 ?? length2;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position2) {
    const oldPosition = this.position;
    this.assertPosition(position2);
    this.position = position2;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
function createCursor(bytes, { recursiveReadLimit = 8192 } = {}) {
  const cursor2 = Object.create(staticCursor);
  cursor2.bytes = bytes;
  cursor2.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  cursor2.positionReadCount = /* @__PURE__ */ new Map();
  cursor2.recursiveReadLimit = recursiveReadLimit;
  return cursor2;
}
function slice$1(value, start2, end2, { strict } = {}) {
  if (isHex(value, { strict: false }))
    return sliceHex(value, start2, end2, {
      strict
    });
  return sliceBytes(value, start2, end2, {
    strict
  });
}
function assertStartOffset$1(value, start2) {
  if (typeof start2 === "number" && start2 > 0 && start2 > size$3(value) - 1)
    throw new SliceOffsetOutOfBoundsError$1({
      offset: start2,
      position: "start",
      size: size$3(value)
    });
}
function assertEndOffset$1(value, start2, end2) {
  if (typeof start2 === "number" && typeof end2 === "number" && size$3(value) !== end2 - start2) {
    throw new SliceOffsetOutOfBoundsError$1({
      offset: end2,
      position: "end",
      size: size$3(value)
    });
  }
}
function sliceBytes(value_, start2, end2, { strict } = {}) {
  assertStartOffset$1(value_, start2);
  const value = value_.slice(start2, end2);
  if (strict)
    assertEndOffset$1(value, start2, end2);
  return value;
}
function sliceHex(value_, start2, end2, { strict } = {}) {
  assertStartOffset$1(value_, start2);
  const value = `0x${value_.replace("0x", "").slice((start2 ?? 0) * 2, (end2 ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset$1(value, start2, end2);
  return value;
}
function bytesToBigInt(bytes, opts = {}) {
  if (typeof opts.size !== "undefined")
    assertSize$1(bytes, { size: opts.size });
  const hex = bytesToHex$1(bytes, opts);
  return hexToBigInt(hex, opts);
}
function bytesToBool(bytes_, opts = {}) {
  let bytes = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize$1(bytes, { size: opts.size });
    bytes = trim(bytes);
  }
  if (bytes.length > 1 || bytes[0] > 1)
    throw new InvalidBytesBooleanError(bytes);
  return Boolean(bytes[0]);
}
function bytesToNumber(bytes, opts = {}) {
  if (typeof opts.size !== "undefined")
    assertSize$1(bytes, { size: opts.size });
  const hex = bytesToHex$1(bytes, opts);
  return hexToNumber(hex, opts);
}
function bytesToString(bytes_, opts = {}) {
  let bytes = bytes_;
  if (typeof opts.size !== "undefined") {
    assertSize$1(bytes, { size: opts.size });
    bytes = trim(bytes, { dir: "right" });
  }
  return new TextDecoder().decode(bytes);
}
function concat$1(values2) {
  if (typeof values2[0] === "string")
    return concatHex(values2);
  return concatBytes(values2);
}
function concatBytes(values2) {
  let length2 = 0;
  for (const arr of values2) {
    length2 += arr.length;
  }
  const result = new Uint8Array(length2);
  let offset2 = 0;
  for (const arr of values2) {
    result.set(arr, offset2);
    offset2 += arr.length;
  }
  return result;
}
function concatHex(values2) {
  return `0x${values2.reduce((acc, x2) => acc + x2.replace("0x", ""), "")}`;
}
const arrayRegex = /^(.*)\[([0-9]*)\]$/;
const bytesRegex$1 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex$1 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function encodeAbiParameters(params, values2) {
  if (params.length !== values2.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: params.length,
      givenLength: values2.length
    });
  const preparedParams = prepareParams({
    params,
    values: values2
  });
  const data2 = encodeParams(preparedParams);
  if (data2.length === 0)
    return "0x";
  return data2;
}
function prepareParams({ params, values: values2 }) {
  const preparedParams = [];
  for (let i4 = 0; i4 < params.length; i4++) {
    preparedParams.push(prepareParam({ param: params[i4], value: values2[i4] }));
  }
  return preparedParams;
}
function prepareParam({ param, value }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length2, type] = arrayComponents;
    return encodeArray(value, { length: length2, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed2 = param.type.startsWith("int");
    const [, , size2 = "256"] = integerRegex$1.exec(param.type) ?? [];
    return encodeNumber(value, {
      signed: signed2,
      size: Number(size2)
    });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(value, { param });
  }
  if (param.type === "string") {
    return encodeString(value);
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(preparedParams) {
  let staticSize = 0;
  for (let i4 = 0; i4 < preparedParams.length; i4++) {
    const { dynamic, encoded } = preparedParams[i4];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size$3(encoded);
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i4 = 0; i4 < preparedParams.length; i4++) {
    const { dynamic, encoded } = preparedParams[i4];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      dynamicParams.push(encoded);
      dynamicSize += size$3(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return concat$1([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!isAddress(value))
    throw new InvalidAddressError({ address: value });
  return { dynamic: false, encoded: padHex(value.toLowerCase()) };
}
function encodeArray(value, { length: length2, param }) {
  const dynamic = length2 === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length2)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: length2,
      givenLength: value.length,
      type: `${param.type}[${length2}]`
    });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i4 = 0; i4 < value.length; i4++) {
    const preparedParam = prepareParam({ param, value: value[i4] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data2 = encodeParams(preparedParams);
    if (dynamic) {
      const length3 = numberToHex(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat$1([length3, data2]) : length3
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data2 };
  }
  return {
    dynamic: false,
    encoded: concat$1(preparedParams.map(({ encoded }) => encoded))
  };
}
function encodeBytes(value, { param }) {
  const [, paramSize] = param.type.split("bytes");
  const bytesSize = size$3(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padHex(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    return {
      dynamic: true,
      encoded: concat$1([padHex(numberToHex(bytesSize, { size: 32 })), value_])
    };
  }
  if (bytesSize !== Number.parseInt(paramSize, 10))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: Number.parseInt(paramSize, 10),
      value
    });
  return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
}
function encodeBool(value) {
  if (typeof value !== "boolean")
    throw new BaseError$4(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, encoded: padHex(boolToHex(value)) };
}
function encodeNumber(value, { signed: signed2, size: size2 = 256 }) {
  if (typeof size2 === "number") {
    const max2 = 2n ** (BigInt(size2) - (signed2 ? 1n : 0n)) - 1n;
    const min2 = signed2 ? -max2 - 1n : 0n;
    if (value > max2 || value < min2)
      throw new IntegerOutOfRangeError$1({
        max: max2.toString(),
        min: min2.toString(),
        signed: signed2,
        size: size2 / 8,
        value: value.toString()
      });
  }
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed: signed2
    })
  };
}
function encodeString(value) {
  const hexValue = stringToHex(value);
  const partsLength = Math.ceil(size$3(hexValue) / 32);
  const parts = [];
  for (let i4 = 0; i4 < partsLength; i4++) {
    parts.push(padHex(slice$1(hexValue, i4 * 32, (i4 + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: concat$1([
      padHex(numberToHex(size$3(hexValue), { size: 32 })),
      ...parts
    ])
  };
}
function encodeTuple(value, { param }) {
  let dynamic = false;
  const preparedParams = [];
  for (let i4 = 0; i4 < param.components.length; i4++) {
    const param_ = param.components[i4];
    const index2 = Array.isArray(value) ? i4 : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index2]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : concat$1(preparedParams.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? (
    // Return `null` if the array is dynamic.
    [matches[2] ? Number(matches[2]) : null, matches[1]]
  ) : void 0;
}
function decodeAbiParameters(params, data2) {
  const bytes = typeof data2 === "string" ? hexToBytes$1(data2) : data2;
  const cursor2 = createCursor(bytes);
  if (size$3(bytes) === 0 && params.length > 0)
    throw new AbiDecodingZeroDataError();
  if (size$3(data2) && size$3(data2) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data: typeof data2 === "string" ? data2 : bytesToHex$1(data2),
      params,
      size: size$3(data2)
    });
  let consumed = 0;
  const values2 = [];
  for (let i4 = 0; i4 < params.length; ++i4) {
    const param = params[i4];
    cursor2.setPosition(consumed);
    const [data3, consumed_] = decodeParameter(cursor2, param, {
      staticPosition: 0
    });
    consumed += consumed_;
    values2.push(data3);
  }
  return values2;
}
function decodeParameter(cursor2, param, { staticPosition }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length2, type] = arrayComponents;
    return decodeArray(cursor2, { ...param, type }, { length: length2, staticPosition });
  }
  if (param.type === "tuple")
    return decodeTuple(cursor2, param, { staticPosition });
  if (param.type === "address")
    return decodeAddress(cursor2);
  if (param.type === "bool")
    return decodeBool(cursor2);
  if (param.type.startsWith("bytes"))
    return decodeBytes(cursor2, param, { staticPosition });
  if (param.type.startsWith("uint") || param.type.startsWith("int"))
    return decodeNumber(cursor2, param);
  if (param.type === "string")
    return decodeString(cursor2, { staticPosition });
  throw new InvalidAbiDecodingTypeError(param.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const sizeOfLength = 32;
const sizeOfOffset = 32;
function decodeAddress(cursor2) {
  const value = cursor2.readBytes(32);
  return [checksumAddress(bytesToHex$1(sliceBytes(value, -20))), 32];
}
function decodeArray(cursor2, param, { length: length2, staticPosition }) {
  if (!length2) {
    const offset2 = bytesToNumber(cursor2.readBytes(sizeOfOffset));
    const start2 = staticPosition + offset2;
    const startOfData = start2 + sizeOfLength;
    cursor2.setPosition(start2);
    const length3 = bytesToNumber(cursor2.readBytes(sizeOfLength));
    const dynamicChild = hasDynamicChild(param);
    let consumed2 = 0;
    const value2 = [];
    for (let i4 = 0; i4 < length3; ++i4) {
      cursor2.setPosition(startOfData + (dynamicChild ? i4 * 32 : consumed2));
      const [data2, consumed_] = decodeParameter(cursor2, param, {
        staticPosition: startOfData
      });
      consumed2 += consumed_;
      value2.push(data2);
    }
    cursor2.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  if (hasDynamicChild(param)) {
    const offset2 = bytesToNumber(cursor2.readBytes(sizeOfOffset));
    const start2 = staticPosition + offset2;
    const value2 = [];
    for (let i4 = 0; i4 < length2; ++i4) {
      cursor2.setPosition(start2 + i4 * 32);
      const [data2] = decodeParameter(cursor2, param, {
        staticPosition: start2
      });
      value2.push(data2);
    }
    cursor2.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  let consumed = 0;
  const value = [];
  for (let i4 = 0; i4 < length2; ++i4) {
    const [data2, consumed_] = decodeParameter(cursor2, param, {
      staticPosition: staticPosition + consumed
    });
    consumed += consumed_;
    value.push(data2);
  }
  return [value, consumed];
}
function decodeBool(cursor2) {
  return [bytesToBool(cursor2.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(cursor2, param, { staticPosition }) {
  const [_2, size2] = param.type.split("bytes");
  if (!size2) {
    const offset2 = bytesToNumber(cursor2.readBytes(32));
    cursor2.setPosition(staticPosition + offset2);
    const length2 = bytesToNumber(cursor2.readBytes(32));
    if (length2 === 0) {
      cursor2.setPosition(staticPosition + 32);
      return ["0x", 32];
    }
    const data2 = cursor2.readBytes(length2);
    cursor2.setPosition(staticPosition + 32);
    return [bytesToHex$1(data2), 32];
  }
  const value = bytesToHex$1(cursor2.readBytes(Number.parseInt(size2, 10), 32));
  return [value, 32];
}
function decodeNumber(cursor2, param) {
  const signed2 = param.type.startsWith("int");
  const size2 = Number.parseInt(param.type.split("int")[1] || "256", 10);
  const value = cursor2.readBytes(32);
  return [
    size2 > 48 ? bytesToBigInt(value, { signed: signed2 }) : bytesToNumber(value, { signed: signed2 }),
    32
  ];
}
function decodeTuple(cursor2, param, { staticPosition }) {
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
  const value = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(param)) {
    const offset2 = bytesToNumber(cursor2.readBytes(sizeOfOffset));
    const start2 = staticPosition + offset2;
    for (let i4 = 0; i4 < param.components.length; ++i4) {
      const component = param.components[i4];
      cursor2.setPosition(start2 + consumed);
      const [data2, consumed_] = decodeParameter(cursor2, component, {
        staticPosition: start2
      });
      consumed += consumed_;
      value[hasUnnamedChild ? i4 : component?.name] = data2;
    }
    cursor2.setPosition(staticPosition + 32);
    return [value, 32];
  }
  for (let i4 = 0; i4 < param.components.length; ++i4) {
    const component = param.components[i4];
    const [data2, consumed_] = decodeParameter(cursor2, component, {
      staticPosition
    });
    value[hasUnnamedChild ? i4 : component?.name] = data2;
    consumed += consumed_;
  }
  return [value, consumed];
}
function decodeString(cursor2, { staticPosition }) {
  const offset2 = bytesToNumber(cursor2.readBytes(32));
  const start2 = staticPosition + offset2;
  cursor2.setPosition(start2);
  const length2 = bytesToNumber(cursor2.readBytes(32));
  if (length2 === 0) {
    cursor2.setPosition(staticPosition + 32);
    return ["", 32];
  }
  const data2 = cursor2.readBytes(length2, 32);
  const value = bytesToString(trim(data2));
  cursor2.setPosition(staticPosition + 32);
  return [value, 32];
}
function hasDynamicChild(param) {
  const { type } = param;
  if (type === "string")
    return true;
  if (type === "bytes")
    return true;
  if (type.endsWith("[]"))
    return true;
  if (type === "tuple")
    return param.components?.some(hasDynamicChild);
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
    return true;
  return false;
}
const hash$2 = (value) => keccak256(toBytes$1(value));
function hashSignature(sig) {
  return hash$2(sig);
}
const version$5 = "1.1.0";
let BaseError$3 = class BaseError2 extends Error {
  constructor(shortMessage, args = {}) {
    const details = args.cause instanceof BaseError2 ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
    const docsPath2 = args.cause instanceof BaseError2 ? args.cause.docsPath || args.docsPath : args.docsPath;
    const message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsPath2 ? [`Docs: https://abitype.dev${docsPath2}`] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: abitype@${version$5}`
    ].join("\n");
    super(message);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiTypeError"
    });
    if (args.cause)
      this.cause = args.cause;
    this.details = details;
    this.docsPath = docsPath2;
    this.metaMessages = args.metaMessages;
    this.shortMessage = shortMessage;
  }
};
function execTyped(regex2, string) {
  const match2 = regex2.exec(string);
  return match2?.groups;
}
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
const isTupleRegex = /^\(.+?\).*?$/;
const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(abiParameter) {
  let type = abiParameter.type;
  if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
    type = "(";
    const length2 = abiParameter.components.length;
    for (let i4 = 0; i4 < length2; i4++) {
      const component = abiParameter.components[i4];
      type += formatAbiParameter(component);
      if (i4 < length2 - 1)
        type += ", ";
    }
    const result = execTyped(tupleRegex, abiParameter.type);
    type += `)${result?.array ?? ""}`;
    return formatAbiParameter({
      ...abiParameter,
      type
    });
  }
  if ("indexed" in abiParameter && abiParameter.indexed)
    type = `${type} indexed`;
  if (abiParameter.name)
    return `${type} ${abiParameter.name}`;
  return type;
}
function formatAbiParameters(abiParameters) {
  let params = "";
  const length2 = abiParameters.length;
  for (let i4 = 0; i4 < length2; i4++) {
    const abiParameter = abiParameters[i4];
    params += formatAbiParameter(abiParameter);
    if (i4 !== length2 - 1)
      params += ", ";
  }
  return params;
}
function formatAbiItem(abiItem) {
  if (abiItem.type === "function")
    return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs?.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : ""}`;
  if (abiItem.type === "event")
    return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "error")
    return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
  if (abiItem.type === "constructor")
    return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  if (abiItem.type === "fallback")
    return `fallback() external${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  return "receive() external payable";
}
const errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isErrorSignature(signature2) {
  return errorSignatureRegex.test(signature2);
}
function execErrorSignature(signature2) {
  return execTyped(errorSignatureRegex, signature2);
}
const eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isEventSignature(signature2) {
  return eventSignatureRegex.test(signature2);
}
function execEventSignature(signature2) {
  return execTyped(eventSignatureRegex, signature2);
}
const functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function isFunctionSignature(signature2) {
  return functionSignatureRegex.test(signature2);
}
function execFunctionSignature(signature2) {
  return execTyped(functionSignatureRegex, signature2);
}
const structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function isStructSignature(signature2) {
  return structSignatureRegex.test(signature2);
}
function execStructSignature(signature2) {
  return execTyped(structSignatureRegex, signature2);
}
const constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function isConstructorSignature(signature2) {
  return constructorSignatureRegex.test(signature2);
}
function execConstructorSignature(signature2) {
  return execTyped(constructorSignatureRegex, signature2);
}
const fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function isFallbackSignature(signature2) {
  return fallbackSignatureRegex.test(signature2);
}
function execFallbackSignature(signature2) {
  return execTyped(fallbackSignatureRegex, signature2);
}
const receiveSignatureRegex = /^receive\(\) external payable$/;
function isReceiveSignature(signature2) {
  return receiveSignatureRegex.test(signature2);
}
const modifiers = /* @__PURE__ */ new Set([
  "memory",
  "indexed",
  "storage",
  "calldata"
]);
const eventModifiers = /* @__PURE__ */ new Set(["indexed"]);
const functionModifiers = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
class InvalidAbiItemError extends BaseError$3 {
  constructor({ signature: signature2 }) {
    super("Failed to parse ABI item.", {
      details: `parseAbiItem(${JSON.stringify(signature2, null, 2)})`,
      docsPath: "/api/human#parseabiitem-1"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiItemError"
    });
  }
}
class UnknownTypeError extends BaseError$3 {
  constructor({ type }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownTypeError"
    });
  }
}
class UnknownSolidityTypeError extends BaseError$3 {
  constructor({ type }) {
    super("Unknown type.", {
      metaMessages: [`Type "${type}" is not a valid ABI type.`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownSolidityTypeError"
    });
  }
}
class InvalidAbiParametersError extends BaseError$3 {
  constructor({ params }) {
    super("Failed to parse ABI parameters.", {
      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
      docsPath: "/api/human#parseabiparameters-1"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiParametersError"
    });
  }
}
class InvalidParameterError extends BaseError$3 {
  constructor({ param }) {
    super("Invalid ABI parameter.", {
      details: param
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidParameterError"
    });
  }
}
class SolidityProtectedKeywordError extends BaseError$3 {
  constructor({ param, name }) {
    super("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SolidityProtectedKeywordError"
    });
  }
}
class InvalidModifierError extends BaseError$3 {
  constructor({ param, type, modifier }) {
    super("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidModifierError"
    });
  }
}
class InvalidFunctionModifierError extends BaseError$3 {
  constructor({ param, type, modifier }) {
    super("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidFunctionModifierError"
    });
  }
}
class InvalidAbiTypeParameterError extends BaseError$3 {
  constructor({ abiParameter }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(abiParameter, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiTypeParameterError"
    });
  }
}
class InvalidSignatureError extends BaseError$3 {
  constructor({ signature: signature2, type }) {
    super(`Invalid ${type} signature.`, {
      details: signature2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidSignatureError"
    });
  }
}
class UnknownSignatureError extends BaseError$3 {
  constructor({ signature: signature2 }) {
    super("Unknown signature.", {
      details: signature2
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownSignatureError"
    });
  }
}
class InvalidStructSignatureError extends BaseError$3 {
  constructor({ signature: signature2 }) {
    super("Invalid struct signature.", {
      details: signature2,
      metaMessages: ["No properties exist."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidStructSignatureError"
    });
  }
}
class CircularReferenceError extends BaseError$3 {
  constructor({ type }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${type}" is a circular reference.`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "CircularReferenceError"
    });
  }
}
class InvalidParenthesisError extends BaseError$3 {
  constructor({ current, depth }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${depth}"`
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidParenthesisError"
    });
  }
}
function getParameterCacheKey(param, type, structs) {
  let structKey = "";
  if (structs)
    for (const struct of Object.entries(structs)) {
      if (!struct)
        continue;
      let propertyKey = "";
      for (const property of struct[1]) {
        propertyKey += `[${property.type}${property.name ? `:${property.name}` : ""}]`;
      }
      structKey += `(${struct[0]}{${propertyKey}})`;
    }
  if (type)
    return `${type}:${param}${structKey}`;
  return param;
}
const parameterCache = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: true }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: true }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: true }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: true }
  ]
]);
function parseSignature(signature2, structs = {}) {
  if (isFunctionSignature(signature2))
    return parseFunctionSignature(signature2, structs);
  if (isEventSignature(signature2))
    return parseEventSignature(signature2, structs);
  if (isErrorSignature(signature2))
    return parseErrorSignature(signature2, structs);
  if (isConstructorSignature(signature2))
    return parseConstructorSignature(signature2, structs);
  if (isFallbackSignature(signature2))
    return parseFallbackSignature(signature2);
  if (isReceiveSignature(signature2))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new UnknownSignatureError({ signature: signature2 });
}
function parseFunctionSignature(signature2, structs = {}) {
  const match2 = execFunctionSignature(signature2);
  if (!match2)
    throw new InvalidSignatureError({ signature: signature2, type: "function" });
  const inputParams = splitParameters(match2.parameters);
  const inputs = [];
  const inputLength = inputParams.length;
  for (let i4 = 0; i4 < inputLength; i4++) {
    inputs.push(parseAbiParameter(inputParams[i4], {
      modifiers: functionModifiers,
      structs,
      type: "function"
    }));
  }
  const outputs = [];
  if (match2.returns) {
    const outputParams = splitParameters(match2.returns);
    const outputLength = outputParams.length;
    for (let i4 = 0; i4 < outputLength; i4++) {
      outputs.push(parseAbiParameter(outputParams[i4], {
        modifiers: functionModifiers,
        structs,
        type: "function"
      }));
    }
  }
  return {
    name: match2.name,
    type: "function",
    stateMutability: match2.stateMutability ?? "nonpayable",
    inputs,
    outputs
  };
}
function parseEventSignature(signature2, structs = {}) {
  const match2 = execEventSignature(signature2);
  if (!match2)
    throw new InvalidSignatureError({ signature: signature2, type: "event" });
  const params = splitParameters(match2.parameters);
  const abiParameters = [];
  const length2 = params.length;
  for (let i4 = 0; i4 < length2; i4++)
    abiParameters.push(parseAbiParameter(params[i4], {
      modifiers: eventModifiers,
      structs,
      type: "event"
    }));
  return { name: match2.name, type: "event", inputs: abiParameters };
}
function parseErrorSignature(signature2, structs = {}) {
  const match2 = execErrorSignature(signature2);
  if (!match2)
    throw new InvalidSignatureError({ signature: signature2, type: "error" });
  const params = splitParameters(match2.parameters);
  const abiParameters = [];
  const length2 = params.length;
  for (let i4 = 0; i4 < length2; i4++)
    abiParameters.push(parseAbiParameter(params[i4], { structs, type: "error" }));
  return { name: match2.name, type: "error", inputs: abiParameters };
}
function parseConstructorSignature(signature2, structs = {}) {
  const match2 = execConstructorSignature(signature2);
  if (!match2)
    throw new InvalidSignatureError({ signature: signature2, type: "constructor" });
  const params = splitParameters(match2.parameters);
  const abiParameters = [];
  const length2 = params.length;
  for (let i4 = 0; i4 < length2; i4++)
    abiParameters.push(parseAbiParameter(params[i4], { structs, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: match2.stateMutability ?? "nonpayable",
    inputs: abiParameters
  };
}
function parseFallbackSignature(signature2) {
  const match2 = execFallbackSignature(signature2);
  if (!match2)
    throw new InvalidSignatureError({ signature: signature2, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: match2.stateMutability ?? "nonpayable"
  };
}
const abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*(?:\spayable)?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter(param, options) {
  const parameterCacheKey = getParameterCacheKey(param, options?.type, options?.structs);
  if (parameterCache.has(parameterCacheKey))
    return parameterCache.get(parameterCacheKey);
  const isTuple = isTupleRegex.test(param);
  const match2 = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
  if (!match2)
    throw new InvalidParameterError({ param });
  if (match2.name && isSolidityKeyword(match2.name))
    throw new SolidityProtectedKeywordError({ param, name: match2.name });
  const name = match2.name ? { name: match2.name } : {};
  const indexed = match2.modifier === "indexed" ? { indexed: true } : {};
  const structs = options?.structs ?? {};
  let type;
  let components = {};
  if (isTuple) {
    type = "tuple";
    const params = splitParameters(match2.type);
    const components_ = [];
    const length2 = params.length;
    for (let i4 = 0; i4 < length2; i4++) {
      components_.push(parseAbiParameter(params[i4], { structs }));
    }
    components = { components: components_ };
  } else if (match2.type in structs) {
    type = "tuple";
    components = { components: structs[match2.type] };
  } else if (dynamicIntegerRegex.test(match2.type)) {
    type = `${match2.type}256`;
  } else if (match2.type === "address payable") {
    type = "address";
  } else {
    type = match2.type;
    if (!(options?.type === "struct") && !isSolidityType(type))
      throw new UnknownSolidityTypeError({ type });
  }
  if (match2.modifier) {
    if (!options?.modifiers?.has?.(match2.modifier))
      throw new InvalidModifierError({
        param,
        type: options?.type,
        modifier: match2.modifier
      });
    if (functionModifiers.has(match2.modifier) && !isValidDataLocation(type, !!match2.array))
      throw new InvalidFunctionModifierError({
        param,
        type: options?.type,
        modifier: match2.modifier
      });
  }
  const abiParameter = {
    type: `${type}${match2.array ?? ""}`,
    ...name,
    ...indexed,
    ...components
  };
  parameterCache.set(parameterCacheKey, abiParameter);
  return abiParameter;
}
function splitParameters(params, result = [], current = "", depth = 0) {
  const length2 = params.trim().length;
  for (let i4 = 0; i4 < length2; i4++) {
    const char2 = params[i4];
    const tail = params.slice(i4 + 1);
    switch (char2) {
      case ",":
        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char2}`, depth);
      case "(":
        return splitParameters(tail, result, `${current}${char2}`, depth + 1);
      case ")":
        return splitParameters(tail, result, `${current}${char2}`, depth - 1);
      default:
        return splitParameters(tail, result, `${current}${char2}`, depth);
    }
  }
  if (current === "")
    return result;
  if (depth !== 0)
    throw new InvalidParenthesisError({ current, depth });
  result.push(current.trim());
  return result;
}
function isSolidityType(type) {
  return type === "address" || type === "bool" || type === "function" || type === "string" || bytesRegex.test(type) || integerRegex.test(type);
}
const protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(name) {
  return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || bytesRegex.test(name) || integerRegex.test(name) || protectedKeywordsRegex.test(name);
}
function isValidDataLocation(type, isArray) {
  return isArray || type === "bytes" || type === "string" || type === "tuple";
}
function parseStructs(signatures) {
  const shallowStructs = {};
  const signaturesLength = signatures.length;
  for (let i4 = 0; i4 < signaturesLength; i4++) {
    const signature2 = signatures[i4];
    if (!isStructSignature(signature2))
      continue;
    const match2 = execStructSignature(signature2);
    if (!match2)
      throw new InvalidSignatureError({ signature: signature2, type: "struct" });
    const properties2 = match2.properties.split(";");
    const components = [];
    const propertiesLength = properties2.length;
    for (let k2 = 0; k2 < propertiesLength; k2++) {
      const property = properties2[k2];
      const trimmed = property.trim();
      if (!trimmed)
        continue;
      const abiParameter = parseAbiParameter(trimmed, {
        type: "struct"
      });
      components.push(abiParameter);
    }
    if (!components.length)
      throw new InvalidStructSignatureError({ signature: signature2 });
    shallowStructs[match2.name] = components;
  }
  const resolvedStructs = {};
  const entries2 = Object.entries(shallowStructs);
  const entriesLength = entries2.length;
  for (let i4 = 0; i4 < entriesLength; i4++) {
    const [name, parameters] = entries2[i4];
    resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
  }
  return resolvedStructs;
}
const typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
  const components = [];
  const length2 = abiParameters.length;
  for (let i4 = 0; i4 < length2; i4++) {
    const abiParameter = abiParameters[i4];
    const isTuple = isTupleRegex.test(abiParameter.type);
    if (isTuple)
      components.push(abiParameter);
    else {
      const match2 = execTyped(typeWithoutTupleRegex, abiParameter.type);
      if (!match2?.type)
        throw new InvalidAbiTypeParameterError({ abiParameter });
      const { array, type } = match2;
      if (type in structs) {
        if (ancestors.has(type))
          throw new CircularReferenceError({ type });
        components.push({
          ...abiParameter,
          type: `tuple${array ?? ""}`,
          components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type]))
        });
      } else {
        if (isSolidityType(type))
          components.push(abiParameter);
        else
          throw new UnknownTypeError({ type });
      }
    }
  }
  return components;
}
function parseAbi(signatures) {
  const structs = parseStructs(signatures);
  const abi = [];
  const length2 = signatures.length;
  for (let i4 = 0; i4 < length2; i4++) {
    const signature2 = signatures[i4];
    if (isStructSignature(signature2))
      continue;
    abi.push(parseSignature(signature2, structs));
  }
  return abi;
}
function normalizeSignature(signature2) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i4 = 0; i4 < signature2.length; i4++) {
    const char2 = signature2[i4];
    if (["(", ")", ","].includes(char2))
      active = true;
    if (char2 === "(")
      level++;
    if (char2 === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char2 === " " && ["event", "function", ""].includes(result))
        result = "";
      else {
        result += char2;
        if (char2 === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char2 === " ") {
      if (signature2[i4 - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char2;
    current += char2;
  }
  if (!valid)
    throw new BaseError$4("Unable to normalize signature.");
  return result;
}
const toSignature = (def) => {
  const def_ = (() => {
    if (typeof def === "string")
      return def;
    return formatAbiItem(def);
  })();
  return normalizeSignature(def_);
};
function toSignatureHash(fn2) {
  return hashSignature(toSignature(fn2));
}
const toEventSelector = toSignatureHash;
const toFunctionSelector = (fn2) => slice$1(toSignatureHash(fn2), 0, 4);
function getAbiItem(parameters) {
  const { abi, args = [], name } = parameters;
  const isSelector = isHex(name, { strict: false });
  const abiItems = abi.filter((abiItem) => {
    if (isSelector) {
      if (abiItem.type === "function")
        return toFunctionSelector(abiItem) === name;
      if (abiItem.type === "event")
        return toEventSelector(abiItem) === name;
      return false;
    }
    return "name" in abiItem && abiItem.name === name;
  });
  if (abiItems.length === 0)
    return void 0;
  if (abiItems.length === 1)
    return abiItems[0];
  let matchedAbiItem;
  for (const abiItem of abiItems) {
    if (!("inputs" in abiItem))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem.inputs || abiItem.inputs.length === 0)
        return abiItem;
      continue;
    }
    if (!abiItem.inputs)
      continue;
    if (abiItem.inputs.length === 0)
      continue;
    if (abiItem.inputs.length !== args.length)
      continue;
    const matched = args.every((arg2, index2) => {
      const abiParameter = "inputs" in abiItem && abiItem.inputs[index2];
      if (!abiParameter)
        return false;
      return isArgOfType(arg2, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new AbiItemAmbiguityError({
            abiItem,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem;
    }
  }
  if (matchedAbiItem)
    return matchedAbiItem;
  return abiItems[0];
}
function isArgOfType(arg2, abiParameter) {
  const argType = typeof arg2;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return isAddress(arg2, { strict: false });
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index2) => {
          return isArgOfType(Object.values(arg2)[index2], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg2 instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg2) && arg2.every((x2) => isArgOfType(x2, {
          ...abiParameter,
          // Pop off `[]` or `[M]` from end of type
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types2 = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types2.includes("address") && types2.includes("bytes20"))
        return true;
      if (types2.includes("address") && types2.includes("string"))
        return isAddress(args[parameterIndex], { strict: false });
      if (types2.includes("address") && types2.includes("bytes"))
        return isAddress(args[parameterIndex], { strict: false });
      return false;
    })();
    if (ambiguous)
      return types2;
  }
  return;
}
const docsPath$4 = "/docs/contract/decodeFunctionResult";
function decodeFunctionResult(parameters) {
  const { abi, args, functionName, data: data2 } = parameters;
  let abiItem = abi[0];
  if (functionName) {
    const item = getAbiItem({ abi, args, name: functionName });
    if (!item)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath$4 });
    abiItem = item;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$4 });
  if (!abiItem.outputs)
    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath$4 });
  const values2 = decodeAbiParameters(abiItem.outputs, data2);
  if (values2 && values2.length > 1)
    return values2;
  if (values2 && values2.length === 1)
    return values2[0];
  return void 0;
}
const docsPath$3 = "/docs/contract/encodeFunctionData";
function prepareEncodeFunctionData(parameters) {
  const { abi, args, functionName } = parameters;
  let abiItem = abi[0];
  if (functionName) {
    const item = getAbiItem({
      abi,
      args,
      name: functionName
    });
    if (!item)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath$3 });
    abiItem = item;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$3 });
  return {
    abi: [abiItem],
    functionName: toFunctionSelector(formatAbiItem$1(abiItem))
  };
}
function encodeFunctionData(parameters) {
  const { args } = parameters;
  const { abi, functionName } = (() => {
    if (parameters.abi.length === 1 && parameters.functionName?.startsWith("0x"))
      return parameters;
    return prepareEncodeFunctionData(parameters);
  })();
  const abiItem = abi[0];
  const signature2 = functionName;
  const data2 = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : void 0;
  return concatHex([signature2, data2 ?? "0x"]);
}
class ChainDoesNotSupportContract extends BaseError$4 {
  constructor({ blockNumber, chain, contract }) {
    super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
          `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
        ] : [
          `- The chain does not have the contract "${contract.name}" configured.`
        ]
      ],
      name: "ChainDoesNotSupportContract"
    });
  }
}
class ChainMismatchError extends BaseError$4 {
  constructor({ chain, currentChainId }) {
    super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id}  ${chain.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${currentChainId}`,
        `Expected Chain ID: ${chain.id}  ${chain.name}`
      ],
      name: "ChainMismatchError"
    });
  }
}
class ChainNotFoundError extends BaseError$4 {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join("\n"), {
      name: "ChainNotFoundError"
    });
  }
}
class ClientChainNotConfiguredError extends BaseError$4 {
  constructor() {
    super("No chain was provided to the Client.", {
      name: "ClientChainNotConfiguredError"
    });
  }
}
function getChainContractAddress({ blockNumber, chain, contract: name }) {
  const contract = chain?.contracts?.[name];
  if (!contract)
    throw new ChainDoesNotSupportContract({
      chain,
      contract: { name }
    });
  if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
    throw new ChainDoesNotSupportContract({
      blockNumber,
      chain,
      contract: {
        name,
        blockCreated: contract.blockCreated
      }
    });
  return contract.address;
}
function parseAccount(account) {
  if (typeof account === "string")
    return { address: account, type: "json-rpc" };
  return account;
}
const panicReasons = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
};
const solidityError = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
};
const solidityPanic = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
function decodeErrorResult(parameters) {
  const { abi, data: data2 } = parameters;
  const signature2 = slice$1(data2, 0, 4);
  if (signature2 === "0x")
    throw new AbiDecodingZeroDataError();
  const abi_ = [...abi || [], solidityError, solidityPanic];
  const abiItem = abi_.find((x2) => x2.type === "error" && signature2 === toFunctionSelector(formatAbiItem$1(x2)));
  if (!abiItem)
    throw new AbiErrorSignatureNotFoundError(signature2, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem,
    args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice$1(data2, 4)) : void 0,
    errorName: abiItem.name
  };
}
const stringify$1 = (value, replacer, space) => JSON.stringify(value, (key2, value_) => {
  const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
  return value2;
}, space);
function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
  if (!("name" in abiItem))
    return;
  if (!("inputs" in abiItem))
    return;
  if (!abiItem.inputs)
    return;
  return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i4) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i4] === "object" ? stringify$1(args[i4]) : args[i4]}`).join(", ")})`;
}
const etherUnits = {
  gwei: 9,
  wei: 18
};
const gweiUnits = {
  ether: -9,
  wei: 9
};
const weiUnits = {
  ether: -18,
  gwei: -9
};
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
function formatEther(wei, unit = "wei") {
  return formatUnits(wei, etherUnits[unit]);
}
function formatGwei(wei, unit = "wei") {
  return formatUnits(wei, gweiUnits[unit]);
}
class AccountStateConflictError extends BaseError$4 {
  constructor({ address }) {
    super(`State for account "${address}" is set multiple times.`, {
      name: "AccountStateConflictError"
    });
  }
}
class StateAssignmentConflictError extends BaseError$4 {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError"
    });
  }
}
function prettyStateMapping(stateMapping) {
  return stateMapping.reduce((pretty, { slot, value }) => {
    return `${pretty}        ${slot}: ${value}
`;
  }, "");
}
function prettyStateOverride(stateOverride) {
  return stateOverride.reduce((pretty, { address, ...state2 }) => {
    let val = `${pretty}    ${address}:
`;
    if (state2.nonce)
      val += `      nonce: ${state2.nonce}
`;
    if (state2.balance)
      val += `      balance: ${state2.balance}
`;
    if (state2.code)
      val += `      code: ${state2.code}
`;
    if (state2.state) {
      val += "      state:\n";
      val += prettyStateMapping(state2.state);
    }
    if (state2.stateDiff) {
      val += "      stateDiff:\n";
      val += prettyStateMapping(state2.stateDiff);
    }
    return val;
  }, "  State Override:\n").slice(0, -1);
}
function prettyPrint(args) {
  const entries2 = Object.entries(args).map(([key2, value]) => {
    if (value === void 0 || value === false)
      return null;
    return [key2, value];
  }).filter(Boolean);
  const maxLength = entries2.reduce((acc, [key2]) => Math.max(acc, key2.length), 0);
  return entries2.map(([key2, value]) => `  ${`${key2}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
}
class FeeConflictError extends BaseError$4 {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join("\n"), { name: "FeeConflictError" });
  }
}
class InvalidSerializableTransactionError extends BaseError$4 {
  constructor({ transaction }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        prettyPrint(transaction),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class TransactionExecutionError extends BaseError$4 {
  constructor(cause, { account, docsPath: docsPath2, chain, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint({
      chain: chain && `${chain?.name} (id: ${chain?.id})`,
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data: data2,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Request Arguments:",
        prettyArgs
      ].filter(Boolean),
      name: "TransactionExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause;
  }
}
class TransactionNotFoundError extends BaseError$4 {
  constructor({ blockHash, blockNumber, blockTag, hash: hash2, index: index2 }) {
    let identifier2 = "Transaction";
    if (blockTag && index2 !== void 0)
      identifier2 = `Transaction at block time "${blockTag}" at index "${index2}"`;
    if (blockHash && index2 !== void 0)
      identifier2 = `Transaction at block hash "${blockHash}" at index "${index2}"`;
    if (blockNumber && index2 !== void 0)
      identifier2 = `Transaction at block number "${blockNumber}" at index "${index2}"`;
    if (hash2)
      identifier2 = `Transaction with hash "${hash2}"`;
    super(`${identifier2} could not be found.`, {
      name: "TransactionNotFoundError"
    });
  }
}
class TransactionReceiptNotFoundError extends BaseError$4 {
  constructor({ hash: hash2 }) {
    super(`Transaction receipt with hash "${hash2}" could not be found. The Transaction may not be processed on a block yet.`, {
      name: "TransactionReceiptNotFoundError"
    });
  }
}
class WaitForTransactionReceiptTimeoutError extends BaseError$4 {
  constructor({ hash: hash2 }) {
    super(`Timed out while waiting for transaction with hash "${hash2}" to be confirmed.`, { name: "WaitForTransactionReceiptTimeoutError" });
  }
}
const getContractAddress = (address) => address;
const getUrl = (url) => url;
class CallExecutionError extends BaseError$4 {
  constructor(cause, { account: account_, docsPath: docsPath2, chain, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride }) {
    const account = account_ ? parseAccount(account_) : void 0;
    let prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data: data2,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    if (stateOverride) {
      prettyArgs += `
${prettyStateOverride(stateOverride)}`;
    }
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Raw Call Arguments:",
        prettyArgs
      ].filter(Boolean),
      name: "CallExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause;
  }
}
class ContractFunctionExecutionError extends BaseError$4 {
  constructor(cause, { abi, args, contractAddress, docsPath: docsPath2, functionName, sender }) {
    const abiItem = getAbiItem({ abi, args, name: functionName });
    const formattedArgs = abiItem ? formatAbiItemWithArgs({
      abiItem,
      args,
      includeFunctionName: false,
      includeName: false
    }) : void 0;
    const functionWithParams = abiItem ? formatAbiItem$1(abiItem, { includeName: true }) : void 0;
    const prettyArgs = prettyPrint({
      address: contractAddress && getContractAddress(contractAddress),
      function: functionWithParams,
      args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
      sender
    });
    super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        prettyArgs && "Contract Call:",
        prettyArgs
      ].filter(Boolean),
      name: "ContractFunctionExecutionError"
    });
    Object.defineProperty(this, "abi", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "args", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "contractAddress", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "formattedArgs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "functionName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "sender", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abi = abi;
    this.args = args;
    this.cause = cause;
    this.contractAddress = contractAddress;
    this.functionName = functionName;
    this.sender = sender;
  }
}
class ContractFunctionRevertedError extends BaseError$4 {
  constructor({ abi, data: data2, functionName, message }) {
    let cause;
    let decodedData;
    let metaMessages;
    let reason;
    if (data2 && data2 !== "0x") {
      try {
        decodedData = decodeErrorResult({ abi, data: data2 });
        const { abiItem, errorName, args: errorArgs } = decodedData;
        if (errorName === "Error") {
          reason = errorArgs[0];
        } else if (errorName === "Panic") {
          const [firstArg] = errorArgs;
          reason = panicReasons[firstArg];
        } else {
          const errorWithParams = abiItem ? formatAbiItem$1(abiItem, { includeName: true }) : void 0;
          const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({
            abiItem,
            args: errorArgs,
            includeFunctionName: false,
            includeName: false
          }) : void 0;
          metaMessages = [
            errorWithParams ? `Error: ${errorWithParams}` : "",
            formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
          ];
        }
      } catch (err) {
        cause = err;
      }
    } else if (message)
      reason = message;
    let signature2;
    if (cause instanceof AbiErrorSignatureNotFoundError) {
      signature2 = cause.signature;
      metaMessages = [
        `Unable to decode signature "${signature2}" as it was not found on the provided ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature2}.`
      ];
    }
    super(reason && reason !== "execution reverted" || signature2 ? [
      `The contract function "${functionName}" reverted with the following ${signature2 ? "signature" : "reason"}:`,
      reason || signature2
    ].join("\n") : `The contract function "${functionName}" reverted.`, {
      cause,
      metaMessages,
      name: "ContractFunctionRevertedError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "raw", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "reason", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "signature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = decodedData;
    this.raw = data2;
    this.reason = reason;
    this.signature = signature2;
  }
}
class ContractFunctionZeroDataError extends BaseError$4 {
  constructor({ functionName }) {
    super(`The contract function "${functionName}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${functionName}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ],
      name: "ContractFunctionZeroDataError"
    });
  }
}
class CounterfactualDeploymentFailedError extends BaseError$4 {
  constructor({ factory }) {
    super(`Deployment for counterfactual contract call failed${factory ? ` for factory "${factory}".` : ""}`, {
      metaMessages: [
        "Please ensure:",
        "- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).",
        "- The `factoryData` is a valid encoded function call for contract deployment function on the factory."
      ],
      name: "CounterfactualDeploymentFailedError"
    });
  }
}
class RawContractError extends BaseError$4 {
  constructor({ data: data2, message }) {
    super(message || "", { name: "RawContractError" });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = data2;
  }
}
function isNullUniversalResolverError(err) {
  if (!(err instanceof BaseError$4))
    return false;
  const cause = err.walk((e2) => e2 instanceof ContractFunctionRevertedError);
  if (!(cause instanceof ContractFunctionRevertedError))
    return false;
  if (cause.data?.errorName === "HttpError")
    return true;
  if (cause.data?.errorName === "ResolverError")
    return true;
  if (cause.data?.errorName === "ResolverNotContract")
    return true;
  if (cause.data?.errorName === "ResolverNotFound")
    return true;
  if (cause.data?.errorName === "ReverseAddressMismatch")
    return true;
  if (cause.data?.errorName === "UnsupportedResolverProfile")
    return true;
  return false;
}
function decodeFunctionData(parameters) {
  const { abi, data: data2 } = parameters;
  const signature2 = slice$1(data2, 0, 4);
  const description = abi.find((x2) => x2.type === "function" && signature2 === toFunctionSelector(formatAbiItem$1(x2)));
  if (!description)
    throw new AbiFunctionSignatureNotFoundError(signature2, {
      docsPath: "/docs/contract/decodeFunctionData"
    });
  return {
    functionName: description.name,
    args: "inputs" in description && description.inputs && description.inputs.length > 0 ? decodeAbiParameters(description.inputs, slice$1(data2, 4)) : void 0
  };
}
const docsPath$2 = "/docs/contract/encodeErrorResult";
function encodeErrorResult(parameters) {
  const { abi, errorName, args } = parameters;
  let abiItem = abi[0];
  if (errorName) {
    const item = getAbiItem({ abi, args, name: errorName });
    if (!item)
      throw new AbiErrorNotFoundError(errorName, { docsPath: docsPath$2 });
    abiItem = item;
  }
  if (abiItem.type !== "error")
    throw new AbiErrorNotFoundError(void 0, { docsPath: docsPath$2 });
  const definition = formatAbiItem$1(abiItem);
  const signature2 = toFunctionSelector(definition);
  let data2 = "0x";
  if (args && args.length > 0) {
    if (!abiItem.inputs)
      throw new AbiErrorInputsNotFoundError(abiItem.name, { docsPath: docsPath$2 });
    data2 = encodeAbiParameters(abiItem.inputs, args);
  }
  return concatHex([signature2, data2]);
}
const docsPath$1 = "/docs/contract/encodeFunctionResult";
function encodeFunctionResult(parameters) {
  const { abi, functionName, result } = parameters;
  let abiItem = abi[0];
  if (functionName) {
    const item = getAbiItem({ abi, name: functionName });
    if (!item)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath$1 });
    abiItem = item;
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath$1 });
  if (!abiItem.outputs)
    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath$1 });
  const values2 = (() => {
    if (abiItem.outputs.length === 0)
      return [];
    if (abiItem.outputs.length === 1)
      return [result];
    if (Array.isArray(result))
      return result;
    throw new InvalidArrayError(result);
  })();
  return encodeAbiParameters(abiItem.outputs, values2);
}
const localBatchGatewayUrl = "x-batch-gateway:true";
async function localBatchGatewayRequest(parameters) {
  const { data: data2, ccipRequest } = parameters;
  const { args: [queries] } = decodeFunctionData({ abi: batchGatewayAbi, data: data2 });
  const failures = [];
  const responses = [];
  await Promise.all(queries.map(async (query, i4) => {
    try {
      responses[i4] = query.urls.includes(localBatchGatewayUrl) ? await localBatchGatewayRequest({ data: query.data, ccipRequest }) : await ccipRequest(query);
      failures[i4] = false;
    } catch (err) {
      failures[i4] = true;
      responses[i4] = encodeError(err);
    }
  }));
  return encodeFunctionResult({
    abi: batchGatewayAbi,
    functionName: "query",
    result: [failures, responses]
  });
}
function encodeError(error) {
  if (error.name === "HttpRequestError" && error.status)
    return encodeErrorResult({
      abi: batchGatewayAbi,
      errorName: "HttpError",
      args: [error.status, error.shortMessage]
    });
  return encodeErrorResult({
    abi: [solidityError],
    errorName: "Error",
    args: ["shortMessage" in error ? error.shortMessage : error.message]
  });
}
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash2 = `0x${label.slice(1, 65)}`;
  if (!isHex(hash2))
    return null;
  return hash2;
}
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return bytesToHex$1(result);
  const labels = name.split(".");
  for (let i4 = labels.length - 1; i4 >= 0; i4 -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i4]);
    const hashed = hashFromEncodedLabel ? toBytes$1(hashFromEncodedLabel) : keccak256(stringToBytes(labels[i4]), "bytes");
    result = keccak256(concat$1([result, hashed]), "bytes");
  }
  return bytesToHex$1(result);
}
function encodeLabelhash(hash2) {
  return `[${hash2.slice(2)}]`;
}
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex$1(result);
  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));
}
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset2 = 0;
  const list = value.split(".");
  for (let i4 = 0; i4 < list.length; i4++) {
    let encoded = stringToBytes(list[i4]);
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash(labelhash(list[i4])));
    bytes[offset2] = encoded.length;
    bytes.set(encoded, offset2 + 1);
    offset2 += encoded.length + 1;
  }
  if (bytes.byteLength !== offset2 + 1)
    return bytes.slice(0, offset2 + 1);
  return bytes;
}
function getAction$1(client2, actionFn, name) {
  const action_implicit = client2[actionFn.name];
  if (typeof action_implicit === "function")
    return action_implicit;
  const action_explicit = client2[name];
  if (typeof action_explicit === "function")
    return action_explicit;
  return (params) => actionFn(client2, params);
}
class HttpRequestError extends BaseError$4 {
  constructor({ body: body2, cause, details, headers, status, url }) {
    super("HTTP request failed.", {
      cause,
      details,
      metaMessages: [
        status && `Status: ${status}`,
        `URL: ${getUrl(url)}`,
        body2 && `Request body: ${stringify$1(body2)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    });
    Object.defineProperty(this, "body", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "headers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "url", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.body = body2;
    this.headers = headers;
    this.status = status;
    this.url = url;
  }
}
class RpcRequestError extends BaseError$4 {
  constructor({ body: body2, error, url }) {
    super("RPC Request failed.", {
      cause: error,
      details: error.message,
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify$1(body2)}`],
      name: "RpcRequestError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = error.code;
    this.data = error.data;
  }
}
class TimeoutError extends BaseError$4 {
  constructor({ body: body2, url }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify$1(body2)}`],
      name: "TimeoutError"
    });
  }
}
const unknownErrorCode = -1;
class RpcError extends BaseError$4 {
  constructor(cause, { code, docsPath: docsPath2, metaMessages, name, shortMessage }) {
    super(shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: metaMessages || cause?.metaMessages,
      name: name || "RpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = name || cause.name;
    this.code = cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode;
  }
}
class ProviderRpcError extends RpcError {
  constructor(cause, options) {
    super(cause, options);
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = options.data;
  }
}
class ParseRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ParseRpcError.code,
      name: "ParseRpcError",
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
  }
}
Object.defineProperty(ParseRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});
class InvalidRequestRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidRequestRpcError.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object."
    });
  }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
class MethodNotFoundRpcError extends RpcError {
  constructor(cause, { method } = {}) {
    super(cause, {
      code: MethodNotFoundRpcError.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${method ? ` "${method}"` : ""} does not exist / is not available.`
    });
  }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
class InvalidParamsRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidParamsRpcError.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
  }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
class InternalRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InternalRpcError.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(InternalRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
class InvalidInputRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: InvalidInputRpcError.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join("\n")
    });
  }
}
Object.defineProperty(InvalidInputRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
class ResourceNotFoundRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceNotFoundRpcError.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found."
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: ResourceUnavailableRpcError.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available."
    });
  }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
class TransactionRejectedRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: TransactionRejectedRpcError.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed."
    });
  }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
  constructor(cause, { method } = {}) {
    super(cause, {
      code: MethodNotSupportedRpcError.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${method ? ` "${method}"` : ""} is not supported.`
    });
  }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
class LimitExceededRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: LimitExceededRpcError.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit."
    });
  }
}
Object.defineProperty(LimitExceededRpcError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
  constructor(cause) {
    super(cause, {
      code: JsonRpcVersionUnsupportedError.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
  }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UserRejectedRequestError.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request."
    });
  }
}
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnauthorizedProviderError.code,
      name: "UnauthorizedProviderError",
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
  }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
  constructor(cause, { method } = {}) {
    super(cause, {
      code: UnsupportedProviderMethodError.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ""}.`
    });
  }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ProviderDisconnectedError.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains."
    });
  }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: ChainDisconnectedError.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain."
    });
  }
}
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
class SwitchChainError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: SwitchChainError.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain."
    });
  }
}
Object.defineProperty(SwitchChainError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4902
});
class UnsupportedNonOptionalCapabilityError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnsupportedNonOptionalCapabilityError.code,
      name: "UnsupportedNonOptionalCapabilityError",
      shortMessage: "This Wallet does not support a capability that was not marked as optional."
    });
  }
}
Object.defineProperty(UnsupportedNonOptionalCapabilityError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5700
});
class UnsupportedChainIdError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnsupportedChainIdError.code,
      name: "UnsupportedChainIdError",
      shortMessage: "This Wallet does not support the requested chain ID."
    });
  }
}
Object.defineProperty(UnsupportedChainIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5710
});
class DuplicateIdError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: DuplicateIdError.code,
      name: "DuplicateIdError",
      shortMessage: "There is already a bundle submitted with this ID."
    });
  }
}
Object.defineProperty(DuplicateIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5720
});
class UnknownBundleIdError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: UnknownBundleIdError.code,
      name: "UnknownBundleIdError",
      shortMessage: "This bundle id is unknown / has not been submitted"
    });
  }
}
Object.defineProperty(UnknownBundleIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5730
});
class BundleTooLargeError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: BundleTooLargeError.code,
      name: "BundleTooLargeError",
      shortMessage: "The call bundle is too large for the Wallet to process."
    });
  }
}
Object.defineProperty(BundleTooLargeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5740
});
class AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: AtomicReadyWalletRejectedUpgradeError.code,
      name: "AtomicReadyWalletRejectedUpgradeError",
      shortMessage: "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade."
    });
  }
}
Object.defineProperty(AtomicReadyWalletRejectedUpgradeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5750
});
class AtomicityNotSupportedError extends ProviderRpcError {
  constructor(cause) {
    super(cause, {
      code: AtomicityNotSupportedError.code,
      name: "AtomicityNotSupportedError",
      shortMessage: "The wallet does not support atomic execution but the request requires it."
    });
  }
}
Object.defineProperty(AtomicityNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5760
});
class UnknownRpcError extends RpcError {
  constructor(cause) {
    super(cause, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred."
    });
  }
}
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi, address, args, docsPath: docsPath2, functionName, sender }) {
  const error = err instanceof RawContractError ? err : err instanceof BaseError$4 ? err.walk((err2) => "data" in err2) || err.walk() : {};
  const { code, data: data2, details, message, shortMessage } = error;
  const cause = (() => {
    if (err instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) && (data2 || details || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi,
        data: typeof data2 === "object" ? data2.data : data2,
        functionName,
        message: error instanceof RpcRequestError ? details : shortMessage ?? message
      });
    }
    return err;
  })();
  return new ContractFunctionExecutionError(cause, {
    abi,
    args,
    contractAddress: address,
    docsPath: docsPath2,
    functionName,
    sender
  });
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    let allSettled2 = function(promises) {
      return Promise.all(
        promises.map(
          (p2) => Promise.resolve(p2).then(
            (value) => ({ status: "fulfilled", value }),
            (reason) => ({ status: "rejected", reason })
          )
        )
      );
    };
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = allSettled2(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e2 = new Event("vite:preloadError", {
      cancelable: true
    });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const version$4 = "0.1.1";
function getVersion$2() {
  return version$4;
}
let BaseError$2 = class BaseError3 extends Error {
  constructor(shortMessage, options = {}) {
    const details = (() => {
      if (options.cause instanceof BaseError3) {
        if (options.cause.details)
          return options.cause.details;
        if (options.cause.shortMessage)
          return options.cause.shortMessage;
      }
      if (options.cause && "details" in options.cause && typeof options.cause.details === "string")
        return options.cause.details;
      if (options.cause?.message)
        return options.cause.message;
      return options.details;
    })();
    const docsPath2 = (() => {
      if (options.cause instanceof BaseError3)
        return options.cause.docsPath || options.docsPath;
      return options.docsPath;
    })();
    const docsBaseUrl = "https://oxlib.sh";
    const docs = `${docsBaseUrl}${docsPath2 ?? ""}`;
    const message = [
      shortMessage || "An error occurred.",
      ...options.metaMessages ? ["", ...options.metaMessages] : [],
      ...details || docsPath2 ? [
        "",
        details ? `Details: ${details}` : void 0,
        docsPath2 ? `See: ${docs}` : void 0
      ] : []
    ].filter((x2) => typeof x2 === "string").join("\n");
    super(message, options.cause ? { cause: options.cause } : void 0);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `ox@${getVersion$2()}`
    });
    this.cause = options.cause;
    this.details = details;
    this.docs = docs;
    this.docsPath = docsPath2;
    this.shortMessage = shortMessage;
  }
  walk(fn2) {
    return walk(this, fn2);
  }
};
function walk(err, fn2) {
  if (fn2?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause)
    return walk(err.cause, fn2);
  return fn2 ? null : err;
}
function assertSize(hex, size_) {
  if (size$2(hex) > size_)
    throw new SizeOverflowError2({
      givenSize: size$2(hex),
      maxSize: size_
    });
}
function assertStartOffset(value, start2) {
  if (typeof start2 === "number" && start2 > 0 && start2 > size$2(value) - 1)
    throw new SliceOffsetOutOfBoundsError2({
      offset: start2,
      position: "start",
      size: size$2(value)
    });
}
function assertEndOffset(value, start2, end2) {
  if (typeof start2 === "number" && typeof end2 === "number" && size$2(value) !== end2 - start2) {
    throw new SliceOffsetOutOfBoundsError2({
      offset: end2,
      position: "end",
      size: size$2(value)
    });
  }
}
function pad(hex_, options = {}) {
  const { dir, size: size2 = 32 } = options;
  if (size2 === 0)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError2({
      size: Math.ceil(hex.length / 2),
      targetSize: size2,
      type: "Hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
const bigIntSuffix = "#__bigint";
function stringify(value, replacer, space) {
  return JSON.stringify(value, (key2, value2) => {
    if (typeof value2 === "bigint")
      return value2.toString() + bigIntSuffix;
    return value2;
  }, space);
}
const encoder = /* @__PURE__ */ new TextEncoder();
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i4) => i4.toString(16).padStart(2, "0"));
function assert(value, options = {}) {
  const { strict = false } = options;
  if (!value)
    throw new InvalidHexTypeError(value);
  if (typeof value !== "string")
    throw new InvalidHexTypeError(value);
  if (strict) {
    if (!/^0x[0-9a-fA-F]*$/.test(value))
      throw new InvalidHexValueError(value);
  }
  if (!value.startsWith("0x"))
    throw new InvalidHexValueError(value);
}
function concat(...values2) {
  return `0x${values2.reduce((acc, x2) => acc + x2.replace("0x", ""), "")}`;
}
function from$1(value) {
  if (value instanceof Uint8Array)
    return fromBytes(value);
  if (Array.isArray(value))
    return fromBytes(new Uint8Array(value));
  return value;
}
function fromBoolean(value, options = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof options.size === "number") {
    assertSize(hex, options.size);
    return padLeft(hex, options.size);
  }
  return hex;
}
function fromBytes(value, options = {}) {
  let string = "";
  for (let i4 = 0; i4 < value.length; i4++)
    string += hexes[value[i4]];
  const hex = `0x${string}`;
  if (typeof options.size === "number") {
    assertSize(hex, options.size);
    return padRight(hex, options.size);
  }
  return hex;
}
function fromNumber(value, options = {}) {
  const { signed: signed2, size: size2 } = options;
  const value_ = BigInt(value);
  let maxValue;
  if (size2) {
    if (signed2)
      maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed2 ? -maxValue - 1n : 0;
  if (maxValue && value_ > maxValue || value_ < minValue) {
    const suffix = typeof value === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError2({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed: signed2,
      size: size2,
      value: `${value}${suffix}`
    });
  }
  const stringValue = (signed2 && value_ < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value_) : value_).toString(16);
  const hex = `0x${stringValue}`;
  if (size2)
    return padLeft(hex, size2);
  return hex;
}
function fromString$1(value, options = {}) {
  return fromBytes(encoder.encode(value), options);
}
function padLeft(value, size2) {
  return pad(value, { dir: "left", size: size2 });
}
function padRight(value, size2) {
  return pad(value, { dir: "right", size: size2 });
}
function slice(value, start2, end2, options = {}) {
  const { strict } = options;
  assertStartOffset(value, start2);
  const value_ = `0x${value.replace("0x", "").slice((start2 ?? 0) * 2, (end2 ?? value.length) * 2)}`;
  if (strict)
    assertEndOffset(value_, start2, end2);
  return value_;
}
function size$2(value) {
  return Math.ceil((value.length - 2) / 2);
}
function toBigInt(hex, options = {}) {
  const { signed: signed2 } = options;
  if (options.size)
    assertSize(hex, options.size);
  const value = BigInt(hex);
  if (!signed2)
    return value;
  const size2 = (hex.length - 2) / 2;
  const max_unsigned = (1n << BigInt(size2) * 8n) - 1n;
  const max_signed = max_unsigned >> 1n;
  if (value <= max_signed)
    return value;
  return value - max_unsigned - 1n;
}
function toNumber(hex, options = {}) {
  const { signed: signed2, size: size2 } = options;
  if (!signed2 && !size2)
    return Number(hex);
  return Number(toBigInt(hex, options));
}
function validate(value, options = {}) {
  const { strict = false } = options;
  try {
    assert(value, { strict });
    return true;
  } catch {
    return false;
  }
}
class IntegerOutOfRangeError2 extends BaseError$2 {
  constructor({ max: max2, min: min2, signed: signed2, size: size2, value }) {
    super(`Number \`${value}\` is not in safe${size2 ? ` ${size2 * 8}-bit` : ""}${signed2 ? " signed" : " unsigned"} integer range ${max2 ? `(\`${min2}\` to \`${max2}\`)` : `(above \`${min2}\`)`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
}
class InvalidHexTypeError extends BaseError$2 {
  constructor(value) {
    super(`Value \`${typeof value === "object" ? stringify(value) : value}\` of type \`${typeof value}\` is an invalid hex type.`, {
      metaMessages: ['Hex types must be represented as `"0x${string}"`.']
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.InvalidHexTypeError"
    });
  }
}
class InvalidHexValueError extends BaseError$2 {
  constructor(value) {
    super(`Value \`${value}\` is an invalid hex value.`, {
      metaMessages: [
        'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.InvalidHexValueError"
    });
  }
}
class SizeOverflowError2 extends BaseError$2 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeOverflowError"
    });
  }
}
class SliceOffsetOutOfBoundsError2 extends BaseError$2 {
  constructor({ offset: offset2, position: position2, size: size2 }) {
    super(`Slice ${position2 === "start" ? "starting" : "ending"} at offset \`${offset2}\` is out-of-bounds (size: \`${size2}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SliceOffsetOutOfBoundsError"
    });
  }
}
class SizeExceedsPaddingSizeError2 extends BaseError$2 {
  constructor({ size: size2, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size2}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
}
function toRpc$1(withdrawal) {
  return {
    address: withdrawal.address,
    amount: fromNumber(withdrawal.amount),
    index: fromNumber(withdrawal.index),
    validatorIndex: fromNumber(withdrawal.validatorIndex)
  };
}
function toRpc(blockOverrides) {
  return {
    ...typeof blockOverrides.baseFeePerGas === "bigint" && {
      baseFeePerGas: fromNumber(blockOverrides.baseFeePerGas)
    },
    ...typeof blockOverrides.blobBaseFee === "bigint" && {
      blobBaseFee: fromNumber(blockOverrides.blobBaseFee)
    },
    ...typeof blockOverrides.feeRecipient === "string" && {
      feeRecipient: blockOverrides.feeRecipient
    },
    ...typeof blockOverrides.gasLimit === "bigint" && {
      gasLimit: fromNumber(blockOverrides.gasLimit)
    },
    ...typeof blockOverrides.number === "bigint" && {
      number: fromNumber(blockOverrides.number)
    },
    ...typeof blockOverrides.prevRandao === "bigint" && {
      prevRandao: fromNumber(blockOverrides.prevRandao)
    },
    ...typeof blockOverrides.time === "bigint" && {
      time: fromNumber(blockOverrides.time)
    },
    ...blockOverrides.withdrawals && {
      withdrawals: blockOverrides.withdrawals.map(toRpc$1)
    }
  };
}
const aggregate3Signature = "0x82ad56cb";
const deploylessCallViaBytecodeBytecode = "0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe";
const deploylessCallViaFactoryBytecode = "0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe";
const erc6492SignatureValidatorByteCode = "0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
const multicall3Bytecode = "0x608060405234801561001057600080fd5b506115b9806100206000396000f3fe6080604052600436106100f35760003560e01c80634d2301cc1161008a578063a8b0574e11610059578063a8b0574e14610325578063bce38bd714610350578063c3077fa914610380578063ee82ac5e146103b2576100f3565b80634d2301cc1461026257806372425d9d1461029f57806382ad56cb146102ca57806386d516e8146102fa576100f3565b80633408e470116100c65780633408e470146101af578063399542e9146101da5780633e64a6961461020c57806342cbb15c14610237576100f3565b80630f28c97d146100f8578063174dea7114610123578063252dba421461015357806327e86d6e14610184575b600080fd5b34801561010457600080fd5b5061010d6103ef565b60405161011a9190610c0a565b60405180910390f35b61013d60048036038101906101389190610c94565b6103f7565b60405161014a9190610e94565b60405180910390f35b61016d60048036038101906101689190610f0c565b610615565b60405161017b92919061101b565b60405180910390f35b34801561019057600080fd5b506101996107ab565b6040516101a69190611064565b60405180910390f35b3480156101bb57600080fd5b506101c46107b7565b6040516101d19190610c0a565b60405180910390f35b6101f460048036038101906101ef91906110ab565b6107bf565b6040516102039392919061110b565b60405180910390f35b34801561021857600080fd5b506102216107e1565b60405161022e9190610c0a565b60405180910390f35b34801561024357600080fd5b5061024c6107e9565b6040516102599190610c0a565b60405180910390f35b34801561026e57600080fd5b50610289600480360381019061028491906111a7565b6107f1565b6040516102969190610c0a565b60405180910390f35b3480156102ab57600080fd5b506102b4610812565b6040516102c19190610c0a565b60405180910390f35b6102e460048036038101906102df919061122a565b61081a565b6040516102f19190610e94565b60405180910390f35b34801561030657600080fd5b5061030f6109e4565b60405161031c9190610c0a565b60405180910390f35b34801561033157600080fd5b5061033a6109ec565b6040516103479190611286565b60405180910390f35b61036a600480360381019061036591906110ab565b6109f4565b6040516103779190610e94565b60405180910390f35b61039a60048036038101906103959190610f0c565b610ba6565b6040516103a99392919061110b565b60405180910390f35b3480156103be57600080fd5b506103d960048036038101906103d491906112cd565b610bca565b6040516103e69190611064565b60405180910390f35b600042905090565b60606000808484905090508067ffffffffffffffff81111561041c5761041b6112fa565b5b60405190808252806020026020018201604052801561045557816020015b610442610bd5565b81526020019060019003908161043a5790505b5092503660005b828110156105c957600085828151811061047957610478611329565b5b6020026020010151905087878381811061049657610495611329565b5b90506020028101906104a89190611367565b925060008360400135905080860195508360000160208101906104cb91906111a7565b73ffffffffffffffffffffffffffffffffffffffff16818580606001906104f2919061138f565b604051610500929190611431565b60006040518083038185875af1925050503d806000811461053d576040519150601f19603f3d011682016040523d82523d6000602084013e610542565b606091505b5083600001846020018290528215151515815250505081516020850135176105bc577f08c379a000000000000000000000000000000000000000000000000000000000600052602060045260176024527f4d756c746963616c6c333a2063616c6c206661696c656400000000000000000060445260846000fd5b826001019250505061045c565b5082341461060c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610603906114a7565b60405180910390fd5b50505092915050565b6000606043915060008484905090508067ffffffffffffffff81111561063e5761063d6112fa565b5b60405190808252806020026020018201604052801561067157816020015b606081526020019060019003908161065c5790505b5091503660005b828110156107a157600087878381811061069557610694611329565b5b90506020028101906106a791906114c7565b92508260000160208101906106bc91906111a7565b73ffffffffffffffffffffffffffffffffffffffff168380602001906106e2919061138f565b6040516106f0929190611431565b6000604051808303816000865af19150503d806000811461072d576040519150601f19603f3d011682016040523d82523d6000602084013e610732565b606091505b5086848151811061074657610745611329565b5b60200260200101819052819250505080610795576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161078c9061153b565b60405180910390fd5b81600101915050610678565b5050509250929050565b60006001430340905090565b600046905090565b6000806060439250434091506107d68686866109f4565b905093509350939050565b600048905090565b600043905090565b60008173ffffffffffffffffffffffffffffffffffffffff16319050919050565b600044905090565b606060008383905090508067ffffffffffffffff81111561083e5761083d6112fa565b5b60405190808252806020026020018201604052801561087757816020015b610864610bd5565b81526020019060019003908161085c5790505b5091503660005b828110156109db57600084828151811061089b5761089a611329565b5b602002602001015190508686838181106108b8576108b7611329565b5b90506020028101906108ca919061155b565b92508260000160208101906108df91906111a7565b73ffffffffffffffffffffffffffffffffffffffff16838060400190610905919061138f565b604051610913929190611431565b6000604051808303816000865af19150503d8060008114610950576040519150601f19603f3d011682016040523d82523d6000602084013e610955565b606091505b5082600001836020018290528215151515815250505080516020840135176109cf577f08c379a000000000000000000000000000000000000000000000000000000000600052602060045260176024527f4d756c746963616c6c333a2063616c6c206661696c656400000000000000000060445260646000fd5b8160010191505061087e565b50505092915050565b600045905090565b600041905090565b606060008383905090508067ffffffffffffffff811115610a1857610a176112fa565b5b604051908082528060200260200182016040528015610a5157816020015b610a3e610bd5565b815260200190600190039081610a365790505b5091503660005b82811015610b9c576000848281518110610a7557610a74611329565b5b60200260200101519050868683818110610a9257610a91611329565b5b9050602002810190610aa491906114c7565b9250826000016020810190610ab991906111a7565b73ffffffffffffffffffffffffffffffffffffffff16838060200190610adf919061138f565b604051610aed929190611431565b6000604051808303816000865af19150503d8060008114610b2a576040519150601f19603f3d011682016040523d82523d6000602084013e610b2f565b606091505b508260000183602001829052821515151581525050508715610b90578060000151610b8f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b869061153b565b60405180910390fd5b5b81600101915050610a58565b5050509392505050565b6000806060610bb7600186866107bf565b8093508194508295505050509250925092565b600081409050919050565b6040518060400160405280600015158152602001606081525090565b6000819050919050565b610c0481610bf1565b82525050565b6000602082019050610c1f6000830184610bfb565b92915050565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f840112610c5457610c53610c2f565b5b8235905067ffffffffffffffff811115610c7157610c70610c34565b5b602083019150836020820283011115610c8d57610c8c610c39565b5b9250929050565b60008060208385031215610cab57610caa610c25565b5b600083013567ffffffffffffffff811115610cc957610cc8610c2a565b5b610cd585828601610c3e565b92509250509250929050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b60008115159050919050565b610d2281610d0d565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015610d62578082015181840152602081019050610d47565b83811115610d71576000848401525b50505050565b6000601f19601f8301169050919050565b6000610d9382610d28565b610d9d8185610d33565b9350610dad818560208601610d44565b610db681610d77565b840191505092915050565b6000604083016000830151610dd96000860182610d19565b5060208301518482036020860152610df18282610d88565b9150508091505092915050565b6000610e0a8383610dc1565b905092915050565b6000602082019050919050565b6000610e2a82610ce1565b610e348185610cec565b935083602082028501610e4685610cfd565b8060005b85811015610e825784840389528151610e638582610dfe565b9450610e6e83610e12565b925060208a01995050600181019050610e4a565b50829750879550505050505092915050565b60006020820190508181036000830152610eae8184610e1f565b905092915050565b60008083601f840112610ecc57610ecb610c2f565b5b8235905067ffffffffffffffff811115610ee957610ee8610c34565b5b602083019150836020820283011115610f0557610f04610c39565b5b9250929050565b60008060208385031215610f2357610f22610c25565b5b600083013567ffffffffffffffff811115610f4157610f40610c2a565b5b610f4d85828601610eb6565b92509250509250929050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000610f918383610d88565b905092915050565b6000602082019050919050565b6000610fb182610f59565b610fbb8185610f64565b935083602082028501610fcd85610f75565b8060005b858110156110095784840389528151610fea8582610f85565b9450610ff583610f99565b925060208a01995050600181019050610fd1565b50829750879550505050505092915050565b60006040820190506110306000830185610bfb565b81810360208301526110428184610fa6565b90509392505050565b6000819050919050565b61105e8161104b565b82525050565b60006020820190506110796000830184611055565b92915050565b61108881610d0d565b811461109357600080fd5b50565b6000813590506110a58161107f565b92915050565b6000806000604084860312156110c4576110c3610c25565b5b60006110d286828701611096565b935050602084013567ffffffffffffffff8111156110f3576110f2610c2a565b5b6110ff86828701610eb6565b92509250509250925092565b60006060820190506111206000830186610bfb565b61112d6020830185611055565b818103604083015261113f8184610e1f565b9050949350505050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061117482611149565b9050919050565b61118481611169565b811461118f57600080fd5b50565b6000813590506111a18161117b565b92915050565b6000602082840312156111bd576111bc610c25565b5b60006111cb84828501611192565b91505092915050565b60008083601f8401126111ea576111e9610c2f565b5b8235905067ffffffffffffffff81111561120757611206610c34565b5b60208301915083602082028301111561122357611222610c39565b5b9250929050565b6000806020838503121561124157611240610c25565b5b600083013567ffffffffffffffff81111561125f5761125e610c2a565b5b61126b858286016111d4565b92509250509250929050565b61128081611169565b82525050565b600060208201905061129b6000830184611277565b92915050565b6112aa81610bf1565b81146112b557600080fd5b50565b6000813590506112c7816112a1565b92915050565b6000602082840312156112e3576112e2610c25565b5b60006112f1848285016112b8565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600080fd5b600080fd5b600080fd5b60008235600160800383360303811261138357611382611358565b5b80830191505092915050565b600080833560016020038436030381126113ac576113ab611358565b5b80840192508235915067ffffffffffffffff8211156113ce576113cd61135d565b5b6020830192506001820236038313156113ea576113e9611362565b5b509250929050565b600081905092915050565b82818337600083830152505050565b600061141883856113f2565b93506114258385846113fd565b82840190509392505050565b600061143e82848661140c565b91508190509392505050565b600082825260208201905092915050565b7f4d756c746963616c6c333a2076616c7565206d69736d61746368000000000000600082015250565b6000611491601a8361144a565b915061149c8261145b565b602082019050919050565b600060208201905081810360008301526114c081611484565b9050919050565b6000823560016040038336030381126114e3576114e2611358565b5b80830191505092915050565b7f4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000600082015250565b600061152560178361144a565b9150611530826114ef565b602082019050919050565b6000602082019050818103600083015261155481611518565b9050919050565b60008235600160600383360303811261157757611576611358565b5b8083019150509291505056fea264697066735822122020c1bc9aacf8e4a6507193432a895a8e77094f45a1395583f07b24e860ef06cd64736f6c634300080c0033";
const docsPath = "/docs/contract/encodeDeployData";
function encodeDeployData(parameters) {
  const { abi, args, bytecode } = parameters;
  if (!args || args.length === 0)
    return bytecode;
  const description = abi.find((x2) => "type" in x2 && x2.type === "constructor");
  if (!description)
    throw new AbiConstructorNotFoundError({ docsPath });
  if (!("inputs" in description))
    throw new AbiConstructorParamsNotFoundError({ docsPath });
  if (!description.inputs || description.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath });
  const data2 = encodeAbiParameters(description.inputs, args);
  return concatHex([bytecode, data2]);
}
class ExecutionRevertedError extends BaseError$4 {
  constructor({ cause, message } = {}) {
    const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
    super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
      cause,
      name: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(ExecutionRevertedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /execution reverted/
});
class FeeCapTooHighError extends BaseError$4 {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends BaseError$4 {
  constructor({ cause, maxFeePerGas } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause,
      name: "FeeCapTooLowError"
    });
  }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends BaseError$4 {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause, name: "NonceTooHighError" });
  }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too high/
});
class NonceTooLowError extends BaseError$4 {
  constructor({ cause, nonce } = {}) {
    super([
      `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join("\n"), { cause, name: "NonceTooLowError" });
  }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends BaseError$4 {
  constructor({ cause, nonce } = {}) {
    super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause, name: "NonceMaxValueError" });
  }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /nonce has max value/
});
class InsufficientFundsError extends BaseError$4 {
  constructor({ cause } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join("\n"), {
      cause,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ],
      name: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class IntrinsicGasTooHighError extends BaseError$4 {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause,
      name: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends BaseError$4 {
  constructor({ cause, gas } = {}) {
    super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
      cause,
      name: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends BaseError$4 {
  constructor({ cause }) {
    super("The transaction type is not supported for this chain.", {
      cause,
      name: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /transaction type not valid/
});
class TipAboveFeeCapError extends BaseError$4 {
  constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
    ].join("\n"), {
      cause,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends BaseError$4 {
  constructor({ cause }) {
    super(`An error occurred while executing: ${cause?.shortMessage}`, {
      cause,
      name: "UnknownNodeError"
    });
  }
}
function getNodeError(err, args) {
  const message = (err.details || "").toLowerCase();
  const executionRevertedError = err instanceof BaseError$4 ? err.walk((e2) => e2?.code === ExecutionRevertedError.code) : err;
  if (executionRevertedError instanceof BaseError$4)
    return new ExecutionRevertedError({
      cause: err,
      message: executionRevertedError.details
    });
  if (ExecutionRevertedError.nodeMessage.test(message))
    return new ExecutionRevertedError({
      cause: err,
      message: err.details
    });
  if (FeeCapTooHighError.nodeMessage.test(message))
    return new FeeCapTooHighError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (FeeCapTooLowError.nodeMessage.test(message))
    return new FeeCapTooLowError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (NonceTooHighError.nodeMessage.test(message))
    return new NonceTooHighError({ cause: err, nonce: args?.nonce });
  if (NonceTooLowError.nodeMessage.test(message))
    return new NonceTooLowError({ cause: err, nonce: args?.nonce });
  if (NonceMaxValueError.nodeMessage.test(message))
    return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
  if (InsufficientFundsError.nodeMessage.test(message))
    return new InsufficientFundsError({ cause: err });
  if (IntrinsicGasTooHighError.nodeMessage.test(message))
    return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
  if (IntrinsicGasTooLowError.nodeMessage.test(message))
    return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
  if (TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError({ cause: err });
  if (TipAboveFeeCapError.nodeMessage.test(message))
    return new TipAboveFeeCapError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas,
      maxPriorityFeePerGas: args?.maxPriorityFeePerGas
    });
  return new UnknownNodeError({
    cause: err
  });
}
function getCallError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new CallExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
function extract(value_, { format }) {
  if (!format)
    return {};
  const value = {};
  function extract_(formatted2) {
    const keys = Object.keys(formatted2);
    for (const key2 of keys) {
      if (key2 in value_)
        value[key2] = value_[key2];
      if (formatted2[key2] && typeof formatted2[key2] === "object" && !Array.isArray(formatted2[key2]))
        extract_(formatted2[key2]);
    }
  }
  const formatted = format(value_ || {});
  extract_(formatted);
  return value;
}
const rpcTransactionType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function formatTransactionRequest(request) {
  const rpcRequest = {};
  if (typeof request.authorizationList !== "undefined")
    rpcRequest.authorizationList = formatAuthorizationList$1(request.authorizationList);
  if (typeof request.accessList !== "undefined")
    rpcRequest.accessList = request.accessList;
  if (typeof request.blobVersionedHashes !== "undefined")
    rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
  if (typeof request.blobs !== "undefined") {
    if (typeof request.blobs[0] !== "string")
      rpcRequest.blobs = request.blobs.map((x2) => bytesToHex$1(x2));
    else
      rpcRequest.blobs = request.blobs;
  }
  if (typeof request.data !== "undefined")
    rpcRequest.data = request.data;
  if (typeof request.from !== "undefined")
    rpcRequest.from = request.from;
  if (typeof request.gas !== "undefined")
    rpcRequest.gas = numberToHex(request.gas);
  if (typeof request.gasPrice !== "undefined")
    rpcRequest.gasPrice = numberToHex(request.gasPrice);
  if (typeof request.maxFeePerBlobGas !== "undefined")
    rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas);
  if (typeof request.maxFeePerGas !== "undefined")
    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas);
  if (typeof request.nonce !== "undefined")
    rpcRequest.nonce = numberToHex(request.nonce);
  if (typeof request.to !== "undefined")
    rpcRequest.to = request.to;
  if (typeof request.type !== "undefined")
    rpcRequest.type = rpcTransactionType[request.type];
  if (typeof request.value !== "undefined")
    rpcRequest.value = numberToHex(request.value);
  return rpcRequest;
}
function formatAuthorizationList$1(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    r: authorization.r ? numberToHex(BigInt(authorization.r)) : authorization.r,
    s: authorization.s ? numberToHex(BigInt(authorization.s)) : authorization.s,
    chainId: numberToHex(authorization.chainId),
    nonce: numberToHex(authorization.nonce),
    ...typeof authorization.yParity !== "undefined" ? { yParity: numberToHex(authorization.yParity) } : {},
    ...typeof authorization.v !== "undefined" && typeof authorization.yParity === "undefined" ? { v: numberToHex(authorization.v) } : {}
  }));
}
function withResolvers() {
  let resolve = () => void 0;
  let reject = () => void 0;
  const promise = new Promise((resolve_, reject_) => {
    resolve = resolve_;
    reject = reject_;
  });
  return { promise, resolve, reject };
}
const schedulerCache = /* @__PURE__ */ new Map();
function createBatchScheduler({ fn: fn2, id, shouldSplitBatch, wait: wait2 = 0, sort }) {
  const exec = async () => {
    const scheduler2 = getScheduler();
    flush();
    const args = scheduler2.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn2(args).then((data2) => {
      if (sort && Array.isArray(data2))
        data2.sort(sort);
      for (let i4 = 0; i4 < scheduler2.length; i4++) {
        const { resolve } = scheduler2[i4];
        resolve?.([data2[i4], data2]);
      }
    }).catch((err) => {
      for (let i4 = 0; i4 < scheduler2.length; i4++) {
        const { reject } = scheduler2[i4];
        reject?.(err);
      }
    });
  };
  const flush = () => schedulerCache.delete(id);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id) || [];
  const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
  return {
    flush,
    async schedule(args) {
      const { promise, resolve, reject } = withResolvers();
      const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, resolve, reject });
        return promise;
      }
      setScheduler({ args, resolve, reject });
      setTimeout(exec, wait2);
      return promise;
    }
  };
}
function serializeStateMapping(stateMapping) {
  if (!stateMapping || stateMapping.length === 0)
    return void 0;
  return stateMapping.reduce((acc, { slot, value }) => {
    if (slot.length !== 66)
      throw new InvalidBytesLengthError({
        size: slot.length,
        targetSize: 66,
        type: "hex"
      });
    if (value.length !== 66)
      throw new InvalidBytesLengthError({
        size: value.length,
        targetSize: 66,
        type: "hex"
      });
    acc[slot] = value;
    return acc;
  }, {});
}
function serializeAccountStateOverride(parameters) {
  const { balance, nonce, state: state2, stateDiff, code } = parameters;
  const rpcAccountStateOverride = {};
  if (code !== void 0)
    rpcAccountStateOverride.code = code;
  if (balance !== void 0)
    rpcAccountStateOverride.balance = numberToHex(balance);
  if (nonce !== void 0)
    rpcAccountStateOverride.nonce = numberToHex(nonce);
  if (state2 !== void 0)
    rpcAccountStateOverride.state = serializeStateMapping(state2);
  if (stateDiff !== void 0) {
    if (rpcAccountStateOverride.state)
      throw new StateAssignmentConflictError();
    rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);
  }
  return rpcAccountStateOverride;
}
function serializeStateOverride(parameters) {
  if (!parameters)
    return void 0;
  const rpcStateOverride = {};
  for (const { address, ...accountState2 } of parameters) {
    if (!isAddress(address, { strict: false }))
      throw new InvalidAddressError({ address });
    if (rpcStateOverride[address])
      throw new AccountStateConflictError({ address });
    rpcStateOverride[address] = serializeAccountStateOverride(accountState2);
  }
  return rpcStateOverride;
}
const maxUint256 = 2n ** 256n - 1n;
function assertRequest(args) {
  const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
  const account = account_ ? parseAccount(account_) : void 0;
  if (account && !isAddress(account.address))
    throw new InvalidAddressError({ address: account.address });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
    throw new FeeConflictError();
  if (maxFeePerGas && maxFeePerGas > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
async function call(client2, args) {
  const { account: account_ = client2.account, authorizationList, batch = Boolean(client2.batch?.multicall), blockNumber, blockTag = client2.experimental_blockTag ?? "latest", accessList, blobs, blockOverrides, code, data: data_, factory, factoryData, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;
  const account = account_ ? parseAccount(account_) : void 0;
  if (code && (factory || factoryData))
    throw new BaseError$4("Cannot provide both `code` & `factory`/`factoryData` as parameters.");
  if (code && to)
    throw new BaseError$4("Cannot provide both `code` & `to` as parameters.");
  const deploylessCallViaBytecode = code && data_;
  const deploylessCallViaFactory = factory && factoryData && to && data_;
  const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;
  const data2 = (() => {
    if (deploylessCallViaBytecode)
      return toDeploylessCallViaBytecodeData({
        code,
        data: data_
      });
    if (deploylessCallViaFactory)
      return toDeploylessCallViaFactoryData({
        data: data_,
        factory,
        factoryData,
        to
      });
    return data_;
  })();
  try {
    assertRequest(args);
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const rpcBlockOverrides = blockOverrides ? toRpc(blockOverrides) : void 0;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const chainFormat = client2.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      authorizationList,
      blobs,
      data: data2,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to: deploylessCall ? void 0 : to,
      value
    });
    if (batch && shouldPerformMulticall({ request }) && !rpcStateOverride && !rpcBlockOverrides) {
      try {
        return await scheduleMulticall(client2, {
          ...request,
          blockNumber,
          blockTag
        });
      } catch (err) {
        if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))
          throw err;
      }
    }
    const params = (() => {
      const base3 = [
        request,
        block
      ];
      if (rpcStateOverride && rpcBlockOverrides)
        return [...base3, rpcStateOverride, rpcBlockOverrides];
      if (rpcStateOverride)
        return [...base3, rpcStateOverride];
      if (rpcBlockOverrides)
        return [...base3, {}, rpcBlockOverrides];
      return base3;
    })();
    const response = await client2.request({
      method: "eth_call",
      params
    });
    if (response === "0x")
      return { data: void 0 };
    return { data: response };
  } catch (err) {
    const data3 = getRevertErrorData(err);
    const { offchainLookup, offchainLookupSignature } = await __vitePreload(async () => {
      const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await import("./ccip-D6kDQOZ3.js");
      return { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 };
    }, true ? __vite__mapDeps([0,1]) : void 0);
    if (client2.ccipRead !== false && data3?.slice(0, 10) === offchainLookupSignature && to)
      return { data: await offchainLookup(client2, { data: data3, to }) };
    if (deploylessCall && data3?.slice(0, 10) === "0x101bb98d")
      throw new CounterfactualDeploymentFailedError({ factory });
    throw getCallError(err, {
      ...args,
      account,
      chain: client2.chain
    });
  }
}
function shouldPerformMulticall({ request }) {
  const { data: data2, to, ...request_ } = request;
  if (!data2)
    return false;
  if (data2.startsWith(aggregate3Signature))
    return false;
  if (!to)
    return false;
  if (Object.values(request_).filter((x2) => typeof x2 !== "undefined").length > 0)
    return false;
  return true;
}
async function scheduleMulticall(client2, args) {
  const { batchSize = 1024, deployless = false, wait: wait2 = 0 } = typeof client2.batch?.multicall === "object" ? client2.batch.multicall : {};
  const { blockNumber, blockTag = client2.experimental_blockTag ?? "latest", data: data2, to } = args;
  const multicallAddress = (() => {
    if (deployless)
      return null;
    if (args.multicallAddress)
      return args.multicallAddress;
    if (client2.chain) {
      return getChainContractAddress({
        blockNumber,
        chain: client2.chain,
        contract: "multicall3"
      });
    }
    throw new ClientChainNotConfiguredError();
  })();
  const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
  const block = blockNumberHex || blockTag;
  const { schedule } = createBatchScheduler({
    id: `${client2.uid}.${block}`,
    wait: wait2,
    shouldSplitBatch(args2) {
      const size2 = args2.reduce((size3, { data: data3 }) => size3 + (data3.length - 2), 0);
      return size2 > batchSize * 2;
    },
    fn: async (requests) => {
      const calls = requests.map((request) => ({
        allowFailure: true,
        callData: request.data,
        target: request.to
      }));
      const calldata = encodeFunctionData({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3"
      });
      const data3 = await client2.request({
        method: "eth_call",
        params: [
          {
            ...multicallAddress === null ? {
              data: toDeploylessCallViaBytecodeData({
                code: multicall3Bytecode,
                data: calldata
              })
            } : { to: multicallAddress, data: calldata }
          },
          block
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3",
        data: data3 || "0x"
      });
    }
  });
  const [{ returnData, success }] = await schedule({ data: data2, to });
  if (!success)
    throw new RawContractError({ data: returnData });
  if (returnData === "0x")
    return { data: void 0 };
  return { data: returnData };
}
function toDeploylessCallViaBytecodeData(parameters) {
  const { code, data: data2 } = parameters;
  return encodeDeployData({
    abi: parseAbi(["constructor(bytes, bytes)"]),
    bytecode: deploylessCallViaBytecodeBytecode,
    args: [code, data2]
  });
}
function toDeploylessCallViaFactoryData(parameters) {
  const { data: data2, factory, factoryData, to } = parameters;
  return encodeDeployData({
    abi: parseAbi(["constructor(address, bytes, address, bytes)"]),
    bytecode: deploylessCallViaFactoryBytecode,
    args: [to, data2, factory, factoryData]
  });
}
function getRevertErrorData(err) {
  if (!(err instanceof BaseError$4))
    return void 0;
  const error = err.walk();
  return typeof error?.data === "object" ? error.data?.data : error.data;
}
async function readContract$1(client2, parameters) {
  const { abi, address, args, functionName, ...rest } = parameters;
  const calldata = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const { data: data2 } = await getAction$1(client2, call, "call")({
      ...rest,
      data: calldata,
      to: address
    });
    return decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data2 || "0x"
    });
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}
async function getEnsAddress$1(client2, parameters) {
  const { blockNumber, blockTag, coinType, name, gatewayUrls, strict } = parameters;
  const { chain } = client2;
  const universalResolverAddress = (() => {
    if (parameters.universalResolverAddress)
      return parameters.universalResolverAddress;
    if (!chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    return getChainContractAddress({
      blockNumber,
      chain,
      contract: "ensUniversalResolver"
    });
  })();
  const tlds = chain?.ensTlds;
  if (tlds && !tlds.some((tld) => name.endsWith(tld)))
    return null;
  const args = (() => {
    if (coinType != null)
      return [namehash(name), BigInt(coinType)];
    return [namehash(name)];
  })();
  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      args
    });
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolveWithGateways",
      args: [
        toHex(packetToBytes(name)),
        functionData,
        gatewayUrls ?? [localBatchGatewayUrl]
      ],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction$1(client2, readContract$1, "readContract");
    const res = await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const address = decodeFunctionResult({
      abi: addressResolverAbi,
      args,
      functionName: "addr",
      data: res[0]
    });
    if (address === "0x")
      return null;
    if (trim(address) === "0x00")
      return null;
    return address;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err))
      return null;
    throw err;
  }
}
class EnsAvatarInvalidMetadataError extends BaseError$4 {
  constructor({ data: data2 }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data2)}`
      ],
      name: "EnsAvatarInvalidMetadataError"
    });
  }
}
class EnsAvatarInvalidNftUriError extends BaseError$4 {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`, {
      name: "EnsAvatarInvalidNftUriError"
    });
  }
}
class EnsAvatarUriResolutionError extends BaseError$4 {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: "EnsAvatarUriResolutionError" });
  }
}
class EnsAvatarUnsupportedNamespaceError extends BaseError$4 {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`, { name: "EnsAvatarUnsupportedNamespaceError" });
  }
}
const networkRegex = /(?<protocol>https?:\/\/[^/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
const base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
const dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType?.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (!Object.hasOwn(globalThis, "Image"))
      return false;
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        resolve(true);
      };
      img.onerror = () => {
        resolve(false);
      };
      img.src = uri;
    });
  }
}
function getGateway(custom2, defaultGateway) {
  if (!custom2)
    return defaultGateway;
  if (custom2.endsWith("/"))
    return custom2.slice(0, -1);
  return custom2;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS) {
    let replacedUri = uri;
    if (gatewayUrls?.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data2) {
  if (typeof data2 !== "object" || !("image" in data2) && !("image_url" in data2) && !("image_data" in data2)) {
    throw new EnsAvatarInvalidMetadataError({ data: data2 });
  }
  return data2.image || data2.image_url || data2.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError({ uri });
  }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference2, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference2.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: Number.parseInt(chainID, 10),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri(client2, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract$1(client2, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract$1(client2, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}
async function parseAvatarRecord(client2, { gatewayUrls, record }) {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri(client2, { gatewayUrls, record });
  return parseAvatarUri({ uri: record, gatewayUrls });
}
async function parseNftAvatarUri(client2, { gatewayUrls, record }) {
  const nft = parseNftUri(record);
  const nftUri = await getNftTokenUri(client2, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? (
      // if it is encoded, decode it
      atob(resolvedNftUri.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      resolvedNftUri
    );
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}
async function getEnsText(client2, parameters) {
  const { blockNumber, blockTag, key: key2, name, gatewayUrls, strict } = parameters;
  const { chain } = client2;
  const universalResolverAddress = (() => {
    if (parameters.universalResolverAddress)
      return parameters.universalResolverAddress;
    if (!chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    return getChainContractAddress({
      blockNumber,
      chain,
      contract: "ensUniversalResolver"
    });
  })();
  const tlds = chain?.ensTlds;
  if (tlds && !tlds.some((tld) => name.endsWith(tld)))
    return null;
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      args: [
        toHex(packetToBytes(name)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(name), key2]
        }),
        gatewayUrls ?? [localBatchGatewayUrl]
      ],
      functionName: "resolveWithGateways",
      blockNumber,
      blockTag
    };
    const readContractAction = getAction$1(client2, readContract$1, "readContract");
    const res = await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err))
      return null;
    throw err;
  }
}
async function getEnsAvatar$1(client2, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress }) {
  const record = await getAction$1(client2, getEnsText, "getEnsText")({
    blockNumber,
    blockTag,
    key: "avatar",
    name,
    universalResolverAddress,
    gatewayUrls,
    strict
  });
  if (!record)
    return null;
  try {
    return await parseAvatarRecord(client2, {
      record,
      gatewayUrls: assetGatewayUrls
    });
  } catch {
    return null;
  }
}
async function getEnsName$1(client2, parameters) {
  const { address, blockNumber, blockTag, coinType = 60n, gatewayUrls, strict } = parameters;
  const { chain } = client2;
  const universalResolverAddress = (() => {
    if (parameters.universalResolverAddress)
      return parameters.universalResolverAddress;
    if (!chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    return getChainContractAddress({
      blockNumber,
      chain,
      contract: "ensUniversalResolver"
    });
  })();
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      args: [address, coinType, gatewayUrls ?? [localBatchGatewayUrl]],
      functionName: "reverseWithGateways",
      blockNumber,
      blockTag
    };
    const readContractAction = getAction$1(client2, readContract$1, "readContract");
    const [name] = await readContractAction(readContractParameters);
    return name || null;
  } catch (err) {
    if (strict)
      throw err;
    if (isNullUniversalResolverError(err))
      return null;
    throw err;
  }
}
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}
async function recoverPublicKey({ hash: hash2, signature: signature2 }) {
  const hashHex = isHex(hash2) ? hash2 : toHex(hash2);
  const { secp256k1: secp256k12 } = await __vitePreload(async () => {
    const { secp256k1: secp256k13 } = await import("./secp256k1-btqibVvj.js").then((n3) => n3.a);
    return { secp256k1: secp256k13 };
  }, true ? [] : void 0);
  const signature_ = (() => {
    if (typeof signature2 === "object" && "r" in signature2 && "s" in signature2) {
      const { r: r2, s: s2, v: v2, yParity } = signature2;
      const yParityOrV2 = Number(yParity ?? v2);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt(r2), hexToBigInt(s2)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature2) ? signature2 : toHex(signature2);
    if (size$3(signatureHex) !== 65)
      throw new Error("invalid signature length");
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function recoverAddress({ hash: hash2, signature: signature2 }) {
  return publicKeyToAddress(await recoverPublicKey({ hash: hash2, signature: signature2 }));
}
function toRlp(bytes, to = "hex") {
  const encodable = getEncodable(bytes);
  const cursor2 = createCursor(new Uint8Array(encodable.length));
  encodable.encode(cursor2);
  if (to === "hex")
    return bytesToHex$1(cursor2.bytes);
  return cursor2.bytes;
}
function getEncodable(bytes) {
  if (Array.isArray(bytes))
    return getEncodableList(bytes.map((x2) => getEncodable(x2)));
  return getEncodableBytes(bytes);
}
function getEncodableList(list) {
  const bodyLength = list.reduce((acc, x2) => acc + x2.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length2 = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length: length2,
    encode(cursor2) {
      if (bodyLength <= 55) {
        cursor2.pushByte(192 + bodyLength);
      } else {
        cursor2.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor2.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor2.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor2.pushUint24(bodyLength);
        else
          cursor2.pushUint32(bodyLength);
      }
      for (const { encode: encode2 } of list) {
        encode2(cursor2);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes = typeof bytesOrHex === "string" ? hexToBytes$1(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes.length);
  const length2 = (() => {
    if (bytes.length === 1 && bytes[0] < 128)
      return 1;
    if (bytes.length <= 55)
      return 1 + bytes.length;
    return 1 + sizeOfBytesLength + bytes.length;
  })();
  return {
    length: length2,
    encode(cursor2) {
      if (bytes.length === 1 && bytes[0] < 128) {
        cursor2.pushBytes(bytes);
      } else if (bytes.length <= 55) {
        cursor2.pushByte(128 + bytes.length);
        cursor2.pushBytes(bytes);
      } else {
        cursor2.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor2.pushUint8(bytes.length);
        else if (sizeOfBytesLength === 2)
          cursor2.pushUint16(bytes.length);
        else if (sizeOfBytesLength === 3)
          cursor2.pushUint24(bytes.length);
        else
          cursor2.pushUint32(bytes.length);
        cursor2.pushBytes(bytes);
      }
    }
  };
}
function getSizeOfLength(length2) {
  if (length2 < 2 ** 8)
    return 1;
  if (length2 < 2 ** 16)
    return 2;
  if (length2 < 2 ** 24)
    return 3;
  if (length2 < 2 ** 32)
    return 4;
  throw new BaseError$4("Length is too large.");
}
function hashAuthorization(parameters) {
  const { chainId, nonce, to } = parameters;
  const address = parameters.contractAddress ?? parameters.address;
  const hash2 = keccak256(concatHex([
    "0x05",
    toRlp([
      chainId ? numberToHex(chainId) : "0x",
      address,
      nonce ? numberToHex(nonce) : "0x"
    ])
  ]));
  if (to === "bytes")
    return hexToBytes$1(hash2);
  return hash2;
}
async function recoverAuthorizationAddress(parameters) {
  const { authorization, signature: signature2 } = parameters;
  return recoverAddress({
    hash: hashAuthorization(authorization),
    signature: signature2 ?? authorization
  });
}
class EstimateGasExecutionError extends BaseError$4 {
  constructor(cause, { account, docsPath: docsPath2, chain, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data: data2,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath2,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause;
  }
}
function getEstimateGasError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
class BaseFeeScalarError extends BaseError$4 {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}
class Eip1559FeesNotSupportedError extends BaseError$4 {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}
class MaxFeePerGasTooLowError extends BaseError$4 {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}
class BlockNotFoundError extends BaseError$4 {
  constructor({ blockHash, blockNumber }) {
    let identifier2 = "Block";
    if (blockHash)
      identifier2 = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier2 = `Block at number "${blockNumber}"`;
    super(`${identifier2} could not be found.`, { name: "BlockNotFoundError" });
  }
}
const transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
async function getBlock(client2, { blockHash, blockNumber, blockTag = client2.experimental_blockTag ?? "latest", includeTransactions: includeTransactions_ } = {}) {
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let block = null;
  if (blockHash) {
    block = await client2.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    }, { dedupe: true });
  } else {
    block = await client2.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format = client2.chain?.formatters?.block?.format || formatBlock;
  return format(block);
}
async function getGasPrice(client2) {
  const gasPrice = await client2.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}
async function estimateMaxPriorityFeePerGas(client2, args) {
  return internal_estimateMaxPriorityFeePerGas(client2, args);
}
async function internal_estimateMaxPriorityFeePerGas(client2, args) {
  const { block: block_, chain = client2.chain, request } = args || {};
  try {
    const maxPriorityFeePerGas = chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee;
    if (typeof maxPriorityFeePerGas === "function") {
      const block = block_ || await getAction$1(client2, getBlock, "getBlock")({});
      const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
        block,
        client: client2,
        request
      });
      if (maxPriorityFeePerGas_ === null)
        throw new Error();
      return maxPriorityFeePerGas_;
    }
    if (typeof maxPriorityFeePerGas !== "undefined")
      return maxPriorityFeePerGas;
    const maxPriorityFeePerGasHex = await client2.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction$1(client2, getBlock, "getBlock")({}),
      getAction$1(client2, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}
async function estimateFeesPerGas(client2, args) {
  return internal_estimateFeesPerGas(client2, args);
}
async function internal_estimateFeesPerGas(client2, args) {
  const { block: block_, chain = client2.chain, request, type = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    if (typeof chain?.fees?.baseFeeMultiplier === "function")
      return chain.fees.baseFeeMultiplier({
        block: block_,
        client: client2,
        request
      });
    return chain?.fees?.baseFeeMultiplier ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError();
  const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base3) => base3 * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block = block_ ? block_ : await getAction$1(client2, getBlock, "getBlock")({});
  if (typeof chain?.fees?.estimateFeesPerGas === "function") {
    const fees = await chain.fees.estimateFeesPerGas({
      block: block_,
      client: client2,
      multiply,
      request,
      type
    });
    if (fees !== null)
      return fees;
  }
  if (type === "eip1559") {
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === "bigint" ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client2, {
      block,
      chain,
      request
    });
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = request?.gasPrice ?? multiply(await getAction$1(client2, getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}
async function getTransactionCount(client2, { address, blockTag = "latest", blockNumber }) {
  const count = await client2.request({
    method: "eth_getTransactionCount",
    params: [
      address,
      typeof blockNumber === "bigint" ? numberToHex(blockNumber) : blockTag
    ]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return hexToNumber(count);
}
function blobsToCommitments(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x2) => hexToBytes$1(x2)) : parameters.blobs;
  const commitments = [];
  for (const blob of blobs)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return to === "bytes" ? commitments : commitments.map((x2) => bytesToHex$1(x2));
}
function blobsToProofs(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x2) => hexToBytes$1(x2)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x2) => hexToBytes$1(x2)) : parameters.commitments;
  const proofs = [];
  for (let i4 = 0; i4 < blobs.length; i4++) {
    const blob = blobs[i4];
    const commitment = commitments[i4];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return to === "bytes" ? proofs : proofs.map((x2) => bytesToHex$1(x2));
}
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l2 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE2);
  view.setUint32(byteOffset + l2, wl, isLE2);
}
function Chi(a2, b2, c2) {
  return a2 & b2 ^ ~a2 & c2;
}
function Maj(a2, b2, c2) {
  return a2 & b2 ^ a2 & c2 ^ b2 & c2;
}
class HashMD extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data2) {
    aexists(this);
    data2 = toBytes(data2);
    abytes(data2);
    const { view, buffer: buffer2, blockLen } = this;
    const len = data2.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data2);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data2.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data2.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i4 = pos; i4 < blockLen; i4++)
      buffer2[i4] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state2 = this.get();
    if (outLen > state2.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i4 = 0; i4 < outLen; i4++)
      oview.setUint32(4 * i4, state2[i4], isLE2);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length: length2, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length2;
    to.pos = pos;
    if (length2 % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
}
const SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA384_IV = /* @__PURE__ */ Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
const SHA512_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: A2, B: B3, C: C2, D, E: E2, F, G, H: H2 } = this;
    return [A2, B3, C2, D, E2, F, G, H2];
  }
  // prettier-ignore
  set(A2, B3, C2, D, E2, F, G, H2) {
    this.A = A2 | 0;
    this.B = B3 | 0;
    this.C = C2 | 0;
    this.D = D | 0;
    this.E = E2 | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H2 | 0;
  }
  process(view, offset2) {
    for (let i4 = 0; i4 < 16; i4++, offset2 += 4)
      SHA256_W[i4] = view.getUint32(offset2, false);
    for (let i4 = 16; i4 < 64; i4++) {
      const W15 = SHA256_W[i4 - 15];
      const W2 = SHA256_W[i4 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i4] = s1 + SHA256_W[i4 - 7] + s0 + SHA256_W[i4 - 16] | 0;
    }
    let { A: A2, B: B3, C: C2, D, E: E2, F, G, H: H2 } = this;
    for (let i4 = 0; i4 < 64; i4++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T12 = H2 + sigma1 + Chi(E2, F, G) + SHA256_K[i4] + SHA256_W[i4] | 0;
      const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
      const T2 = sigma0 + Maj(A2, B3, C2) | 0;
      H2 = G;
      G = F;
      F = E2;
      E2 = D + T12 | 0;
      D = C2;
      C2 = B3;
      B3 = A2;
      A2 = T12 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B3 = B3 + this.B | 0;
    C2 = C2 + this.C | 0;
    D = D + this.D | 0;
    E2 = E2 + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B3, C2, D, E2, F, G, H2);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
}
const K512 = /* @__PURE__ */ (() => split$1([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n3) => BigInt(n3))))();
const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset2) {
    for (let i4 = 0; i4 < 16; i4++, offset2 += 4) {
      SHA512_W_H[i4] = view.getUint32(offset2);
      SHA512_W_L[i4] = view.getUint32(offset2 += 4);
    }
    for (let i4 = 16; i4 < 80; i4++) {
      const W15h = SHA512_W_H[i4 - 15] | 0;
      const W15l = SHA512_W_L[i4 - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i4 - 2] | 0;
      const W2l = SHA512_W_L[i4 - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i4 - 7], SHA512_W_L[i4 - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i4 - 7], SHA512_W_H[i4 - 16]);
      SHA512_W_H[i4] = SUMh | 0;
      SHA512_W_L[i4] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i4 = 0; i4 < 80; i4++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i4], SHA512_W_L[i4]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i4], SHA512_W_H[i4]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class SHA384 extends SHA512 {
  constructor() {
    super(48);
    this.Ah = SHA384_IV[0] | 0;
    this.Al = SHA384_IV[1] | 0;
    this.Bh = SHA384_IV[2] | 0;
    this.Bl = SHA384_IV[3] | 0;
    this.Ch = SHA384_IV[4] | 0;
    this.Cl = SHA384_IV[5] | 0;
    this.Dh = SHA384_IV[6] | 0;
    this.Dl = SHA384_IV[7] | 0;
    this.Eh = SHA384_IV[8] | 0;
    this.El = SHA384_IV[9] | 0;
    this.Fh = SHA384_IV[10] | 0;
    this.Fl = SHA384_IV[11] | 0;
    this.Gh = SHA384_IV[12] | 0;
    this.Gl = SHA384_IV[13] | 0;
    this.Hh = SHA384_IV[14] | 0;
    this.Hl = SHA384_IV[15] | 0;
  }
}
const sha256$3 = /* @__PURE__ */ createHasher(() => new SHA256());
const sha512$1 = /* @__PURE__ */ createHasher(() => new SHA512());
const sha384 = /* @__PURE__ */ createHasher(() => new SHA384());
const sha256$2 = sha256$3;
function sha256$1(value, to_) {
  const bytes = sha256$2(isHex(value, { strict: false }) ? toBytes$1(value) : value);
  return bytes;
}
function commitmentToVersionedHash(parameters) {
  const { commitment, version: version2 = 1 } = parameters;
  const to = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
  const versionedHash = sha256$1(commitment);
  versionedHash.set([version2], 0);
  return to === "bytes" ? versionedHash : bytesToHex$1(versionedHash);
}
function commitmentsToVersionedHashes(parameters) {
  const { commitments, version: version2 } = parameters;
  const to = parameters.to;
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash({
      commitment,
      to,
      version: version2
    }));
  }
  return hashes;
}
const blobsPerTransaction = 6;
const bytesPerFieldElement = 32;
const fieldElementsPerBlob = 4096;
const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
const maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;
class BlobSizeTooLargeError extends BaseError$4 {
  constructor({ maxSize, size: size2 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size2} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class EmptyBlobError extends BaseError$4 {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
function toBlobs(parameters) {
  const data2 = typeof parameters.data === "string" ? hexToBytes$1(parameters.data) : parameters.data;
  const size_ = size$3(data2);
  if (!size_)
    throw new EmptyBlobError();
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active = true;
  let position2 = 0;
  while (active) {
    const blob = createCursor(new Uint8Array(bytesPerBlob));
    let size2 = 0;
    while (size2 < fieldElementsPerBlob) {
      const bytes = data2.slice(position2, position2 + (bytesPerFieldElement - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes);
      if (bytes.length < 31) {
        blob.pushByte(128);
        active = false;
        break;
      }
      size2++;
      position2 += 31;
    }
    blobs.push(blob);
  }
  return blobs.map((x2) => bytesToHex$1(x2.bytes));
}
function toBlobSidecars(parameters) {
  const { data: data2, kzg, to } = parameters;
  const blobs = parameters.blobs ?? toBlobs({ data: data2 });
  const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to });
  const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to });
  const sidecars = [];
  for (let i4 = 0; i4 < blobs.length; i4++)
    sidecars.push({
      blob: blobs[i4],
      commitment: commitments[i4],
      proof: proofs[i4]
    });
  return sidecars;
}
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (typeof transaction.authorizationList !== "undefined")
    return "eip7702";
  if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined")
    return "eip4844";
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
    return "eip1559";
  }
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}
async function getChainId$1(client2) {
  const chainIdHex = await client2.request({
    method: "eth_chainId"
  }, { dedupe: true });
  return hexToNumber(chainIdHex);
}
const defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
const eip1559NetworkCache = /* @__PURE__ */ new Map();
async function prepareTransactionRequest$1(client2, args) {
  const { account: account_ = client2.account, blobs, chain, gas, kzg, nonce, nonceManager, parameters = defaultParameters, type } = args;
  const account = account_ ? parseAccount(account_) : account_;
  const request = { ...args, ...account ? { from: account?.address } : {} };
  let block;
  async function getBlock$1() {
    if (block)
      return block;
    block = await getAction$1(client2, getBlock, "getBlock")({ blockTag: "latest" });
    return block;
  }
  let chainId;
  async function getChainId2() {
    if (chainId)
      return chainId;
    if (chain)
      return chain.id;
    if (typeof args.chainId !== "undefined")
      return args.chainId;
    const chainId_ = await getAction$1(client2, getChainId$1, "getChainId")({});
    chainId = chainId_;
    return chainId;
  }
  if (parameters.includes("nonce") && typeof nonce === "undefined" && account) {
    if (nonceManager) {
      const chainId2 = await getChainId2();
      request.nonce = await nonceManager.consume({
        address: account.address,
        chainId: chainId2,
        client: client2
      });
    } else {
      request.nonce = await getAction$1(client2, getTransactionCount, "getTransactionCount")({
        address: account.address,
        blockTag: "pending"
      });
    }
  }
  if ((parameters.includes("blobVersionedHashes") || parameters.includes("sidecars")) && blobs && kzg) {
    const commitments = blobsToCommitments({ blobs, kzg });
    if (parameters.includes("blobVersionedHashes")) {
      const versionedHashes = commitmentsToVersionedHashes({
        commitments,
        to: "hex"
      });
      request.blobVersionedHashes = versionedHashes;
    }
    if (parameters.includes("sidecars")) {
      const proofs = blobsToProofs({ blobs, commitments, kzg });
      const sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs,
        to: "hex"
      });
      request.sidecars = sidecars;
    }
  }
  if (parameters.includes("chainId"))
    request.chainId = await getChainId2();
  if ((parameters.includes("fees") || parameters.includes("type")) && typeof type === "undefined") {
    try {
      request.type = getTransactionType(request);
    } catch {
      let isEip1559Network = eip1559NetworkCache.get(client2.uid);
      if (typeof isEip1559Network === "undefined") {
        const block2 = await getBlock$1();
        isEip1559Network = typeof block2?.baseFeePerGas === "bigint";
        eip1559NetworkCache.set(client2.uid, isEip1559Network);
      }
      request.type = isEip1559Network ? "eip1559" : "legacy";
    }
  }
  if (parameters.includes("fees")) {
    if (request.type !== "legacy" && request.type !== "eip2930") {
      if (typeof request.maxFeePerGas === "undefined" || typeof request.maxPriorityFeePerGas === "undefined") {
        const block2 = await getBlock$1();
        const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client2, {
          block: block2,
          chain,
          request
        });
        if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      }
    } else {
      if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
        throw new Eip1559FeesNotSupportedError();
      if (typeof args.gasPrice === "undefined") {
        const block2 = await getBlock$1();
        const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client2, {
          block: block2,
          chain,
          request,
          type: "legacy"
        });
        request.gasPrice = gasPrice_;
      }
    }
  }
  if (parameters.includes("gas") && typeof gas === "undefined")
    request.gas = await getAction$1(client2, estimateGas$1, "estimateGas")({
      ...request,
      account: account ? { address: account.address, type: "json-rpc" } : account
    });
  assertRequest(request);
  delete request.parameters;
  return request;
}
async function getBalance$1(client2, { address, blockNumber, blockTag = client2.experimental_blockTag ?? "latest" }) {
  const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
  const balance = await client2.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}
async function estimateGas$1(client2, args) {
  const { account: account_ = client2.account } = args;
  const account = account_ ? parseAccount(account_) : void 0;
  try {
    let estimateGas_rpc = function(parameters) {
      const { block: block2, request: request2, rpcStateOverride: rpcStateOverride2 } = parameters;
      return client2.request({
        method: "eth_estimateGas",
        params: rpcStateOverride2 ? [
          request2,
          block2 ?? client2.experimental_blockTag ?? "latest",
          rpcStateOverride2
        ] : block2 ? [request2, block2] : [request2]
      });
    };
    const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data: data2, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = await prepareTransactionRequest$1(client2, {
      ...args,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        account?.type === "local" ? void 0 : ["blobVersionedHashes"]
      )
    });
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const to = await (async () => {
      if (rest.to)
        return rest.to;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError$4("`to` is required. Could not infer from `authorizationList`");
        });
      return void 0;
    })();
    assertRequest(args);
    const chainFormat = client2.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      authorizationList,
      blobs,
      blobVersionedHashes,
      data: data2,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    let estimate = BigInt(await estimateGas_rpc({ block, request, rpcStateOverride }));
    if (authorizationList) {
      const value2 = await getBalance$1(client2, { address: request.from });
      const estimates = await Promise.all(authorizationList.map(async (authorization) => {
        const { address } = authorization;
        const estimate2 = await estimateGas_rpc({
          block,
          request: {
            authorizationList: void 0,
            data: data2,
            from: account?.address,
            to: address,
            value: numberToHex(value2)
          },
          rpcStateOverride
        }).catch(() => 100000n);
        return 2n * BigInt(estimate2);
      }));
      estimate += estimates.reduce((acc, curr) => acc + curr, 0n);
    }
    return estimate;
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      account,
      chain: client2.chain
    });
  }
}
const promiseCache$1 = /* @__PURE__ */ new Map();
const responseCache = /* @__PURE__ */ new Map();
function getCache(cacheKey2) {
  const buildCache = (cacheKey3, cache) => ({
    clear: () => cache.delete(cacheKey3),
    get: () => cache.get(cacheKey3),
    set: (data2) => cache.set(cacheKey3, data2)
  });
  const promise = buildCache(cacheKey2, promiseCache$1);
  const response = buildCache(cacheKey2, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn2, { cacheKey: cacheKey2, cacheTime = Number.POSITIVE_INFINITY }) {
  const cache = getCache(cacheKey2);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = Date.now() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn2();
    cache.promise.set(promise);
  }
  try {
    const data2 = await promise;
    cache.response.set({ created: /* @__PURE__ */ new Date(), data: data2 });
    return data2;
  } finally {
    cache.promise.clear();
  }
}
const cacheKey = (id) => `blockNumber.${id}`;
async function getBlockNumber(client2, { cacheTime = client2.cacheTime } = {}) {
  const blockNumberHex = await withCache(() => client2.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client2.uid), cacheTime });
  return BigInt(blockNumberHex);
}
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}
const promiseCache = /* @__PURE__ */ new LruMap(8192);
function withDedupe(fn2, { enabled = true, id }) {
  if (!enabled || !id)
    return fn2();
  if (promiseCache.get(id))
    return promiseCache.get(id);
  const promise = fn2().finally(() => promiseCache.delete(id));
  promiseCache.set(id, promise);
  return promise;
}
async function wait(time2) {
  return new Promise((res) => setTimeout(res, time2));
}
function withRetry(fn2, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay2 = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay2)
          await wait(delay2);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data2 = await fn2();
        resolve(data2);
      } catch (err) {
        if (count < retryCount && await shouldRetry2({ count, error: err }))
          return retry({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}
function buildRequest(request, options = {}) {
  return async (args, overrideOptions = {}) => {
    const { dedupe = false, methods, retryDelay = 150, retryCount = 3, uid: uid2 } = {
      ...options,
      ...overrideOptions
    };
    const { method } = args;
    if (methods?.exclude?.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    if (methods?.include && !methods.include.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    const requestId = dedupe ? stringToHex(`${uid2}.${stringify$1(args)}`) : void 0;
    return withDedupe(() => withRetry(async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err = err_;
        switch (err.code) {
          // -32700
          case ParseRpcError.code:
            throw new ParseRpcError(err);
          // -32600
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(err);
          // -32601
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(err, { method: args.method });
          // -32602
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(err);
          // -32603
          case InternalRpcError.code:
            throw new InternalRpcError(err);
          // -32000
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(err);
          // -32001
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(err);
          // -32002
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(err);
          // -32003
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(err);
          // -32004
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(err, {
              method: args.method
            });
          // -32005
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(err);
          // -32006
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(err);
          // 4001
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(err);
          // 4100
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(err);
          // 4200
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(err);
          // 4900
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(err);
          // 4901
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(err);
          // 4902
          case SwitchChainError.code:
            throw new SwitchChainError(err);
          // 5700
          case UnsupportedNonOptionalCapabilityError.code:
            throw new UnsupportedNonOptionalCapabilityError(err);
          // 5710
          case UnsupportedChainIdError.code:
            throw new UnsupportedChainIdError(err);
          // 5720
          case DuplicateIdError.code:
            throw new DuplicateIdError(err);
          // 5730
          case UnknownBundleIdError.code:
            throw new UnknownBundleIdError(err);
          // 5740
          case BundleTooLargeError.code:
            throw new BundleTooLargeError(err);
          // 5750
          case AtomicReadyWalletRejectedUpgradeError.code:
            throw new AtomicReadyWalletRejectedUpgradeError(err);
          // 5760
          case AtomicityNotSupportedError.code:
            throw new AtomicityNotSupportedError(err);
          // CAIP-25: User Rejected Error
          // https://docs.walletconnect.com/2.0/specs/clients/sign/error-codes#rejected-caip-25
          case 5e3:
            throw new UserRejectedRequestError(err);
          default:
            if (err_ instanceof BaseError$4)
              throw err_;
            throw new UnknownRpcError(err);
        }
      }
    }, {
      delay: ({ count, error }) => {
        if (error && error instanceof HttpRequestError) {
          const retryAfter = error?.headers?.get("Retry-After");
          if (retryAfter?.match(/\d/))
            return Number.parseInt(retryAfter, 10) * 1e3;
        }
        return ~~(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => shouldRetry(error)
    }), { enabled: dedupe, id: requestId });
  };
}
function shouldRetry(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === -1)
      return true;
    if (error.code === LimitExceededRpcError.code)
      return true;
    if (error.code === InternalRpcError.code)
      return true;
    return false;
  }
  if (error instanceof HttpRequestError && error.status) {
    if (error.status === 403)
      return true;
    if (error.status === 408)
      return true;
    if (error.status === 413)
      return true;
    if (error.status === 429)
      return true;
    if (error.status === 500)
      return true;
    if (error.status === 502)
      return true;
    if (error.status === 503)
      return true;
    if (error.status === 504)
      return true;
    return false;
  }
  return true;
}
function assertCurrentChain({ chain, currentChainId }) {
  if (!chain)
    throw new ChainNotFoundError();
  if (currentChainId !== chain.id)
    throw new ChainMismatchError({ chain, currentChainId });
}
function defineChain(chain) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain
  };
}
function getTransactionError(err, { docsPath: docsPath2, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new TransactionExecutionError(cause, {
    docsPath: docsPath2,
    ...args
  });
}
const receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
function withTimeout(fn2, { errorInstance = new Error("timed out"), timeout, signal }) {
  return new Promise((resolve, reject) => {
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn2({ signal: controller?.signal || null }));
      } catch (err) {
        if (err?.name === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const idCache = /* @__PURE__ */ createIdStore();
function getHttpRpcClient(url, options = {}) {
  return {
    async request(params) {
      const { body: body2, fetchFn = options.fetchFn ?? fetch, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;
      const fetchOptions = {
        ...options.fetchOptions ?? {},
        ...params.fetchOptions ?? {}
      };
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await withTimeout(async ({ signal }) => {
          const init2 = {
            ...fetchOptions,
            body: Array.isArray(body2) ? stringify$1(body2.map((body3) => ({
              jsonrpc: "2.0",
              id: body3.id ?? idCache.take(),
              ...body3
            }))) : stringify$1({
              jsonrpc: "2.0",
              id: body2.id ?? idCache.take(),
              ...body2
            }),
            headers: {
              "Content-Type": "application/json",
              ...headers
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : null)
          };
          const request = new Request(url, init2);
          const args = await onRequest?.(request, init2) ?? { ...init2, url };
          const response2 = await fetchFn(args.url ?? url, args);
          return response2;
        }, {
          errorInstance: new TimeoutError({ body: body2, url }),
          timeout,
          signal: true
        });
        if (onResponse)
          await onResponse(response);
        let data2;
        if (response.headers.get("Content-Type")?.startsWith("application/json"))
          data2 = await response.json();
        else {
          data2 = await response.text();
          try {
            data2 = JSON.parse(data2 || "{}");
          } catch (err) {
            if (response.ok)
              throw err;
            data2 = { error: data2 };
          }
        }
        if (!response.ok) {
          throw new HttpRequestError({
            body: body2,
            details: stringify$1(data2.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data2;
      } catch (err) {
        if (err instanceof HttpRequestError)
          throw err;
        if (err instanceof TimeoutError)
          throw err;
        throw new HttpRequestError({
          body: body2,
          cause: err,
          url
        });
      }
    }
  };
}
class InvalidDecimalNumberError extends BaseError$4 {
  constructor({ value }) {
    super(`Number \`${value}\` is not a valid decimal number.`, {
      name: "InvalidDecimalNumberError"
    });
  }
}
function parseUnits(value, decimals) {
  if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(value))
    throw new InvalidDecimalNumberError({ value });
  let [integer, fraction = "0"] = value.split(".");
  const negative = integer.startsWith("-");
  if (negative)
    integer = integer.slice(1);
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    if (Math.round(Number(`.${fraction}`)) === 1)
      integer = `${BigInt(integer) + 1n}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [left2, unit, right2] = [
      fraction.slice(0, decimals - 1),
      fraction.slice(decimals - 1, decimals),
      fraction.slice(decimals)
    ];
    const rounded = Math.round(Number(`${unit}.${right2}`));
    if (rounded > 9)
      fraction = `${BigInt(left2) + BigInt(1)}0`.padStart(left2.length + 1, "0");
    else
      fraction = `${left2}${rounded}`;
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer = `${BigInt(integer) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
}
function parseEther(ether, unit = "wei") {
  return parseUnits(ether, etherUnits[unit]);
}
async function getTransaction(client2, { blockHash, blockNumber, blockTag: blockTag_, hash: hash2, index: index2 }) {
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let transaction = null;
  if (hash2) {
    transaction = await client2.request({
      method: "eth_getTransactionByHash",
      params: [hash2]
    }, { dedupe: true });
  } else if (blockHash) {
    transaction = await client2.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index2)]
    }, { dedupe: true });
  } else {
    transaction = await client2.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index2)]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!transaction)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash2,
      index: index2
    });
  const format = client2.chain?.formatters?.transaction?.format || formatTransaction;
  return format(transaction);
}
async function getTransactionReceipt(client2, { hash: hash2 }) {
  const receipt = await client2.request({
    method: "eth_getTransactionReceipt",
    params: [hash2]
  }, { dedupe: true });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash: hash2 });
  const format = client2.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt;
  return format(receipt);
}
async function multicall$1(client2, parameters) {
  const { account, authorizationList, allowFailure = true, blockNumber, blockOverrides, blockTag, stateOverride } = parameters;
  const contracts = parameters.contracts;
  const { batchSize = parameters.batchSize ?? 1024, deployless = parameters.deployless ?? false } = typeof client2.batch?.multicall === "object" ? client2.batch.multicall : {};
  const multicallAddress = (() => {
    if (parameters.multicallAddress)
      return parameters.multicallAddress;
    if (deployless)
      return null;
    if (client2.chain) {
      return getChainContractAddress({
        blockNumber,
        chain: client2.chain,
        contract: "multicall3"
      });
    }
    throw new Error("client chain not configured. multicallAddress is required.");
  })();
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i4 = 0; i4 < contracts.length; i4++) {
    const { abi, address, args, functionName } = contracts[i4];
    try {
      const callData = encodeFunctionData({ abi, args, functionName });
      currentChunkSize += (callData.length - 2) / 2;
      if (
        // Check if batching is enabled.
        batchSize > 0 && // Check if the current size of the batch exceeds the size limit.
        currentChunkSize > batchSize && // Check if the current chunk is not already empty.
        chunkedCalls[currentChunk].length > 0
      ) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address
        }
      ];
    } catch (err) {
      const error = getContractError(err, {
        abi,
        address,
        args,
        docsPath: "/docs/contract/multicall",
        functionName,
        sender: account
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction$1(client2, readContract$1, "readContract")({
    ...multicallAddress === null ? { code: multicall3Bytecode } : { address: multicallAddress },
    abi: multicall3Abi,
    account,
    args: [calls],
    authorizationList,
    blockNumber,
    blockOverrides,
    blockTag,
    functionName: "aggregate3",
    stateOverride
  })));
  const results = [];
  for (let i4 = 0; i4 < aggregate3Results.length; i4++) {
    const result = aggregate3Results[i4];
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let j2 = 0; j2 < chunkedCalls[i4].length; j2++) {
        results.push({
          status: "failure",
          error: result.reason,
          result: void 0
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (let j2 = 0; j2 < aggregate3Result.length; j2++) {
      const { returnData, success } = aggregate3Result[j2];
      const { callData } = chunkedCalls[i4][j2];
      const { abi, address, functionName, args } = contracts[results.length];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError();
        if (!success)
          throw new RawContractError({ data: returnData });
        const result2 = decodeFunctionResult({
          abi,
          args,
          data: returnData,
          functionName
        });
        results.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (err) {
        const error = getContractError(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        results.push({ error, result: void 0, status: "failure" });
      }
    }
  }
  if (results.length !== contracts.length)
    throw new BaseError$4("multicall results mismatch");
  return results;
}
const listenersCache = /* @__PURE__ */ new Map();
const cleanupCache = /* @__PURE__ */ new Map();
let callbackCount = 0;
function observe(observerId, callbacks, fn2) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
  };
  const unwatch = () => {
    const listeners2 = getListeners();
    if (!listeners2.some((cb) => cb.id === callbackId))
      return;
    const cleanup2 = cleanupCache.get(observerId);
    if (listeners2.length === 1 && cleanup2) {
      const p2 = cleanup2();
      if (p2 instanceof Promise)
        p2.catch(() => {
        });
    }
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit = {};
  for (const key2 in callbacks) {
    emit[key2] = ((...args) => {
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      for (const listener of listeners2)
        listener.fns[key2]?.(...args);
    });
  }
  const cleanup = fn2(emit);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}
function poll(fn2, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch2 = async () => {
    let data2;
    if (emitOnBegin)
      data2 = await fn2({ unpoll: unwatch });
    const initialWait = await initialWaitTime?.(data2) ?? interval;
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn2({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch2();
  return unwatch;
}
function watchBlockNumber(client2, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client2.pollingInterval }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (client2.transport.type === "webSocket" || client2.transport.type === "ipc")
      return false;
    if (client2.transport.type === "fallback" && (client2.transport.transports[0].config.type === "webSocket" || client2.transport.transports[0].config.type === "ipc"))
      return false;
    return true;
  })();
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify$1([
      "watchBlockNumber",
      client2.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {
      try {
        const blockNumber = await getAction$1(client2, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (prevBlockNumber !== void 0) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i4 = prevBlockNumber + 1n; i4 < blockNumber; i4++) {
              emit.onBlockNumber(i4, prevBlockNumber);
              prevBlockNumber = i4;
            }
          }
        }
        if (prevBlockNumber === void 0 || blockNumber > prevBlockNumber) {
          emit.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err) {
        emit.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    const observerId = stringify$1([
      "watchBlockNumber",
      client2.uid,
      emitOnBegin,
      emitMissed
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const transport = (() => {
            if (client2.transport.type === "fallback") {
              const transport2 = client2.transport.transports.find((transport3) => transport3.config.type === "webSocket" || transport3.config.type === "ipc");
              if (!transport2)
                return client2.transport;
              return transport2.value;
            }
            return client2.transport;
          })();
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["newHeads"],
            onData(data2) {
              if (!active)
                return;
              const blockNumber = hexToBigInt(data2.result?.number);
              emit.onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            },
            onError(error) {
              emit.onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}
async function waitForTransactionReceipt$1(client2, parameters) {
  const {
    checkReplacement = true,
    confirmations = 1,
    hash: hash2,
    onReplaced,
    retryCount = 6,
    retryDelay = ({ count }) => ~~(1 << count) * 200,
    // exponential backoff
    timeout = 18e4
  } = parameters;
  const observerId = stringify$1(["waitForTransactionReceipt", client2.uid, hash2]);
  const pollingInterval = (() => {
    if (parameters.pollingInterval)
      return parameters.pollingInterval;
    if (client2.chain?.experimental_preconfirmationTime)
      return client2.chain.experimental_preconfirmationTime;
    return client2.pollingInterval;
  })();
  let transaction;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  let _unobserve;
  let _unwatch;
  const { promise, resolve, reject } = withResolvers();
  const timer = timeout ? setTimeout(() => {
    _unwatch?.();
    _unobserve?.();
    reject(new WaitForTransactionReceiptTimeoutError({ hash: hash2 }));
  }, timeout) : void 0;
  _unobserve = observe(observerId, { onReplaced, resolve, reject }, async (emit) => {
    receipt = await getAction$1(client2, getTransactionReceipt, "getTransactionReceipt")({ hash: hash2 }).catch(() => void 0);
    if (receipt && confirmations <= 1) {
      clearTimeout(timer);
      emit.resolve(receipt);
      _unobserve?.();
      return;
    }
    _unwatch = getAction$1(client2, watchBlockNumber, "watchBlockNumber")({
      emitMissed: true,
      emitOnBegin: true,
      poll: true,
      pollingInterval,
      async onBlockNumber(blockNumber_) {
        const done = (fn2) => {
          clearTimeout(timer);
          _unwatch?.();
          fn2();
          _unobserve?.();
        };
        let blockNumber = blockNumber_;
        if (retrying)
          return;
        try {
          if (receipt) {
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit.resolve(receipt));
            return;
          }
          if (checkReplacement && !transaction) {
            retrying = true;
            await withRetry(async () => {
              transaction = await getAction$1(client2, getTransaction, "getTransaction")({ hash: hash2 });
              if (transaction.blockNumber)
                blockNumber = transaction.blockNumber;
            }, {
              delay: retryDelay,
              retryCount
            });
            retrying = false;
          }
          receipt = await getAction$1(client2, getTransactionReceipt, "getTransactionReceipt")({ hash: hash2 });
          if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
            return;
          done(() => emit.resolve(receipt));
        } catch (err) {
          if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {
            if (!transaction) {
              retrying = false;
              return;
            }
            try {
              replacedTransaction = transaction;
              retrying = true;
              const block = await withRetry(() => getAction$1(client2, getBlock, "getBlock")({
                blockNumber,
                includeTransactions: true
              }), {
                delay: retryDelay,
                retryCount,
                shouldRetry: ({ error }) => error instanceof BlockNotFoundError
              });
              retrying = false;
              const replacementTransaction = block.transactions.find(({ from: from2, nonce }) => from2 === replacedTransaction.from && nonce === replacedTransaction.nonce);
              if (!replacementTransaction)
                return;
              receipt = await getAction$1(client2, getTransactionReceipt, "getTransactionReceipt")({
                hash: replacementTransaction.hash
              });
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              let reason = "replaced";
              if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {
                reason = "repriced";
              } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                reason = "cancelled";
              }
              done(() => {
                emit.onReplaced?.({
                  reason,
                  replacedTransaction,
                  transaction: replacementTransaction,
                  transactionReceipt: receipt
                });
                emit.resolve(receipt);
              });
            } catch (err_) {
              done(() => emit.reject(err_));
            }
          } else {
            done(() => emit.reject(err));
          }
        }
      }
    });
  });
  return promise;
}
class AccountNotFoundError extends BaseError$4 {
  constructor({ docsPath: docsPath2 } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join("\n"), {
      docsPath: docsPath2,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}
class AccountTypeNotSupportedError extends BaseError$4 {
  constructor({ docsPath: docsPath2, metaMessages, type }) {
    super(`Account type "${type}" is not supported.`, {
      docsPath: docsPath2,
      metaMessages,
      name: "AccountTypeNotSupportedError"
    });
  }
}
async function sendRawTransaction(client2, { serializedTransaction }) {
  return client2.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  }, { retryCount: 0 });
}
const supportsWalletNamespace = new LruMap(128);
async function sendTransaction$1(client2, parameters) {
  const { account: account_ = client2.account, chain = client2.chain, accessList, authorizationList, blobs, data: data2, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, type, value, ...rest } = parameters;
  if (typeof account_ === "undefined")
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account = account_ ? parseAccount(account_) : null;
  try {
    assertRequest(parameters);
    const to = await (async () => {
      if (parameters.to)
        return parameters.to;
      if (parameters.to === null)
        return void 0;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError$4("`to` is required. Could not infer from `authorizationList`.");
        });
      return void 0;
    })();
    if (account?.type === "json-rpc" || account === null) {
      let chainId;
      if (chain !== null) {
        chainId = await getAction$1(client2, getChainId$1, "getChainId")({});
        assertCurrentChain({
          currentChainId: chainId,
          chain
        });
      }
      const chainFormat = client2.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || formatTransactionRequest;
      const request = format({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { format: chainFormat }),
        accessList,
        authorizationList,
        blobs,
        chainId,
        data: data2,
        from: account?.address,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        type,
        value
      });
      const isWalletNamespaceSupported = supportsWalletNamespace.get(client2.uid);
      const method = isWalletNamespaceSupported ? "wallet_sendTransaction" : "eth_sendTransaction";
      try {
        return await client2.request({
          method,
          params: [request]
        }, { retryCount: 0 });
      } catch (e2) {
        if (isWalletNamespaceSupported === false)
          throw e2;
        const error = e2;
        if (error.name === "InvalidInputRpcError" || error.name === "InvalidParamsRpcError" || error.name === "MethodNotFoundRpcError" || error.name === "MethodNotSupportedRpcError") {
          return await client2.request({
            method: "wallet_sendTransaction",
            params: [request]
          }, { retryCount: 0 }).then((hash2) => {
            supportsWalletNamespace.set(client2.uid, true);
            return hash2;
          }).catch((e3) => {
            const walletNamespaceError = e3;
            if (walletNamespaceError.name === "MethodNotFoundRpcError" || walletNamespaceError.name === "MethodNotSupportedRpcError") {
              supportsWalletNamespace.set(client2.uid, false);
              throw error;
            }
            throw walletNamespaceError;
          });
        }
        throw error;
      }
    }
    if (account?.type === "local") {
      const request = await getAction$1(client2, prepareTransactionRequest$1, "prepareTransactionRequest")({
        account,
        accessList,
        authorizationList,
        blobs,
        chain,
        data: data2,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        nonceManager: account.nonceManager,
        parameters: [...defaultParameters, "sidecars"],
        type,
        value,
        ...rest,
        to
      });
      const serializer = chain?.serializers?.transaction;
      const serializedTransaction = await account.signTransaction(request, {
        serializer
      });
      return await getAction$1(client2, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction
      });
    }
    if (account?.type === "smart")
      throw new AccountTypeNotSupportedError({
        metaMessages: [
          "Consider using the `sendUserOperation` Action instead."
        ],
        docsPath: "/docs/actions/bundler/sendUserOperation",
        type: "smart"
      });
    throw new AccountTypeNotSupportedError({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: account?.type
    });
  } catch (err) {
    if (err instanceof AccountTypeNotSupportedError)
      throw err;
    throw getTransactionError(err, {
      ...parameters,
      account,
      chain: parameters.chain || void 0
    });
  }
}
async function signMessage$1(client2, { account: account_ = client2.account, message }) {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const account = parseAccount(account_);
  if (account.signMessage)
    return account.signMessage({ message });
  const message_ = (() => {
    if (typeof message === "string")
      return stringToHex(message);
    if (message.raw instanceof Uint8Array)
      return toHex(message.raw);
    return message.raw;
  })();
  return client2.request({
    method: "personal_sign",
    params: [message_, account.address]
  }, { retryCount: 0 });
}
async function writeContract$1(client2, parameters) {
  const { abi, account: account_ = client2.account, address, args, dataSuffix, functionName, ...request } = parameters;
  if (typeof account_ === "undefined")
    throw new AccountNotFoundError({
      docsPath: "/docs/contract/writeContract"
    });
  const account = account_ ? parseAccount(account_) : null;
  const data2 = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    return await getAction$1(client2, sendTransaction$1, "sendTransaction")({
      data: `${data2}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      account,
      ...request
    });
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/writeContract",
      functionName,
      sender: account?.address
    });
  }
}
function getAction(client2, actionFn, name) {
  const action_implicit = client2[actionFn.name];
  if (typeof action_implicit === "function")
    return action_implicit;
  const action_explicit = client2[name];
  if (typeof action_explicit === "function")
    return action_explicit;
  return (params) => actionFn(client2, params);
}
const version$3 = "2.20.3";
const getVersion$1 = () => `@wagmi/core@${version$3}`;
var __classPrivateFieldGet$1 = function(receiver, state2, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f2 : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state2.get(receiver);
};
var _BaseError_instances, _BaseError_walk;
let BaseError$1 = class BaseError4 extends Error {
  get docsBaseUrl() {
    return "https://wagmi.sh/core";
  }
  get version() {
    return getVersion$1();
  }
  constructor(shortMessage, options = {}) {
    super();
    _BaseError_instances.add(this);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiCoreError"
    });
    const details = options.cause instanceof BaseError4 ? options.cause.details : options.cause?.message ? options.cause.message : options.details;
    const docsPath2 = options.cause instanceof BaseError4 ? options.cause.docsPath || options.docsPath : options.docsPath;
    this.message = [
      shortMessage || "An error occurred.",
      "",
      ...options.metaMessages ? [...options.metaMessages, ""] : [],
      ...docsPath2 ? [
        `Docs: ${this.docsBaseUrl}${docsPath2}.html${options.docsSlug ? `#${options.docsSlug}` : ""}`
      ] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${this.version}`
    ].join("\n");
    if (options.cause)
      this.cause = options.cause;
    this.details = details;
    this.docsPath = docsPath2;
    this.metaMessages = options.metaMessages;
    this.shortMessage = shortMessage;
  }
  walk(fn2) {
    return __classPrivateFieldGet$1(this, _BaseError_instances, "m", _BaseError_walk).call(this, this, fn2);
  }
};
_BaseError_instances = /* @__PURE__ */ new WeakSet(), _BaseError_walk = function _BaseError_walk2(err, fn2) {
  if (fn2?.(err))
    return err;
  if (err.cause)
    return __classPrivateFieldGet$1(this, _BaseError_instances, "m", _BaseError_walk2).call(this, err.cause, fn2);
  return err;
};
class ChainNotConfiguredError extends BaseError$1 {
  constructor() {
    super("Chain not configured.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainNotConfiguredError"
    });
  }
}
class ConnectorAlreadyConnectedError extends BaseError$1 {
  constructor() {
    super("Connector already connected.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorAlreadyConnectedError"
    });
  }
}
class ConnectorNotConnectedError extends BaseError$1 {
  constructor() {
    super("Connector not connected.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorNotConnectedError"
    });
  }
}
class ConnectorAccountNotFoundError extends BaseError$1 {
  constructor({ address, connector }) {
    super(`Account "${address}" not found for connector "${connector.name}".`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorAccountNotFoundError"
    });
  }
}
class ConnectorChainMismatchError extends BaseError$1 {
  constructor({ connectionChainId, connectorChainId }) {
    super(`The current chain of the connector (id: ${connectorChainId}) does not match the connection's chain (id: ${connectionChainId}).`, {
      metaMessages: [
        `Current Chain ID:  ${connectorChainId}`,
        `Expected Chain ID: ${connectionChainId}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorChainMismatchError"
    });
  }
}
class ConnectorUnavailableReconnectingError extends BaseError$1 {
  constructor({ connector }) {
    super(`Connector "${connector.name}" unavailable while reconnecting.`, {
      details: [
        "During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.",
        "All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.",
        "This error commonly occurs for connectors that asynchronously inject after reconnection has already started."
      ].join(" ")
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorUnavailableReconnectingError"
    });
  }
}
async function connect(config2, parameters) {
  let connector;
  if (typeof parameters.connector === "function") {
    connector = config2._internal.connectors.setup(parameters.connector);
  } else
    connector = parameters.connector;
  if (connector.uid === config2.state.current)
    throw new ConnectorAlreadyConnectedError();
  try {
    config2.setState((x2) => ({ ...x2, status: "connecting" }));
    connector.emitter.emit("message", { type: "connecting" });
    const { connector: _2, ...rest } = parameters;
    const data2 = await connector.connect(rest);
    const accounts = data2.accounts;
    connector.emitter.off("connect", config2._internal.events.connect);
    connector.emitter.on("change", config2._internal.events.change);
    connector.emitter.on("disconnect", config2._internal.events.disconnect);
    await config2.storage?.setItem("recentConnectorId", connector.id);
    config2.setState((x2) => ({
      ...x2,
      connections: new Map(x2.connections).set(connector.uid, {
        accounts,
        chainId: data2.chainId,
        connector
      }),
      current: connector.uid,
      status: "connected"
    }));
    return { accounts, chainId: data2.chainId };
  } catch (error) {
    config2.setState((x2) => ({
      ...x2,
      // Keep existing connector connected in case of error
      status: x2.current ? "connected" : "disconnected"
    }));
    throw error;
  }
}
const size$1 = 256;
let index$2 = size$1;
let buffer$2;
function uid$1(length2 = 11) {
  if (!buffer$2 || index$2 + length2 > size$1 * 2) {
    buffer$2 = "";
    index$2 = 0;
    for (let i4 = 0; i4 < size$1; i4++) {
      buffer$2 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer$2.substring(index$2, index$2++ + length2);
}
function createClient(parameters) {
  const { batch, chain, ccipRead, key: key2 = "base", name = "Base Client", type = "base" } = parameters;
  const experimental_blockTag = parameters.experimental_blockTag ?? (typeof chain?.experimental_preconfirmationTime === "number" ? "pending" : void 0);
  const blockTime = chain?.blockTime ?? 12e3;
  const defaultPollingInterval = Math.min(Math.max(Math.floor(blockTime / 2), 500), 4e3);
  const pollingInterval = parameters.pollingInterval ?? defaultPollingInterval;
  const cacheTime = parameters.cacheTime ?? pollingInterval;
  const account = parameters.account ? parseAccount(parameters.account) : void 0;
  const { config: config2, request, value } = parameters.transport({
    chain,
    pollingInterval
  });
  const transport = { ...config2, ...value };
  const client2 = {
    account,
    batch,
    cacheTime,
    ccipRead,
    chain,
    key: key2,
    name,
    pollingInterval,
    request,
    transport,
    type,
    uid: uid$1(),
    ...experimental_blockTag ? { experimental_blockTag } : {}
  };
  function extend(base3) {
    return (extendFn) => {
      const extended = extendFn(base3);
      for (const key3 in client2)
        delete extended[key3];
      const combined = { ...base3, ...extended };
      return Object.assign(combined, { extend: extend(combined) });
    };
  }
  return Object.assign(client2, { extend: extend(client2) });
}
function createTransport({ key: key2, methods, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  const uid2 = uid$1();
  return {
    config: {
      key: key2,
      methods,
      name,
      request,
      retryCount,
      retryDelay,
      timeout,
      type
    },
    request: buildRequest(request, { methods, retryCount, retryDelay, uid: uid2 }),
    value
  };
}
function custom$1(provider, config2 = {}) {
  const { key: key2 = "custom", methods, name = "Custom Provider", retryDelay } = config2;
  return ({ retryCount: defaultRetryCount }) => createTransport({
    key: key2,
    methods,
    name,
    request: provider.request.bind(provider),
    retryCount: config2.retryCount ?? defaultRetryCount,
    retryDelay,
    type: "custom"
  });
}
function fallback(transports_, config2 = {}) {
  const { key: key2 = "fallback", name = "Fallback", rank = false, shouldThrow: shouldThrow_ = shouldThrow, retryCount, retryDelay } = config2;
  return (({ chain, pollingInterval = 4e3, timeout, ...rest }) => {
    let transports = transports_;
    let onResponse = () => {
    };
    const transport = createTransport({
      key: key2,
      name,
      async request({ method, params }) {
        let includes;
        const fetch2 = async (i4 = 0) => {
          const transport2 = transports[i4]({
            ...rest,
            chain,
            retryCount: 0,
            timeout
          });
          try {
            const response = await transport2.request({
              method,
              params
            });
            onResponse({
              method,
              params,
              response,
              transport: transport2,
              status: "success"
            });
            return response;
          } catch (err) {
            onResponse({
              error: err,
              method,
              params,
              transport: transport2,
              status: "error"
            });
            if (shouldThrow_(err))
              throw err;
            if (i4 === transports.length - 1)
              throw err;
            includes ?? (includes = transports.slice(i4 + 1).some((transport3) => {
              const { include, exclude } = transport3({ chain }).config.methods || {};
              if (include)
                return include.includes(method);
              if (exclude)
                return !exclude.includes(method);
              return true;
            }));
            if (!includes)
              throw err;
            return fetch2(i4 + 1);
          }
        };
        return fetch2();
      },
      retryCount,
      retryDelay,
      type: "fallback"
    }, {
      onResponse: (fn2) => onResponse = fn2,
      transports: transports.map((fn2) => fn2({ chain, retryCount: 0 }))
    });
    if (rank) {
      const rankOptions = typeof rank === "object" ? rank : {};
      rankTransports({
        chain,
        interval: rankOptions.interval ?? pollingInterval,
        onTransports: (transports_2) => transports = transports_2,
        ping: rankOptions.ping,
        sampleCount: rankOptions.sampleCount,
        timeout: rankOptions.timeout,
        transports,
        weights: rankOptions.weights
      });
    }
    return transport;
  });
}
function shouldThrow(error) {
  if ("code" in error && typeof error.code === "number") {
    if (error.code === TransactionRejectedRpcError.code || error.code === UserRejectedRequestError.code || ExecutionRevertedError.nodeMessage.test(error.message) || error.code === 5e3)
      return true;
  }
  return false;
}
function rankTransports({ chain, interval = 4e3, onTransports, ping, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
  const samples = [];
  const rankTransports_ = async () => {
    const sample = await Promise.all(transports.map(async (transport) => {
      const transport_ = transport({ chain, retryCount: 0, timeout });
      const start2 = Date.now();
      let end2;
      let success;
      try {
        await (ping ? ping({ transport: transport_ }) : transport_.request({ method: "net_listening" }));
        success = 1;
      } catch {
        success = 0;
      } finally {
        end2 = Date.now();
      }
      const latency = end2 - start2;
      return { latency, success };
    }));
    samples.push(sample);
    if (samples.length > sampleCount)
      samples.shift();
    const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
    const scores = transports.map((_2, i4) => {
      const latencies = samples.map((sample2) => sample2[i4].latency);
      const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
      const latencyScore = 1 - meanLatency / maxLatency;
      const successes = samples.map((sample2) => sample2[i4].success);
      const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
      if (stabilityScore === 0)
        return [0, i4];
      return [
        latencyWeight * latencyScore + stabilityWeight * stabilityScore,
        i4
      ];
    }).sort((a2, b2) => b2[0] - a2[0]);
    onTransports(scores.map(([, i4]) => transports[i4]));
    await wait(interval);
    rankTransports_();
  };
  rankTransports_();
}
class UrlRequiredError extends BaseError$4 {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
}
function http(url, config2 = {}) {
  const { batch, fetchFn, fetchOptions, key: key2 = "http", methods, name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay, raw } = config2;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config2.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config2.timeout ?? 1e4;
    const url_ = url || chain?.rpcUrls.default.http[0];
    if (!url_)
      throw new UrlRequiredError();
    const rpcClient = getHttpRpcClient(url_, {
      fetchFn,
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout
    });
    return createTransport({
      key: key2,
      methods,
      name,
      async request({ method, params }) {
        const body2 = { method, params };
        const { schedule } = createBatchScheduler({
          id: url_,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body3) => rpcClient.request({
            body: body3
          }),
          sort: (a2, b2) => a2.id - b2.id
        });
        const fn2 = async (body3) => batch ? schedule(body3) : [
          await rpcClient.request({
            body: body3
          })
        ];
        const [{ error, result }] = await fn2(body2);
        if (raw)
          return { error, result };
        if (error)
          throw new RpcRequestError({
            body: body2,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      fetchOptions,
      url: url_
    });
  };
}
async function getConnectorClient(config2, parameters = {}) {
  let connection;
  if (parameters.connector) {
    const { connector: connector2 } = parameters;
    if (config2.state.status === "reconnecting" && !connector2.getAccounts && !connector2.getChainId)
      throw new ConnectorUnavailableReconnectingError({ connector: connector2 });
    const [accounts, chainId2] = await Promise.all([
      connector2.getAccounts().catch((e2) => {
        if (parameters.account === null)
          return [];
        throw e2;
      }),
      connector2.getChainId()
    ]);
    connection = {
      accounts,
      chainId: chainId2,
      connector: connector2
    };
  } else
    connection = config2.state.connections.get(config2.state.current);
  if (!connection)
    throw new ConnectorNotConnectedError();
  const chainId = parameters.chainId ?? connection.chainId;
  const connectorChainId = await connection.connector.getChainId();
  if (connectorChainId !== chainId)
    throw new ConnectorChainMismatchError({
      connectionChainId: chainId,
      connectorChainId
    });
  const connector = connection.connector;
  if (connector.getClient)
    return connector.getClient({ chainId });
  const account = parseAccount(parameters.account ?? connection.accounts[0]);
  if (account)
    account.address = getAddress(account.address);
  if (parameters.account && !connection.accounts.some((x2) => x2.toLowerCase() === account.address.toLowerCase()))
    throw new ConnectorAccountNotFoundError({
      address: account.address,
      connector
    });
  const chain = config2.chains.find((chain2) => chain2.id === chainId);
  const provider = await connection.connector.getProvider({ chainId });
  return createClient({
    account,
    chain,
    name: "Connector Client",
    transport: (opts) => custom$1(provider)({ ...opts, retryCount: 0 })
  });
}
async function disconnect(config2, parameters = {}) {
  let connector;
  if (parameters.connector)
    connector = parameters.connector;
  else {
    const { connections: connections2, current } = config2.state;
    const connection = connections2.get(current);
    connector = connection?.connector;
  }
  const connections = config2.state.connections;
  if (connector) {
    await connector.disconnect();
    connector.emitter.off("change", config2._internal.events.change);
    connector.emitter.off("disconnect", config2._internal.events.disconnect);
    connector.emitter.on("connect", config2._internal.events.connect);
    connections.delete(connector.uid);
  }
  config2.setState((x2) => {
    if (connections.size === 0)
      return {
        ...x2,
        connections: /* @__PURE__ */ new Map(),
        current: null,
        status: "disconnected"
      };
    const nextConnection = connections.values().next().value;
    return {
      ...x2,
      connections: new Map(connections),
      current: nextConnection.connector.uid
    };
  });
  {
    const current = config2.state.current;
    if (!current)
      return;
    const connector2 = config2.state.connections.get(current)?.connector;
    if (!connector2)
      return;
    await config2.storage?.setItem("recentConnectorId", connector2.id);
  }
}
function getUnit(unit) {
  if (typeof unit === "number")
    return unit;
  if (unit === "wei")
    return 0;
  return Math.abs(weiUnits[unit]);
}
async function estimateGas(config2, parameters) {
  const { chainId, connector, ...rest } = parameters;
  let account;
  if (parameters.account)
    account = parameters.account;
  else {
    const connectorClient = await getConnectorClient(config2, {
      account: parameters.account,
      chainId,
      connector
    });
    account = connectorClient.account;
  }
  const client2 = config2.getClient({ chainId });
  const action = getAction(client2, estimateGas$1, "estimateGas");
  return action({ ...rest, account });
}
function getAccount(config2) {
  const uid2 = config2.state.current;
  const connection = config2.state.connections.get(uid2);
  const addresses = connection?.accounts;
  const address = addresses?.[0];
  const chain = config2.chains.find((chain2) => chain2.id === connection?.chainId);
  const status = config2.state.status;
  switch (status) {
    case "connected":
      return {
        address,
        addresses,
        chain,
        chainId: connection?.chainId,
        connector: connection?.connector,
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "reconnecting":
      return {
        address,
        addresses,
        chain,
        chainId: connection?.chainId,
        connector: connection?.connector,
        isConnected: !!address,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: true,
        status
      };
    case "connecting":
      return {
        address,
        addresses,
        chain,
        chainId: connection?.chainId,
        connector: connection?.connector,
        isConnected: false,
        isConnecting: true,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "disconnected":
      return {
        address: void 0,
        addresses: void 0,
        chain: void 0,
        chainId: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status
      };
  }
}
async function multicall(config2, parameters) {
  const { allowFailure = true, chainId, contracts, ...rest } = parameters;
  const client2 = config2.getClient({ chainId });
  const action = getAction(client2, multicall$1, "multicall");
  return action({
    allowFailure,
    contracts,
    ...rest
  });
}
function readContract(config2, parameters) {
  const { chainId, ...rest } = parameters;
  const client2 = config2.getClient({ chainId });
  const action = getAction(client2, readContract$1, "readContract");
  return action(rest);
}
async function readContracts(config2, parameters) {
  const { allowFailure = true, blockNumber, blockTag, ...rest } = parameters;
  const contracts = parameters.contracts;
  try {
    const contractsByChainId = {};
    for (const [index2, contract] of contracts.entries()) {
      const chainId = contract.chainId ?? config2.state.chainId;
      if (!contractsByChainId[chainId])
        contractsByChainId[chainId] = [];
      contractsByChainId[chainId]?.push({ contract, index: index2 });
    }
    const promises = () => Object.entries(contractsByChainId).map(([chainId, contracts2]) => multicall(config2, {
      ...rest,
      allowFailure,
      blockNumber,
      blockTag,
      chainId: Number.parseInt(chainId),
      contracts: contracts2.map(({ contract }) => contract)
    }));
    const multicallResults = (await Promise.all(promises())).flat();
    const resultIndexes = Object.values(contractsByChainId).flatMap((contracts2) => contracts2.map(({ index: index2 }) => index2));
    return multicallResults.reduce((results, result, index2) => {
      if (results)
        results[resultIndexes[index2]] = result;
      return results;
    }, []);
  } catch (error) {
    if (error instanceof ContractFunctionExecutionError)
      throw error;
    const promises = () => contracts.map((contract) => readContract(config2, { ...contract, blockNumber, blockTag }));
    if (allowFailure)
      return (await Promise.allSettled(promises())).map((result) => {
        if (result.status === "fulfilled")
          return { result: result.value, status: "success" };
        return { error: result.reason, result: void 0, status: "failure" };
      });
    return await Promise.all(promises());
  }
}
async function getBalance(config2, parameters) {
  const { address, blockNumber, blockTag, chainId, token: tokenAddress, unit = "ether" } = parameters;
  if (tokenAddress) {
    try {
      return await getTokenBalance(config2, {
        balanceAddress: address,
        chainId,
        symbolType: "string",
        tokenAddress
      });
    } catch (error) {
      if (error.name === "ContractFunctionExecutionError") {
        const balance = await getTokenBalance(config2, {
          balanceAddress: address,
          chainId,
          symbolType: "bytes32",
          tokenAddress
        });
        const symbol = hexToString(trim(balance.symbol, { dir: "right" }));
        return { ...balance, symbol };
      }
      throw error;
    }
  }
  const client2 = config2.getClient({ chainId });
  const action = getAction(client2, getBalance$1, "getBalance");
  const value = await action(blockNumber ? { address, blockNumber } : { address, blockTag });
  const chain = config2.chains.find((x2) => x2.id === chainId) ?? client2.chain;
  return {
    decimals: chain.nativeCurrency.decimals,
    formatted: formatUnits(value, getUnit(unit)),
    symbol: chain.nativeCurrency.symbol,
    value
  };
}
async function getTokenBalance(config2, parameters) {
  const { balanceAddress, chainId, symbolType: symbolType2, tokenAddress, unit } = parameters;
  const contract = {
    abi: [
      {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [{ type: "address" }],
        outputs: [{ type: "uint256" }]
      },
      {
        type: "function",
        name: "decimals",
        stateMutability: "view",
        inputs: [],
        outputs: [{ type: "uint8" }]
      },
      {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [{ type: symbolType2 }]
      }
    ],
    address: tokenAddress
  };
  const [value, decimals, symbol] = await readContracts(config2, {
    allowFailure: false,
    contracts: [
      {
        ...contract,
        functionName: "balanceOf",
        args: [balanceAddress],
        chainId
      },
      { ...contract, functionName: "decimals", chainId },
      { ...contract, functionName: "symbol", chainId }
    ]
  });
  const formatted = formatUnits(value ?? "0", getUnit(unit ?? decimals));
  return { decimals, formatted, symbol, value };
}
function getChainId(config2) {
  return config2.state.chainId;
}
function deepEqual(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    let length2;
    let i4;
    if (Array.isArray(a2) && Array.isArray(b2)) {
      length2 = a2.length;
      if (length2 !== b2.length)
        return false;
      for (i4 = length2; i4-- !== 0; )
        if (!deepEqual(a2[i4], b2[i4]))
          return false;
      return true;
    }
    if (typeof a2.valueOf === "function" && a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b2.valueOf();
    if (typeof a2.toString === "function" && a2.toString !== Object.prototype.toString)
      return a2.toString() === b2.toString();
    const keys = Object.keys(a2);
    length2 = keys.length;
    if (length2 !== Object.keys(b2).length)
      return false;
    for (i4 = length2; i4-- !== 0; )
      if (!Object.hasOwn(b2, keys[i4]))
        return false;
    for (i4 = length2; i4-- !== 0; ) {
      const key2 = keys[i4];
      if (key2 && !deepEqual(a2[key2], b2[key2]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
let previousChains = [];
function getChains(config2) {
  const chains2 = config2.chains;
  if (deepEqual(previousChains, chains2))
    return previousChains;
  previousChains = chains2;
  return chains2;
}
let previousConnections = [];
function getConnections(config2) {
  const connections = [...config2.state.connections.values()];
  if (config2.state.status === "reconnecting")
    return previousConnections;
  if (deepEqual(previousConnections, connections))
    return previousConnections;
  previousConnections = connections;
  return connections;
}
function getEnsAddress(config2, parameters) {
  const { chainId, ...rest } = parameters;
  const client2 = config2.getClient({ chainId });
  const action = getAction(client2, getEnsAddress$1, "getEnsAddress");
  return action(rest);
}
function getEnsAvatar(config2, parameters) {
  const { chainId, ...rest } = parameters;
  const client2 = config2.getClient({ chainId });
  const action = getAction(client2, getEnsAvatar$1, "getEnsAvatar");
  return action(rest);
}
function getEnsName(config2, parameters) {
  const { chainId, ...rest } = parameters;
  const client2 = config2.getClient({ chainId });
  const action = getAction(client2, getEnsName$1, "getEnsName");
  return action(rest);
}
async function prepareTransactionRequest(config2, parameters) {
  const { account: account_, chainId, ...rest } = parameters;
  const account = account_ ?? getAccount(config2).address;
  const client2 = config2.getClient({ chainId });
  const action = getAction(client2, prepareTransactionRequest$1, "prepareTransactionRequest");
  return action({
    ...rest,
    ...account ? { account } : {}
  });
}
let isReconnecting = false;
async function reconnect(config2, parameters = {}) {
  if (isReconnecting)
    return [];
  isReconnecting = true;
  config2.setState((x2) => ({
    ...x2,
    status: x2.current ? "reconnecting" : "connecting"
  }));
  const connectors = [];
  if (parameters.connectors?.length) {
    for (const connector_ of parameters.connectors) {
      let connector;
      if (typeof connector_ === "function")
        connector = config2._internal.connectors.setup(connector_);
      else
        connector = connector_;
      connectors.push(connector);
    }
  } else
    connectors.push(...config2.connectors);
  let recentConnectorId;
  try {
    recentConnectorId = await config2.storage?.getItem("recentConnectorId");
  } catch {
  }
  const scores = {};
  for (const [, connection] of config2.state.connections) {
    scores[connection.connector.id] = 1;
  }
  if (recentConnectorId)
    scores[recentConnectorId] = 0;
  const sorted = Object.keys(scores).length > 0 ? (
    // .toSorted()
    [...connectors].sort((a2, b2) => (scores[a2.id] ?? 10) - (scores[b2.id] ?? 10))
  ) : connectors;
  let connected = false;
  const connections = [];
  const providers = [];
  for (const connector of sorted) {
    const provider = await connector.getProvider().catch(() => void 0);
    if (!provider)
      continue;
    if (providers.some((x2) => x2 === provider))
      continue;
    const isAuthorized = await connector.isAuthorized();
    if (!isAuthorized)
      continue;
    const data2 = await connector.connect({ isReconnecting: true }).catch(() => null);
    if (!data2)
      continue;
    connector.emitter.off("connect", config2._internal.events.connect);
    connector.emitter.on("change", config2._internal.events.change);
    connector.emitter.on("disconnect", config2._internal.events.disconnect);
    config2.setState((x2) => {
      const connections2 = new Map(connected ? x2.connections : /* @__PURE__ */ new Map()).set(connector.uid, { accounts: data2.accounts, chainId: data2.chainId, connector });
      return {
        ...x2,
        current: connected ? x2.current : connector.uid,
        connections: connections2
      };
    });
    connections.push({
      accounts: data2.accounts,
      chainId: data2.chainId,
      connector
    });
    providers.push(provider);
    connected = true;
  }
  if (config2.state.status === "reconnecting" || config2.state.status === "connecting") {
    if (!connected)
      config2.setState((x2) => ({
        ...x2,
        connections: /* @__PURE__ */ new Map(),
        current: null,
        status: "disconnected"
      }));
    else
      config2.setState((x2) => ({ ...x2, status: "connected" }));
  }
  isReconnecting = false;
  return connections;
}
async function sendTransaction(config2, parameters) {
  const { account, chainId, connector, ...rest } = parameters;
  let client2;
  if (typeof account === "object" && account?.type === "local")
    client2 = config2.getClient({ chainId });
  else
    client2 = await getConnectorClient(config2, {
      account: account ?? void 0,
      chainId,
      connector
    });
  const action = getAction(client2, sendTransaction$1, "sendTransaction");
  const hash2 = await action({
    ...rest,
    ...account ? { account } : {},
    chain: chainId ? { id: chainId } : null,
    gas: rest.gas ?? void 0
  });
  return hash2;
}
async function signMessage(config2, parameters) {
  const { account, connector, ...rest } = parameters;
  let client2;
  if (typeof account === "object" && account.type === "local")
    client2 = config2.getClient();
  else
    client2 = await getConnectorClient(config2, { account, connector });
  const action = getAction(client2, signMessage$1, "signMessage");
  return action({
    ...rest,
    ...account ? { account } : {}
  });
}
async function switchAccount(config2, parameters) {
  const { connector } = parameters;
  const connection = config2.state.connections.get(connector.uid);
  if (!connection)
    throw new ConnectorNotConnectedError();
  await config2.storage?.setItem("recentConnectorId", connector.id);
  config2.setState((x2) => ({
    ...x2,
    current: connector.uid
  }));
  return {
    accounts: connection.accounts,
    chainId: connection.chainId
  };
}
class ProviderNotFoundError extends BaseError$1 {
  constructor() {
    super("Provider not found.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderNotFoundError"
    });
  }
}
class SwitchChainNotSupportedError extends BaseError$1 {
  constructor({ connector }) {
    super(`"${connector.name}" does not support programmatic chain switching.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SwitchChainNotSupportedError"
    });
  }
}
async function switchChain(config2, parameters) {
  const { addEthereumChainParameter, chainId } = parameters;
  const connection = config2.state.connections.get(parameters.connector?.uid ?? config2.state.current);
  if (connection) {
    const connector = connection.connector;
    if (!connector.switchChain)
      throw new SwitchChainNotSupportedError({ connector });
    const chain2 = await connector.switchChain({
      addEthereumChainParameter,
      chainId
    });
    return chain2;
  }
  const chain = config2.chains.find((x2) => x2.id === chainId);
  if (!chain)
    throw new ChainNotConfiguredError();
  config2.setState((x2) => ({ ...x2, chainId }));
  return chain;
}
async function waitForTransactionReceipt(config2, parameters) {
  const { chainId, timeout = 0, ...rest } = parameters;
  const client2 = config2.getClient({ chainId });
  const action = getAction(client2, waitForTransactionReceipt$1, "waitForTransactionReceipt");
  const receipt = await action({ ...rest, timeout });
  if (receipt.status === "reverted") {
    const action_getTransaction = getAction(client2, getTransaction, "getTransaction");
    const txn = await action_getTransaction({ hash: receipt.transactionHash });
    const action_call = getAction(client2, call, "call");
    const code = await action_call({
      ...txn,
      data: txn.input,
      gasPrice: txn.type !== "eip1559" ? txn.gasPrice : void 0,
      maxFeePerGas: txn.type === "eip1559" ? txn.maxFeePerGas : void 0,
      maxPriorityFeePerGas: txn.type === "eip1559" ? txn.maxPriorityFeePerGas : void 0
    });
    const reason = code?.data ? hexToString(`0x${code.data.substring(138)}`) : "unknown reason";
    throw new Error(reason);
  }
  return {
    ...receipt,
    chainId: client2.chain.id
  };
}
function watchAccount(config2, parameters) {
  const { onChange } = parameters;
  return config2.subscribe(() => getAccount(config2), onChange, {
    equalityFn(a2, b2) {
      const { connector: aConnector, ...aRest } = a2;
      const { connector: bConnector, ...bRest } = b2;
      return deepEqual(aRest, bRest) && // check connector separately
      aConnector?.id === bConnector?.id && aConnector?.uid === bConnector?.uid;
    }
  });
}
function watchChainId(config2, parameters) {
  const { onChange } = parameters;
  return config2.subscribe((state2) => state2.chainId, onChange);
}
function watchConnections(config2, parameters) {
  const { onChange } = parameters;
  return config2.subscribe(() => getConnections(config2), onChange, {
    equalityFn: deepEqual
  });
}
function watchConnectors(config2, parameters) {
  const { onChange } = parameters;
  return config2._internal.connectors.subscribe((connectors, prevConnectors) => {
    onChange(Object.values(connectors), prevConnectors);
  });
}
async function writeContract(config2, parameters) {
  const { account, chainId, connector, ...request } = parameters;
  let client2;
  if (typeof account === "object" && account?.type === "local")
    client2 = config2.getClient({ chainId });
  else
    client2 = await getConnectorClient(config2, {
      account: account ?? void 0,
      chainId,
      connector
    });
  const action = getAction(client2, writeContract$1, "writeContract");
  const hash2 = await action({
    ...request,
    ...account ? { account } : {},
    chain: chainId ? { id: chainId } : null
  });
  return hash2;
}
function createConnector(createConnectorFn) {
  return createConnectorFn;
}
injected.type = "injected";
function injected(parameters = {}) {
  const { shimDisconnect = true, unstable_shimAsyncInject } = parameters;
  function getTarget() {
    const target = parameters.target;
    if (typeof target === "function") {
      const result = target();
      if (result)
        return result;
    }
    if (typeof target === "object")
      return target;
    if (typeof target === "string")
      return {
        ...targetMap[target] ?? {
          id: target,
          name: `${target[0].toUpperCase()}${target.slice(1)}`,
          provider: `is${target[0].toUpperCase()}${target.slice(1)}`
        }
      };
    return {
      id: "injected",
      name: "Injected",
      provider(window2) {
        return window2?.ethereum;
      }
    };
  }
  let accountsChanged;
  let chainChanged;
  let connect2;
  let disconnect2;
  return createConnector((config2) => ({
    get icon() {
      return getTarget().icon;
    },
    get id() {
      return getTarget().id;
    },
    get name() {
      return getTarget().name;
    },
    /** @deprecated */
    get supportsSimulation() {
      return true;
    },
    type: injected.type,
    async setup() {
      const provider = await this.getProvider();
      if (provider?.on && parameters.target) {
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider.on("connect", connect2);
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
      }
    },
    async connect({ chainId, isReconnecting: isReconnecting2 } = {}) {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      let accounts = [];
      if (isReconnecting2)
        accounts = await this.getAccounts().catch(() => []);
      else if (shimDisconnect) {
        try {
          const permissions = await provider.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }]
          });
          accounts = permissions[0]?.caveats?.[0]?.value?.map((x2) => getAddress(x2));
          if (accounts.length > 0) {
            const sortedAccounts = await this.getAccounts();
            accounts = sortedAccounts;
          }
        } catch (err) {
          const error = err;
          if (error.code === UserRejectedRequestError.code)
            throw new UserRejectedRequestError(error);
          if (error.code === ResourceUnavailableRpcError.code)
            throw error;
        }
      }
      try {
        if (!accounts?.length && !isReconnecting2) {
          const requestedAccounts = await provider.request({
            method: "eth_requestAccounts"
          });
          accounts = requestedAccounts.map((x2) => getAddress(x2));
        }
        if (connect2) {
          provider.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = chain?.id ?? currentChainId;
        }
        if (shimDisconnect)
          await config2.storage?.removeItem(`${this.id}.disconnected`);
        if (!parameters.target)
          await config2.storage?.setItem("injected.connected", true);
        return { accounts, chainId: currentChainId };
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        if (error.code === ResourceUnavailableRpcError.code)
          throw new ResourceUnavailableRpcError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
      try {
        await withTimeout(() => (
          // TODO: Remove explicit type for viem@3
          provider.request({
            // `'wallet_revokePermissions'` added in `viem@2.10.3`
            method: "wallet_revokePermissions",
            params: [{ eth_accounts: {} }]
          })
        ), { timeout: 100 });
      } catch {
      }
      if (shimDisconnect) {
        await config2.storage?.setItem(`${this.id}.disconnected`, true);
      }
      if (!parameters.target)
        await config2.storage?.removeItem("injected.connected");
    },
    async getAccounts() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const accounts = await provider.request({ method: "eth_accounts" });
      return accounts.map((x2) => getAddress(x2));
    },
    async getChainId() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const hexChainId = await provider.request({ method: "eth_chainId" });
      return Number(hexChainId);
    },
    async getProvider() {
      if (typeof window === "undefined")
        return void 0;
      let provider;
      const target = getTarget();
      if (typeof target.provider === "function")
        provider = target.provider(window);
      else if (typeof target.provider === "string")
        provider = findProvider(window, target.provider);
      else
        provider = target.provider;
      if (provider && !provider.removeListener) {
        if ("off" in provider && typeof provider.off === "function")
          provider.removeListener = provider.off;
        else
          provider.removeListener = () => {
          };
      }
      return provider;
    },
    async isAuthorized() {
      try {
        const isDisconnected = shimDisconnect && // If shim exists in storage, connector is disconnected
        await config2.storage?.getItem(`${this.id}.disconnected`);
        if (isDisconnected)
          return false;
        if (!parameters.target) {
          const connected = await config2.storage?.getItem("injected.connected");
          if (!connected)
            return false;
        }
        const provider = await this.getProvider();
        if (!provider) {
          if (unstable_shimAsyncInject !== void 0 && unstable_shimAsyncInject !== false) {
            const handleEthereum = async () => {
              if (typeof window !== "undefined")
                window.removeEventListener("ethereum#initialized", handleEthereum);
              const provider2 = await this.getProvider();
              return !!provider2;
            };
            const timeout = typeof unstable_shimAsyncInject === "number" ? unstable_shimAsyncInject : 1e3;
            const res = await Promise.race([
              ...typeof window !== "undefined" ? [
                new Promise((resolve) => window.addEventListener("ethereum#initialized", () => resolve(handleEthereum()), { once: true }))
              ] : [],
              new Promise((resolve) => setTimeout(() => resolve(handleEthereum()), timeout))
            ]);
            if (res)
              return true;
          }
          throw new ProviderNotFoundError();
        }
        const accounts = await withRetry(() => this.getAccounts());
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const chain = config2.chains.find((x2) => x2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const promise = new Promise((resolve) => {
        const listener = ((data2) => {
          if ("chainId" in data2 && data2.chainId === chainId) {
            config2.emitter.off("change", listener);
            resolve();
          }
        });
        config2.emitter.on("change", listener);
      });
      try {
        await Promise.all([
          provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          }).then(async () => {
            const currentChainId = await this.getChainId();
            if (currentChainId === chainId)
              config2.emitter.emit("change", { chainId });
          }),
          promise
        ]);
        return chain;
      } catch (err) {
        const error = err;
        if (error.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        error?.data?.originalError?.code === 4902) {
          try {
            const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
            let blockExplorerUrls;
            if (addEthereumChainParameter?.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else if (blockExplorer)
              blockExplorerUrls = [
                blockExplorer.url,
                ...Object.values(blockExplorers).map((x2) => x2.url)
              ];
            let rpcUrls;
            if (addEthereumChainParameter?.rpcUrls?.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [chain.rpcUrls.default?.http[0] ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: addEthereumChainParameter?.chainName ?? chain.name,
              iconUrls: addEthereumChainParameter?.iconUrls,
              nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,
              rpcUrls
            };
            await Promise.all([
              provider.request({
                method: "wallet_addEthereumChain",
                params: [addEthereumChain]
              }).then(async () => {
                const currentChainId = await this.getChainId();
                if (currentChainId === chainId)
                  config2.emitter.emit("change", { chainId });
                else
                  throw new UserRejectedRequestError(new Error("User rejected switch after adding network."));
              }),
              promise
            ]);
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        throw new SwitchChainError(error);
      }
    },
    async onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else if (config2.emitter.listenerCount("connect")) {
        const chainId = (await this.getChainId()).toString();
        this.onConnect({ chainId });
        if (shimDisconnect)
          await config2.storage?.removeItem(`${this.id}.disconnected`);
      } else
        config2.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const accounts = await this.getAccounts();
      if (accounts.length === 0)
        return;
      const chainId = Number(connectInfo.chainId);
      config2.emitter.emit("connect", { accounts, chainId });
      const provider = await this.getProvider();
      if (provider) {
        if (connect2) {
          provider.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
      }
    },
    async onDisconnect(error) {
      const provider = await this.getProvider();
      if (error && error.code === 1013) {
        if (provider && !!(await this.getAccounts()).length)
          return;
      }
      config2.emitter.emit("disconnect");
      if (provider) {
        if (chainChanged) {
          provider.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider.on("connect", connect2);
        }
      }
    }
  }));
}
const targetMap = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    provider(window2) {
      if (window2?.coinbaseWalletExtension)
        return window2.coinbaseWalletExtension;
      return findProvider(window2, "isCoinbaseWallet");
    }
  },
  metaMask: {
    id: "metaMask",
    name: "MetaMask",
    provider(window2) {
      return findProvider(window2, (provider) => {
        if (!provider.isMetaMask)
          return false;
        if (provider.isBraveWallet && !provider._events && !provider._state)
          return false;
        const flags = [
          "isApexWallet",
          "isAvalanche",
          "isBitKeep",
          "isBlockWallet",
          "isKuCoinWallet",
          "isMathWallet",
          "isOkxWallet",
          "isOKExWallet",
          "isOneInchIOSWallet",
          "isOneInchAndroidWallet",
          "isOpera",
          "isPhantom",
          "isPortal",
          "isRabby",
          "isTokenPocket",
          "isTokenary",
          "isUniswapWallet",
          "isZerion"
        ];
        for (const flag of flags)
          if (provider[flag])
            return false;
        return true;
      });
    }
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    provider(window2) {
      if (window2?.phantom?.ethereum)
        return window2.phantom?.ethereum;
      return findProvider(window2, "isPhantom");
    }
  }
};
function findProvider(window2, select) {
  function isProvider(provider) {
    if (typeof select === "function")
      return select(provider);
    if (typeof select === "string")
      return provider[select];
    return true;
  }
  const ethereum = window2.ethereum;
  if (ethereum?.providers)
    return ethereum.providers.find((provider) => isProvider(provider));
  if (ethereum && isProvider(ethereum))
    return ethereum;
  return void 0;
}
function requestProviders(listener) {
  if (typeof window === "undefined")
    return;
  const handler = (event) => listener(event.detail);
  window.addEventListener("eip6963:announceProvider", handler);
  window.dispatchEvent(new CustomEvent("eip6963:requestProvider"));
  return () => window.removeEventListener("eip6963:announceProvider", handler);
}
function createStore$1() {
  const listeners = /* @__PURE__ */ new Set();
  let providerDetails = [];
  const request = () => requestProviders((providerDetail) => {
    if (providerDetails.some(({ info }) => info.uuid === providerDetail.info.uuid))
      return;
    providerDetails = [...providerDetails, providerDetail];
    listeners.forEach((listener) => listener(providerDetails, { added: [providerDetail] }));
  });
  let unwatch = request();
  return {
    _listeners() {
      return listeners;
    },
    clear() {
      listeners.forEach((listener) => listener([], { removed: [...providerDetails] }));
      providerDetails = [];
    },
    destroy() {
      this.clear();
      listeners.clear();
      unwatch?.();
    },
    findProvider({ rdns }) {
      return providerDetails.find((providerDetail) => providerDetail.info.rdns === rdns);
    },
    getProviders() {
      return providerDetails;
    },
    reset() {
      this.clear();
      unwatch?.();
      unwatch = request();
    },
    subscribe(listener, { emitImmediately } = {}) {
      listeners.add(listener);
      if (emitImmediately)
        listener(providerDetails, { added: providerDetails });
      return () => listeners.delete(listener);
    }
  };
}
const subscribeWithSelectorImpl = (fn2) => (set, get, api2) => {
  const origSubscribe = api2.subscribe;
  api2.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api2.getState());
      listener = (state2) => {
        const nextSlice = selector(state2);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState2 = fn2(set, get, api2);
  return initialState2;
};
const subscribeWithSelector = subscribeWithSelectorImpl;
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e2) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a3;
      const parse2 = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, void 0);
      };
      const str = (_a3 = storage.getItem(name)) != null ? _a3 : null;
      if (str instanceof Promise) {
        return str.then(parse2);
      }
      return parse2(str);
    },
    setItem: (name, newValue) => storage.setItem(
      name,
      JSON.stringify(newValue, void 0)
    ),
    removeItem: (name) => storage.removeItem(name)
  };
  return persistStorage;
}
const toThenable = (fn2) => (input) => {
  try {
    const result = fn2(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e2) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e2);
      }
    };
  }
};
const persistImpl = (config2, baseOptions) => (set, get, api2) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state2) => state2,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config2(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api2
    );
  }
  const setItem = () => {
    const state2 = options.partialize({ ...get() });
    return storage.setItem(options.name, {
      state: state2,
      version: options.version
    });
  };
  const savedSetState = api2.setState;
  api2.setState = (state2, replace2) => {
    savedSetState(state2, replace2);
    void setItem();
  };
  const configResult = config2(
    (...args) => {
      set(...args);
      void setItem();
    },
    get,
    api2
  );
  api2.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate2 = () => {
    var _a3, _b2;
    if (!storage) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => {
      var _a22;
      return cb((_a22 = get()) != null ? _a22 : configResult);
    });
    const postRehydrationCallback = ((_b2 = options.onRehydrateStorage) == null ? void 0 : _b2.call(options, (_a3 = get()) != null ? _a3 : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return [
              true,
              options.migrate(
                deserializedStorageValue.state,
                deserializedStorageValue.version
              )
            ];
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return [false, deserializedStorageValue.state];
        }
      }
      return [false, void 0];
    }).then((migrationResult) => {
      var _a22;
      const [migrated, migratedState] = migrationResult;
      stateFromStorage = options.merge(
        migratedState,
        (_a22 = get()) != null ? _a22 : configResult
      );
      set(stateFromStorage, true);
      if (migrated) {
        return setItem();
      }
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api2.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate2(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate2();
  }
  return stateFromStorage || configResult;
};
const persist = persistImpl;
const createStoreImpl = (createState) => {
  let state2;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace2) => {
    const nextState = typeof partial === "function" ? partial(state2) : partial;
    if (!Object.is(nextState, state2)) {
      const previousState = state2;
      state2 = (replace2 != null ? replace2 : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state2, nextState);
      listeners.forEach((listener) => listener(state2, previousState));
    }
  };
  const getState = () => state2;
  const getInitialState = () => initialState2;
  const subscribe2 = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api2 = { setState, getState, getInitialState, subscribe: subscribe2 };
  const initialState2 = state2 = createState(setState, getState, api2);
  return api2;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3) return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has = Object.prototype.hasOwnProperty, prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix2 = false;
    }
    function EE(fn2, context, once) {
      this.fn = fn2;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn2, context, once) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events2, name;
      if (this._eventsCount === 0) return names;
      for (name in events2 = this._events) {
        if (has.call(events2, name)) names.push(prefix2 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i4 = 0, l2 = handlers.length, ee2 = new Array(l2); i4 < l2; i4++) {
        ee2[i4] = handlers[i4].fn;
      }
      return ee2;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i4;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i4 = 1, args = new Array(len - 1); i4 < len; i4++) {
          args[i4 - 1] = arguments[i4];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length2 = listeners.length, j2;
        for (i4 = 0; i4 < length2; i4++) {
          if (listeners[i4].once) this.removeListener(event, listeners[i4].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i4].fn.call(listeners[i4].context);
              break;
            case 2:
              listeners[i4].fn.call(listeners[i4].context, a1);
              break;
            case 3:
              listeners[i4].fn.call(listeners[i4].context, a1, a2);
              break;
            case 4:
              listeners[i4].fn.call(listeners[i4].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners[i4].fn.apply(listeners[i4].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn2, context) {
      return addListener(this, event, fn2, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn2, context) {
      return addListener(this, event, fn2, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn2, context, once) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i4 = 0, events2 = [], length2 = listeners.length; i4 < length2; i4++) {
          if (listeners[i4].fn !== fn2 || once && !listeners[i4].once || context && listeners[i4].context !== context) {
            events2.push(listeners[i4]);
          }
        }
        if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix2;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module.exports = EventEmitter2;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var eventemitter3Exports = requireEventemitter3();
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
class Emitter {
  constructor(uid2) {
    Object.defineProperty(this, "uid", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: uid2
    });
    Object.defineProperty(this, "_emitter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new EventEmitter()
    });
  }
  on(eventName, fn2) {
    this._emitter.on(eventName, fn2);
  }
  once(eventName, fn2) {
    this._emitter.once(eventName, fn2);
  }
  off(eventName, fn2) {
    this._emitter.off(eventName, fn2);
  }
  emit(eventName, ...params) {
    const data2 = params[0];
    this._emitter.emit(eventName, { uid: this.uid, ...data2 });
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
}
function createEmitter(uid2) {
  return new Emitter(uid2);
}
function deserialize(value, reviver) {
  return JSON.parse(value, (key2, value_) => {
    let value2 = value_;
    if (value2?.__type === "bigint")
      value2 = BigInt(value2.value);
    if (value2?.__type === "Map")
      value2 = new Map(value2.value);
    return reviver?.(key2, value2) ?? value2;
  });
}
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join(".") || ".";
}
function getCutoff(array, value) {
  const { length: length2 } = array;
  for (let index2 = 0; index2 < length2; ++index2) {
    if (array[index2] === value) {
      return index2 + 1;
    }
  }
  return 0;
}
function createReplacer(replacer, circularReplacer) {
  const hasReplacer = typeof replacer === "function";
  const hasCircularReplacer = typeof circularReplacer === "function";
  const cache = [];
  const keys = [];
  return function replace2(key2, value) {
    if (typeof value === "object") {
      if (cache.length) {
        const thisCutoff = getCutoff(cache, this);
        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }
        keys[keys.length] = key2;
        const valueCutoff = getCutoff(cache, value);
        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(this, key2, value, getReferenceKey(keys, valueCutoff)) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;
        }
      } else {
        cache[0] = value;
        keys[0] = key2;
      }
    }
    return hasReplacer ? replacer.call(this, key2, value) : value;
  };
}
function serialize(value, replacer, indent, circularReplacer) {
  return JSON.stringify(value, createReplacer((key2, value_) => {
    let value2 = value_;
    if (typeof value2 === "bigint")
      value2 = { __type: "bigint", value: value_.toString() };
    if (value2 instanceof Map)
      value2 = { __type: "Map", value: Array.from(value_.entries()) };
    return replacer?.(key2, value2) ?? value2;
  }, circularReplacer), indent ?? void 0);
}
function createStorage(parameters) {
  const { deserialize: deserialize$1 = deserialize, key: prefix2 = "wagmi", serialize: serialize$12 = serialize, storage = noopStorage } = parameters;
  function unwrap(value) {
    if (value instanceof Promise)
      return value.then((x2) => x2).catch(() => null);
    return value;
  }
  return {
    ...storage,
    key: prefix2,
    async getItem(key2, defaultValue) {
      const value = storage.getItem(`${prefix2}.${key2}`);
      const unwrapped = await unwrap(value);
      if (unwrapped)
        return deserialize$1(unwrapped) ?? null;
      return defaultValue ?? null;
    },
    async setItem(key2, value) {
      const storageKey = `${prefix2}.${key2}`;
      if (value === null)
        await unwrap(storage.removeItem(storageKey));
      else
        await unwrap(storage.setItem(storageKey, serialize$12(value)));
    },
    async removeItem(key2) {
      await unwrap(storage.removeItem(`${prefix2}.${key2}`));
    }
  };
}
const noopStorage = {
  getItem: () => null,
  setItem: () => {
  },
  removeItem: () => {
  }
};
function getDefaultStorage() {
  const storage = (() => {
    if (typeof window !== "undefined" && window.localStorage)
      return window.localStorage;
    return noopStorage;
  })();
  return {
    getItem(key2) {
      return storage.getItem(key2);
    },
    removeItem(key2) {
      storage.removeItem(key2);
    },
    setItem(key2, value) {
      try {
        storage.setItem(key2, value);
      } catch {
      }
    }
  };
}
const size = 256;
let index$1 = size;
let buffer$1;
function uid(length2 = 11) {
  if (!buffer$1 || index$1 + length2 > size * 2) {
    buffer$1 = "";
    index$1 = 0;
    for (let i4 = 0; i4 < size; i4++) {
      buffer$1 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer$1.substring(index$1, index$1++ + length2);
}
function createConfig(parameters) {
  const { multiInjectedProviderDiscovery = true, storage = createStorage({
    storage: getDefaultStorage()
  }), syncConnectedChain = true, ssr = false, ...rest } = parameters;
  const mipd = typeof window !== "undefined" && multiInjectedProviderDiscovery ? createStore$1() : void 0;
  const chains2 = createStore(() => rest.chains);
  const connectors = createStore(() => {
    const collection = [];
    const rdnsSet = /* @__PURE__ */ new Set();
    for (const connectorFns of rest.connectors ?? []) {
      const connector = setup(connectorFns);
      collection.push(connector);
      if (!ssr && connector.rdns) {
        const rdnsValues = typeof connector.rdns === "string" ? [connector.rdns] : connector.rdns;
        for (const rdns of rdnsValues) {
          rdnsSet.add(rdns);
        }
      }
    }
    if (!ssr && mipd) {
      const providers = mipd.getProviders();
      for (const provider of providers) {
        if (rdnsSet.has(provider.info.rdns))
          continue;
        collection.push(setup(providerDetailToConnector(provider)));
      }
    }
    return collection;
  });
  function setup(connectorFn) {
    const emitter = createEmitter(uid());
    const connector = {
      ...connectorFn({
        emitter,
        chains: chains2.getState(),
        storage,
        transports: rest.transports
      }),
      emitter,
      uid: emitter.uid
    };
    emitter.on("connect", connect2);
    connector.setup?.();
    return connector;
  }
  function providerDetailToConnector(providerDetail) {
    const { info } = providerDetail;
    const provider = providerDetail.provider;
    return injected({ target: { ...info, id: info.rdns, provider } });
  }
  const clients = /* @__PURE__ */ new Map();
  function getClient(config2 = {}) {
    const chainId = config2.chainId ?? store.getState().chainId;
    const chain = chains2.getState().find((x2) => x2.id === chainId);
    if (config2.chainId && !chain)
      throw new ChainNotConfiguredError();
    {
      const client3 = clients.get(store.getState().chainId);
      if (client3 && !chain)
        return client3;
      if (!chain)
        throw new ChainNotConfiguredError();
    }
    {
      const client3 = clients.get(chainId);
      if (client3)
        return client3;
    }
    let client2;
    if (rest.client)
      client2 = rest.client({ chain });
    else {
      const chainId2 = chain.id;
      const chainIds = chains2.getState().map((x2) => x2.id);
      const properties2 = {};
      const entries2 = Object.entries(rest);
      for (const [key2, value] of entries2) {
        if (key2 === "chains" || key2 === "client" || key2 === "connectors" || key2 === "transports")
          continue;
        if (typeof value === "object") {
          if (chainId2 in value)
            properties2[key2] = value[chainId2];
          else {
            const hasChainSpecificValue = chainIds.some((x2) => x2 in value);
            if (hasChainSpecificValue)
              continue;
            properties2[key2] = value;
          }
        } else
          properties2[key2] = value;
      }
      client2 = createClient({
        ...properties2,
        chain,
        batch: properties2.batch ?? { multicall: true },
        transport: (parameters2) => rest.transports[chainId2]({ ...parameters2, connectors })
      });
    }
    clients.set(chainId, client2);
    return client2;
  }
  function getInitialState() {
    return {
      chainId: chains2.getState()[0].id,
      connections: /* @__PURE__ */ new Map(),
      current: null,
      status: "disconnected"
    };
  }
  let currentVersion;
  const prefix2 = "0.0.0-canary-";
  if (version$3.startsWith(prefix2))
    currentVersion = Number.parseInt(version$3.replace(prefix2, ""));
  else
    currentVersion = Number.parseInt(version$3.split(".")[0] ?? "0");
  const store = createStore(subscribeWithSelector(
    // only use persist middleware if storage exists
    storage ? persist(getInitialState, {
      migrate(persistedState, version2) {
        if (version2 === currentVersion)
          return persistedState;
        const initialState2 = getInitialState();
        const chainId = validatePersistedChainId(persistedState, initialState2.chainId);
        return { ...initialState2, chainId };
      },
      name: "store",
      partialize(state2) {
        return {
          connections: {
            __type: "Map",
            value: Array.from(state2.connections.entries()).map(([key2, connection]) => {
              const { id, name, type, uid: uid2 } = connection.connector;
              const connector = { id, name, type, uid: uid2 };
              return [key2, { ...connection, connector }];
            })
          },
          chainId: state2.chainId,
          current: state2.current
        };
      },
      merge(persistedState, currentState) {
        if (typeof persistedState === "object" && persistedState && "status" in persistedState)
          delete persistedState.status;
        const chainId = validatePersistedChainId(persistedState, currentState.chainId);
        return {
          ...currentState,
          ...persistedState,
          chainId
        };
      },
      skipHydration: ssr,
      storage,
      version: currentVersion
    }) : getInitialState
  ));
  store.setState(getInitialState());
  function validatePersistedChainId(persistedState, defaultChainId) {
    return persistedState && typeof persistedState === "object" && "chainId" in persistedState && typeof persistedState.chainId === "number" && chains2.getState().some((x2) => x2.id === persistedState.chainId) ? persistedState.chainId : defaultChainId;
  }
  if (syncConnectedChain)
    store.subscribe(({ connections, current }) => current ? connections.get(current)?.chainId : void 0, (chainId) => {
      const isChainConfigured = chains2.getState().some((x2) => x2.id === chainId);
      if (!isChainConfigured)
        return;
      return store.setState((x2) => ({
        ...x2,
        chainId: chainId ?? x2.chainId
      }));
    });
  mipd?.subscribe((providerDetails) => {
    const connectorIdSet = /* @__PURE__ */ new Set();
    const connectorRdnsSet = /* @__PURE__ */ new Set();
    for (const connector of connectors.getState()) {
      connectorIdSet.add(connector.id);
      if (connector.rdns) {
        const rdnsValues = typeof connector.rdns === "string" ? [connector.rdns] : connector.rdns;
        for (const rdns of rdnsValues) {
          connectorRdnsSet.add(rdns);
        }
      }
    }
    const newConnectors = [];
    for (const providerDetail of providerDetails) {
      if (connectorRdnsSet.has(providerDetail.info.rdns))
        continue;
      const connector = setup(providerDetailToConnector(providerDetail));
      if (connectorIdSet.has(connector.id))
        continue;
      newConnectors.push(connector);
    }
    if (storage && !store.persist.hasHydrated())
      return;
    connectors.setState((x2) => [...x2, ...newConnectors], true);
  });
  function change(data2) {
    store.setState((x2) => {
      const connection = x2.connections.get(data2.uid);
      if (!connection)
        return x2;
      return {
        ...x2,
        connections: new Map(x2.connections).set(data2.uid, {
          accounts: data2.accounts ?? connection.accounts,
          chainId: data2.chainId ?? connection.chainId,
          connector: connection.connector
        })
      };
    });
  }
  function connect2(data2) {
    if (store.getState().status === "connecting" || store.getState().status === "reconnecting")
      return;
    store.setState((x2) => {
      const connector = connectors.getState().find((x3) => x3.uid === data2.uid);
      if (!connector)
        return x2;
      if (connector.emitter.listenerCount("connect"))
        connector.emitter.off("connect", change);
      if (!connector.emitter.listenerCount("change"))
        connector.emitter.on("change", change);
      if (!connector.emitter.listenerCount("disconnect"))
        connector.emitter.on("disconnect", disconnect2);
      return {
        ...x2,
        connections: new Map(x2.connections).set(data2.uid, {
          accounts: data2.accounts,
          chainId: data2.chainId,
          connector
        }),
        current: data2.uid,
        status: "connected"
      };
    });
  }
  function disconnect2(data2) {
    store.setState((x2) => {
      const connection = x2.connections.get(data2.uid);
      if (connection) {
        const connector = connection.connector;
        if (connector.emitter.listenerCount("change"))
          connection.connector.emitter.off("change", change);
        if (connector.emitter.listenerCount("disconnect"))
          connection.connector.emitter.off("disconnect", disconnect2);
        if (!connector.emitter.listenerCount("connect"))
          connection.connector.emitter.on("connect", connect2);
      }
      x2.connections.delete(data2.uid);
      if (x2.connections.size === 0)
        return {
          ...x2,
          connections: /* @__PURE__ */ new Map(),
          current: null,
          status: "disconnected"
        };
      const nextConnection = x2.connections.values().next().value;
      return {
        ...x2,
        connections: new Map(x2.connections),
        current: nextConnection.connector.uid
      };
    });
  }
  return {
    get chains() {
      return chains2.getState();
    },
    get connectors() {
      return connectors.getState();
    },
    storage,
    getClient,
    get state() {
      return store.getState();
    },
    setState(value) {
      let newState;
      if (typeof value === "function")
        newState = value(store.getState());
      else
        newState = value;
      const initialState2 = getInitialState();
      if (typeof newState !== "object")
        newState = initialState2;
      const isCorrupt = Object.keys(initialState2).some((x2) => !(x2 in newState));
      if (isCorrupt)
        newState = initialState2;
      store.setState(newState, true);
    },
    subscribe(selector, listener, options) {
      return store.subscribe(selector, listener, options ? {
        ...options,
        fireImmediately: options.emitImmediately
        // Workaround cast since Zustand does not support `'exactOptionalPropertyTypes'`
      } : void 0);
    },
    _internal: {
      mipd,
      async revalidate() {
        const state2 = store.getState();
        const connections = state2.connections;
        let current = state2.current;
        for (const [, connection] of connections) {
          const connector = connection.connector;
          const isAuthorized = connector.isAuthorized ? await connector.isAuthorized() : false;
          if (isAuthorized)
            continue;
          connections.delete(connector.uid);
          if (current === connector.uid)
            current = null;
        }
        store.setState((x2) => ({ ...x2, connections, current }));
      },
      store,
      ssr: Boolean(ssr),
      syncConnectedChain,
      transports: rest.transports,
      chains: {
        setState(value) {
          const nextChains = typeof value === "function" ? value(chains2.getState()) : value;
          if (nextChains.length === 0)
            return;
          return chains2.setState(nextChains, true);
        },
        subscribe(listener) {
          return chains2.subscribe(listener);
        }
      },
      connectors: {
        providerDetailToConnector,
        setup,
        setState(value) {
          return connectors.setState(typeof value === "function" ? value(connectors.getState()) : value, true);
        },
        subscribe(listener) {
          return connectors.subscribe(listener);
        }
      },
      events: { change, connect: connect2, disconnect: disconnect2 }
    }
  };
}
function hydrate(config2, parameters) {
  const { initialState: initialState2, reconnectOnMount } = parameters;
  if (initialState2 && !config2._internal.store.persist.hasHydrated())
    config2.setState({
      ...initialState2,
      chainId: config2.chains.some((x2) => x2.id === initialState2.chainId) ? initialState2.chainId : config2.chains[0].id,
      connections: reconnectOnMount ? initialState2.connections : /* @__PURE__ */ new Map(),
      status: reconnectOnMount ? "reconnecting" : "disconnected"
    });
  return {
    async onMount() {
      if (config2._internal.ssr) {
        await config2._internal.store.persist.rehydrate();
        if (config2._internal.mipd) {
          config2._internal.connectors.setState((connectors) => {
            const rdnsSet = /* @__PURE__ */ new Set();
            for (const connector of connectors ?? []) {
              if (connector.rdns) {
                const rdnsValues = Array.isArray(connector.rdns) ? connector.rdns : [connector.rdns];
                for (const rdns of rdnsValues) {
                  rdnsSet.add(rdns);
                }
              }
            }
            const mipdConnectors = [];
            const providers = config2._internal.mipd?.getProviders() ?? [];
            for (const provider of providers) {
              if (rdnsSet.has(provider.info.rdns))
                continue;
              const connectorFn = config2._internal.connectors.providerDetailToConnector(provider);
              const connector = config2._internal.connectors.setup(connectorFn);
              mipdConnectors.push(connector);
            }
            return [...connectors, ...mipdConnectors];
          });
        }
      }
      if (reconnectOnMount)
        reconnect(config2);
      else if (config2.storage)
        config2.setState((x2) => ({
          ...x2,
          connections: /* @__PURE__ */ new Map()
        }));
    }
  };
}
function extractRpcUrls(parameters) {
  const { chain } = parameters;
  const fallbackUrl = chain.rpcUrls.default.http[0];
  if (!parameters.transports)
    return [fallbackUrl];
  const transport = parameters.transports?.[chain.id]?.({ chain });
  const transports = transport?.value?.transports || [transport];
  return transports.map(({ value }) => value?.url || fallbackUrl);
}
function Hydrate(parameters) {
  const { children, config: config2, initialState: initialState2, reconnectOnMount = true } = parameters;
  const { onMount } = hydrate(config2, {
    initialState: initialState2,
    reconnectOnMount
  });
  if (!config2._internal.ssr)
    onMount();
  const active = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (!active.current)
      return;
    if (!config2._internal.ssr)
      return;
    onMount();
    return () => {
      active.current = false;
    };
  }, []);
  return children;
}
const WagmiContext = reactExports.createContext(void 0);
function WagmiProvider(parameters) {
  const { children, config: config2 } = parameters;
  const props = { value: config2 };
  return reactExports.createElement(Hydrate, parameters, reactExports.createElement(WagmiContext.Provider, props, children));
}
const version$2 = "2.16.9";
const getVersion = () => `wagmi@${version$2}`;
class BaseError5 extends BaseError$1 {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiError"
    });
  }
  get docsBaseUrl() {
    return "https://wagmi.sh/react";
  }
  get version() {
    return getVersion();
  }
}
class WagmiProviderNotFoundError extends BaseError5 {
  constructor() {
    super("`useConfig` must be used within `WagmiProvider`.", {
      docsPath: "/api/WagmiProvider"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiProviderNotFoundError"
    });
  }
}
function useConfig(parameters = {}) {
  const config2 = parameters.config ?? reactExports.useContext(WagmiContext);
  if (!config2)
    throw new WagmiProviderNotFoundError();
  return config2;
}
function watchChains(config2, parameters) {
  const { onChange } = parameters;
  return config2._internal.chains.subscribe((chains2, prevChains) => {
    onChange(chains2, prevChains);
  });
}
var withSelector = { exports: {} };
var withSelector_production = {};
var shim = { exports: {} };
var useSyncExternalStoreShim_production = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_production;
function requireUseSyncExternalStoreShim_production() {
  if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
  hasRequiredUseSyncExternalStoreShim_production = 1;
  var React2 = requireReact();
  function is(x2, y3) {
    return x2 === y3 && (0 !== x2 || 1 / x2 === 1 / y3) || x2 !== x2 && y3 !== y3;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is, useState = React2.useState, useEffect = React2.useEffect, useLayoutEffect = React2.useLayoutEffect, useDebugValue = React2.useDebugValue;
  function useSyncExternalStore$2(subscribe2, getSnapshot) {
    var value = getSnapshot(), _useState = useState({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    useLayoutEffect(
      function() {
        inst.value = value;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      },
      [subscribe2, value, getSnapshot]
    );
    useEffect(
      function() {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        return subscribe2(function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        });
      },
      [subscribe2]
    );
    useDebugValue(value);
    return value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error) {
      return true;
    }
  }
  function useSyncExternalStore$1(subscribe2, getSnapshot) {
    return getSnapshot();
  }
  var shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
  useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React2.useSyncExternalStore ? React2.useSyncExternalStore : shim2;
  return useSyncExternalStoreShim_production;
}
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim.exports;
  hasRequiredShim = 1;
  {
    shim.exports = requireUseSyncExternalStoreShim_production();
  }
  return shim.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_production;
function requireWithSelector_production() {
  if (hasRequiredWithSelector_production) return withSelector_production;
  hasRequiredWithSelector_production = 1;
  var React2 = requireReact(), shim2 = requireShim();
  function is(x2, y3) {
    return x2 === y3 && (0 !== x2 || 1 / x2 === 1 / y3) || x2 !== x2 && y3 !== y3;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim2.useSyncExternalStore, useRef = React2.useRef, useEffect = React2.useEffect, useMemo = React2.useMemo, useDebugValue = React2.useDebugValue;
  withSelector_production.useSyncExternalStoreWithSelector = function(subscribe2, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
      var inst = { hasValue: false, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = true;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector(nextSnapshot);
            if (void 0 !== isEqual && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
            return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          null === maybeGetServerSnapshot ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual]
    );
    var value = useSyncExternalStore(subscribe2, instRef[0], instRef[1]);
    useEffect(
      function() {
        inst.hasValue = true;
        inst.value = value;
      },
      [value]
    );
    useDebugValue(value);
    return value;
  };
  return withSelector_production;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  {
    withSelector.exports = requireWithSelector_production();
  }
  return withSelector.exports;
}
var withSelectorExports = requireWithSelector();
const isPlainObject$1 = (obj) => typeof obj === "object" && !Array.isArray(obj);
function useSyncExternalStoreWithTracked(subscribe2, getSnapshot, getServerSnapshot = getSnapshot, isEqual = deepEqual) {
  const trackedKeys = reactExports.useRef([]);
  const result = withSelectorExports.useSyncExternalStoreWithSelector(subscribe2, getSnapshot, getServerSnapshot, (x2) => x2, (a2, b2) => {
    if (isPlainObject$1(a2) && isPlainObject$1(b2) && trackedKeys.current.length) {
      for (const key2 of trackedKeys.current) {
        const equal = isEqual(a2[key2], b2[key2]);
        if (!equal)
          return false;
      }
      return true;
    }
    return isEqual(a2, b2);
  });
  return reactExports.useMemo(() => {
    if (isPlainObject$1(result)) {
      const trackedResult = { ...result };
      let properties2 = {};
      for (const [key2, value] of Object.entries(trackedResult)) {
        properties2 = {
          ...properties2,
          [key2]: {
            configurable: false,
            enumerable: true,
            get: () => {
              if (!trackedKeys.current.includes(key2)) {
                trackedKeys.current.push(key2);
              }
              return value;
            }
          }
        };
      }
      Object.defineProperties(trackedResult, properties2);
      return trackedResult;
    }
    return result;
  }, [result]);
}
function useAccount(parameters = {}) {
  const config2 = useConfig(parameters);
  return useSyncExternalStoreWithTracked((onChange) => watchAccount(config2, { onChange }), () => getAccount(config2));
}
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};
var defaultTimeoutProvider = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: (callback, delay2) => setTimeout(callback, delay2),
  clearTimeout: (timeoutId) => clearTimeout(timeoutId),
  setInterval: (callback, delay2) => setInterval(callback, delay2),
  clearInterval: (intervalId) => clearInterval(intervalId)
};
var TimeoutManager = (_a2 = class {
  constructor() {
    // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
    // type at app boot; and if we leave that type, then any new timer provider
    // would need to support ReturnType<typeof setTimeout>, which is infeasible.
    //
    // We settle for type safety for the TimeoutProvider type, and accept that
    // this class is unsafe internally to allow for extension.
    __privateAdd(this, _provider, defaultTimeoutProvider);
    __privateAdd(this, _providerCalled, false);
  }
  setTimeoutProvider(provider) {
    __privateSet(this, _provider, provider);
  }
  setTimeout(callback, delay2) {
    return __privateGet(this, _provider).setTimeout(callback, delay2);
  }
  clearTimeout(timeoutId) {
    __privateGet(this, _provider).clearTimeout(timeoutId);
  }
  setInterval(callback, delay2) {
    return __privateGet(this, _provider).setInterval(callback, delay2);
  }
  clearInterval(intervalId) {
    __privateGet(this, _provider).clearInterval(intervalId);
  }
}, _provider = new WeakMap(), _providerCalled = new WeakMap(), _a2);
var timeoutManager = new TimeoutManager();
function systemSetTimeoutZero(callback) {
  setTimeout(callback, 0);
}
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop() {
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = options?.queryKeyHashFn || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_2, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key2) => {
      result[key2] = val[key2];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    return Object.keys(b2).every((key2) => partialMatchKey(a2[key2], b2[key2]));
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty;
function replaceEqualDeep(a2, b2) {
  if (a2 === b2) {
    return a2;
  }
  const array = isPlainArray(a2) && isPlainArray(b2);
  if (!array && !(isPlainObject(a2) && isPlainObject(b2))) return b2;
  const aItems = array ? a2 : Object.keys(a2);
  const aSize = aItems.length;
  const bItems = array ? b2 : Object.keys(b2);
  const bSize = bItems.length;
  const copy2 = array ? new Array(bSize) : {};
  let equalItems = 0;
  for (let i4 = 0; i4 < bSize; i4++) {
    const key2 = array ? i4 : bItems[i4];
    const aItem = a2[key2];
    const bItem = b2[key2];
    if (aItem === bItem) {
      copy2[key2] = aItem;
      if (array ? i4 < aSize : hasOwn.call(a2, key2)) equalItems++;
      continue;
    }
    if (aItem === null || bItem === null || typeof aItem !== "object" || typeof bItem !== "object") {
      copy2[key2] = bItem;
      continue;
    }
    const v2 = replaceEqualDeep(aItem, bItem);
    copy2[key2] = v2;
    if (v2 === aItem) equalItems++;
  }
  return aSize === bSize && equalItems === aSize ? a2 : copy2;
}
function shallowEqualObjects(a2, b2) {
  if (!b2 || Object.keys(a2).length !== Object.keys(b2).length) {
    return false;
  }
  for (const key2 in a2) {
    if (a2[key2] !== b2[key2]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o2) {
  if (!hasObjectPrototype(o2)) {
    return false;
  }
  const ctor = o2.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o2) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function sleep(timeout) {
  return new Promise((resolve) => {
    timeoutManager.setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data2, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data2);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data2);
  }
  return data2;
}
function addToEnd(items, item, max2 = 0) {
  const newItems = [...items, item];
  return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max2 = 0) {
  const newItems = [item, ...items];
  return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (!options.queryFn && fetchOptions?.initialPromise) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
function shouldThrowError(throwOnError, params) {
  if (typeof throwOnError === "function") {
    return throwOnError(...params);
  }
  return !!throwOnError;
}
var FocusManager = (_b = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused);
    __privateAdd(this, _cleanup);
    __privateAdd(this, _setup);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a3;
    if (!this.hasListeners()) {
      (_a3 = __privateGet(this, _cleanup)) == null ? void 0 : _a3.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a3;
    __privateSet(this, _setup, setup);
    (_a3 = __privateGet(this, _cleanup)) == null ? void 0 : _a3.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return globalThis.document?.visibilityState !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _b);
var focusManager = new FocusManager();
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data2) {
    Object.assign(thenable, data2);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}
var defaultScheduler = systemSetTimeoutZero;
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = defaultScheduler;
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn2) => {
      notifyFn = fn2;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn2) => {
      batchNotifyFn = fn2;
    },
    setScheduler: (fn2) => {
      scheduleFn = fn2;
    }
  };
}
var notifyManager = createNotifyManager();
var OnlineManager = (_c = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2);
    __privateAdd(this, _setup2);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a3;
    if (!this.hasListeners()) {
      (_a3 = __privateGet(this, _cleanup2)) == null ? void 0 : _a3.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a3;
    __privateSet(this, _setup2, setup);
    (_a3 = __privateGet(this, _cleanup2)) == null ? void 0 : _a3.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online) {
    const changed = __privateGet(this, _online) !== online;
    if (changed) {
      __privateSet(this, _online, online);
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _c);
var onlineManager = new OnlineManager();
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options?.revert;
    this.silent = options?.silent;
  }
};
function createRetryer(config2) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let continueFn;
  const thenable = pendingThenable();
  const isResolved = () => thenable.status !== "pending";
  const cancel = (cancelOptions) => {
    if (!isResolved()) {
      const error = new CancelledError(cancelOptions);
      reject(error);
      config2.onCancel?.(error);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config2.networkMode === "always" || onlineManager.isOnline()) && config2.canRun();
  const canStart = () => canFetch(config2.networkMode) && config2.canRun();
  const resolve = (value) => {
    if (!isResolved()) {
      continueFn?.();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved()) {
      continueFn?.();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        if (isResolved() || canContinue()) {
          continueResolve(value);
        }
      };
      config2.onPause?.();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved()) {
        config2.onContinue?.();
      }
    });
  };
  const run = () => {
    if (isResolved()) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config2.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config2.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      if (isResolved()) {
        return;
      }
      const retry = config2.retry ?? (isServer ? 0 : 3);
      const retryDelay = config2.retryDelay ?? defaultRetryDelay;
      const delay2 = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry2 = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry2) {
        reject(error);
        return;
      }
      failureCount++;
      config2.onFail?.(failureCount, error);
      sleep(delay2).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise: thenable,
    status: () => thenable.status,
    cancel,
    continue: () => {
      continueFn?.();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    }
  };
}
var Removable = (_d = class {
  constructor() {
    __privateAdd(this, _gcTimeout);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      __privateSet(this, _gcTimeout, timeoutManager.setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime));
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (__privateGet(this, _gcTimeout)) {
      timeoutManager.clearTimeout(__privateGet(this, _gcTimeout));
      __privateSet(this, _gcTimeout, void 0);
    }
  }
}, _gcTimeout = new WeakMap(), _d);
var Query = (_e2 = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _Query_instances);
    __privateAdd(this, _initialState);
    __privateAdd(this, _revertState);
    __privateAdd(this, _cache);
    __privateAdd(this, _client);
    __privateAdd(this, _retryer);
    __privateAdd(this, _defaultOptions);
    __privateAdd(this, _abortSignalConsumed);
    __privateSet(this, _abortSignalConsumed, false);
    __privateSet(this, _defaultOptions, config2.defaultOptions);
    this.setOptions(config2.options);
    this.observers = [];
    __privateSet(this, _client, config2.client);
    __privateSet(this, _cache, __privateGet(this, _client).getQueryCache());
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    __privateSet(this, _initialState, getDefaultState$1(this.options));
    this.state = config2.state ?? __privateGet(this, _initialState);
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return __privateGet(this, _retryer)?.promise;
  }
  setOptions(options) {
    this.options = { ...__privateGet(this, _defaultOptions), ...options };
    this.updateGcTime(this.options.gcTime);
    if (this.state && this.state.data === void 0) {
      const defaultState2 = getDefaultState$1(this.options);
      if (defaultState2.data !== void 0) {
        this.setData(defaultState2.data, {
          updatedAt: defaultState2.dataUpdatedAt,
          manual: true
        });
        __privateSet(this, _initialState, defaultState2);
      }
    }
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      __privateGet(this, _cache).remove(this);
    }
  }
  setData(newData, options) {
    const data2 = replaceData(this.state.data, newData, this.options);
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
      data: data2,
      type: "success",
      dataUpdatedAt: options?.updatedAt,
      manual: options?.manual
    });
    return data2;
  }
  setState(state2, setStateOptions) {
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "setState", state: state2, setStateOptions });
  }
  cancel(options) {
    const promise = __privateGet(this, _retryer)?.promise;
    __privateGet(this, _retryer)?.cancel(options);
    return promise ? promise.then(noop).catch(noop) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(__privateGet(this, _initialState));
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    if (this.getObserversCount() > 0) {
      return !this.isActive();
    }
    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => resolveStaleTime(observer.options.staleTime, this) === "static"
      );
    }
    return false;
  }
  isStale() {
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(staleTime = 0) {
    if (this.state.data === void 0) {
      return true;
    }
    if (staleTime === "static") {
      return false;
    }
    if (this.state.isInvalidated) {
      return true;
    }
    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    const observer = this.observers.find((x2) => x2.shouldFetchOnWindowFocus());
    observer?.refetch({ cancelRefetch: false });
    __privateGet(this, _retryer)?.continue();
  }
  onOnline() {
    const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
    observer?.refetch({ cancelRefetch: false });
    __privateGet(this, _retryer)?.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x2) => x2 !== observer);
      if (!this.observers.length) {
        if (__privateGet(this, _retryer)) {
          if (__privateGet(this, _abortSignalConsumed)) {
            __privateGet(this, _retryer).cancel({ revert: true });
          } else {
            __privateGet(this, _retryer).cancelRetry();
          }
        }
        this.scheduleGc();
      }
      __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "invalidate" });
    }
  }
  async fetch(options, fetchOptions) {
    if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    __privateGet(this, _retryer)?.status() !== "rejected") {
      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {
        this.cancel({ silent: true });
      } else if (__privateGet(this, _retryer)) {
        __privateGet(this, _retryer).continueRetry();
        return __privateGet(this, _retryer).promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x2) => x2.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          __privateSet(this, _abortSignalConsumed, true);
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const createQueryFnContext = () => {
        const queryFnContext2 = {
          client: __privateGet(this, _client),
          queryKey: this.queryKey,
          meta: this.meta
        };
        addSignalProperty(queryFnContext2);
        return queryFnContext2;
      };
      const queryFnContext = createQueryFnContext();
      __privateSet(this, _abortSignalConsumed, false);
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const createFetchContext = () => {
      const context2 = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        client: __privateGet(this, _client),
        state: this.state,
        fetchFn
      };
      addSignalProperty(context2);
      return context2;
    };
    const context = createFetchContext();
    this.options.behavior?.onFetch(context, this);
    __privateSet(this, _revertState, this.state);
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== context.fetchOptions?.meta) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "fetch", meta: context.fetchOptions?.meta });
    }
    __privateSet(this, _retryer, createRetryer({
      initialPromise: fetchOptions?.initialPromise,
      fn: context.fetchFn,
      onCancel: (error) => {
        if (error instanceof CancelledError && error.revert) {
          this.setState({
            ...__privateGet(this, _revertState),
            fetchStatus: "idle"
          });
        }
        abortController.abort();
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    }));
    try {
      const data2 = await __privateGet(this, _retryer).start();
      if (data2 === void 0) {
        if (false) ;
        throw new Error(`${this.queryHash} data is undefined`);
      }
      this.setData(data2);
      __privateGet(this, _cache).config.onSuccess?.(data2, this);
      __privateGet(this, _cache).config.onSettled?.(
        data2,
        this.state.error,
        this
      );
      return data2;
    } catch (error) {
      if (error instanceof CancelledError) {
        if (error.silent) {
          return __privateGet(this, _retryer).promise;
        } else if (error.revert) {
          if (this.state.data === void 0) {
            throw error;
          }
          return this.state.data;
        }
      }
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
        type: "error",
        error
      });
      __privateGet(this, _cache).config.onError?.(
        error,
        this
      );
      __privateGet(this, _cache).config.onSettled?.(
        this.state.data,
        error,
        this
      );
      throw error;
    } finally {
      this.scheduleGc();
    }
  }
}, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _client = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _Query_instances = new WeakSet(), dispatch_fn = function(action) {
  const reducer = (state2) => {
    switch (action.type) {
      case "failed":
        return {
          ...state2,
          fetchFailureCount: action.failureCount,
          fetchFailureReason: action.error
        };
      case "pause":
        return {
          ...state2,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...state2,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...state2,
          ...fetchState(state2.data, this.options),
          fetchMeta: action.meta ?? null
        };
      case "success":
        const newState = {
          ...state2,
          data: action.data,
          dataUpdateCount: state2.dataUpdateCount + 1,
          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: false,
          status: "success",
          ...!action.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
        __privateSet(this, _revertState, action.manual ? newState : void 0);
        return newState;
      case "error":
        const error = action.error;
        return {
          ...state2,
          error,
          errorUpdateCount: state2.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state2.fetchFailureCount + 1,
          fetchFailureReason: error,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...state2,
          isInvalidated: true
        };
      case "setState":
        return {
          ...state2,
          ...action.state
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    this.observers.forEach((observer) => {
      observer.onQueryUpdate();
    });
    __privateGet(this, _cache).notify({ query: this, type: "updated", action });
  });
}, _e2);
function fetchState(data2, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data2 === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState$1(options) {
  const data2 = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data2 !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data: data2,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      const options = context.options;
      const direction = context.fetchOptions?.meta?.fetchMore?.direction;
      const oldPages = context.state.data?.pages || [];
      const oldPageParams = context.state.data?.pageParams || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data2, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data2.pages.length) {
            return Promise.resolve(data2);
          }
          const createQueryFnContext = () => {
            const queryFnContext2 = {
              client: context.client,
              queryKey: context.queryKey,
              pageParam: param,
              direction: previous ? "backward" : "forward",
              meta: context.options.meta
            };
            addSignalProperty(queryFnContext2);
            return queryFnContext2;
          };
          const queryFnContext = createQueryFnContext();
          const page = await queryFn(queryFnContext);
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data2.pages, page, maxPages),
            pageParams: addTo(data2.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          return context.options.persister?.(
            fetchFn,
            {
              client: context.client,
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;
}
var Mutation = (_f2 = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _Mutation_instances);
    __privateAdd(this, _observers);
    __privateAdd(this, _mutationCache);
    __privateAdd(this, _retryer2);
    this.mutationId = config2.mutationId;
    __privateSet(this, _mutationCache, config2.mutationCache);
    __privateSet(this, _observers, []);
    this.state = config2.state || getDefaultState();
    this.setOptions(config2.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!__privateGet(this, _observers).includes(observer)) {
      __privateGet(this, _observers).push(observer);
      this.clearGcTimeout();
      __privateGet(this, _mutationCache).notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    __privateSet(this, _observers, __privateGet(this, _observers).filter((x2) => x2 !== observer));
    this.scheduleGc();
    __privateGet(this, _mutationCache).notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!__privateGet(this, _observers).length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        __privateGet(this, _mutationCache).remove(this);
      }
    }
  }
  continue() {
    return __privateGet(this, _retryer2)?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    const onContinue = () => {
      __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "continue" });
    };
    __privateSet(this, _retryer2, createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables);
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pause" });
      },
      onContinue,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => __privateGet(this, _mutationCache).canRun(this)
    }));
    const restored = this.state.status === "pending";
    const isPaused = !__privateGet(this, _retryer2).canStart();
    try {
      if (restored) {
        onContinue();
      } else {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
        await __privateGet(this, _mutationCache).config.onMutate?.(
          variables,
          this
        );
        const context = await this.options.onMutate?.(variables);
        if (context !== this.state.context) {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data2 = await __privateGet(this, _retryer2).start();
      await __privateGet(this, _mutationCache).config.onSuccess?.(
        data2,
        variables,
        this.state.context,
        this
      );
      await this.options.onSuccess?.(data2, variables, this.state.context);
      await __privateGet(this, _mutationCache).config.onSettled?.(
        data2,
        null,
        this.state.variables,
        this.state.context,
        this
      );
      await this.options.onSettled?.(data2, null, variables, this.state.context);
      __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "success", data: data2 });
      return data2;
    } catch (error) {
      try {
        await __privateGet(this, _mutationCache).config.onError?.(
          error,
          variables,
          this.state.context,
          this
        );
        await this.options.onError?.(
          error,
          variables,
          this.state.context
        );
        await __privateGet(this, _mutationCache).config.onSettled?.(
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this
        );
        await this.options.onSettled?.(
          void 0,
          error,
          variables,
          this.state.context
        );
        throw error;
      } finally {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "error", error });
      }
    } finally {
      __privateGet(this, _mutationCache).runNext(this);
    }
  }
}, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _Mutation_instances = new WeakSet(), dispatch_fn2 = function(action) {
  const reducer = (state2) => {
    switch (action.type) {
      case "failed":
        return {
          ...state2,
          failureCount: action.failureCount,
          failureReason: action.error
        };
      case "pause":
        return {
          ...state2,
          isPaused: true
        };
      case "continue":
        return {
          ...state2,
          isPaused: false
        };
      case "pending":
        return {
          ...state2,
          context: action.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: action.isPaused,
          status: "pending",
          variables: action.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...state2,
          data: action.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: false
        };
      case "error":
        return {
          ...state2,
          data: void 0,
          error: action.error,
          failureCount: state2.failureCount + 1,
          failureReason: action.error,
          isPaused: false,
          status: "error"
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    __privateGet(this, _observers).forEach((observer) => {
      observer.onMutationUpdate(action);
    });
    __privateGet(this, _mutationCache).notify({
      mutation: this,
      type: "updated",
      action
    });
  });
}, _f2);
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var MutationCache = (_g = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _mutations);
    __privateAdd(this, _scopes);
    __privateAdd(this, _mutationId);
    this.config = config2;
    __privateSet(this, _mutations, /* @__PURE__ */ new Set());
    __privateSet(this, _scopes, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationId, 0);
  }
  build(client2, options, state2) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++__privateWrapper(this, _mutationId)._,
      options: client2.defaultMutationOptions(options),
      state: state2
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    __privateGet(this, _mutations).add(mutation);
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const scopedMutations = __privateGet(this, _scopes).get(scope);
      if (scopedMutations) {
        scopedMutations.push(mutation);
      } else {
        __privateGet(this, _scopes).set(scope, [mutation]);
      }
    }
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    if (__privateGet(this, _mutations).delete(mutation)) {
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const scopedMutations = __privateGet(this, _scopes).get(scope);
        if (scopedMutations) {
          if (scopedMutations.length > 1) {
            const index2 = scopedMutations.indexOf(mutation);
            if (index2 !== -1) {
              scopedMutations.splice(index2, 1);
            }
          } else if (scopedMutations[0] === mutation) {
            __privateGet(this, _scopes).delete(scope);
          }
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const mutationsWithSameScope = __privateGet(this, _scopes).get(scope);
      const firstPendingMutation = mutationsWithSameScope?.find(
        (m3) => m3.state.status === "pending"
      );
      return !firstPendingMutation || firstPendingMutation === mutation;
    } else {
      return true;
    }
  }
  runNext(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const foundMutation = __privateGet(this, _scopes).get(scope)?.find((m3) => m3 !== mutation && m3.state.isPaused);
      return foundMutation?.continue() ?? Promise.resolve();
    } else {
      return Promise.resolve();
    }
  }
  clear() {
    notifyManager.batch(() => {
      __privateGet(this, _mutations).forEach((mutation) => {
        this.notify({ type: "removed", mutation });
      });
      __privateGet(this, _mutations).clear();
      __privateGet(this, _scopes).clear();
    });
  }
  getAll() {
    return Array.from(__privateGet(this, _mutations));
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x2) => x2.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop))
      )
    );
  }
}, _mutations = new WeakMap(), _scopes = new WeakMap(), _mutationId = new WeakMap(), _g);
function scopeFor(mutation) {
  return mutation.options.scope?.id;
}
var MutationObserver$1 = (_h = class extends Subscribable {
  constructor(client2, options) {
    super();
    __privateAdd(this, _MutationObserver_instances);
    __privateAdd(this, _client2);
    __privateAdd(this, _currentResult);
    __privateAdd(this, _currentMutation);
    __privateAdd(this, _mutateOptions);
    __privateSet(this, _client2, client2);
    this.setOptions(options);
    this.bindMethods();
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    this.options = __privateGet(this, _client2).defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client2).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _currentMutation),
        observer: this
      });
    }
    if (prevOptions?.mutationKey && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (__privateGet(this, _currentMutation)?.state.status === "pending") {
      __privateGet(this, _currentMutation).setOptions(this.options);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      __privateGet(this, _currentMutation)?.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn).call(this, action);
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult);
  }
  reset() {
    __privateGet(this, _currentMutation)?.removeObserver(this);
    __privateSet(this, _currentMutation, void 0);
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn).call(this);
  }
  mutate(variables, options) {
    __privateSet(this, _mutateOptions, options);
    __privateGet(this, _currentMutation)?.removeObserver(this);
    __privateSet(this, _currentMutation, __privateGet(this, _client2).getMutationCache().build(__privateGet(this, _client2), this.options));
    __privateGet(this, _currentMutation).addObserver(this);
    return __privateGet(this, _currentMutation).execute(variables);
  }
}, _client2 = new WeakMap(), _currentResult = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _MutationObserver_instances = new WeakSet(), updateResult_fn = function() {
  const state2 = __privateGet(this, _currentMutation)?.state ?? getDefaultState();
  __privateSet(this, _currentResult, {
    ...state2,
    isPending: state2.status === "pending",
    isSuccess: state2.status === "success",
    isError: state2.status === "error",
    isIdle: state2.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, notify_fn = function(action) {
  notifyManager.batch(() => {
    if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
      const variables = __privateGet(this, _currentResult).variables;
      const context = __privateGet(this, _currentResult).context;
      if (action?.type === "success") {
        __privateGet(this, _mutateOptions).onSuccess?.(action.data, variables, context);
        __privateGet(this, _mutateOptions).onSettled?.(action.data, null, variables, context);
      } else if (action?.type === "error") {
        __privateGet(this, _mutateOptions).onError?.(action.error, variables, context);
        __privateGet(this, _mutateOptions).onSettled?.(
          void 0,
          action.error,
          variables,
          context
        );
      }
    }
    this.listeners.forEach((listener) => {
      listener(__privateGet(this, _currentResult));
    });
  });
}, _h);
var QueryCache = (_i2 = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _queries);
    this.config = config2;
    __privateSet(this, _queries, /* @__PURE__ */ new Map());
  }
  build(client2, options, state2) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        client: client2,
        queryKey,
        queryHash,
        options: client2.defaultQueryOptions(options),
        state: state2,
        defaultOptions: client2.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!__privateGet(this, _queries).has(query.queryHash)) {
      __privateGet(this, _queries).set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = __privateGet(this, _queries).get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        __privateGet(this, _queries).delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return __privateGet(this, _queries).get(queryHash);
  }
  getAll() {
    return [...__privateGet(this, _queries).values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
}, _queries = new WeakMap(), _i2);
var QueryClient = (_j = class {
  constructor(config2 = {}) {
    __privateAdd(this, _queryCache);
    __privateAdd(this, _mutationCache2);
    __privateAdd(this, _defaultOptions2);
    __privateAdd(this, _queryDefaults);
    __privateAdd(this, _mutationDefaults);
    __privateAdd(this, _mountCount);
    __privateAdd(this, _unsubscribeFocus);
    __privateAdd(this, _unsubscribeOnline);
    __privateSet(this, _queryCache, config2.queryCache || new QueryCache());
    __privateSet(this, _mutationCache2, config2.mutationCache || new MutationCache());
    __privateSet(this, _defaultOptions2, config2.defaultOptions || {});
    __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mountCount, 0);
  }
  mount() {
    __privateWrapper(this, _mountCount)._++;
    if (__privateGet(this, _mountCount) !== 1) return;
    __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onFocus();
      }
    }));
    __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onOnline();
      }
    }));
  }
  unmount() {
    var _a3, _b2;
    __privateWrapper(this, _mountCount)._--;
    if (__privateGet(this, _mountCount) !== 0) return;
    (_a3 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a3.call(this);
    __privateSet(this, _unsubscribeFocus, void 0);
    (_b2 = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b2.call(this);
    __privateSet(this, _unsubscribeOnline, void 0);
  }
  isFetching(filters) {
    return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return __privateGet(this, _queryCache).get(options.queryHash)?.state.data;
  }
  ensureQueryData(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    const cachedData = query.state.data;
    if (cachedData === void 0) {
      return this.fetchQuery(options);
    }
    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
      void this.prefetchQuery(defaultedOptions);
    }
    return Promise.resolve(cachedData);
  }
  getQueriesData(filters) {
    return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state: state2 }) => {
      const data2 = state2.data;
      return [queryKey, data2];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = __privateGet(this, _queryCache).get(
      defaultedOptions.queryHash
    );
    const prevData = query?.state.data;
    const data2 = functionalUpdate(updater, prevData);
    if (data2 === void 0) {
      return void 0;
    }
    return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data2, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return __privateGet(this, _queryCache).get(
      options.queryHash
    )?.state;
  }
  removeQueries(filters) {
    const queryCache = __privateGet(this, _queryCache);
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = __privateGet(this, _queryCache);
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(
        {
          type: "active",
          ...filters
        },
        options
      );
    });
  }
  cancelQueries(filters, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop).catch(noop);
  }
  invalidateQueries(filters, options = {}) {
    return notifyManager.batch(() => {
      __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters?.refetchType === "none") {
        return Promise.resolve();
      }
      return this.refetchQueries(
        {
          ...filters,
          type: filters?.refetchType ?? filters?.type ?? "active"
        },
        options
      );
    });
  }
  refetchQueries(filters, options = {}) {
    const fetchOptions = {
      ...options,
      cancelRefetch: options.cancelRefetch ?? true
    };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop).catch(noop);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop).catch(noop);
  }
  ensureInfiniteQueryData(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.ensureQueryData(options);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return __privateGet(this, _mutationCache2).resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return __privateGet(this, _queryCache);
  }
  getMutationCache() {
    return __privateGet(this, _mutationCache2);
  }
  getDefaultOptions() {
    return __privateGet(this, _defaultOptions2);
  }
  setDefaultOptions(options) {
    __privateSet(this, _defaultOptions2, options);
  }
  setQueryDefaults(queryKey, options) {
    __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults = [...__privateGet(this, _queryDefaults).values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults = [...__privateGet(this, _mutationDefaults).values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...__privateGet(this, _defaultOptions2).queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options?._defaulted) {
      return options;
    }
    return {
      ...__privateGet(this, _defaultOptions2).mutations,
      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    __privateGet(this, _queryCache).clear();
    __privateGet(this, _mutationCache2).clear();
  }
}, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _j);
function disconnectMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return disconnect(config2, variables);
    },
    mutationKey: ["disconnect"]
  };
}
function switchChainMutationOptions(config2) {
  return {
    mutationFn(variables) {
      return switchChain(config2, variables);
    },
    mutationKey: ["switchChain"]
  };
}
var QueryClientContext = reactExports.createContext(
  void 0
);
var useQueryClient = (queryClient2) => {
  const client2 = reactExports.useContext(QueryClientContext);
  if (!client2) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client2;
};
var QueryClientProvider = ({
  client: client2,
  children
}) => {
  reactExports.useEffect(() => {
    client2.mount();
    return () => {
      client2.unmount();
    };
  }, [client2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientContext.Provider, { value: client2, children });
};
function useMutation(options, queryClient2) {
  const client2 = useQueryClient();
  const [observer] = reactExports.useState(
    () => new MutationObserver$1(
      client2,
      options
    )
  );
  reactExports.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = reactExports.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}
function useChainId(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchChainId(config2, { onChange }), () => getChainId(config2), () => getChainId(config2));
}
function useChains(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchChains(config2, { onChange }), () => getChains(config2), () => getChains(config2));
}
function useConnections(parameters = {}) {
  const config2 = useConfig(parameters);
  return reactExports.useSyncExternalStore((onChange) => watchConnections(config2, { onChange }), () => getConnections(config2), () => getConnections(config2));
}
function useDisconnect(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = disconnectMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    connectors: useConnections({ config: config2 }).map((connection) => connection.connector),
    disconnect: mutate,
    disconnectAsync: mutateAsync
  };
}
function useSwitchChain(parameters = {}) {
  const { mutation } = parameters;
  const config2 = useConfig(parameters);
  const mutationOptions = switchChainMutationOptions(config2);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    chains: useChains({ config: config2 }),
    switchChain: mutate,
    switchChainAsync: mutateAsync
  };
}
const customizeWeb3Modal = () => {
  console.log(" Starting Web3Modal customization...");
  const observer = new MutationObserver(() => {
    const modal2 = document.querySelector("w3m-modal");
    if (modal2) {
      setTimeout(customizeModalContent, 100);
    }
  });
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
  setTimeout(customizeModalContent, 100);
};
const customizeModalContent = () => {
  try {
    const modal2 = document.querySelector("w3m-modal");
    if (!modal2) return;
    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const trustWalletButton = modal2.querySelector('wui-wallet-button[data-wallet-id="4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0"]');
    if (trustWalletButton) {
      const parent2 = trustWalletButton.parentElement;
      if (parent2) {
        parent2.insertBefore(trustWalletButton, parent2.firstChild);
        console.log(" Trust Wallet moved to first position");
        if (isMobile) {
          trustWalletButton.addEventListener("click", () => {
            console.log(" Trust Wallet clicked on mobile");
          });
        }
      }
    }
    reorderWallets();
    forceWalletLayout();
    addCustomStyling();
  } catch (error) {
    console.error(" Customization error:", error);
  }
};
if (typeof window !== "undefined") {
  customizeWeb3Modal();
  setTimeout(customizeWeb3Modal, 500);
  document.addEventListener("click", () => {
    setTimeout(customizeWeb3Modal, 100);
  });
}
const reorderWallets = () => {
  const trustWalletId = "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0";
  const metaMaskId = "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96";
  const coinbaseId = "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa";
  const allWalletButtons = document.querySelectorAll("w3m-modal wui-wallet-button");
  const trustWalletButton = document.querySelector(`w3m-modal wui-wallet-button[data-wallet-id="${trustWalletId}"]`);
  const metaMaskButton = document.querySelector(`w3m-modal wui-wallet-button[data-wallet-id="${metaMaskId}"]`);
  const coinbaseButton = document.querySelector(`w3m-modal wui-wallet-button[data-wallet-id="${coinbaseId}"]`);
  if (trustWalletButton) {
    const parent2 = trustWalletButton.parentElement;
    if (parent2) {
      parent2.insertBefore(trustWalletButton, parent2.firstChild);
      trustWalletButton.style.order = "-9999";
      trustWalletButton.style.border = "3px solid #FFA000";
      trustWalletButton.style.background = "linear-gradient(135deg, #FFA000 0%, #FF8F00 100%)";
      trustWalletButton.style.transform = "scale(1.1)";
      trustWalletButton.style.boxShadow = "0 8px 25px rgba(255, 160, 0, 0.6)";
      trustWalletButton.style.margin = "12px 8px";
      trustWalletButton.style.width = "calc(100% - 16px)";
      trustWalletButton.style.minHeight = "70px";
      trustWalletButton.style.borderRadius = "12px";
      trustWalletButton.style.zIndex = "999";
      trustWalletButton.style.position = "relative";
      const trustText = trustWalletButton.querySelector("wui-text");
      if (trustText) {
        trustText.style.color = "white";
        trustText.style.fontWeight = "bold";
      }
    }
  }
  if (metaMaskButton) {
    metaMaskButton.style.order = "-500";
    metaMaskButton.style.margin = "8px";
    metaMaskButton.style.width = "calc(100% - 16px)";
  }
  if (coinbaseButton) {
    coinbaseButton.style.order = "-400";
    coinbaseButton.style.margin = "8px";
    coinbaseButton.style.width = "calc(100% - 16px)";
  }
  allWalletButtons.forEach((button) => {
    const walletId = button.getAttribute("data-wallet-id");
    if (walletId && ![trustWalletId, metaMaskId, coinbaseId].includes(walletId)) {
      button.style.display = "none";
      button.style.visibility = "hidden";
      button.style.opacity = "0";
      button.style.height = "0";
      button.style.overflow = "hidden";
      button.style.position = "absolute";
      button.style.left = "-9999px";
    }
  });
};
const forceWalletLayout = () => {
  const walletContainers = document.querySelectorAll("w3m-modal wui-flex, w3m-modal wui-grid");
  walletContainers.forEach((container) => {
    const hasWalletButton = container.querySelector("wui-wallet-button");
    if (hasWalletButton) {
      container.style.display = "flex";
      container.style.flexDirection = "column";
      container.style.alignItems = "center";
      container.style.width = "100%";
      container.style.gap = "8px";
    }
  });
};
const addCustomStyling = () => {
  if (!document.getElementById("web3modal-custom-styles")) {
    const style2 = document.createElement("style");
    style2.id = "web3modal-custom-styles";
    style2.textContent = `
      /* FORCE Trust Wallet to be HUGE on mobile */
      @media (max-width: 768px) {
        w3m-modal wui-wallet-button[data-wallet-id="4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0"] {
          order: -9999 !important;
          border: 4px solid #FFA000 !important;
          background: linear-gradient(135deg, #FFA000 0%, #FF8F00 100%) !important;
          transform: scale(1.2) !important;
          box-shadow: 0 12px 40px rgba(255, 160, 0, 0.7) !important;
          margin: 16px 8px !important;
          width: calc(100% - 16px) !important;
          min-height: 80px !important;
          border-radius: 16px !important;
          z-index: 9999 !important;
          position: relative !important;
        }

        /* Hide ALL other wallets on mobile */
        w3m-modal wui-wallet-button:not([data-wallet-id="4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0"]) {
          display: none !important;
          visibility: hidden !important;
          opacity: 0 !important;
          height: 0 !important;
          width: 0 !important;
          overflow: hidden !important;
          position: absolute !important;
          left: -9999px !important;
        }
      }

      /* Hide email/social completely */
      w3m-modal [data-testid*="email"],
      w3m-modal [data-testid*="social"],
      w3m-modal [data-testid*="onramp"],
      w3m-modal wui-email-input,
      w3m-modal wui-social-login-list,
      w3m-modal wui-onramp-widget {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        height: 0 !important;
        overflow: hidden !important;
      }
    `;
    document.head.appendChild(style2);
  }
};
if (typeof window !== "undefined") {
  customizeWeb3Modal();
  setTimeout(customizeWeb3Modal, 100);
  setTimeout(customizeWeb3Modal, 500);
  setTimeout(customizeWeb3Modal, 1e3);
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", customizeWeb3Modal);
  }
  document.addEventListener("click", (e2) => {
    const target = e2.target;
    if (target && (target.textContent?.includes("Connect") || target.closest("w3m-modal"))) {
      setTimeout(customizeWeb3Modal, 100);
      setTimeout(customizeWeb3Modal, 500);
    }
  });
  setInterval(customizeWeb3Modal, 2e3);
}
const ConstantsUtil$3 = {
  WALLET_CONNECT_CONNECTOR_ID: "walletConnect",
  INJECTED_CONNECTOR_ID: "injected",
  WALLET_STANDARD_CONNECTOR_ID: "announced",
  COINBASE_CONNECTOR_ID: "coinbaseWallet",
  COINBASE_SDK_CONNECTOR_ID: "coinbaseWalletSDK",
  SAFE_CONNECTOR_ID: "safe",
  LEDGER_CONNECTOR_ID: "ledger",
  EIP6963_CONNECTOR_ID: "eip6963",
  AUTH_CONNECTOR_ID: "w3mAuth",
  EIP155: "eip155",
  ADD_CHAIN_METHOD: "wallet_addEthereumChain",
  EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
  EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
  CONNECTOR_RDNS_MAP: {
    coinbaseWallet: "com.coinbase.wallet",
    coinbaseWalletSDK: "com.coinbase.wallet"
  },
  VERSION: "5.1.11"
};
const PresetsUtil = {
  ConnectorExplorerIds: {
    [ConstantsUtil$3.COINBASE_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [ConstantsUtil$3.COINBASE_SDK_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [ConstantsUtil$3.SAFE_CONNECTOR_ID]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
    [ConstantsUtil$3.LEDGER_CONNECTOR_ID]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927"
  },
  EIP155NetworkImageIds: {
    1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
    42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
    43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
    56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
    250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
    10: "ab9c186a-c52f-464b-2906-ca59d760a400",
    137: "41d04d42-da3b-4453-8506-668cc0727900",
    100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
    9001: "f926ff41-260d-4028-635e-91913fc28e00",
    324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
    314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
    4689: "34e68754-e536-40da-c153-6ef2e7188a00",
    1088: "3897a66d-40b9-4833-162f-a2c90531c900",
    1284: "161038da-44ae-4ec7-1208-0ea569454b00",
    1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
    7777777: "845c60df-d429-4991-e687-91ae45791600",
    42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
    8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
    1313161554: "3ff73439-a619-4894-9262-4470c773a100",
    2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
    2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
    "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": "a1b58899-f671-4276-6a5e-56ca5bd59700",
    "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z": "a1b58899-f671-4276-6a5e-56ca5bd59700",
    EtWTRABZaYq6iMfeYKouRu166VU2xqa1: "a1b58899-f671-4276-6a5e-56ca5bd59700"
  },
  ConnectorImageIds: {
    [ConstantsUtil$3.COINBASE_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil$3.COINBASE_SDK_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil$3.SAFE_CONNECTOR_ID]: "461db637-8616-43ce-035a-d89b8a1d5800",
    [ConstantsUtil$3.LEDGER_CONNECTOR_ID]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
    [ConstantsUtil$3.WALLET_CONNECT_CONNECTOR_ID]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
    [ConstantsUtil$3.INJECTED_CONNECTOR_ID]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
  },
  ConnectorNamesMap: {
    [ConstantsUtil$3.INJECTED_CONNECTOR_ID]: "Browser Wallet",
    [ConstantsUtil$3.WALLET_CONNECT_CONNECTOR_ID]: "WalletConnect",
    [ConstantsUtil$3.COINBASE_CONNECTOR_ID]: "Coinbase",
    [ConstantsUtil$3.COINBASE_SDK_CONNECTOR_ID]: "Coinbase",
    [ConstantsUtil$3.LEDGER_CONNECTOR_ID]: "Ledger",
    [ConstantsUtil$3.SAFE_CONNECTOR_ID]: "Safe"
  },
  ConnectorTypesMap: {
    [ConstantsUtil$3.INJECTED_CONNECTOR_ID]: "INJECTED",
    [ConstantsUtil$3.WALLET_CONNECT_CONNECTOR_ID]: "WALLET_CONNECT",
    [ConstantsUtil$3.EIP6963_CONNECTOR_ID]: "ANNOUNCED",
    [ConstantsUtil$3.AUTH_CONNECTOR_ID]: "AUTH"
  },
  WalletConnectRpcChainIds: [
    1,
    5,
    11155111,
    10,
    420,
    42161,
    421613,
    137,
    80001,
    42220,
    1313161554,
    1313161555,
    56,
    97,
    43114,
    43113,
    100,
    8453,
    84531,
    7777777,
    999,
    324,
    280
  ]
};
const HelpersUtil = {
  getCaipTokens(tokens) {
    if (!tokens) {
      return void 0;
    }
    const caipTokens = {};
    Object.entries(tokens).forEach(([id, token2]) => {
      caipTokens[`${ConstantsUtil$3.EIP155}:${id}`] = token2;
    });
    return caipTokens;
  }
};
var SocialProviderEnum;
(function(SocialProviderEnum2) {
  SocialProviderEnum2["Google"] = "google";
  SocialProviderEnum2["Github"] = "github";
  SocialProviderEnum2["Apple"] = "apple";
  SocialProviderEnum2["Facebook"] = "facebook";
  SocialProviderEnum2["X"] = "x";
  SocialProviderEnum2["Discord"] = "discord";
  SocialProviderEnum2["Farcaster"] = "farcaster";
})(SocialProviderEnum || (SocialProviderEnum = {}));
const t$3 = Symbol();
const s$4 = Object.getPrototypeOf, c$5 = /* @__PURE__ */ new WeakMap(), l$3 = (e2) => e2 && (c$5.has(e2) ? c$5.get(e2) : s$4(e2) === Object.prototype || s$4(e2) === Array.prototype), y$4 = (e2) => l$3(e2) && e2[t$3] || null, h$4 = (e2, t2 = true) => {
  c$5.set(e2, t2);
};
const __vite_import_meta_env__ = {};
const isObject = (x2) => typeof x2 === "object" && x2 !== null;
const proxyStateMap = /* @__PURE__ */ new WeakMap();
const refSet = /* @__PURE__ */ new WeakSet();
const buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x2) => isObject(x2) && !refSet.has(x2) && (Array.isArray(x2) || !(Symbol.iterator in x2)) && !(x2 instanceof WeakMap) && !(x2 instanceof WeakSet) && !(x2 instanceof Error) && !(x2 instanceof Number) && !(x2 instanceof Date) && !(x2 instanceof String) && !(x2 instanceof RegExp) && !(x2 instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version2, handlePromise = defaultHandlePromise) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version2) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  h$4(snap, true);
  snapCache.set(target, [version2, snap]);
  Reflect.ownKeys(target).forEach((key2) => {
    if (Object.getOwnPropertyDescriptor(snap, key2)) {
      return;
    }
    const value = Reflect.get(target, key2);
    const desc = {
      value,
      enumerable: true,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: true
    };
    if (refSet.has(value)) {
      h$4(value, false);
    } else if (value instanceof Promise) {
      delete desc.value;
      desc.get = () => handlePromise(value);
    } else if (proxyStateMap.has(value)) {
      const [target2, ensureVersion] = proxyStateMap.get(
        value
      );
      desc.value = createSnapshot(
        target2,
        ensureVersion(),
        handlePromise
      );
    }
    Object.defineProperty(snap, key2, desc);
  });
  return Object.preventExtensions(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version2 = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version2 !== nextVersion) {
      version2 = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version2) {
          version2 = propVersion;
        }
      });
    }
    return version2;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a3;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a3 = entry[1]) == null ? void 0 : _a3.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject(value)) {
        value = y$4(value) || value;
      }
      let nextValue = value;
      if (value instanceof Promise) {
        value.then((v2) => {
          value.status = "fulfilled";
          value.value = v2;
          notifyUpdate(["resolve", [prop], v2]);
        }).catch((e2) => {
          value.status = "rejected";
          value.reason = e2;
          notifyUpdate(["reject", [prop], e2]);
        });
      } else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxyFunction(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [
    baseObject,
    ensureVersion,
    createSnapshot,
    addListener
  ];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key2) => {
    const desc = Object.getOwnPropertyDescriptor(
      initialObject,
      key2
    );
    if ("value" in desc) {
      proxyObject[key2] = initialObject[key2];
      delete desc.value;
      delete desc.writable;
    }
    Object.defineProperty(baseObject, key2, desc);
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
const [defaultProxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return defaultProxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
function subscribeKey(proxyObject, key2, callback, notifyInSync) {
  let prevValue = proxyObject[key2];
  return subscribe(
    proxyObject,
    () => {
      const nextValue = proxyObject[key2];
      if (!Object.is(prevValue, nextValue)) {
        callback(prevValue = nextValue);
      }
    }
  );
}
function proxyMap(entries2) {
  const map = proxy({
    data: Array.from([]),
    has(key2) {
      return this.data.some((p2) => p2[0] === key2);
    },
    set(key2, value) {
      const record = this.data.find((p2) => p2[0] === key2);
      if (record) {
        record[1] = value;
      } else {
        this.data.push([key2, value]);
      }
      return this;
    },
    get(key2) {
      var _a3;
      return (_a3 = this.data.find((p2) => p2[0] === key2)) == null ? void 0 : _a3[1];
    },
    delete(key2) {
      const index2 = this.data.findIndex((p2) => p2[0] === key2);
      if (index2 === -1) {
        return false;
      }
      this.data.splice(index2, 1);
      return true;
    },
    clear() {
      this.data.splice(0);
    },
    get size() {
      return this.data.length;
    },
    toJSON() {
      return new Map(this.data);
    },
    forEach(cb) {
      this.data.forEach((p2) => {
        cb(p2[1], p2[0], this);
      });
    },
    keys() {
      return this.data.map((p2) => p2[0]).values();
    },
    values() {
      return this.data.map((p2) => p2[1]).values();
    },
    entries() {
      return new Map(this.data).entries();
    },
    get [Symbol.toStringTag]() {
      return "Map";
    },
    [Symbol.iterator]() {
      return this.entries();
    }
  });
  Object.defineProperties(map, {
    data: {
      enumerable: false
    },
    size: {
      enumerable: false
    },
    toJSON: {
      enumerable: false
    }
  });
  Object.seal(map);
  return map;
}
var dayjs_min$1 = { exports: {} };
var dayjs_min = dayjs_min$1.exports;
var hasRequiredDayjs_min;
function requireDayjs_min() {
  if (hasRequiredDayjs_min) return dayjs_min$1.exports;
  hasRequiredDayjs_min = 1;
  (function(module, exports) {
    !(function(t2, e2) {
      module.exports = e2();
    })(dayjs_min, (function() {
      var t2 = 1e3, e2 = 6e4, n3 = 36e5, r2 = "millisecond", i4 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d3 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y3 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t22) {
        var e22 = ["th", "st", "nd", "rd"], n22 = t22 % 100;
        return "[" + t22 + (e22[(n22 - 20) % 10] || e22[n22] || e22[0]) + "]";
      } }, m3 = function(t22, e22, n22) {
        var r22 = String(t22);
        return !r22 || r22.length >= e22 ? t22 : "" + Array(e22 + 1 - r22.length).join(n22) + t22;
      }, v2 = { s: m3, z: function(t22) {
        var e22 = -t22.utcOffset(), n22 = Math.abs(e22), r22 = Math.floor(n22 / 60), i22 = n22 % 60;
        return (e22 <= 0 ? "+" : "-") + m3(r22, 2, "0") + ":" + m3(i22, 2, "0");
      }, m: function t22(e22, n22) {
        if (e22.date() < n22.date()) return -t22(n22, e22);
        var r22 = 12 * (n22.year() - e22.year()) + (n22.month() - e22.month()), i22 = e22.clone().add(r22, c2), s22 = n22 - i22 < 0, u22 = e22.clone().add(r22 + (s22 ? -1 : 1), c2);
        return +(-(r22 + (n22 - i22) / (s22 ? i22 - u22 : u22 - i22)) || 0);
      }, a: function(t22) {
        return t22 < 0 ? Math.ceil(t22) || 0 : Math.floor(t22);
      }, p: function(t22) {
        return { M: c2, y: h2, w: o2, d: a2, D: d3, h: u2, m: s2, s: i4, ms: r2, Q: f2 }[t22] || String(t22 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t22) {
        return void 0 === t22;
      } }, g2 = "en", D = {};
      D[g2] = M2;
      var p2 = "$isDayjsObject", S2 = function(t22) {
        return t22 instanceof _2 || !(!t22 || !t22[p2]);
      }, w2 = function t22(e22, n22, r22) {
        var i22;
        if (!e22) return g2;
        if ("string" == typeof e22) {
          var s22 = e22.toLowerCase();
          D[s22] && (i22 = s22), n22 && (D[s22] = n22, i22 = s22);
          var u22 = e22.split("-");
          if (!i22 && u22.length > 1) return t22(u22[0]);
        } else {
          var a22 = e22.name;
          D[a22] = e22, i22 = a22;
        }
        return !r22 && i22 && (g2 = i22), i22 || !r22 && g2;
      }, O2 = function(t22, e22) {
        if (S2(t22)) return t22.clone();
        var n22 = "object" == typeof e22 ? e22 : {};
        return n22.date = t22, n22.args = arguments, new _2(n22);
      }, b2 = v2;
      b2.l = w2, b2.i = S2, b2.w = function(t22, e22) {
        return O2(t22, { locale: e22.$L, utc: e22.$u, x: e22.$x, $offset: e22.$offset });
      };
      var _2 = (function() {
        function M22(t22) {
          this.$L = w2(t22.locale, null, true), this.parse(t22), this.$x = this.$x || t22.x || {}, this[p2] = true;
        }
        var m22 = M22.prototype;
        return m22.parse = function(t22) {
          this.$d = (function(t3) {
            var e22 = t3.date, n22 = t3.utc;
            if (null === e22) return /* @__PURE__ */ new Date(NaN);
            if (b2.u(e22)) return /* @__PURE__ */ new Date();
            if (e22 instanceof Date) return new Date(e22);
            if ("string" == typeof e22 && !/Z$/i.test(e22)) {
              var r22 = e22.match($2);
              if (r22) {
                var i22 = r22[2] - 1 || 0, s22 = (r22[7] || "0").substring(0, 3);
                return n22 ? new Date(Date.UTC(r22[1], i22, r22[3] || 1, r22[4] || 0, r22[5] || 0, r22[6] || 0, s22)) : new Date(r22[1], i22, r22[3] || 1, r22[4] || 0, r22[5] || 0, r22[6] || 0, s22);
              }
            }
            return new Date(e22);
          })(t22), this.init();
        }, m22.init = function() {
          var t22 = this.$d;
          this.$y = t22.getFullYear(), this.$M = t22.getMonth(), this.$D = t22.getDate(), this.$W = t22.getDay(), this.$H = t22.getHours(), this.$m = t22.getMinutes(), this.$s = t22.getSeconds(), this.$ms = t22.getMilliseconds();
        }, m22.$utils = function() {
          return b2;
        }, m22.isValid = function() {
          return !(this.$d.toString() === l2);
        }, m22.isSame = function(t22, e22) {
          var n22 = O2(t22);
          return this.startOf(e22) <= n22 && n22 <= this.endOf(e22);
        }, m22.isAfter = function(t22, e22) {
          return O2(t22) < this.startOf(e22);
        }, m22.isBefore = function(t22, e22) {
          return this.endOf(e22) < O2(t22);
        }, m22.$g = function(t22, e22, n22) {
          return b2.u(t22) ? this[e22] : this.set(n22, t22);
        }, m22.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m22.valueOf = function() {
          return this.$d.getTime();
        }, m22.startOf = function(t22, e22) {
          var n22 = this, r22 = !!b2.u(e22) || e22, f22 = b2.p(t22), l22 = function(t3, e3) {
            var i22 = b2.w(n22.$u ? Date.UTC(n22.$y, e3, t3) : new Date(n22.$y, e3, t3), n22);
            return r22 ? i22 : i22.endOf(a2);
          }, $22 = function(t3, e3) {
            return b2.w(n22.toDate()[t3].apply(n22.toDate("s"), (r22 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n22);
          }, y22 = this.$W, M3 = this.$M, m32 = this.$D, v22 = "set" + (this.$u ? "UTC" : "");
          switch (f22) {
            case h2:
              return r22 ? l22(1, 0) : l22(31, 11);
            case c2:
              return r22 ? l22(1, M3) : l22(0, M3 + 1);
            case o2:
              var g22 = this.$locale().weekStart || 0, D2 = (y22 < g22 ? y22 + 7 : y22) - g22;
              return l22(r22 ? m32 - D2 : m32 + (6 - D2), M3);
            case a2:
            case d3:
              return $22(v22 + "Hours", 0);
            case u2:
              return $22(v22 + "Minutes", 1);
            case s2:
              return $22(v22 + "Seconds", 2);
            case i4:
              return $22(v22 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m22.endOf = function(t22) {
          return this.startOf(t22, false);
        }, m22.$set = function(t22, e22) {
          var n22, o22 = b2.p(t22), f22 = "set" + (this.$u ? "UTC" : ""), l22 = (n22 = {}, n22[a2] = f22 + "Date", n22[d3] = f22 + "Date", n22[c2] = f22 + "Month", n22[h2] = f22 + "FullYear", n22[u2] = f22 + "Hours", n22[s2] = f22 + "Minutes", n22[i4] = f22 + "Seconds", n22[r2] = f22 + "Milliseconds", n22)[o22], $22 = o22 === a2 ? this.$D + (e22 - this.$W) : e22;
          if (o22 === c2 || o22 === h2) {
            var y22 = this.clone().set(d3, 1);
            y22.$d[l22]($22), y22.init(), this.$d = y22.set(d3, Math.min(this.$D, y22.daysInMonth())).$d;
          } else l22 && this.$d[l22]($22);
          return this.init(), this;
        }, m22.set = function(t22, e22) {
          return this.clone().$set(t22, e22);
        }, m22.get = function(t22) {
          return this[b2.p(t22)]();
        }, m22.add = function(r22, f22) {
          var d22, l22 = this;
          r22 = Number(r22);
          var $22 = b2.p(f22), y22 = function(t22) {
            var e22 = O2(l22);
            return b2.w(e22.date(e22.date() + Math.round(t22 * r22)), l22);
          };
          if ($22 === c2) return this.set(c2, this.$M + r22);
          if ($22 === h2) return this.set(h2, this.$y + r22);
          if ($22 === a2) return y22(1);
          if ($22 === o2) return y22(7);
          var M3 = (d22 = {}, d22[s2] = e2, d22[u2] = n3, d22[i4] = t2, d22)[$22] || 1, m32 = this.$d.getTime() + r22 * M3;
          return b2.w(m32, this);
        }, m22.subtract = function(t22, e22) {
          return this.add(-1 * t22, e22);
        }, m22.format = function(t22) {
          var e22 = this, n22 = this.$locale();
          if (!this.isValid()) return n22.invalidDate || l2;
          var r22 = t22 || "YYYY-MM-DDTHH:mm:ssZ", i22 = b2.z(this), s22 = this.$H, u22 = this.$m, a22 = this.$M, o22 = n22.weekdays, c22 = n22.months, f22 = n22.meridiem, h22 = function(t3, n32, i32, s3) {
            return t3 && (t3[n32] || t3(e22, r22)) || i32[n32].slice(0, s3);
          }, d22 = function(t3) {
            return b2.s(s22 % 12 || 12, t3, "0");
          }, $22 = f22 || function(t3, e3, n32) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n32 ? r3.toLowerCase() : r3;
          };
          return r22.replace(y3, (function(t3, r3) {
            return r3 || (function(t4) {
              switch (t4) {
                case "YY":
                  return String(e22.$y).slice(-2);
                case "YYYY":
                  return b2.s(e22.$y, 4, "0");
                case "M":
                  return a22 + 1;
                case "MM":
                  return b2.s(a22 + 1, 2, "0");
                case "MMM":
                  return h22(n22.monthsShort, a22, c22, 3);
                case "MMMM":
                  return h22(c22, a22);
                case "D":
                  return e22.$D;
                case "DD":
                  return b2.s(e22.$D, 2, "0");
                case "d":
                  return String(e22.$W);
                case "dd":
                  return h22(n22.weekdaysMin, e22.$W, o22, 2);
                case "ddd":
                  return h22(n22.weekdaysShort, e22.$W, o22, 3);
                case "dddd":
                  return o22[e22.$W];
                case "H":
                  return String(s22);
                case "HH":
                  return b2.s(s22, 2, "0");
                case "h":
                  return d22(1);
                case "hh":
                  return d22(2);
                case "a":
                  return $22(s22, u22, true);
                case "A":
                  return $22(s22, u22, false);
                case "m":
                  return String(u22);
                case "mm":
                  return b2.s(u22, 2, "0");
                case "s":
                  return String(e22.$s);
                case "ss":
                  return b2.s(e22.$s, 2, "0");
                case "SSS":
                  return b2.s(e22.$ms, 3, "0");
                case "Z":
                  return i22;
              }
              return null;
            })(t3) || i22.replace(":", "");
          }));
        }, m22.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m22.diff = function(r22, d22, l22) {
          var $22, y22 = this, M3 = b2.p(d22), m32 = O2(r22), v22 = (m32.utcOffset() - this.utcOffset()) * e2, g22 = this - m32, D2 = function() {
            return b2.m(y22, m32);
          };
          switch (M3) {
            case h2:
              $22 = D2() / 12;
              break;
            case c2:
              $22 = D2();
              break;
            case f2:
              $22 = D2() / 3;
              break;
            case o2:
              $22 = (g22 - v22) / 6048e5;
              break;
            case a2:
              $22 = (g22 - v22) / 864e5;
              break;
            case u2:
              $22 = g22 / n3;
              break;
            case s2:
              $22 = g22 / e2;
              break;
            case i4:
              $22 = g22 / t2;
              break;
            default:
              $22 = g22;
          }
          return l22 ? $22 : b2.a($22);
        }, m22.daysInMonth = function() {
          return this.endOf(c2).$D;
        }, m22.$locale = function() {
          return D[this.$L];
        }, m22.locale = function(t22, e22) {
          if (!t22) return this.$L;
          var n22 = this.clone(), r22 = w2(t22, e22, true);
          return r22 && (n22.$L = r22), n22;
        }, m22.clone = function() {
          return b2.w(this.$d, this);
        }, m22.toDate = function() {
          return new Date(this.valueOf());
        }, m22.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m22.toISOString = function() {
          return this.$d.toISOString();
        }, m22.toString = function() {
          return this.$d.toUTCString();
        }, M22;
      })(), k2 = _2.prototype;
      return O2.prototype = k2, [["$ms", r2], ["$s", i4], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d3]].forEach((function(t22) {
        k2[t22[1]] = function(e22) {
          return this.$g(e22, t22[0], t22[1]);
        };
      })), O2.extend = function(t22, e22) {
        return t22.$i || (t22(e22, _2, O2), t22.$i = true), O2;
      }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t22) {
        return O2(1e3 * t22);
      }, O2.en = D[g2], O2.Ls = D, O2.p = {}, O2;
    }));
  })(dayjs_min$1);
  return dayjs_min$1.exports;
}
var dayjs_minExports = requireDayjs_min();
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var en$1 = { exports: {} };
var en = en$1.exports;
var hasRequiredEn;
function requireEn() {
  if (hasRequiredEn) return en$1.exports;
  hasRequiredEn = 1;
  (function(module, exports) {
    !(function(e2, n3) {
      module.exports = n3();
    })(en, (function() {
      return { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(e2) {
        var n3 = ["th", "st", "nd", "rd"], t2 = e2 % 100;
        return "[" + e2 + (n3[(t2 - 20) % 10] || n3[t2] || n3[0]) + "]";
      } };
    }));
  })(en$1);
  return en$1.exports;
}
var enExports = requireEn();
const englishLocale = /* @__PURE__ */ getDefaultExportFromCjs(enExports);
var relativeTime$2 = { exports: {} };
var relativeTime$1 = relativeTime$2.exports;
var hasRequiredRelativeTime;
function requireRelativeTime() {
  if (hasRequiredRelativeTime) return relativeTime$2.exports;
  hasRequiredRelativeTime = 1;
  (function(module, exports) {
    !(function(r2, e2) {
      module.exports = e2();
    })(relativeTime$1, (function() {
      return function(r2, e2, t2) {
        r2 = r2 || {};
        var n3 = e2.prototype, o2 = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
        function i4(r22, e22, t22, o22) {
          return n3.fromToBase(r22, e22, t22, o22);
        }
        t2.en.relativeTime = o2, n3.fromToBase = function(e22, n22, i22, d22, u2) {
          for (var f2, a2, s2, l2 = i22.$locale().relativeTime || o2, h2 = r2.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m3 = h2.length, c2 = 0; c2 < m3; c2 += 1) {
            var y3 = h2[c2];
            y3.d && (f2 = d22 ? t2(e22).diff(i22, y3.d, true) : i22.diff(e22, y3.d, true));
            var p2 = (r2.rounding || Math.round)(Math.abs(f2));
            if (s2 = f2 > 0, p2 <= y3.r || !y3.r) {
              p2 <= 1 && c2 > 0 && (y3 = h2[c2 - 1]);
              var v2 = l2[y3.l];
              u2 && (p2 = u2("" + p2)), a2 = "string" == typeof v2 ? v2.replace("%d", p2) : v2(p2, n22, y3.l, s2);
              break;
            }
          }
          if (n22) return a2;
          var M2 = s2 ? l2.future : l2.past;
          return "function" == typeof M2 ? M2(a2) : M2.replace("%s", a2);
        }, n3.to = function(r22, e22) {
          return i4(r22, e22, this, true);
        }, n3.from = function(r22, e22) {
          return i4(r22, e22, this);
        };
        var d3 = function(r22) {
          return r22.$u ? t2.utc() : t2();
        };
        n3.toNow = function(r22) {
          return this.to(d3(this), r22);
        }, n3.fromNow = function(r22) {
          return this.from(d3(this), r22);
        };
      };
    }));
  })(relativeTime$2);
  return relativeTime$2.exports;
}
var relativeTimeExports = requireRelativeTime();
const relativeTime = /* @__PURE__ */ getDefaultExportFromCjs(relativeTimeExports);
var updateLocale$2 = { exports: {} };
var updateLocale$1 = updateLocale$2.exports;
var hasRequiredUpdateLocale;
function requireUpdateLocale() {
  if (hasRequiredUpdateLocale) return updateLocale$2.exports;
  hasRequiredUpdateLocale = 1;
  (function(module, exports) {
    !(function(e2, n3) {
      module.exports = n3();
    })(updateLocale$1, (function() {
      return function(e2, n3, t2) {
        t2.updateLocale = function(e22, n22) {
          var o2 = t2.Ls[e22];
          if (o2) return (n22 ? Object.keys(n22) : []).forEach((function(e3) {
            o2[e3] = n22[e3];
          })), o2;
        };
      };
    }));
  })(updateLocale$2);
  return updateLocale$2.exports;
}
var updateLocaleExports = requireUpdateLocale();
const updateLocale = /* @__PURE__ */ getDefaultExportFromCjs(updateLocaleExports);
dayjs.extend(relativeTime);
dayjs.extend(updateLocale);
const localeObject = {
  ...englishLocale,
  name: "en-web3-modal",
  relativeTime: {
    future: "in %s",
    past: "%s ago",
    s: "%d sec",
    m: "1 min",
    mm: "%d min",
    h: "1 hr",
    hh: "%d hrs",
    d: "1 d",
    dd: "%d d",
    M: "1 mo",
    MM: "%d mo",
    y: "1 yr",
    yy: "%d yr"
  }
};
dayjs.locale("en-web3-modal", localeObject);
const DateUtil = {
  getYear(date = (/* @__PURE__ */ new Date()).toISOString()) {
    return dayjs(date).year();
  },
  getRelativeDateFromNow(date) {
    return dayjs(date).locale("en-web3-modal").fromNow(true);
  },
  formatDate(date, format = "DD MMM") {
    return dayjs(date).format(format);
  }
};
const NetworkUtil$1 = {
  caipNetworkIdToNumber(caipnetworkId) {
    return caipnetworkId ? Number(caipnetworkId.split(":")[1]) : void 0;
  },
  parseEvmChainId(chainId) {
    return typeof chainId === "string" ? this.caipNetworkIdToNumber(chainId) : chainId;
  }
};
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v2, b2) {
    var alphabet2, c2, caseChanged, e2, i4, isNum, len, str, x2 = this;
    if (!(x2 instanceof BigNumber2)) return new BigNumber2(v2, b2);
    if (b2 == null) {
      if (v2 && v2._isBigNumber === true) {
        x2.s = v2.s;
        if (!v2.c || v2.e > MAX_EXP) {
          x2.c = x2.e = null;
        } else if (v2.e < MIN_EXP) {
          x2.c = [x2.e = 0];
        } else {
          x2.e = v2.e;
          x2.c = v2.c.slice();
        }
        return;
      }
      if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
        x2.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
        if (v2 === ~~v2) {
          for (e2 = 0, i4 = v2; i4 >= 10; i4 /= 10, e2++) ;
          if (e2 > MAX_EXP) {
            x2.c = x2.e = null;
          } else {
            x2.e = e2;
            x2.c = [v2];
          }
          return;
        }
        str = String(v2);
      } else {
        if (!isNumeric.test(str = String(v2))) return parseNumeric(x2, str, isNum);
        x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
      if ((i4 = str.search(/e/i)) > 0) {
        if (e2 < 0) e2 = i4;
        e2 += +str.slice(i4 + 1);
        str = str.substring(0, i4);
      } else if (e2 < 0) {
        e2 = str.length;
      }
    } else {
      intCheck(b2, 2, ALPHABET.length, "Base");
      if (b2 == 10 && alphabetHasNormalDecimalDigits) {
        x2 = new BigNumber2(v2);
        return round2(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
      }
      str = String(v2);
      if (isNum = typeof v2 == "number") {
        if (v2 * 0 != 0) return parseNumeric(x2, str, isNum, b2);
        x2.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v2);
        }
      } else {
        x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet2 = ALPHABET.slice(0, b2);
      e2 = i4 = 0;
      for (len = str.length; i4 < len; i4++) {
        if (alphabet2.indexOf(c2 = str.charAt(i4)) < 0) {
          if (c2 == ".") {
            if (i4 > e2) {
              e2 = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i4 = -1;
              e2 = 0;
              continue;
            }
          }
          return parseNumeric(x2, String(v2), isNum, b2);
        }
      }
      isNum = false;
      str = convertBase(str, b2, 10, x2.s);
      if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
      else e2 = str.length;
    }
    for (i4 = 0; str.charCodeAt(i4) === 48; i4++) ;
    for (len = str.length; str.charCodeAt(--len) === 48; ) ;
    if (str = str.slice(i4, ++len)) {
      len -= i4;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
        throw Error(tooManyDigits + x2.s * v2);
      }
      if ((e2 = e2 - i4 - 1) > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (e2 < MIN_EXP) {
        x2.c = [x2.e = 0];
      } else {
        x2.e = e2;
        x2.c = [];
        i4 = (e2 + 1) % LOG_BASE;
        if (e2 < 0) i4 += LOG_BASE;
        if (i4 < len) {
          if (i4) x2.c.push(+str.slice(0, i4));
          for (len -= LOG_BASE; i4 < len; ) {
            x2.c.push(+str.slice(i4, i4 += LOG_BASE));
          }
          i4 = LOG_BASE - (str = str.slice(i4)).length;
        } else {
          i4 -= len;
        }
        for (; i4--; str += "0") ;
        x2.c.push(+str);
      }
    } else {
      x2.c = [x2.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p2, v2;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
          v2 = obj[p2];
          intCheck(v2, 0, MAX, p2);
          DECIMAL_PLACES = v2;
        }
        if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
          v2 = obj[p2];
          intCheck(v2, 0, 8, p2);
          ROUNDING_MODE = v2;
        }
        if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
          v2 = obj[p2];
          if (v2 && v2.pop) {
            intCheck(v2[0], -MAX, 0, p2);
            intCheck(v2[1], 0, MAX, p2);
            TO_EXP_NEG = v2[0];
            TO_EXP_POS = v2[1];
          } else {
            intCheck(v2, -MAX, MAX, p2);
            TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
          }
        }
        if (obj.hasOwnProperty(p2 = "RANGE")) {
          v2 = obj[p2];
          if (v2 && v2.pop) {
            intCheck(v2[0], -MAX, -1, p2);
            intCheck(v2[1], 1, MAX, p2);
            MIN_EXP = v2[0];
            MAX_EXP = v2[1];
          } else {
            intCheck(v2, -MAX, MAX, p2);
            if (v2) {
              MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
            } else {
              throw Error(bignumberError + p2 + " cannot be zero: " + v2);
            }
          }
        }
        if (obj.hasOwnProperty(p2 = "CRYPTO")) {
          v2 = obj[p2];
          if (v2 === !!v2) {
            if (v2) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v2;
              } else {
                CRYPTO = !v2;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v2;
            }
          } else {
            throw Error(bignumberError + p2 + " not true or false: " + v2);
          }
        }
        if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
          v2 = obj[p2];
          intCheck(v2, 0, 9, p2);
          MODULO_MODE = v2;
        }
        if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
          v2 = obj[p2];
          intCheck(v2, 0, MAX, p2);
          POW_PRECISION = v2;
        }
        if (obj.hasOwnProperty(p2 = "FORMAT")) {
          v2 = obj[p2];
          if (typeof v2 == "object") FORMAT = v2;
          else throw Error(bignumberError + p2 + " not an object: " + v2);
        }
        if (obj.hasOwnProperty(p2 = "ALPHABET")) {
          v2 = obj[p2];
          if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
            alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
            ALPHABET = v2;
          } else {
            throw Error(bignumberError + p2 + " invalid: " + v2);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v2) {
    if (!v2 || v2._isBigNumber !== true) return false;
    if (!BigNumber2.DEBUG) return true;
    var i4, n3, c2 = v2.c, e2 = v2.e, s2 = v2.s;
    out: if ({}.toString.call(c2) == "[object Array]") {
      if ((s2 === 1 || s2 === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
        if (c2[0] === 0) {
          if (e2 === 0 && c2.length === 1) return true;
          break out;
        }
        i4 = (e2 + 1) % LOG_BASE;
        if (i4 < 1) i4 += LOG_BASE;
        if (String(c2[0]).length == i4) {
          for (i4 = 0; i4 < c2.length; i4++) {
            n3 = c2[i4];
            if (n3 < 0 || n3 >= BASE || n3 !== mathfloor(n3)) break out;
          }
          if (n3 !== 0) return true;
        }
      }
    } else if (c2 === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
      return true;
    }
    throw Error(bignumberError + "Invalid BigNumber: " + v2);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = (function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a2, b2, e2, k2, v2, i4 = 0, c2 = [], rand = new BigNumber2(ONE);
      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);
      k2 = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a2 = crypto.getRandomValues(new Uint32Array(k2 *= 2));
          for (; i4 < k2; ) {
            v2 = a2[i4] * 131072 + (a2[i4 + 1] >>> 11);
            if (v2 >= 9e15) {
              b2 = crypto.getRandomValues(new Uint32Array(2));
              a2[i4] = b2[0];
              a2[i4 + 1] = b2[1];
            } else {
              c2.push(v2 % 1e14);
              i4 += 2;
            }
          }
          i4 = k2 / 2;
        } else if (crypto.randomBytes) {
          a2 = crypto.randomBytes(k2 *= 7);
          for (; i4 < k2; ) {
            v2 = (a2[i4] & 31) * 281474976710656 + a2[i4 + 1] * 1099511627776 + a2[i4 + 2] * 4294967296 + a2[i4 + 3] * 16777216 + (a2[i4 + 4] << 16) + (a2[i4 + 5] << 8) + a2[i4 + 6];
            if (v2 >= 9e15) {
              crypto.randomBytes(7).copy(a2, i4);
            } else {
              c2.push(v2 % 1e14);
              i4 += 7;
            }
          }
          i4 = k2 / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i4 < k2; ) {
          v2 = random53bitInt();
          if (v2 < 9e15) c2[i4++] = v2 % 1e14;
        }
      }
      k2 = c2[--i4];
      dp %= LOG_BASE;
      if (k2 && dp) {
        v2 = POWS_TEN[LOG_BASE - dp];
        c2[i4] = mathfloor(k2 / v2) * v2;
      }
      for (; c2[i4] === 0; c2.pop(), i4--) ;
      if (i4 < 0) {
        c2 = [e2 = 0];
      } else {
        for (e2 = -1; c2[0] === 0; c2.splice(0, 1), e2 -= LOG_BASE) ;
        for (i4 = 1, v2 = c2[0]; v2 >= 10; v2 /= 10, i4++) ;
        if (i4 < LOG_BASE) e2 -= LOG_BASE - i4;
      }
      rand.e = e2;
      rand.c = c2;
      return rand;
    };
  })();
  BigNumber2.sum = function() {
    var i4 = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i4 < args.length; ) sum = sum.plus(args[i4++]);
    return sum;
  };
  convertBase = /* @__PURE__ */ (function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet2) {
      var j2, arr = [0], arrL, i4 = 0, len = str.length;
      for (; i4 < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
        arr[0] += alphabet2.indexOf(str.charAt(i4++));
        for (j2 = 0; j2 < arr.length; j2++) {
          if (arr[j2] > baseOut - 1) {
            if (arr[j2 + 1] == null) arr[j2 + 1] = 0;
            arr[j2 + 1] += arr[j2] / baseOut | 0;
            arr[j2] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet2, d3, e2, k2, r2, x2, xc, y3, i4 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i4 >= 0) {
        k2 = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y3 = new BigNumber2(baseIn);
        x2 = y3.pow(str.length - i4);
        POW_PRECISION = k2;
        y3.c = toBaseOut(
          toFixedPoint(coeffToString(x2.c), x2.e, "0"),
          10,
          baseOut,
          decimal
        );
        y3.e = y3.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET, decimal) : (alphabet2 = decimal, ALPHABET));
      e2 = k2 = xc.length;
      for (; xc[--k2] == 0; xc.pop()) ;
      if (!xc[0]) return alphabet2.charAt(0);
      if (i4 < 0) {
        --e2;
      } else {
        x2.c = xc;
        x2.e = e2;
        x2.s = sign;
        x2 = div(x2, y3, dp, rm, baseOut);
        xc = x2.c;
        r2 = x2.r;
        e2 = x2.e;
      }
      d3 = e2 + dp + 1;
      i4 = xc[d3];
      k2 = baseOut / 2;
      r2 = r2 || d3 < 0 || xc[d3 + 1] != null;
      r2 = rm < 4 ? (i4 != null || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i4 > k2 || i4 == k2 && (rm == 4 || r2 || rm == 6 && xc[d3 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
      if (d3 < 1 || !xc[0]) {
        str = r2 ? toFixedPoint(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
      } else {
        xc.length = d3;
        if (r2) {
          for (--baseOut; ++xc[--d3] > baseOut; ) {
            xc[d3] = 0;
            if (!d3) {
              ++e2;
              xc = [1].concat(xc);
            }
          }
        }
        for (k2 = xc.length; !xc[--k2]; ) ;
        for (i4 = 0, str = ""; i4 <= k2; str += alphabet2.charAt(xc[i4++])) ;
        str = toFixedPoint(str, e2, alphabet2.charAt(0));
      }
      return str;
    };
  })();
  div = /* @__PURE__ */ (function() {
    function multiply(x2, k2, base3) {
      var m3, temp, xlo, xhi, carry = 0, i4 = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
      for (x2 = x2.slice(); i4--; ) {
        xlo = x2[i4] % SQRT_BASE;
        xhi = x2[i4] / SQRT_BASE | 0;
        m3 = khi * xlo + xhi * klo;
        temp = klo * xlo + m3 % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base3 | 0) + (m3 / SQRT_BASE | 0) + khi * xhi;
        x2[i4] = temp % base3;
      }
      if (carry) x2 = [carry].concat(x2);
      return x2;
    }
    function compare2(a2, b2, aL, bL) {
      var i4, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i4 = cmp = 0; i4 < aL; i4++) {
          if (a2[i4] != b2[i4]) {
            cmp = a2[i4] > b2[i4] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a2, b2, aL, base3) {
      var i4 = 0;
      for (; aL--; ) {
        a2[aL] -= i4;
        i4 = a2[aL] < b2[aL] ? 1 : 0;
        a2[aL] = i4 * base3 + a2[aL] - b2[aL];
      }
      for (; !a2[0] && a2.length > 1; a2.splice(0, 1)) ;
    }
    return function(x2, y3, dp, rm, base3) {
      var cmp, e2, i4, more, n3, prod, prodL, q, qc, rem, remL, rem0, xi2, xL, yc0, yL, yz, s2 = x2.s == y3.s ? 1 : -1, xc = x2.c, yc = y3.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x2.s || !y3.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
          )
        );
      }
      q = new BigNumber2(s2);
      qc = q.c = [];
      e2 = x2.e - y3.e;
      s2 = dp + e2 + 1;
      if (!base3) {
        base3 = BASE;
        e2 = bitFloor(x2.e / LOG_BASE) - bitFloor(y3.e / LOG_BASE);
        s2 = s2 / LOG_BASE | 0;
      }
      for (i4 = 0; yc[i4] == (xc[i4] || 0); i4++) ;
      if (yc[i4] > (xc[i4] || 0)) e2--;
      if (s2 < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i4 = 0;
        s2 += 2;
        n3 = mathfloor(base3 / (yc[0] + 1));
        if (n3 > 1) {
          yc = multiply(yc, n3, base3);
          xc = multiply(xc, n3, base3);
          yL = yc.length;
          xL = xc.length;
        }
        xi2 = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0) ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base3 / 2) yc0++;
        do {
          n3 = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base3 + (rem[1] || 0);
            n3 = mathfloor(rem0 / yc0);
            if (n3 > 1) {
              if (n3 >= base3) n3 = base3 - 1;
              prod = multiply(yc, n3, base3);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n3--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base3);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n3 == 0) {
                cmp = n3 = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL) prod = [0].concat(prod);
            subtract(rem, prod, remL, base3);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n3++;
                subtract(rem, yL < remL ? yz : yc, remL, base3);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n3++;
            rem = [0];
          }
          qc[i4++] = n3;
          if (rem[0]) {
            rem[remL++] = xc[xi2] || 0;
          } else {
            rem = [xc[xi2]];
            remL = 1;
          }
        } while ((xi2++ < xL || rem[0] != null) && s2--);
        more = rem[0] != null;
        if (!qc[0]) qc.splice(0, 1);
      }
      if (base3 == BASE) {
        for (i4 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i4++) ;
        round2(q, dp + (q.e = i4 + e2 * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e2;
        q.r = +more;
      }
      return q;
    };
  })();
  function format(n3, i4, rm, id) {
    var c0, e2, ne2, len, str;
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    if (!n3.c) return n3.toString();
    c0 = n3.c[0];
    ne2 = n3.e;
    if (i4 == null) {
      str = coeffToString(n3.c);
      str = id == 1 || id == 2 && (ne2 <= TO_EXP_NEG || ne2 >= TO_EXP_POS) ? toExponential(str, ne2) : toFixedPoint(str, ne2, "0");
    } else {
      n3 = round2(new BigNumber2(n3), i4, rm);
      e2 = n3.e;
      str = coeffToString(n3.c);
      len = str.length;
      if (id == 1 || id == 2 && (i4 <= e2 || e2 <= TO_EXP_NEG)) {
        for (; len < i4; str += "0", len++) ;
        str = toExponential(str, e2);
      } else {
        i4 -= ne2;
        str = toFixedPoint(str, e2, "0");
        if (e2 + 1 > len) {
          if (--i4 > 0) for (str += "."; i4--; str += "0") ;
        } else {
          i4 += e2 - len;
          if (i4 > 0) {
            if (e2 + 1 == len) str += ".";
            for (; i4--; str += "0") ;
          }
        }
      }
    }
    return n3.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n3) {
    var k2, y3, i4 = 1, x2 = new BigNumber2(args[0]);
    for (; i4 < args.length; i4++) {
      y3 = new BigNumber2(args[i4]);
      if (!y3.s || (k2 = compare(x2, y3)) === n3 || k2 === 0 && x2.s === n3) {
        x2 = y3;
      }
    }
    return x2;
  }
  function normalise(n3, c2, e2) {
    var i4 = 1, j2 = c2.length;
    for (; !c2[--j2]; c2.pop()) ;
    for (j2 = c2[0]; j2 >= 10; j2 /= 10, i4++) ;
    if ((e2 = i4 + e2 * LOG_BASE - 1) > MAX_EXP) {
      n3.c = n3.e = null;
    } else if (e2 < MIN_EXP) {
      n3.c = [n3.e = 0];
    } else {
      n3.e = e2;
      n3.c = c2;
    }
    return n3;
  }
  parseNumeric = /* @__PURE__ */ (function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x2, str, isNum, b2) {
      var base3, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s2)) {
        x2.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s2 = s2.replace(basePrefix, function(m3, p1, p2) {
            base3 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b2 || b2 == base3 ? p1 : m3;
          });
          if (b2) {
            base3 = b2;
            s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s2) return new BigNumber2(s2, base3);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
        }
        x2.s = null;
      }
      x2.c = x2.e = null;
    };
  })();
  function round2(x2, sd, rm, r2) {
    var d3, i4, j2, k2, n3, ni, rd, xc = x2.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d3 = 1, k2 = xc[0]; k2 >= 10; k2 /= 10, d3++) ;
        i4 = sd - d3;
        if (i4 < 0) {
          i4 += LOG_BASE;
          j2 = sd;
          n3 = xc[ni = 0];
          rd = mathfloor(n3 / pows10[d3 - j2 - 1] % 10);
        } else {
          ni = mathceil((i4 + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r2) {
              for (; xc.length <= ni; xc.push(0)) ;
              n3 = rd = 0;
              d3 = 1;
              i4 %= LOG_BASE;
              j2 = i4 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n3 = k2 = xc[ni];
            for (d3 = 1; k2 >= 10; k2 /= 10, d3++) ;
            i4 %= LOG_BASE;
            j2 = i4 - LOG_BASE + d3;
            rd = j2 < 0 ? 0 : mathfloor(n3 / pows10[d3 - j2 - 1] % 10);
          }
        }
        r2 = r2 || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j2 < 0 ? n3 : n3 % pows10[d3 - j2 - 1]);
        r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i4 > 0 ? j2 > 0 ? n3 / pows10[d3 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r2) {
            sd -= x2.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x2.e = -sd || 0;
          } else {
            xc[0] = x2.e = 0;
          }
          return x2;
        }
        if (i4 == 0) {
          xc.length = ni;
          k2 = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k2 = pows10[LOG_BASE - i4];
          xc[ni] = j2 > 0 ? mathfloor(n3 / pows10[d3 - j2] % pows10[j2]) * k2 : 0;
        }
        if (r2) {
          for (; ; ) {
            if (ni == 0) {
              for (i4 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i4++) ;
              j2 = xc[0] += k2;
              for (k2 = 1; j2 >= 10; j2 /= 10, k2++) ;
              if (i4 != k2) {
                x2.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k2;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k2 = 1;
            }
          }
        }
        for (i4 = xc.length; xc[--i4] === 0; xc.pop()) ;
      }
      if (x2.e > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (x2.e < MIN_EXP) {
        x2.c = [x2.e = 0];
      }
    }
    return x2;
  }
  function valueOf(n3) {
    var str, e2 = n3.e;
    if (e2 === null) return n3.toString();
    str = coeffToString(n3.c);
    str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
    return n3.s < 0 ? "-" + str : str;
  }
  P2.absoluteValue = P2.abs = function() {
    var x2 = new BigNumber2(this);
    if (x2.s < 0) x2.s = 1;
    return x2;
  };
  P2.comparedTo = function(y3, b2) {
    return compare(this, new BigNumber2(y3, b2));
  };
  P2.decimalPlaces = P2.dp = function(dp, rm) {
    var c2, n3, v2, x2 = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round2(new BigNumber2(x2), dp + x2.e + 1, rm);
    }
    if (!(c2 = x2.c)) return null;
    n3 = ((v2 = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v2 = c2[v2]) for (; v2 % 10 == 0; v2 /= 10, n3--) ;
    if (n3 < 0) n3 = 0;
    return n3;
  };
  P2.dividedBy = P2.div = function(y3, b2) {
    return div(this, new BigNumber2(y3, b2), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P2.dividedToIntegerBy = P2.idiv = function(y3, b2) {
    return div(this, new BigNumber2(y3, b2), 0, 1);
  };
  P2.exponentiatedBy = P2.pow = function(n3, m3) {
    var half, isModExp, i4, k2, more, nIsBig, nIsNeg, nIsOdd, y3, x2 = this;
    n3 = new BigNumber2(n3);
    if (n3.c && !n3.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n3));
    }
    if (m3 != null) m3 = new BigNumber2(m3);
    nIsBig = n3.e > 14;
    if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n3.c || !n3.c[0]) {
      y3 = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? n3.s * (2 - isOdd(n3)) : +valueOf(n3)));
      return m3 ? y3.mod(m3) : y3;
    }
    nIsNeg = n3.s < 0;
    if (m3) {
      if (m3.c ? !m3.c[0] : !m3.s) return new BigNumber2(NaN);
      isModExp = !nIsNeg && x2.isInteger() && m3.isInteger();
      if (isModExp) x2 = x2.mod(m3);
    } else if (n3.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
      k2 = x2.s < 0 && isOdd(n3) ? -0 : 0;
      if (x2.e > -1) k2 = 1 / k2;
      return new BigNumber2(nIsNeg ? 1 / k2 : k2);
    } else if (POW_PRECISION) {
      k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg) n3.s = 1;
      nIsOdd = isOdd(n3);
    } else {
      i4 = Math.abs(+valueOf(n3));
      nIsOdd = i4 % 2;
    }
    y3 = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y3 = y3.times(x2);
        if (!y3.c) break;
        if (k2) {
          if (y3.c.length > k2) y3.c.length = k2;
        } else if (isModExp) {
          y3 = y3.mod(m3);
        }
      }
      if (i4) {
        i4 = mathfloor(i4 / 2);
        if (i4 === 0) break;
        nIsOdd = i4 % 2;
      } else {
        n3 = n3.times(half);
        round2(n3, n3.e + 1, 1);
        if (n3.e > 14) {
          nIsOdd = isOdd(n3);
        } else {
          i4 = +valueOf(n3);
          if (i4 === 0) break;
          nIsOdd = i4 % 2;
        }
      }
      x2 = x2.times(x2);
      if (k2) {
        if (x2.c && x2.c.length > k2) x2.c.length = k2;
      } else if (isModExp) {
        x2 = x2.mod(m3);
      }
    }
    if (isModExp) return y3;
    if (nIsNeg) y3 = ONE.div(y3);
    return m3 ? y3.mod(m3) : k2 ? round2(y3, POW_PRECISION, ROUNDING_MODE, more) : y3;
  };
  P2.integerValue = function(rm) {
    var n3 = new BigNumber2(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round2(n3, n3.e + 1, rm);
  };
  P2.isEqualTo = P2.eq = function(y3, b2) {
    return compare(this, new BigNumber2(y3, b2)) === 0;
  };
  P2.isFinite = function() {
    return !!this.c;
  };
  P2.isGreaterThan = P2.gt = function(y3, b2) {
    return compare(this, new BigNumber2(y3, b2)) > 0;
  };
  P2.isGreaterThanOrEqualTo = P2.gte = function(y3, b2) {
    return (b2 = compare(this, new BigNumber2(y3, b2))) === 1 || b2 === 0;
  };
  P2.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P2.isLessThan = P2.lt = function(y3, b2) {
    return compare(this, new BigNumber2(y3, b2)) < 0;
  };
  P2.isLessThanOrEqualTo = P2.lte = function(y3, b2) {
    return (b2 = compare(this, new BigNumber2(y3, b2))) === -1 || b2 === 0;
  };
  P2.isNaN = function() {
    return !this.s;
  };
  P2.isNegative = function() {
    return this.s < 0;
  };
  P2.isPositive = function() {
    return this.s > 0;
  };
  P2.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P2.minus = function(y3, b2) {
    var i4, j2, t2, xLTy, x2 = this, a2 = x2.s;
    y3 = new BigNumber2(y3, b2);
    b2 = y3.s;
    if (!a2 || !b2) return new BigNumber2(NaN);
    if (a2 != b2) {
      y3.s = -b2;
      return x2.plus(y3);
    }
    var xe = x2.e / LOG_BASE, ye2 = y3.e / LOG_BASE, xc = x2.c, yc = y3.c;
    if (!xe || !ye2) {
      if (!xc || !yc) return xc ? (y3.s = -b2, y3) : new BigNumber2(yc ? x2 : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y3.s = -b2, y3) : new BigNumber2(xc[0] ? x2 : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye2 = bitFloor(ye2);
    xc = xc.slice();
    if (a2 = xe - ye2) {
      if (xLTy = a2 < 0) {
        a2 = -a2;
        t2 = xc;
      } else {
        ye2 = xe;
        t2 = yc;
      }
      t2.reverse();
      for (b2 = a2; b2--; t2.push(0)) ;
      t2.reverse();
    } else {
      j2 = (xLTy = (a2 = xc.length) < (b2 = yc.length)) ? a2 : b2;
      for (a2 = b2 = 0; b2 < j2; b2++) {
        if (xc[b2] != yc[b2]) {
          xLTy = xc[b2] < yc[b2];
          break;
        }
      }
    }
    if (xLTy) {
      t2 = xc;
      xc = yc;
      yc = t2;
      y3.s = -y3.s;
    }
    b2 = (j2 = yc.length) - (i4 = xc.length);
    if (b2 > 0) for (; b2--; xc[i4++] = 0) ;
    b2 = BASE - 1;
    for (; j2 > a2; ) {
      if (xc[--j2] < yc[j2]) {
        for (i4 = j2; i4 && !xc[--i4]; xc[i4] = b2) ;
        --xc[i4];
        xc[j2] += BASE;
      }
      xc[j2] -= yc[j2];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye2) ;
    if (!xc[0]) {
      y3.s = ROUNDING_MODE == 3 ? -1 : 1;
      y3.c = [y3.e = 0];
      return y3;
    }
    return normalise(y3, xc, ye2);
  };
  P2.modulo = P2.mod = function(y3, b2) {
    var q, s2, x2 = this;
    y3 = new BigNumber2(y3, b2);
    if (!x2.c || !y3.s || y3.c && !y3.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y3.c || x2.c && !x2.c[0]) {
      return new BigNumber2(x2);
    }
    if (MODULO_MODE == 9) {
      s2 = y3.s;
      y3.s = 1;
      q = div(x2, y3, 0, 3);
      y3.s = s2;
      q.s *= s2;
    } else {
      q = div(x2, y3, 0, MODULO_MODE);
    }
    y3 = x2.minus(q.times(y3));
    if (!y3.c[0] && MODULO_MODE == 1) y3.s = x2.s;
    return y3;
  };
  P2.multipliedBy = P2.times = function(y3, b2) {
    var c2, e2, i4, j2, k2, m3, xcL, xlo, xhi, ycL, ylo, yhi, zc, base3, sqrtBase, x2 = this, xc = x2.c, yc = (y3 = new BigNumber2(y3, b2)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x2.s || !y3.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y3.c = y3.e = y3.s = null;
      } else {
        y3.s *= x2.s;
        if (!xc || !yc) {
          y3.c = y3.e = null;
        } else {
          y3.c = [0];
          y3.e = 0;
        }
      }
      return y3;
    }
    e2 = bitFloor(x2.e / LOG_BASE) + bitFloor(y3.e / LOG_BASE);
    y3.s *= x2.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i4 = xcL;
      xcL = ycL;
      ycL = i4;
    }
    for (i4 = xcL + ycL, zc = []; i4--; zc.push(0)) ;
    base3 = BASE;
    sqrtBase = SQRT_BASE;
    for (i4 = ycL; --i4 >= 0; ) {
      c2 = 0;
      ylo = yc[i4] % sqrtBase;
      yhi = yc[i4] / sqrtBase | 0;
      for (k2 = xcL, j2 = i4 + k2; j2 > i4; ) {
        xlo = xc[--k2] % sqrtBase;
        xhi = xc[k2] / sqrtBase | 0;
        m3 = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m3 % sqrtBase * sqrtBase + zc[j2] + c2;
        c2 = (xlo / base3 | 0) + (m3 / sqrtBase | 0) + yhi * xhi;
        zc[j2--] = xlo % base3;
      }
      zc[j2] = c2;
    }
    if (c2) {
      ++e2;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y3, zc, e2);
  };
  P2.negated = function() {
    var x2 = new BigNumber2(this);
    x2.s = -x2.s || null;
    return x2;
  };
  P2.plus = function(y3, b2) {
    var t2, x2 = this, a2 = x2.s;
    y3 = new BigNumber2(y3, b2);
    b2 = y3.s;
    if (!a2 || !b2) return new BigNumber2(NaN);
    if (a2 != b2) {
      y3.s = -b2;
      return x2.minus(y3);
    }
    var xe = x2.e / LOG_BASE, ye2 = y3.e / LOG_BASE, xc = x2.c, yc = y3.c;
    if (!xe || !ye2) {
      if (!xc || !yc) return new BigNumber2(a2 / 0);
      if (!xc[0] || !yc[0]) return yc[0] ? y3 : new BigNumber2(xc[0] ? x2 : a2 * 0);
    }
    xe = bitFloor(xe);
    ye2 = bitFloor(ye2);
    xc = xc.slice();
    if (a2 = xe - ye2) {
      if (a2 > 0) {
        ye2 = xe;
        t2 = yc;
      } else {
        a2 = -a2;
        t2 = xc;
      }
      t2.reverse();
      for (; a2--; t2.push(0)) ;
      t2.reverse();
    }
    a2 = xc.length;
    b2 = yc.length;
    if (a2 - b2 < 0) {
      t2 = yc;
      yc = xc;
      xc = t2;
      b2 = a2;
    }
    for (a2 = 0; b2; ) {
      a2 = (xc[--b2] = xc[b2] + yc[b2] + a2) / BASE | 0;
      xc[b2] = BASE === xc[b2] ? 0 : xc[b2] % BASE;
    }
    if (a2) {
      xc = [a2].concat(xc);
      ++ye2;
    }
    return normalise(y3, xc, ye2);
  };
  P2.precision = P2.sd = function(sd, rm) {
    var c2, n3, v2, x2 = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round2(new BigNumber2(x2), sd, rm);
    }
    if (!(c2 = x2.c)) return null;
    v2 = c2.length - 1;
    n3 = v2 * LOG_BASE + 1;
    if (v2 = c2[v2]) {
      for (; v2 % 10 == 0; v2 /= 10, n3--) ;
      for (v2 = c2[0]; v2 >= 10; v2 /= 10, n3++) ;
    }
    if (sd && x2.e + 1 > n3) n3 = x2.e + 1;
    return n3;
  };
  P2.shiftedBy = function(k2) {
    intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k2);
  };
  P2.squareRoot = P2.sqrt = function() {
    var m3, n3, r2, rep, t2, x2 = this, c2 = x2.c, s2 = x2.s, e2 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s2 !== 1 || !c2 || !c2[0]) {
      return new BigNumber2(!s2 || s2 < 0 && (!c2 || c2[0]) ? NaN : c2 ? x2 : 1 / 0);
    }
    s2 = Math.sqrt(+valueOf(x2));
    if (s2 == 0 || s2 == 1 / 0) {
      n3 = coeffToString(c2);
      if ((n3.length + e2) % 2 == 0) n3 += "0";
      s2 = Math.sqrt(+n3);
      e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
      if (s2 == 1 / 0) {
        n3 = "5e" + e2;
      } else {
        n3 = s2.toExponential();
        n3 = n3.slice(0, n3.indexOf("e") + 1) + e2;
      }
      r2 = new BigNumber2(n3);
    } else {
      r2 = new BigNumber2(s2 + "");
    }
    if (r2.c[0]) {
      e2 = r2.e;
      s2 = e2 + dp;
      if (s2 < 3) s2 = 0;
      for (; ; ) {
        t2 = r2;
        r2 = half.times(t2.plus(div(x2, t2, dp, 1)));
        if (coeffToString(t2.c).slice(0, s2) === (n3 = coeffToString(r2.c)).slice(0, s2)) {
          if (r2.e < e2) --s2;
          n3 = n3.slice(s2 - 3, s2 + 1);
          if (n3 == "9999" || !rep && n3 == "4999") {
            if (!rep) {
              round2(t2, t2.e + DECIMAL_PLACES + 2, 0);
              if (t2.times(t2).eq(x2)) {
                r2 = t2;
                break;
              }
            }
            dp += 4;
            s2 += 4;
            rep = 1;
          } else {
            if (!+n3 || !+n3.slice(1) && n3.charAt(0) == "5") {
              round2(r2, r2.e + DECIMAL_PLACES + 2, 1);
              m3 = !r2.times(r2).eq(x2);
            }
            break;
          }
        }
      }
    }
    return round2(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m3);
  };
  P2.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P2.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P2.toFormat = function(dp, rm, format2) {
    var str, x2 = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x2.toFixed(dp, rm);
    if (x2.c) {
      var i4, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i4 = g1;
        g1 = g2;
        g2 = i4;
        len -= i4;
      }
      if (g1 > 0 && len > 0) {
        i4 = len % g1 || g1;
        intPart = intDigits.substr(0, i4);
        for (; i4 < len; i4 += g1) intPart += groupSeparator + intDigits.substr(i4, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i4);
        if (isNeg) intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P2.toFraction = function(md) {
    var d3, d02, d1, d22, e2, exp, n3, n0, n1, q, r2, s2, x2 = this, xc = x2.c;
    if (md != null) {
      n3 = new BigNumber2(md);
      if (!n3.isInteger() && (n3.c || n3.s !== 1) || n3.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n3.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n3));
      }
    }
    if (!xc) return new BigNumber2(x2);
    d3 = new BigNumber2(ONE);
    n1 = d02 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s2 = coeffToString(xc);
    e2 = d3.e = s2.length - x2.e - 1;
    d3.c[0] = POWS_TEN[(exp = e2 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n3.comparedTo(d3) > 0 ? e2 > 0 ? d3 : n1 : n3;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n3 = new BigNumber2(s2);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n3, d3, 0, 1);
      d22 = d02.plus(q.times(d1));
      if (d22.comparedTo(md) == 1) break;
      d02 = d1;
      d1 = d22;
      n1 = n0.plus(q.times(d22 = n1));
      n0 = d22;
      d3 = n3.minus(q.times(d22 = d3));
      n3 = d22;
    }
    d22 = div(md.minus(d02), d1, 0, 1);
    n0 = n0.plus(d22.times(n1));
    d02 = d02.plus(d22.times(d1));
    n0.s = n1.s = x2.s;
    e2 = e2 * 2;
    r2 = div(n1, d1, e2, ROUNDING_MODE).minus(x2).abs().comparedTo(
      div(n0, d02, e2, ROUNDING_MODE).minus(x2).abs()
    ) < 1 ? [n1, d1] : [n0, d02];
    MAX_EXP = exp;
    return r2;
  };
  P2.toNumber = function() {
    return +valueOf(this);
  };
  P2.toPrecision = function(sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P2.toString = function(b2) {
    var str, n3 = this, s2 = n3.s, e2 = n3.e;
    if (e2 === null) {
      if (s2) {
        str = "Infinity";
        if (s2 < 0) str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b2 == null) {
        str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n3.c), e2) : toFixedPoint(coeffToString(n3.c), e2, "0");
      } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
        n3 = round2(new BigNumber2(n3), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n3.c), n3.e, "0");
      } else {
        intCheck(b2, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n3.c), e2, "0"), 10, b2, s2, true);
      }
      if (s2 < 0 && n3.c[0]) str = "-" + str;
    }
    return str;
  };
  P2.valueOf = P2.toJSON = function() {
    return valueOf(this);
  };
  P2._isBigNumber = true;
  P2[Symbol.toStringTag] = "BigNumber";
  P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
  if (configObject != null) BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n3) {
  var i4 = n3 | 0;
  return n3 > 0 || n3 === i4 ? i4 : i4 - 1;
}
function coeffToString(a2) {
  var s2, z3, i4 = 1, j2 = a2.length, r2 = a2[0] + "";
  for (; i4 < j2; ) {
    s2 = a2[i4++] + "";
    z3 = LOG_BASE - s2.length;
    for (; z3--; s2 = "0" + s2) ;
    r2 += s2;
  }
  for (j2 = r2.length; r2.charCodeAt(--j2) === 48; ) ;
  return r2.slice(0, j2 + 1 || 1);
}
function compare(x2, y3) {
  var a2, b2, xc = x2.c, yc = y3.c, i4 = x2.s, j2 = y3.s, k2 = x2.e, l2 = y3.e;
  if (!i4 || !j2) return null;
  a2 = xc && !xc[0];
  b2 = yc && !yc[0];
  if (a2 || b2) return a2 ? b2 ? 0 : -j2 : i4;
  if (i4 != j2) return i4;
  a2 = i4 < 0;
  b2 = k2 == l2;
  if (!xc || !yc) return b2 ? 0 : !xc ^ a2 ? 1 : -1;
  if (!b2) return k2 > l2 ^ a2 ? 1 : -1;
  j2 = (k2 = xc.length) < (l2 = yc.length) ? k2 : l2;
  for (i4 = 0; i4 < j2; i4++) if (xc[i4] != yc[i4]) return xc[i4] > yc[i4] ^ a2 ? 1 : -1;
  return k2 == l2 ? 0 : k2 > l2 ^ a2 ? 1 : -1;
}
function intCheck(n3, min2, max2, name) {
  if (n3 < min2 || n3 > max2 || n3 !== mathfloor(n3)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n3 == "number" ? n3 < min2 || n3 > max2 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n3));
  }
}
function isOdd(n3) {
  var k2 = n3.c.length - 1;
  return bitFloor(n3.e / LOG_BASE) == k2 && n3.c[k2] % 2 != 0;
}
function toExponential(str, e2) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
}
function toFixedPoint(str, e2, z3) {
  var len, zs2;
  if (e2 < 0) {
    for (zs2 = z3 + "."; ++e2; zs2 += z3) ;
    str = zs2 + str;
  } else {
    len = str.length;
    if (++e2 > len) {
      for (zs2 = z3, e2 -= len; --e2; zs2 += z3) ;
      str += zs2;
    } else if (e2 < len) {
      str = str.slice(0, e2) + "." + str.slice(e2);
    }
  }
  return str;
}
var BigNumber = clone();
const NumberUtil = {
  bigNumber(value) {
    return new BigNumber(value);
  },
  multiply(a2, b2) {
    if (a2 === void 0 || b2 === void 0) {
      return BigNumber(0);
    }
    const aBigNumber = new BigNumber(a2);
    const bBigNumber = new BigNumber(b2);
    return aBigNumber.multipliedBy(bBigNumber);
  },
  formatNumberToLocalString(value, decimals = 2) {
    if (value === void 0) {
      return "0.00";
    }
    if (typeof value === "number") {
      return value.toLocaleString("en-US", {
        maximumFractionDigits: decimals,
        minimumFractionDigits: decimals
      });
    }
    return parseFloat(value).toLocaleString("en-US", {
      maximumFractionDigits: decimals,
      minimumFractionDigits: decimals
    });
  }
};
const InputUtil = {
  numericInputKeyDown(event, currentValue, onChange) {
    const allowedKeys = [
      "Backspace",
      "Meta",
      "Ctrl",
      "a",
      "A",
      "c",
      "C",
      "x",
      "X",
      "v",
      "V",
      "ArrowLeft",
      "ArrowRight",
      "Tab"
    ];
    const controlPressed = event.metaKey || event.ctrlKey;
    const eventKey = event.key;
    const lowercaseEventKey = eventKey.toLocaleLowerCase();
    const selectAll = lowercaseEventKey === "a";
    const copyKey = lowercaseEventKey === "c";
    const pasteKey = lowercaseEventKey === "v";
    const cutKey = lowercaseEventKey === "x";
    const isComma = eventKey === ",";
    const isDot = eventKey === ".";
    const isNumericKey = eventKey >= "0" && eventKey <= "9";
    if (!controlPressed && (selectAll || copyKey || pasteKey || cutKey)) {
      event.preventDefault();
    }
    if (currentValue === "0" && !isComma && !isDot && eventKey === "0") {
      event.preventDefault();
    }
    if (currentValue === "0" && isNumericKey) {
      onChange(eventKey);
      event.preventDefault();
    }
    if (isComma || isDot) {
      if (!currentValue) {
        onChange("0.");
        event.preventDefault();
      }
      if (currentValue?.includes(".") || currentValue?.includes(",")) {
        event.preventDefault();
      }
    }
    if (!isNumericKey && !allowedKeys.includes(eventKey) && !isDot && !isComma) {
      event.preventDefault();
    }
  }
};
const erc20ABI = [
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_spender",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      },
      {
        name: "_spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    payable: true,
    stateMutability: "payable",
    type: "fallback"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  }
];
const NavigationUtil = {
  URLS: {
    FAQ: "https://walletconnect.com/faq"
  }
};
const ConstantsUtil$2 = {
  WC_NAME_SUFFIX: ".wcn.id",
  BLOCKCHAIN_API_RPC_URL: "https://rpc.walletconnect.org",
  PULSE_API_URL: "https://pulse.walletconnect.org",
  W3M_API_URL: "https://api.web3modal.org",
  CHAIN: {
    EVM: "evm",
    SOLANA: "solana"
  },
  CHAIN_NAME_MAP: {
    evm: "Ethereum",
    solana: "Solana"
  }
};
function getW3mThemeVariables(themeVariables, themeType) {
  if (themeType === "light") {
    return {
      "--w3m-accent": themeVariables?.["--w3m-accent"] || "hsla(231, 100%, 70%, 1)",
      "--w3m-background": "#fff"
    };
  }
  return {
    "--w3m-accent": themeVariables?.["--w3m-accent"] || "hsla(230, 100%, 67%, 1)",
    "--w3m-background": "#121313"
  };
}
const SECURE_SITE = "https://secure.walletconnect.org";
const ONRAMP_PROVIDERS = [
  {
    label: "Coinbase",
    name: "coinbase",
    feeRange: "1-2%",
    url: "",
    supportedChains: ["evm"]
  },
  {
    label: "Meld.io",
    name: "meld",
    feeRange: "1-2%",
    url: "https://meldcrypto.com",
    supportedChains: ["evm", "solana"]
  }
];
const MELD_PROD_PUBLIC_KEY = "WXETMuFUQmqqybHuRkSgxv:25B8LJHSfpG6LVjR2ytU5Cwh7Z4Sch2ocoU";
const ConstantsUtil$1 = {
  FOUR_MINUTES_MS: 24e4,
  TEN_SEC_MS: 1e4,
  ONE_SEC_MS: 1e3,
  SECURE_SITE,
  SECURE_SITE_DASHBOARD: `${SECURE_SITE}/dashboard`,
  SECURE_SITE_FAVICON: `${SECURE_SITE}/images/favicon.png`,
  /**
   * Network name to Coinbase Pay SDK chain name map object
   * @see supported chain names on Coinbase for Pay SDK: https://github.com/coinbase/cbpay-js/blob/d4bda2c05c4d5917c8db6a05476b603546046394/src/types/onramp.ts
   */
  WC_COINBASE_PAY_SDK_CHAINS: [
    "ethereum",
    "arbitrum",
    "polygon",
    "avalanche-c-chain",
    "optimism",
    "celo",
    "base"
  ],
  WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: "ethereum",
  WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
    Ethereum: "ethereum",
    "Arbitrum One": "arbitrum",
    Polygon: "polygon",
    Avalanche: "avalanche-c-chain",
    "OP Mainnet": "optimism",
    Celo: "celo",
    Base: "base"
  },
  SWAP_SUGGESTED_TOKENS: [
    "ETH",
    "UNI",
    "1INCH",
    "AAVE",
    "SOL",
    "ADA",
    "AVAX",
    "DOT",
    "LINK",
    "NITRO",
    "GAIA",
    "MILK",
    "TRX",
    "NEAR",
    "GNO",
    "WBTC",
    "DAI",
    "WETH",
    "USDC",
    "USDT",
    "ARB",
    "BAL",
    "BICO",
    "CRV",
    "ENS",
    "MATIC",
    "OP"
  ],
  SWAP_SUPPORTED_NETWORKS: [
    // Ethereum'
    "eip155:1",
    // Arbitrum One'
    "eip155:42161",
    // Optimism'
    "eip155:10",
    // ZKSync Era'
    "eip155:324",
    // Base'
    "eip155:8453",
    // BNB Smart Chain'
    "eip155:56",
    // Polygon'
    "eip155:137",
    // Gnosis'
    "eip155:100",
    // Avalanche'
    "eip155:43114",
    // Fantom'
    "eip155:250",
    // Klaytn'
    "eip155:8217",
    // Aurora
    "eip155:1313161554"
  ],
  NATIVE_TOKEN_ADDRESS: {
    evm: "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
    solana: "So11111111111111111111111111111111111111111"
  },
  CONVERT_SLIPPAGE_TOLERANCE: 1,
  DEFAULT_FEATURES: {
    swaps: true,
    onramp: true,
    analytics: true,
    allWallets: "SHOW",
    disableAppend: false,
    enableEIP6963: false
  }
};
const CoreHelperUtil = {
  isMobile() {
    if (typeof window !== "undefined") {
      return Boolean(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));
    }
    return false;
  },
  checkCaipNetwork(network, networkName = "") {
    return network?.id.toLocaleLowerCase().includes(networkName.toLowerCase());
  },
  isAndroid() {
    const ua2 = window.navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && ua2.includes("android");
  },
  isIos() {
    const ua2 = window.navigator.userAgent.toLowerCase();
    return CoreHelperUtil.isMobile() && (ua2.includes("iphone") || ua2.includes("ipad"));
  },
  isClient() {
    return typeof window !== "undefined";
  },
  isPairingExpired(expiry) {
    return expiry ? expiry - Date.now() <= ConstantsUtil$1.TEN_SEC_MS : true;
  },
  isAllowedRetry(lastRetry) {
    return Date.now() - lastRetry >= ConstantsUtil$1.ONE_SEC_MS;
  },
  copyToClopboard(text) {
    navigator.clipboard.writeText(text);
  },
  getPairingExpiry() {
    return Date.now() + ConstantsUtil$1.FOUR_MINUTES_MS;
  },
  getNetworkId(caipAddress) {
    return caipAddress?.split(":")[1];
  },
  getPlainAddress(caipAddress) {
    return caipAddress?.split(":")[2];
  },
  async wait(milliseconds) {
    return new Promise((resolve) => {
      setTimeout(resolve, milliseconds);
    });
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  debounce(func, timeout = 500) {
    let timer = void 0;
    return (...args) => {
      function next2() {
        func(...args);
      }
      if (timer) {
        clearTimeout(timer);
      }
      timer = setTimeout(next2, timeout);
    };
  },
  isHttpUrl(url) {
    return url.startsWith("http://") || url.startsWith("https://");
  },
  formatNativeUrl(appUrl, wcUri) {
    if (CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatUniversalUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.includes("://")) {
      safeAppUrl = appUrl.replaceAll("/", "").replaceAll(":", "");
      safeAppUrl = `${safeAppUrl}://`;
    }
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  formatUniversalUrl(appUrl, wcUri) {
    if (!CoreHelperUtil.isHttpUrl(appUrl)) {
      return this.formatNativeUrl(appUrl, wcUri);
    }
    let safeAppUrl = appUrl;
    if (!safeAppUrl.endsWith("/")) {
      safeAppUrl = `${safeAppUrl}/`;
    }
    const encodedWcUrl = encodeURIComponent(wcUri);
    return {
      redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
      href: safeAppUrl
    };
  },
  openHref(href, target, features) {
    window.open(href, target, features || "noreferrer noopener");
  },
  returnOpenHref(href, target, features) {
    return window.open(href, target, features || "noreferrer noopener");
  },
  async preloadImage(src2) {
    const imagePromise = new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = resolve;
      image.onerror = reject;
      image.crossOrigin = "anonymous";
      image.src = src2;
    });
    return Promise.race([imagePromise, CoreHelperUtil.wait(2e3)]);
  },
  formatBalance(balance, symbol) {
    let formattedBalance = "0.000";
    if (typeof balance === "string") {
      const number = Number(balance);
      if (number) {
        const formattedValue = Math.floor(number * 1e3) / 1e3;
        if (formattedValue) {
          formattedBalance = formattedValue.toString();
        }
      }
    }
    return `${formattedBalance}${symbol ? ` ${symbol}` : ""}`;
  },
  formatBalance2(balance, symbol) {
    let formattedBalance = void 0;
    if (balance === "0") {
      formattedBalance = "0";
    } else if (typeof balance === "string") {
      const number = Number(balance);
      if (number) {
        formattedBalance = number.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0];
      }
    }
    return {
      value: formattedBalance ?? "0",
      rest: formattedBalance === "0" ? "000" : "",
      symbol
    };
  },
  getApiUrl() {
    return ConstantsUtil$2.W3M_API_URL;
  },
  getBlockchainApiUrl() {
    return ConstantsUtil$2.BLOCKCHAIN_API_RPC_URL;
  },
  getAnalyticsUrl() {
    return ConstantsUtil$2.PULSE_API_URL;
  },
  getUUID() {
    if (crypto?.randomUUID) {
      return crypto.randomUUID();
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (c2) => {
      const r2 = Math.random() * 16 | 0;
      const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
      return v2.toString(16);
    });
  },
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  parseError(error) {
    if (typeof error === "string") {
      return error;
    } else if (typeof error?.issues?.[0]?.message === "string") {
      return error.issues[0].message;
    } else if (error instanceof Error) {
      return error.message;
    }
    return "Unknown error";
  },
  sortRequestedNetworks(approvedIds, requestedNetworks = []) {
    const approvedIndexMap = {};
    if (requestedNetworks && approvedIds) {
      approvedIds.forEach((id, index2) => {
        approvedIndexMap[id] = index2;
      });
      requestedNetworks.sort((a2, b2) => {
        const indexA = approvedIndexMap[a2.id];
        const indexB = approvedIndexMap[b2.id];
        if (indexA !== void 0 && indexB !== void 0) {
          return indexA - indexB;
        } else if (indexA !== void 0) {
          return -1;
        } else if (indexB !== void 0) {
          return 1;
        }
        return 0;
      });
    }
    return requestedNetworks;
  },
  calculateBalance(array) {
    let sum = 0;
    for (const item of array) {
      sum += item.value ?? 0;
    }
    return sum;
  },
  formatTokenBalance(number) {
    const roundedNumber = number.toFixed(2);
    const [dollars, pennies] = roundedNumber.split(".");
    return { dollars, pennies };
  },
  isAddress(address, chain = "evm") {
    switch (chain) {
      case "evm":
        if (!/^(?:0x)?[0-9a-f]{40}$/iu.test(address)) {
          return false;
        } else if (/^(?:0x)?[0-9a-f]{40}$/iu.test(address) || /^(?:0x)?[0-9A-F]{40}$/iu.test(address)) {
          return true;
        }
        return false;
      case "solana":
        return /[1-9A-HJ-NP-Za-km-z]{32,44}$/iu.test(address);
      default:
        return false;
    }
  },
  uniqueBy(arr, key2) {
    const set = /* @__PURE__ */ new Set();
    return arr.filter((item) => {
      const keyValue = item[key2];
      if (set.has(keyValue)) {
        return false;
      }
      set.add(keyValue);
      return true;
    });
  }
};
async function fetchData(...args) {
  const response = await fetch(...args);
  if (!response.ok) {
    const err = new Error(`HTTP status code: ${response.status}`, {
      cause: response
    });
    throw err;
  }
  return response;
}
class FetchUtil {
  constructor({ baseUrl: baseUrl2, clientId }) {
    this.baseUrl = baseUrl2;
    this.clientId = clientId;
  }
  async get({ headers, signal, cache, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, { method: "GET", headers, signal, cache });
    return response.json();
  }
  async getBlob({ headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, { method: "GET", headers, signal });
    return response.blob();
  }
  async post({ body: body2, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "POST",
      headers,
      body: body2 ? JSON.stringify(body2) : void 0,
      signal
    });
    return response.json();
  }
  async put({ body: body2, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "PUT",
      headers,
      body: body2 ? JSON.stringify(body2) : void 0,
      signal
    });
    return response.json();
  }
  async delete({ body: body2, headers, signal, ...args }) {
    const url = this.createUrl(args);
    const response = await fetchData(url, {
      method: "DELETE",
      headers,
      body: body2 ? JSON.stringify(body2) : void 0,
      signal
    });
    return response.json();
  }
  createUrl({ path, params }) {
    const url = new URL(path, this.baseUrl);
    if (params) {
      Object.entries(params).forEach(([key2, value]) => {
        if (value) {
          url.searchParams.append(key2, value);
        }
      });
    }
    if (this.clientId) {
      url.searchParams.append("clientId", this.clientId);
    }
    return url;
  }
}
const WC_DEEPLINK = "WALLETCONNECT_DEEPLINK_CHOICE";
const W3M_RECENT = "@w3m/recent";
const W3M_CONNECTED_CONNECTOR = "@w3m/connected_connector";
const W3M_CONNECTED_SOCIAL = "@w3m/connected_social";
const W3M_CONNECTED_SOCIAL_USERNAME = "@w3m-storage/SOCIAL_USERNAME";
const StorageUtil = {
  setWalletConnectDeepLink({ href, name }) {
    try {
      localStorage.setItem(WC_DEEPLINK, JSON.stringify({ href, name }));
    } catch {
      console.info("Unable to set WalletConnect deep link");
    }
  },
  getWalletConnectDeepLink() {
    try {
      const deepLink = localStorage.getItem(WC_DEEPLINK);
      if (deepLink) {
        return JSON.parse(deepLink);
      }
    } catch {
      console.info("Unable to get WalletConnect deep link");
    }
    return void 0;
  },
  deleteWalletConnectDeepLink() {
    try {
      localStorage.removeItem(WC_DEEPLINK);
    } catch {
      console.info("Unable to delete WalletConnect deep link");
    }
  },
  setWeb3ModalRecent(wallet) {
    try {
      const recentWallets = StorageUtil.getRecentWallets();
      const exists = recentWallets.find((w2) => w2.id === wallet.id);
      if (!exists) {
        recentWallets.unshift(wallet);
        if (recentWallets.length > 2) {
          recentWallets.pop();
        }
        localStorage.setItem(W3M_RECENT, JSON.stringify(recentWallets));
      }
    } catch {
      console.info("Unable to set Web3Modal recent");
    }
  },
  getRecentWallets() {
    try {
      const recent = localStorage.getItem(W3M_RECENT);
      return recent ? JSON.parse(recent) : [];
    } catch {
      console.info("Unable to get Web3Modal recent");
    }
    return [];
  },
  setConnectedConnector(connectorType) {
    try {
      localStorage.setItem(W3M_CONNECTED_CONNECTOR, connectorType);
    } catch {
      console.info("Unable to set Connected Connector");
    }
  },
  getConnectedConnector() {
    try {
      return localStorage.getItem(W3M_CONNECTED_CONNECTOR);
    } catch {
      console.info("Unable to get Connected Connector");
    }
    return void 0;
  },
  setConnectedSocialProvider(socialProvider) {
    try {
      localStorage.setItem(W3M_CONNECTED_SOCIAL, socialProvider);
    } catch {
      console.info("Unable to set Connected Social Provider");
    }
  },
  getConnectedSocialProvider() {
    try {
      return localStorage.getItem(W3M_CONNECTED_SOCIAL);
    } catch {
      console.info("Unable to get Connected Social Provider");
    }
    return void 0;
  },
  getConnectedSocialUsername() {
    try {
      return localStorage.getItem(W3M_CONNECTED_SOCIAL_USERNAME);
    } catch {
      console.info("Unable to get Connected Social Username");
    }
    return void 0;
  }
};
const state$k = proxy({
  walletImages: {},
  networkImages: {},
  chainImages: {},
  connectorImages: {},
  tokenImages: {},
  currencyImages: {}
});
const AssetController = {
  state: state$k,
  subscribeNetworkImages(callback) {
    return subscribe(state$k.networkImages, () => callback(state$k.networkImages));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$k, key2, callback);
  },
  subscribe(callback) {
    return subscribe(state$k, () => callback(state$k));
  },
  setWalletImage(key2, value) {
    state$k.walletImages[key2] = value;
  },
  setNetworkImage(key2, value) {
    state$k.networkImages[key2] = value;
  },
  setChainImage(key2, value) {
    state$k.chainImages[key2] = value;
  },
  setConnectorImage(key2, value) {
    state$k.connectorImages[key2] = value;
  },
  setTokenImage(key2, value) {
    state$k.tokenImages[key2] = value;
  },
  setCurrencyImage(key2, value) {
    state$k.currencyImages[key2] = value;
  }
};
const state$j = proxy({
  themeMode: "dark",
  themeVariables: {},
  w3mThemeVariables: void 0
});
const ThemeController = {
  state: state$j,
  subscribe(callback) {
    return subscribe(state$j, () => callback(state$j));
  },
  setThemeMode(themeMode) {
    state$j.themeMode = themeMode;
    try {
      const authConnector2 = ConnectorController.getAuthConnector();
      if (authConnector2) {
        const themeVariables = ThemeController.getSnapshot().themeVariables;
        authConnector2.provider.syncTheme({
          themeMode,
          themeVariables,
          w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  setThemeVariables(themeVariables) {
    state$j.themeVariables = { ...state$j.themeVariables, ...themeVariables };
    try {
      const authConnector2 = ConnectorController.getAuthConnector();
      if (authConnector2) {
        const themeVariablesSnapshot = ThemeController.getSnapshot().themeVariables;
        authConnector2.provider.syncTheme({
          themeVariables: themeVariablesSnapshot,
          w3mThemeVariables: getW3mThemeVariables(state$j.themeVariables, state$j.themeMode)
        });
      }
    } catch {
      console.info("Unable to sync theme to auth connector");
    }
  },
  getSnapshot() {
    return snapshot(state$j);
  }
};
const state$i = proxy({
  unMergedConnectors: [],
  connectors: []
});
const ConnectorController = {
  state: state$i,
  subscribeKey(key2, callback) {
    return subscribeKey(state$i, key2, callback);
  },
  setConnectors(connectors) {
    connectors.forEach(this.syncIfAuthConnector);
    state$i.unMergedConnectors = [...state$i.unMergedConnectors, ...connectors].filter((connector) => {
      try {
        const canProxyConnector = Boolean(proxy(connector));
        if (!canProxyConnector) {
          throw new Error("Connector is not available");
        }
        return true;
      } catch (error) {
        console.error("ConnectorController.setConnectors: Not possible to add connector", {
          connector,
          error
        });
        return false;
      }
    });
    state$i.connectors = this.mergeMultiChainConnectors(state$i.unMergedConnectors);
  },
  mergeMultiChainConnectors(connectors) {
    const connectorsByNameMap = this.generateConnectorMapByName(connectors);
    const refactoredConnectors = Array.from(connectorsByNameMap.values()).map((_connectors) => {
      if (_connectors.length > 1) {
        return {
          name: _connectors[0]?.name,
          imageUrl: _connectors[0]?.imageUrl,
          imageId: _connectors[0]?.imageId,
          providers: this.getUniqueConnectorsByName(_connectors),
          type: "MULTI_CHAIN"
        };
      }
      return _connectors[0];
    });
    return refactoredConnectors;
  },
  generateConnectorMapByName(connectors) {
    const connectorsByNameMap = /* @__PURE__ */ new Map();
    connectors.forEach((connector) => {
      const { name } = connector;
      if (!name) {
        return;
      }
      const connectorsByName = connectorsByNameMap.get(name) || [];
      const haveSameConnector = connectorsByName.find((c2) => c2.chain === connector.chain);
      if (!haveSameConnector) {
        connectorsByName.push(connector);
      }
      connectorsByNameMap.set(name, connectorsByName);
    });
    return connectorsByNameMap;
  },
  getUniqueConnectorsByName(connectors) {
    const uniqueConnectors = [];
    connectors.forEach((c2) => {
      if (!uniqueConnectors.find((uc) => uc.chain === c2.chain)) {
        uniqueConnectors.push({
          ...c2,
          name: ConstantsUtil$2.CHAIN_NAME_MAP[c2.chain]
        });
      }
    });
    return uniqueConnectors;
  },
  addConnector(connector) {
    this.setConnectors([connector]);
  },
  getAuthConnector() {
    return state$i.connectors.find((c2) => c2.type === "AUTH");
  },
  getAnnouncedConnectorRdns() {
    return state$i.connectors.filter((c2) => c2.type === "ANNOUNCED").map((c2) => c2.info?.rdns);
  },
  getConnectors() {
    return state$i.connectors;
  },
  getConnector(id, rdns) {
    return state$i.connectors.find((c2) => c2.explorerId === id || c2.info?.rdns === rdns);
  },
  syncIfAuthConnector(connector) {
    if (connector.id !== "w3mAuth") {
      return;
    }
    const authConnector2 = connector;
    const optionsState = snapshot(OptionsController.state);
    const themeMode = ThemeController.getSnapshot().themeMode;
    const themeVariables = ThemeController.getSnapshot().themeVariables;
    authConnector2?.provider?.syncDappData?.({
      metadata: optionsState.metadata,
      sdkVersion: optionsState.sdkVersion,
      projectId: optionsState.projectId
    });
    authConnector2.provider.syncTheme({
      themeMode,
      themeVariables,
      w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
    });
  }
};
const baseUrl$2 = CoreHelperUtil.getAnalyticsUrl();
const api$1 = new FetchUtil({ baseUrl: baseUrl$2, clientId: null });
const excluded = ["MODAL_CREATED"];
const state$h = proxy({
  timestamp: Date.now(),
  data: {
    type: "track",
    event: "MODAL_CREATED"
  }
});
const EventsController = {
  state: state$h,
  subscribe(callback) {
    return subscribe(state$h, () => callback(state$h));
  },
  _getApiHeaders() {
    const { projectId: projectId2, sdkType, sdkVersion } = OptionsController.state;
    return {
      "x-project-id": projectId2,
      "x-sdk-type": sdkType,
      "x-sdk-version": sdkVersion
    };
  },
  async _sendAnalyticsEvent(payload) {
    try {
      if (excluded.includes(payload.data.event) || typeof window === "undefined") {
        return;
      }
      await api$1.post({
        path: "/e",
        headers: EventsController._getApiHeaders(),
        body: {
          eventId: CoreHelperUtil.getUUID(),
          url: window.location.href,
          domain: window.location.hostname,
          timestamp: payload.timestamp,
          props: payload.data
        }
      });
    } catch {
    }
  },
  sendEvent(data2) {
    state$h.timestamp = Date.now();
    state$h.data = data2;
    if (OptionsController.state.enableAnalytics) {
      EventsController._sendAnalyticsEvent(state$h);
    }
  }
};
const state$g = proxy({
  loading: false,
  open: false,
  selectedNetworkId: void 0,
  activeChain: void 0
});
const PublicStateController = {
  state: state$g,
  subscribe(callback) {
    return subscribe(state$g, () => callback(state$g));
  },
  set(newState) {
    Object.assign(state$g, { ...state$g, ...newState });
  }
};
const accountState = {
  isConnected: false,
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: false,
  addressLabels: /* @__PURE__ */ new Map(),
  allAccounts: []
};
const networkState = {
  supportsAllNetworks: true,
  isDefaultCaipNetwork: false,
  smartAccountEnabledNetworks: []
};
const state$f = proxy({
  chains: proxyMap(),
  activeChain: void 0,
  activeCaipNetwork: void 0
});
const ChainController = {
  state: state$f,
  subscribeKey(key2, callback) {
    return subscribeKey(state$f, key2, callback);
  },
  subscribeChain(callback) {
    let prev2 = void 0;
    return subscribe(state$f.chains, () => {
      const activeChain = state$f.activeChain;
      if (activeChain) {
        const nextValue = state$f.chains.get(activeChain);
        if (!prev2 || prev2 !== nextValue) {
          prev2 = nextValue;
          callback(nextValue);
        }
      }
    });
  },
  subscribeChainProp(property, callback) {
    let prev2 = void 0;
    return subscribe(state$f.chains, () => {
      const activeChain = state$f.activeChain;
      if (activeChain) {
        const nextValue = state$f.chains.get(activeChain)?.[property];
        if (prev2 !== nextValue) {
          prev2 = nextValue;
          callback(nextValue);
        }
      }
    });
  },
  initialize(adapters) {
    const adapterToActivate = adapters?.[0];
    if (!adapterToActivate) {
      throw new Error("Adapter is required to initialize ChainController");
    }
    state$f.activeChain = adapterToActivate.chain;
    PublicStateController.set({ activeChain: adapterToActivate.chain });
    this.setActiveCaipNetwork(adapterToActivate.defaultChain);
    adapters.forEach((adapter) => {
      state$f.chains.set(adapter.chain, {
        chain: adapter.chain,
        connectionControllerClient: adapter.connectionControllerClient,
        networkControllerClient: adapter.networkControllerClient,
        accountState,
        networkState
      });
    });
  },
  setChainNetworkData(chain, props, replaceState = false) {
    if (!chain) {
      throw new Error("Chain is required to update chain network data");
    }
    const chainAdapter = state$f.chains.get(chain);
    if (chainAdapter) {
      chainAdapter.networkState = ref({
        ...chainAdapter.networkState,
        ...props
      });
      state$f.chains.set(chain, ref(chainAdapter));
      if (replaceState || state$f.chains.size === 1 || state$f.activeChain === chain) {
        NetworkController.replaceState(chainAdapter.networkState);
      }
    }
  },
  setChainAccountData(chain, accountProps, replaceState = true) {
    if (!chain) {
      throw new Error("Chain is required to update chain account data");
    }
    const chainAdapter = state$f.chains.get(chain);
    if (chainAdapter) {
      chainAdapter.accountState = ref({
        ...chainAdapter.accountState,
        ...accountProps
      });
      state$f.chains.set(chain, chainAdapter);
      if (replaceState || state$f.chains.size === 1 || state$f.activeChain === chain) {
        AccountController.replaceState(chainAdapter.accountState);
      }
    }
  },
  setAccountProp(prop, value, chain) {
    this.setChainAccountData(chain, {
      [prop]: value
    });
  },
  setActiveChain(chain) {
    const newAdapter = chain ? state$f.chains.get(chain) : void 0;
    if (newAdapter && newAdapter.chain !== state$f.activeChain) {
      state$f.activeChain = newAdapter.chain;
      state$f.activeCaipNetwork = newAdapter.networkState?.caipNetwork ? ref(newAdapter.networkState?.caipNetwork) : void 0;
      AccountController.replaceState(newAdapter.accountState);
      NetworkController.replaceState(newAdapter.networkState);
      this.setCaipNetwork(newAdapter.chain, newAdapter.networkState?.caipNetwork);
      PublicStateController.set({
        activeChain: chain,
        selectedNetworkId: newAdapter.networkState?.caipNetwork?.id
      });
    }
  },
  setActiveCaipNetwork(caipNetwork) {
    if (!caipNetwork) {
      return;
    }
    if (caipNetwork.chain !== state$f.activeChain) {
      this.setActiveChain(caipNetwork.chain);
    }
    state$f.activeCaipNetwork = ref(caipNetwork);
    state$f.activeChain = caipNetwork.chain;
    this.setCaipNetwork(caipNetwork.chain, caipNetwork, true);
    PublicStateController.set({
      activeChain: caipNetwork.chain,
      selectedNetworkId: caipNetwork?.id
    });
  },
  /**
   * The setCaipNetwork function is being called for different purposes and it needs to be controlled if it should replace the NetworkController state or not.
   * While we initializing the adapters, we need to set the caipNetwork without replacing the state.
   * But when we switch the network, we need to replace the state.
   * @param chain
   * @param caipNetwork
   * @param shouldReplace - if true, it will replace the NetworkController state
   */
  setCaipNetwork(chain, caipNetwork, shouldReplace = false) {
    this.setChainNetworkData(chain, { caipNetwork }, shouldReplace);
  },
  setActiveConnector(connector) {
    if (connector) {
      state$f.activeConnector = ref(connector);
    }
  },
  getNetworkControllerClient() {
    const chain = state$f.activeChain;
    if (!chain) {
      throw new Error("Chain is required to get network controller client");
    }
    const chainAdapter = state$f.chains.get(chain);
    if (!chainAdapter) {
      throw new Error("Chain adapter not found");
    }
    if (!chainAdapter.networkControllerClient) {
      throw new Error("NetworkController client not set");
    }
    return chainAdapter.networkControllerClient;
  },
  getConnectionControllerClient(_chain) {
    const chain = _chain || state$f.activeChain;
    if (!chain) {
      throw new Error("Chain is required to get connection controller client");
    }
    const chainAdapter = state$f.chains.get(chain);
    if (!chainAdapter) {
      throw new Error("Chain adapter not found");
    }
    if (!chainAdapter.connectionControllerClient) {
      throw new Error("ConnectionController client not set");
    }
    return chainAdapter.connectionControllerClient;
  },
  getAccountProp(key2, _chain) {
    let chain = state$f.activeChain;
    if (_chain) {
      chain = _chain;
    }
    if (!chain) {
      return void 0;
    }
    const chainAccountState = state$f.chains.get(chain)?.accountState;
    if (!chainAccountState) {
      return void 0;
    }
    return chainAccountState[key2];
  },
  getNetworkProp(key2) {
    const chainToWrite = state$f.activeChain;
    if (!chainToWrite) {
      return void 0;
    }
    const chainNetworkState = state$f.chains.get(chainToWrite)?.networkState;
    if (!chainNetworkState) {
      return void 0;
    }
    return chainNetworkState[key2];
  },
  resetAccount(chain) {
    const chainToWrite = chain;
    if (!chainToWrite) {
      throw new Error("Chain is required to set account prop");
    }
    this.setChainAccountData(chainToWrite, ref({
      isConnected: false,
      smartAccountDeployed: false,
      currentTab: 0,
      caipAddress: void 0,
      address: void 0,
      balance: void 0,
      balanceSymbol: void 0,
      profileName: void 0,
      profileImage: void 0,
      addressExplorerUrl: void 0,
      tokenBalance: [],
      connectedWalletInfo: void 0,
      preferredAccountType: void 0,
      socialProvider: void 0,
      socialWindow: void 0,
      farcasterUrl: void 0
    }));
  }
};
const state$e = proxy({
  supportsAllNetworks: true,
  isDefaultCaipNetwork: false,
  smartAccountEnabledNetworks: []
});
const NetworkController = {
  state: state$e,
  replaceState(newState) {
    if (!newState) {
      return;
    }
    Object.assign(state$e, ref(newState));
  },
  subscribeKey(property, callback) {
    let prev2 = void 0;
    return ChainController.subscribeChainProp("networkState", (networkState2) => {
      if (networkState2) {
        const nextValue = networkState2[property];
        if (prev2 !== nextValue) {
          prev2 = nextValue;
          callback(nextValue);
        }
      }
    });
  },
  _getClient() {
    return ChainController.getNetworkControllerClient();
  },
  initializeDefaultNetwork() {
    const networks = this.getRequestedCaipNetworks();
    if (networks.length > 0) {
      this.setCaipNetwork(networks[0]);
    }
  },
  setDefaultCaipNetwork(caipNetwork) {
    if (caipNetwork) {
      ChainController.setCaipNetwork(caipNetwork.chain, caipNetwork, true);
      ChainController.setChainNetworkData(caipNetwork.chain, { isDefaultCaipNetwork: true });
      PublicStateController.set({ selectedNetworkId: caipNetwork.id });
    }
  },
  setActiveCaipNetwork(caipNetwork) {
    if (!caipNetwork) {
      return;
    }
    ChainController.setActiveCaipNetwork(caipNetwork);
    ChainController.setChainNetworkData(caipNetwork.chain, { caipNetwork });
    PublicStateController.set({
      activeChain: caipNetwork.chain,
      selectedNetworkId: caipNetwork?.id
    });
    if (!ChainController.state.chains.get(caipNetwork.chain)?.networkState?.allowUnsupportedChain) {
      const isSupported = this.checkIfSupportedNetwork();
      if (!isSupported) {
        this.showUnsupportedChainUI();
      }
    }
  },
  setCaipNetwork(caipNetwork) {
    if (!caipNetwork) {
      return;
    }
    if (!caipNetwork?.chain) {
      throw new Error("chain is required to set active network");
    }
    ChainController.setCaipNetwork(caipNetwork?.chain, caipNetwork);
    if (!ChainController.state.chains.get(caipNetwork.chain)?.networkState?.allowUnsupportedChain) {
      const isSupported = this.checkIfSupportedNetwork();
      if (!isSupported) {
        this.showUnsupportedChainUI();
      }
    }
  },
  setRequestedCaipNetworks(requestedNetworks, chain) {
    ChainController.setChainNetworkData(chain, { requestedCaipNetworks: requestedNetworks });
  },
  setAllowUnsupportedChain(allowUnsupportedChain, chain) {
    ChainController.setChainNetworkData(chain || ChainController.state.activeChain, {
      allowUnsupportedChain
    });
  },
  setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain) {
    ChainController.setChainNetworkData(chain, { smartAccountEnabledNetworks });
  },
  getRequestedCaipNetworks(chainToFilter) {
    let chainAdapters = void 0;
    if (!ChainController.state.activeChain) {
      throw new Error("activeChain is required to get requested networks");
    }
    if (chainToFilter) {
      const chain = chainToFilter;
      if (!chain) {
        throw new Error("chain is required to get requested networks");
      }
      chainAdapters = [chain];
    } else {
      const chains2 = [...ChainController.state.chains.keys()];
      chainAdapters = chains2;
    }
    const approvedIds = [];
    const requestedNetworks = [];
    chainAdapters.forEach((chn) => {
      if (ChainController.state.chains.get(chn)?.networkState?.approvedCaipNetworkIds) {
        approvedIds.push(...ChainController.state.chains.get(chn)?.networkState?.approvedCaipNetworkIds || []);
      }
      if (ChainController.state.chains.get(chn)?.networkState?.requestedCaipNetworks) {
        requestedNetworks.push(...ChainController.state.chains.get(chn)?.networkState?.requestedCaipNetworks || []);
      }
    });
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedIds, requestedNetworks);
    return sortedNetworks;
  },
  async switchActiveNetwork(network) {
    const networkControllerClient = network ? ChainController.state.chains.get(network.chain)?.networkControllerClient : void 0;
    if (!networkControllerClient) {
      throw new Error("networkControllerClient not found for given network object");
    }
    ChainController.setActiveCaipNetwork(network);
    await networkControllerClient?.switchCaipNetwork(network);
    if (network) {
      EventsController.sendEvent({
        type: "track",
        event: "SWITCH_NETWORK",
        properties: { network: network.id }
      });
    }
  },
  getApprovedCaipNetworkIds(chainToFilter) {
    if (chainToFilter) {
      const chain = chainToFilter;
      if (!chain) {
        throw new Error("chain is required to get approved network IDs");
      }
      return ChainController.state.chains.get(chain)?.networkState?.approvedCaipNetworkIds;
    }
    const allCaipNetworkIds = [];
    Object.values(ChainController.state.chains).forEach((adapter) => {
      if (adapter.networkState.approvedCaipNetworkIds) {
        allCaipNetworkIds.push(...adapter.networkState?.approvedCaipNetworkIds || []);
      }
    });
    return allCaipNetworkIds;
  },
  async setApprovedCaipNetworksData(chain) {
    const networkControllerClient = ChainController.getNetworkControllerClient();
    const data2 = await networkControllerClient.getApprovedCaipNetworksData();
    if (!chain) {
      throw new Error("chain is required to set approved network data");
    }
    ChainController.setChainNetworkData(chain, {
      approvedCaipNetworkIds: data2?.approvedCaipNetworkIds,
      supportsAllNetworks: data2?.supportsAllNetworks || false
    });
  },
  checkIfSupportedNetwork() {
    const chain = ChainController.state.activeChain;
    if (!chain) {
      return false;
    }
    const activeCaipNetwork = ChainController.state.chains.get(chain)?.networkState?.caipNetwork;
    const requestedCaipNetworks = this.getRequestedCaipNetworks();
    if (!requestedCaipNetworks.length) {
      return true;
    }
    return requestedCaipNetworks?.some((network) => network.id === activeCaipNetwork?.id);
  },
  checkIfSmartAccountEnabled() {
    const networkId = NetworkUtil$1.caipNetworkIdToNumber(state$e.caipNetwork?.id);
    const activeChain = ChainController.state.activeChain;
    if (!activeChain) {
      throw new Error("activeChain is required to check if smart account is enabled");
    }
    if (!networkId) {
      return false;
    }
    const smartAccountEnabledNetworks = ChainController.getNetworkProp("smartAccountEnabledNetworks");
    return Boolean(smartAccountEnabledNetworks?.includes(networkId));
  },
  checkIfNamesSupported() {
    const chain = ChainController.state.activeChain;
    if (!chain) {
      return false;
    }
    const activeCaipNetwork = ChainController.state.chains.get(chain)?.networkState?.caipNetwork;
    return activeCaipNetwork?.chain === ConstantsUtil$2.CHAIN.EVM;
  },
  resetNetwork() {
    const chain = ChainController.state.activeChain;
    if (!chain) {
      throw new Error("chain is required to reset network");
    }
    ChainController.setChainNetworkData(chain, {
      approvedCaipNetworkIds: void 0,
      supportsAllNetworks: true,
      smartAccountEnabledNetworks: []
    });
  },
  getSupportsAllNetworks() {
    const chain = ChainController.state.activeChain;
    if (!chain) {
      throw new Error("chain is required to check if network supports all networks");
    }
    return ChainController.state.chains.get(chain)?.networkState?.supportsAllNetworks;
  },
  showUnsupportedChainUI() {
    setTimeout(() => {
      ModalController.open({ view: "UnsupportedChain" });
    }, 300);
  },
  getActiveNetworkTokenAddress() {
    const address = ConstantsUtil$1.NATIVE_TOKEN_ADDRESS[this.state.caipNetwork?.chain || "evm"];
    return `${this.state.caipNetwork?.id || "eip155:1"}:${address}`;
  }
};
const baseUrl$1 = CoreHelperUtil.getApiUrl();
const api = new FetchUtil({ baseUrl: baseUrl$1, clientId: null });
const entries = "40";
const recommendedEntries = "4";
const imageCountToFetch = 20;
const state$d = proxy({
  page: 1,
  count: 0,
  featured: [],
  recommended: [],
  wallets: [],
  search: [],
  isAnalyticsEnabled: false,
  excludedRDNS: []
});
const ApiController = {
  state: state$d,
  subscribeKey(key2, callback) {
    return subscribeKey(state$d, key2, callback);
  },
  _getApiHeaders() {
    const { projectId: projectId2, sdkType, sdkVersion } = OptionsController.state;
    return {
      "x-project-id": projectId2,
      "x-sdk-type": sdkType,
      "x-sdk-version": sdkVersion
    };
  },
  _filterOutExtensions(wallets) {
    if (OptionsController.state.isUniversalProvider) {
      return wallets.filter((w2) => Boolean(w2.mobile_link || w2.desktop_link || w2.webapp_link));
    }
    return wallets;
  },
  async _fetchWalletImage(imageId) {
    const imageUrl = `${api.baseUrl}/getWalletImage/${imageId}`;
    const blob = await api.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setWalletImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchNetworkImage(imageId) {
    const imageUrl = `${api.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setNetworkImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchConnectorImage(imageId) {
    const imageUrl = `${api.baseUrl}/public/getAssetImage/${imageId}`;
    const blob = await api.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setConnectorImage(imageId, URL.createObjectURL(blob));
  },
  async _fetchCurrencyImage(countryCode) {
    const imageUrl = `${api.baseUrl}/public/getCurrencyImage/${countryCode}`;
    const blob = await api.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setCurrencyImage(countryCode, URL.createObjectURL(blob));
  },
  async _fetchTokenImage(symbol) {
    const imageUrl = `${api.baseUrl}/public/getTokenImage/${symbol}`;
    const blob = await api.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
    AssetController.setTokenImage(symbol, URL.createObjectURL(blob));
  },
  async fetchNetworkImages() {
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const ids = requestedCaipNetworks?.map(({ imageId }) => imageId).filter(Boolean);
    if (ids) {
      await Promise.allSettled(ids.map((id) => ApiController._fetchNetworkImage(id)));
    }
  },
  async fetchConnectorImages() {
    const { connectors } = ConnectorController.state;
    const ids = connectors.map(({ imageId }) => imageId).filter(Boolean);
    await Promise.allSettled(ids.map((id) => ApiController._fetchConnectorImage(id)));
  },
  async fetchCurrencyImages(currencies = []) {
    await Promise.allSettled(currencies.map((currency) => ApiController._fetchCurrencyImage(currency)));
  },
  async fetchTokenImages(tokens = []) {
    await Promise.allSettled(tokens.map((token2) => ApiController._fetchTokenImage(token2)));
  },
  async fetchFeaturedWallets() {
    const { featuredWalletIds } = OptionsController.state;
    if (featuredWalletIds?.length) {
      const { data: data2 } = await api.get({
        path: "/getWallets",
        headers: ApiController._getApiHeaders(),
        params: {
          page: "1",
          entries: featuredWalletIds?.length ? String(featuredWalletIds.length) : recommendedEntries,
          include: featuredWalletIds?.join(",")
        }
      });
      data2.sort((a2, b2) => featuredWalletIds.indexOf(a2.id) - featuredWalletIds.indexOf(b2.id));
      const images = data2.map((d3) => d3.image_id).filter(Boolean);
      await Promise.allSettled(images.map((id) => ApiController._fetchWalletImage(id)));
      state$d.featured = data2;
    }
  },
  async fetchRecommendedWallets() {
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const exclude = [...excludeWalletIds ?? [], ...featuredWalletIds ?? []].filter(Boolean);
    const { data: data2, count } = await api.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        chains: NetworkController.state.caipNetwork?.id,
        entries: recommendedEntries,
        include: includeWalletIds?.join(","),
        exclude: exclude?.join(",")
      }
    });
    const recent = StorageUtil.getRecentWallets();
    const recommendedImages = data2.map((d3) => d3.image_id).filter(Boolean);
    const recentImages = recent.map((r2) => r2.image_id).filter(Boolean);
    await Promise.allSettled([...recommendedImages, ...recentImages].map((id) => ApiController._fetchWalletImage(id)));
    state$d.recommended = data2;
    state$d.count = count ?? 0;
  },
  async fetchWallets({ page }) {
    const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
    const exclude = [
      ...state$d.recommended.map(({ id }) => id),
      ...excludeWalletIds ?? [],
      ...featuredWalletIds ?? []
    ].filter(Boolean);
    const { data: data2, count } = await api.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: String(page),
        entries,
        chains: NetworkController.state.caipNetwork?.id,
        include: includeWalletIds?.join(","),
        exclude: exclude.join(",")
      }
    });
    const images = data2.slice(0, imageCountToFetch).map((w2) => w2.image_id).filter(Boolean);
    await Promise.allSettled(images.map((id) => ApiController._fetchWalletImage(id)));
    state$d.wallets = CoreHelperUtil.uniqueBy([...state$d.wallets, ...ApiController._filterOutExtensions(data2)], "id");
    state$d.count = count > state$d.count ? count : state$d.count;
    state$d.page = page;
  },
  async searchWalletByIds({ ids }) {
    const { data: data2 } = await api.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        entries: String(ids.length),
        chains: NetworkController.state.caipNetwork?.id,
        include: ids?.join(",")
      }
    });
    if (data2) {
      data2.forEach((wallet) => {
        if (wallet?.rdns) {
          state$d.excludedRDNS.push(wallet.rdns);
        }
      });
    }
  },
  async searchWallet({ search }) {
    const { includeWalletIds, excludeWalletIds } = OptionsController.state;
    state$d.search = [];
    const { data: data2 } = await api.get({
      path: "/getWallets",
      headers: ApiController._getApiHeaders(),
      params: {
        page: "1",
        entries: "100",
        search: search?.trim(),
        chains: NetworkController.state.caipNetwork?.id,
        include: includeWalletIds?.join(","),
        exclude: excludeWalletIds?.join(",")
      }
    });
    const images = data2.map((w2) => w2.image_id).filter(Boolean);
    await Promise.allSettled([
      ...images.map((id) => ApiController._fetchWalletImage(id)),
      CoreHelperUtil.wait(300)
    ]);
    state$d.search = ApiController._filterOutExtensions(data2);
  },
  async reFetchWallets() {
    state$d.page = 1;
    state$d.wallets = [];
    await ApiController.fetchFeaturedWallets();
    await ApiController.fetchRecommendedWallets();
  },
  prefetch() {
    const promises = [
      ApiController.fetchFeaturedWallets(),
      ApiController.fetchRecommendedWallets(),
      ApiController.fetchNetworkImages(),
      ApiController.fetchConnectorImages()
    ];
    if (OptionsController.state.enableAnalytics) {
      promises.push(ApiController.fetchAnalyticsConfig());
    }
    state$d.prefetchPromise = Promise.race([Promise.allSettled(promises)]);
  },
  async fetchAnalyticsConfig() {
    const { isAnalyticsEnabled } = await api.get({
      path: "/getAnalyticsConfig",
      headers: ApiController._getApiHeaders()
    });
    OptionsController.setEnableAnalytics(isAnalyticsEnabled);
  }
};
const state$c = proxy({
  projectId: "",
  sdkType: "w3m",
  sdkVersion: "html-wagmi-undefined",
  enableAnalytics: ConstantsUtil$1.DEFAULT_FEATURES.analytics,
  enableOnramp: ConstantsUtil$1.DEFAULT_FEATURES.onramp,
  enableSwaps: ConstantsUtil$1.DEFAULT_FEATURES.swaps,
  allWallets: ConstantsUtil$1.DEFAULT_FEATURES.allWallets,
  disableAppend: ConstantsUtil$1.DEFAULT_FEATURES.disableAppend,
  enableEIP6963: ConstantsUtil$1.DEFAULT_FEATURES.enableEIP6963
});
const OptionsController = {
  state: state$c,
  subscribeKey(key2, callback) {
    return subscribeKey(state$c, key2, callback);
  },
  setOptions(options) {
    Object.assign(state$c, options);
  },
  setProjectId(projectId2) {
    state$c.projectId = projectId2;
  },
  setAllWallets(allWallets = ConstantsUtil$1.DEFAULT_FEATURES.allWallets) {
    state$c.allWallets = allWallets;
  },
  setIncludeWalletIds(includeWalletIds) {
    state$c.includeWalletIds = includeWalletIds;
  },
  setExcludeWalletIds(excludeWalletIds) {
    state$c.excludeWalletIds = excludeWalletIds;
    if (excludeWalletIds) {
      ApiController.searchWalletByIds({ ids: excludeWalletIds });
    }
  },
  setFeaturedWalletIds(featuredWalletIds) {
    state$c.featuredWalletIds = featuredWalletIds;
  },
  setTokens(tokens) {
    state$c.tokens = tokens;
  },
  setTermsConditionsUrl(termsConditionsUrl) {
    state$c.termsConditionsUrl = termsConditionsUrl;
  },
  setPrivacyPolicyUrl(privacyPolicyUrl) {
    state$c.privacyPolicyUrl = privacyPolicyUrl;
  },
  setCustomWallets(customWallets) {
    state$c.customWallets = customWallets;
  },
  setIsSiweEnabled(isSiweEnabled) {
    state$c.isSiweEnabled = isSiweEnabled;
  },
  setIsUniversalProvider(isUniversalProvider) {
    state$c.isUniversalProvider = isUniversalProvider;
  },
  setEnableAnalytics(enableAnalytics = ConstantsUtil$1.DEFAULT_FEATURES.analytics) {
    state$c.enableAnalytics = enableAnalytics;
  },
  setSdkVersion(sdkVersion) {
    state$c.sdkVersion = sdkVersion;
  },
  setMetadata(metadata2) {
    state$c.metadata = metadata2;
  },
  setOnrampEnabled(enableOnramp = ConstantsUtil$1.DEFAULT_FEATURES.onramp) {
    state$c.enableOnramp = enableOnramp;
  },
  setDisableAppend(disableAppend = ConstantsUtil$1.DEFAULT_FEATURES.disableAppend) {
    state$c.disableAppend = disableAppend;
  },
  setEIP6963Enabled(enableEIP6963 = ConstantsUtil$1.DEFAULT_FEATURES.enableEIP6963) {
    state$c.enableEIP6963 = enableEIP6963;
  },
  setHasMultipleAddresses(hasMultipleAddresses) {
    state$c.hasMultipleAddresses = hasMultipleAddresses;
  },
  setEnableSwaps(enableSwaps = ConstantsUtil$1.DEFAULT_FEATURES.swaps) {
    state$c.enableSwaps = enableSwaps;
  }
};
const DEFAULT_OPTIONS = {
  purchaseCurrencies: [
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "USD Coin",
      symbol: "USDC",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    },
    {
      id: "2b92315d-eab7-5bef-84fa-089a131333f5",
      name: "Ether",
      symbol: "ETH",
      networks: [
        {
          name: "ethereum-mainnet",
          display_name: "Ethereum",
          chain_id: "1",
          contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
        },
        {
          name: "polygon-mainnet",
          display_name: "Polygon",
          chain_id: "137",
          contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
        }
      ]
    }
  ],
  paymentCurrencies: [
    {
      id: "USD",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    },
    {
      id: "EUR",
      payment_method_limits: [
        {
          id: "card",
          min: "10.00",
          max: "7500.00"
        },
        {
          id: "ach_bank_account",
          min: "10.00",
          max: "25000.00"
        }
      ]
    }
  ]
};
const baseUrl = CoreHelperUtil.getBlockchainApiUrl();
const state$b = proxy({
  clientId: null,
  api: new FetchUtil({ baseUrl, clientId: null })
});
const BlockchainApiController = {
  state: state$b,
  fetchIdentity({ address }) {
    return state$b.api.get({
      path: `/v1/identity/${address}`,
      params: {
        projectId: OptionsController.state.projectId,
        sender: AccountController.state.address
      }
    });
  },
  fetchTransactions({ account, projectId: projectId2, cursor: cursor2, onramp, signal, cache, chainId }) {
    return state$b.api.get({
      path: `/v1/account/${account}/history`,
      params: {
        projectId: projectId2,
        cursor: cursor2,
        onramp,
        chainId
      },
      signal,
      cache
    });
  },
  fetchSwapQuote({ projectId: projectId2, amount, userAddress, from: from2, to, gasPrice }) {
    return state$b.api.get({
      path: `/v1/convert/quotes`,
      headers: {
        "Content-Type": "application/json"
      },
      params: {
        projectId: projectId2,
        amount,
        userAddress,
        from: from2,
        to,
        gasPrice
      }
    });
  },
  fetchSwapTokens({ projectId: projectId2, chainId }) {
    return state$b.api.get({
      path: `/v1/convert/tokens`,
      params: {
        projectId: projectId2,
        chainId
      }
    });
  },
  fetchTokenPrice({ projectId: projectId2, addresses }) {
    return state$b.api.post({
      path: "/v1/fungible/price",
      body: {
        projectId: projectId2,
        currency: "usd",
        addresses
      },
      headers: {
        "Content-Type": "application/json"
      }
    });
  },
  fetchSwapAllowance({ projectId: projectId2, tokenAddress, userAddress }) {
    const { sdkType, sdkVersion } = OptionsController.state;
    return state$b.api.get({
      path: `/v1/convert/allowance`,
      params: {
        projectId: projectId2,
        tokenAddress,
        userAddress
      },
      headers: {
        "Content-Type": "application/json",
        "x-sdk-type": sdkType,
        "x-sdk-version": sdkVersion
      }
    });
  },
  fetchGasPrice({ projectId: projectId2, chainId }) {
    const { sdkType, sdkVersion } = OptionsController.state;
    return state$b.api.get({
      path: `/v1/convert/gas-price`,
      headers: {
        "Content-Type": "application/json",
        "x-sdk-type": sdkType,
        "x-sdk-version": sdkVersion
      },
      params: {
        projectId: projectId2,
        chainId
      }
    });
  },
  generateSwapCalldata({ amount, from: from2, projectId: projectId2, to, userAddress }) {
    return state$b.api.post({
      path: "/v1/convert/build-transaction",
      headers: {
        "Content-Type": "application/json"
      },
      body: {
        amount,
        eip155: {
          slippage: ConstantsUtil$1.CONVERT_SLIPPAGE_TOLERANCE
        },
        from: from2,
        projectId: projectId2,
        to,
        userAddress
      }
    });
  },
  generateApproveCalldata({ from: from2, projectId: projectId2, to, userAddress }) {
    const { sdkType, sdkVersion } = OptionsController.state;
    return state$b.api.get({
      path: `/v1/convert/build-approve`,
      headers: {
        "Content-Type": "application/json",
        "x-sdk-type": sdkType,
        "x-sdk-version": sdkVersion
      },
      params: {
        projectId: projectId2,
        userAddress,
        from: from2,
        to
      }
    });
  },
  async getBalance(address, chainId, forceUpdate) {
    const { sdkType, sdkVersion } = OptionsController.state;
    return state$b.api.get({
      path: `/v1/account/${address}/balance`,
      headers: {
        "x-sdk-type": sdkType,
        "x-sdk-version": sdkVersion
      },
      params: {
        currency: "usd",
        projectId: OptionsController.state.projectId,
        chainId,
        forceUpdate
      }
    });
  },
  async lookupEnsName(name) {
    return state$b.api.get({
      path: `/v1/profile/account/${name}${ConstantsUtil$2.WC_NAME_SUFFIX}`,
      params: {
        projectId: OptionsController.state.projectId,
        apiVersion: "2"
      }
    });
  },
  async reverseLookupEnsName({ address }) {
    return state$b.api.get({
      path: `/v1/profile/reverse/${address}`,
      params: {
        sender: AccountController.state.address,
        projectId: OptionsController.state.projectId,
        apiVersion: "2"
      }
    });
  },
  async getEnsNameSuggestions(name) {
    return state$b.api.get({
      path: `/v1/profile/suggestions/${name}`,
      params: {
        projectId: OptionsController.state.projectId
      }
    });
  },
  async registerEnsName({ coinType, address, message, signature: signature2 }) {
    return state$b.api.post({
      path: `/v1/profile/account`,
      body: { coin_type: coinType, address, message, signature: signature2 },
      headers: {
        "Content-Type": "application/json"
      }
    });
  },
  async generateOnRampURL({ destinationWallets, partnerUserId, defaultNetwork, purchaseAmount, paymentAmount }) {
    const response = await state$b.api.post({
      path: `/v1/generators/onrampurl`,
      params: {
        projectId: OptionsController.state.projectId
      },
      body: {
        destinationWallets,
        defaultNetwork,
        partnerUserId,
        defaultExperience: "buy",
        presetCryptoAmount: purchaseAmount,
        presetFiatAmount: paymentAmount
      }
    });
    return response.url;
  },
  async getOnrampOptions() {
    try {
      const response = await state$b.api.get({
        path: `/v1/onramp/options`,
        params: {
          projectId: OptionsController.state.projectId
        }
      });
      return response;
    } catch (e2) {
      return DEFAULT_OPTIONS;
    }
  },
  async getOnrampQuote({ purchaseCurrency, paymentCurrency, amount, network }) {
    try {
      const response = await state$b.api.post({
        path: `/v1/onramp/quote`,
        params: {
          projectId: OptionsController.state.projectId
        },
        body: {
          purchaseCurrency,
          paymentCurrency,
          amount,
          network
        }
      });
      return response;
    } catch (e2) {
      return {
        coinbaseFee: { amount, currency: paymentCurrency.id },
        networkFee: { amount, currency: paymentCurrency.id },
        paymentSubtotal: { amount, currency: paymentCurrency.id },
        paymentTotal: { amount, currency: paymentCurrency.id },
        purchaseAmount: { amount, currency: paymentCurrency.id },
        quoteId: "mocked-quote-id"
      };
    }
  },
  setClientId(clientId) {
    state$b.clientId = clientId;
    state$b.api = new FetchUtil({ baseUrl, clientId });
  }
};
const state$a = proxy({
  message: "",
  variant: "success",
  open: false
});
const SnackController = {
  state: state$a,
  subscribeKey(key2, callback) {
    return subscribeKey(state$a, key2, callback);
  },
  showLoading(message) {
    state$a.message = message;
    state$a.variant = "loading";
    state$a.open = true;
  },
  showSuccess(message) {
    state$a.message = message;
    state$a.variant = "success";
    state$a.open = true;
  },
  showError(message) {
    const errorMessage = CoreHelperUtil.parseError(message);
    state$a.message = errorMessage;
    state$a.variant = "error";
    state$a.open = true;
  },
  hide() {
    state$a.open = false;
  }
};
var buffer = {};
var base64Js = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i4 = 0, len = code.length; i4 < len; ++i4) {
    lookup[i4] = code[i4];
    revLookup[code.charCodeAt(i4)] = i4;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i5;
    for (i5 = 0; i5 < len2; i5 += 4) {
      tmp = revLookup[b64.charCodeAt(i5)] << 18 | revLookup[b64.charCodeAt(i5 + 1)] << 12 | revLookup[b64.charCodeAt(i5 + 2)] << 6 | revLookup[b64.charCodeAt(i5 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i5)] << 2 | revLookup[b64.charCodeAt(i5 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i5)] << 10 | revLookup[b64.charCodeAt(i5 + 1)] << 4 | revLookup[b64.charCodeAt(i5 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start2, end2) {
    var tmp;
    var output = [];
    for (var i5 = start2; i5 < end2; i5 += 3) {
      tmp = (uint8[i5] << 16 & 16711680) + (uint8[i5 + 1] << 8 & 65280) + (uint8[i5 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i5 = 0, len22 = len2 - extraBytes; i5 < len22; i5 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i5, i5 + maxChunkLength > len22 ? len22 : i5 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  return base64Js;
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredIeee754;
function requireIeee754() {
  if (hasRequiredIeee754) return ieee754;
  hasRequiredIeee754 = 1;
  ieee754.read = function(buffer2, offset2, isLE2, mLen, nBytes) {
    var e2, m3;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i4 = isLE2 ? nBytes - 1 : 0;
    var d3 = isLE2 ? -1 : 1;
    var s2 = buffer2[offset2 + i4];
    i4 += d3;
    e2 = s2 & (1 << -nBits) - 1;
    s2 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e2 = e2 * 256 + buffer2[offset2 + i4], i4 += d3, nBits -= 8) {
    }
    m3 = e2 & (1 << -nBits) - 1;
    e2 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m3 = m3 * 256 + buffer2[offset2 + i4], i4 += d3, nBits -= 8) {
    }
    if (e2 === 0) {
      e2 = 1 - eBias;
    } else if (e2 === eMax) {
      return m3 ? NaN : (s2 ? -1 : 1) * Infinity;
    } else {
      m3 = m3 + Math.pow(2, mLen);
      e2 = e2 - eBias;
    }
    return (s2 ? -1 : 1) * m3 * Math.pow(2, e2 - mLen);
  };
  ieee754.write = function(buffer2, value, offset2, isLE2, mLen, nBytes) {
    var e2, m3, c2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i4 = isLE2 ? 0 : nBytes - 1;
    var d3 = isLE2 ? 1 : -1;
    var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m3 = isNaN(value) ? 1 : 0;
      e2 = eMax;
    } else {
      e2 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c2 = Math.pow(2, -e2)) < 1) {
        e2--;
        c2 *= 2;
      }
      if (e2 + eBias >= 1) {
        value += rt / c2;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c2 >= 2) {
        e2++;
        c2 /= 2;
      }
      if (e2 + eBias >= eMax) {
        m3 = 0;
        e2 = eMax;
      } else if (e2 + eBias >= 1) {
        m3 = (value * c2 - 1) * Math.pow(2, mLen);
        e2 = e2 + eBias;
      } else {
        m3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e2 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset2 + i4] = m3 & 255, i4 += d3, m3 /= 256, mLen -= 8) {
    }
    e2 = e2 << mLen | m3;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset2 + i4] = e2 & 255, i4 += d3, e2 /= 256, eLen -= 8) {
    }
    buffer2[offset2 + i4 - d3] |= s2 * 128;
  };
  return ieee754;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  (function(exports) {
    const base642 = requireBase64Js();
    const ieee7542 = requireIeee754();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e2) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length2) {
      if (length2 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length2);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg2, encodingOrOffset, length2) {
      if (typeof arg2 === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg2);
      }
      return from2(arg2, encodingOrOffset, length2);
    }
    Buffer2.poolSize = 8192;
    function from2(value, encodingOrOffset, length2) {
      if (typeof value === "string") {
        return fromString2(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length2);
      }
      const b2 = fromObject(value);
      if (b2) return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length2) {
      return from2(value, encodingOrOffset, length2);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize2(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size2 < 0) {
        throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
      }
    }
    function alloc2(size2, fill, encoding) {
      assertSize2(size2);
      if (size2 <= 0) {
        return createBuffer(size2);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
      }
      return createBuffer(size2);
    }
    Buffer2.alloc = function(size2, fill, encoding) {
      return alloc2(size2, fill, encoding);
    };
    function allocUnsafe(size2) {
      assertSize2(size2);
      return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
    }
    Buffer2.allocUnsafe = function(size2) {
      return allocUnsafe(size2);
    };
    Buffer2.allocUnsafeSlow = function(size2) {
      return allocUnsafe(size2);
    };
    function fromString2(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length2 = byteLength(string, encoding) | 0;
      let buf = createBuffer(length2);
      const actual = buf.write(string, encoding);
      if (actual !== length2) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length2);
      for (let i4 = 0; i4 < length2; i4 += 1) {
        buf[i4] = array[i4] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy2 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length2) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length2 === void 0) {
        buf = new Uint8Array(array);
      } else if (length2 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length2);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length2) {
      if (length2 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length2 | 0;
    }
    function SlowBuffer(length2) {
      if (+length2 != length2) {
        length2 = 0;
      }
      return Buffer2.alloc(+length2);
    }
    Buffer2.isBuffer = function isBuffer(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare2(a2, b2) {
      if (isInstance(a2, Uint8Array)) a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b2, Uint8Array)) b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
      if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b2) return 0;
      let x2 = a2.length;
      let y3 = b2.length;
      for (let i4 = 0, len = Math.min(x2, y3); i4 < len; ++i4) {
        if (a2[i4] !== b2[i4]) {
          x2 = a2[i4];
          y3 = b2[i4];
          break;
        }
      }
      if (x2 < y3) return -1;
      if (y3 < x2) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat2(list, length2) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i4;
      if (length2 === void 0) {
        length2 = 0;
        for (i4 = 0; i4 < list.length; ++i4) {
          length2 += list[i4].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length2);
      let pos = 0;
      for (i4 = 0; i4 < list.length; ++i4) {
        let buf = list[i4];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start2, end2) {
      let loweredCase = false;
      if (start2 === void 0 || start2 < 0) {
        start2 = 0;
      }
      if (start2 > this.length) {
        return "";
      }
      if (end2 === void 0 || end2 > this.length) {
        end2 = this.length;
      }
      if (end2 <= 0) {
        return "";
      }
      end2 >>>= 0;
      start2 >>>= 0;
      if (end2 <= start2) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start2, end2);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start2, end2);
          case "ascii":
            return asciiSlice(this, start2, end2);
          case "latin1":
          case "binary":
            return latin1Slice(this, start2, end2);
          case "base64":
            return base64Slice(this, start2, end2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start2, end2);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b2, n3, m3) {
      const i4 = b2[n3];
      b2[n3] = b2[m3];
      b2[m3] = i4;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i4 = 0; i4 < len; i4 += 2) {
        swap(this, i4, i4 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i4 = 0; i4 < len; i4 += 4) {
        swap(this, i4, i4 + 3);
        swap(this, i4 + 1, i4 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i4 = 0; i4 < len; i4 += 8) {
        swap(this, i4, i4 + 7);
        swap(this, i4 + 1, i4 + 6);
        swap(this, i4 + 2, i4 + 5);
        swap(this, i4 + 3, i4 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      const length2 = this.length;
      if (length2 === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length2);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b2) {
      if (!Buffer2.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
      if (this === b2) return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max2 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare2(target, start2, end2, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start2 === void 0) {
        start2 = 0;
      }
      if (end2 === void 0) {
        end2 = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start2 >= end2) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start2 >= end2) {
        return 1;
      }
      start2 >>>= 0;
      end2 >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x2 = thisEnd - thisStart;
      let y3 = end2 - start2;
      const len = Math.min(x2, y3);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start2, end2);
      for (let i4 = 0; i4 < len; ++i4) {
        if (thisCopy[i4] !== targetCopy[i4]) {
          x2 = thisCopy[i4];
          y3 = targetCopy[i4];
          break;
        }
      }
      if (x2 < y3) return -1;
      if (y3 < x2) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i5) {
        if (indexSize === 1) {
          return buf[i5];
        } else {
          return buf.readUInt16BE(i5 * indexSize);
        }
      }
      let i4;
      if (dir) {
        let foundIndex = -1;
        for (i4 = byteOffset; i4 < arrLength; i4++) {
          if (read2(arr, i4) === read2(val, foundIndex === -1 ? 0 : i4 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i4;
            if (i4 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i4 -= i4 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i4 = byteOffset; i4 >= 0; i4--) {
          let found = true;
          for (let j2 = 0; j2 < valLength; j2++) {
            if (read2(arr, i4 + j2) !== read2(val, j2)) {
              found = false;
              break;
            }
          }
          if (found) return i4;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset2, length2) {
      offset2 = Number(offset2) || 0;
      const remaining = buf.length - offset2;
      if (!length2) {
        length2 = remaining;
      } else {
        length2 = Number(length2);
        if (length2 > remaining) {
          length2 = remaining;
        }
      }
      const strLen = string.length;
      if (length2 > strLen / 2) {
        length2 = strLen / 2;
      }
      let i4;
      for (i4 = 0; i4 < length2; ++i4) {
        const parsed = parseInt(string.substr(i4 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i4;
        buf[offset2 + i4] = parsed;
      }
      return i4;
    }
    function utf8Write(buf, string, offset2, length2) {
      return blitBuffer(utf8ToBytes2(string, buf.length - offset2), buf, offset2, length2);
    }
    function asciiWrite(buf, string, offset2, length2) {
      return blitBuffer(asciiToBytes(string), buf, offset2, length2);
    }
    function base64Write(buf, string, offset2, length2) {
      return blitBuffer(base64ToBytes(string), buf, offset2, length2);
    }
    function ucs2Write(buf, string, offset2, length2) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length2);
    }
    Buffer2.prototype.write = function write2(string, offset2, length2, encoding) {
      if (offset2 === void 0) {
        encoding = "utf8";
        length2 = this.length;
        offset2 = 0;
      } else if (length2 === void 0 && typeof offset2 === "string") {
        encoding = offset2;
        length2 = this.length;
        offset2 = 0;
      } else if (isFinite(offset2)) {
        offset2 = offset2 >>> 0;
        if (isFinite(length2)) {
          length2 = length2 >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length2;
          length2 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset2;
      if (length2 === void 0 || length2 > remaining) length2 = remaining;
      if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset2, length2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset2, length2);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset2, length2);
          case "base64":
            return base64Write(this, string, offset2, length2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset2, length2);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start2, end2) {
      if (start2 === 0 && end2 === buf.length) {
        return base642.fromByteArray(buf);
      } else {
        return base642.fromByteArray(buf.slice(start2, end2));
      }
    }
    function utf8Slice(buf, start2, end2) {
      end2 = Math.min(buf.length, end2);
      const res = [];
      let i4 = start2;
      while (i4 < end2) {
        const firstByte = buf[i4];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i4 + bytesPerSequence <= end2) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i4 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i4 + 1];
              thirdByte = buf[i4 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i4 + 1];
              thirdByte = buf[i4 + 2];
              fourthByte = buf[i4 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i4 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i4 = 0;
      while (i4 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i4, i4 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start2, end2) {
      let ret = "";
      end2 = Math.min(buf.length, end2);
      for (let i4 = start2; i4 < end2; ++i4) {
        ret += String.fromCharCode(buf[i4] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start2, end2) {
      let ret = "";
      end2 = Math.min(buf.length, end2);
      for (let i4 = start2; i4 < end2; ++i4) {
        ret += String.fromCharCode(buf[i4]);
      }
      return ret;
    }
    function hexSlice(buf, start2, end2) {
      const len = buf.length;
      if (!start2 || start2 < 0) start2 = 0;
      if (!end2 || end2 < 0 || end2 > len) end2 = len;
      let out = "";
      for (let i4 = start2; i4 < end2; ++i4) {
        out += hexSliceLookupTable[buf[i4]];
      }
      return out;
    }
    function utf16leSlice(buf, start2, end2) {
      const bytes = buf.slice(start2, end2);
      let res = "";
      for (let i4 = 0; i4 < bytes.length - 1; i4 += 2) {
        res += String.fromCharCode(bytes[i4] + bytes[i4 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice2(start2, end2) {
      const len = this.length;
      start2 = ~~start2;
      end2 = end2 === void 0 ? len : ~~end2;
      if (start2 < 0) {
        start2 += len;
        if (start2 < 0) start2 = 0;
      } else if (start2 > len) {
        start2 = len;
      }
      if (end2 < 0) {
        end2 += len;
        if (end2 < 0) end2 = 0;
      } else if (end2 > len) {
        end2 = len;
      }
      if (end2 < start2) end2 = start2;
      const newBuf = this.subarray(start2, end2);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset2, ext, length2) {
      if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
      if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset2, byteLength2, this.length);
      let val = this[offset2];
      let mul = 1;
      let i4 = 0;
      while (++i4 < byteLength2 && (mul *= 256)) {
        val += this[offset2 + i4] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset2, byteLength2, this.length);
      }
      let val = this[offset2 + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset2 + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 1, this.length);
      return this[offset2];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 2, this.length);
      return this[offset2] | this[offset2 + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 2, this.length);
      return this[offset2] << 8 | this[offset2 + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 4, this.length);
      return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 4, this.length);
      return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
      offset2 = offset2 >>> 0;
      validateNumber(offset2, "offset");
      const first = this[offset2];
      const last = this[offset2 + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset2, this.length - 8);
      }
      const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
      const hi = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
      offset2 = offset2 >>> 0;
      validateNumber(offset2, "offset");
      const first = this[offset2];
      const last = this[offset2 + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset2, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
      const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset2, byteLength2, this.length);
      let val = this[offset2];
      let mul = 1;
      let i4 = 0;
      while (++i4 < byteLength2 && (mul *= 256)) {
        val += this[offset2 + i4] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength2, noAssert) {
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset2, byteLength2, this.length);
      let i4 = byteLength2;
      let mul = 1;
      let val = this[offset2 + --i4];
      while (i4 > 0 && (mul *= 256)) {
        val += this[offset2 + --i4] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 1, this.length);
      if (!(this[offset2] & 128)) return this[offset2];
      return (255 - this[offset2] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 2, this.length);
      const val = this[offset2] | this[offset2 + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 2, this.length);
      const val = this[offset2 + 1] | this[offset2] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 4, this.length);
      return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 4, this.length);
      return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
      offset2 = offset2 >>> 0;
      validateNumber(offset2, "offset");
      const first = this[offset2];
      const last = this[offset2 + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset2, this.length - 8);
      }
      const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
      offset2 = offset2 >>> 0;
      validateNumber(offset2, "offset");
      const first = this[offset2];
      const last = this[offset2 + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset2, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 4, this.length);
      return ieee7542.read(this, offset2, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 4, this.length);
      return ieee7542.read(this, offset2, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 8, this.length);
      return ieee7542.read(this, offset2, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
      offset2 = offset2 >>> 0;
      if (!noAssert) checkOffset(offset2, 8, this.length);
      return ieee7542.read(this, offset2, false, 52, 8);
    };
    function checkInt(buf, value, offset2, ext, max2, min2) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
      if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset2, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i4 = 0;
      this[offset2] = value & 255;
      while (++i4 < byteLength2 && (mul *= 256)) {
        this[offset2 + i4] = value / mul & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset2, byteLength2, maxBytes, 0);
      }
      let i4 = byteLength2 - 1;
      let mul = 1;
      this[offset2 + i4] = value & 255;
      while (--i4 >= 0 && (mul *= 256)) {
        this[offset2 + i4] = value / mul & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value, offset2, 1, 255, 0);
      this[offset2] = value & 255;
      return offset2 + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
      this[offset2] = value & 255;
      this[offset2 + 1] = value >>> 8;
      return offset2 + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
      this[offset2] = value >>> 8;
      this[offset2 + 1] = value & 255;
      return offset2 + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
      this[offset2 + 3] = value >>> 24;
      this[offset2 + 2] = value >>> 16;
      this[offset2 + 1] = value >>> 8;
      this[offset2] = value & 255;
      return offset2 + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
      this[offset2] = value >>> 24;
      this[offset2 + 1] = value >>> 16;
      this[offset2 + 2] = value >>> 8;
      this[offset2 + 3] = value & 255;
      return offset2 + 4;
    };
    function wrtBigUInt64LE(buf, value, offset2, min2, max2) {
      checkIntBI(value, min2, max2, buf, offset2, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset2++] = lo;
      lo = lo >> 8;
      buf[offset2++] = lo;
      lo = lo >> 8;
      buf[offset2++] = lo;
      lo = lo >> 8;
      buf[offset2++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset2++] = hi;
      hi = hi >> 8;
      buf[offset2++] = hi;
      hi = hi >> 8;
      buf[offset2++] = hi;
      hi = hi >> 8;
      buf[offset2++] = hi;
      return offset2;
    }
    function wrtBigUInt64BE(buf, value, offset2, min2, max2) {
      checkIntBI(value, min2, max2, buf, offset2, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset2 + 7] = lo;
      lo = lo >> 8;
      buf[offset2 + 6] = lo;
      lo = lo >> 8;
      buf[offset2 + 5] = lo;
      lo = lo >> 8;
      buf[offset2 + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset2 + 3] = hi;
      hi = hi >> 8;
      buf[offset2 + 2] = hi;
      hi = hi >> 8;
      buf[offset2 + 1] = hi;
      hi = hi >> 8;
      buf[offset2] = hi;
      return offset2 + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
      return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
      return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
      }
      let i4 = 0;
      let mul = 1;
      let sub = 0;
      this[offset2] = value & 255;
      while (++i4 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset2 + i4 - 1] !== 0) {
          sub = 1;
        }
        this[offset2 + i4] = (value / mul >> 0) - sub & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
      }
      let i4 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset2 + i4] = value & 255;
      while (--i4 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset2 + i4 + 1] !== 0) {
          sub = 1;
        }
        this[offset2 + i4] = (value / mul >> 0) - sub & 255;
      }
      return offset2 + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value, offset2, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset2] = value & 255;
      return offset2 + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
      this[offset2] = value & 255;
      this[offset2 + 1] = value >>> 8;
      return offset2 + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
      this[offset2] = value >>> 8;
      this[offset2 + 1] = value & 255;
      return offset2 + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
      this[offset2] = value & 255;
      this[offset2 + 1] = value >>> 8;
      this[offset2 + 2] = value >>> 16;
      this[offset2 + 3] = value >>> 24;
      return offset2 + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset2] = value >>> 24;
      this[offset2 + 1] = value >>> 16;
      this[offset2 + 2] = value >>> 8;
      this[offset2 + 3] = value & 255;
      return offset2 + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
      return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
      return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset2, ext, max2, min2) {
      if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
      if (offset2 < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset2, littleEndian, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset2, 4);
      }
      ieee7542.write(buf, value, offset2, littleEndian, 23, 4);
      return offset2 + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
      return writeFloat(this, value, offset2, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
      return writeFloat(this, value, offset2, false, noAssert);
    };
    function writeDouble(buf, value, offset2, littleEndian, noAssert) {
      value = +value;
      offset2 = offset2 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset2, 8);
      }
      ieee7542.write(buf, value, offset2, littleEndian, 52, 8);
      return offset2 + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
      return writeDouble(this, value, offset2, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
      return writeDouble(this, value, offset2, false, noAssert);
    };
    Buffer2.prototype.copy = function copy2(target, targetStart, start2, end2) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start2) start2 = 0;
      if (!end2 && end2 !== 0) end2 = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end2 > 0 && end2 < start2) end2 = start2;
      if (end2 === start2) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start2 < 0 || start2 >= this.length) throw new RangeError("Index out of range");
      if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
      if (end2 > this.length) end2 = this.length;
      if (target.length - targetStart < end2 - start2) {
        end2 = target.length - targetStart + start2;
      }
      const len = end2 - start2;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start2, end2);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start2, end2),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start2, end2, encoding) {
      if (typeof val === "string") {
        if (typeof start2 === "string") {
          encoding = start2;
          start2 = 0;
          end2 = this.length;
        } else if (typeof end2 === "string") {
          encoding = end2;
          end2 = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start2 < 0 || this.length < start2 || this.length < end2) {
        throw new RangeError("Out of range index");
      }
      if (end2 <= start2) {
        return this;
      }
      start2 = start2 >>> 0;
      end2 = end2 === void 0 ? this.length : end2 >>> 0;
      if (!val) val = 0;
      let i4;
      if (typeof val === "number") {
        for (i4 = start2; i4 < end2; ++i4) {
          this[i4] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i4 = 0; i4 < end2 - start2; ++i4) {
          this[i4 + start2] = bytes[i4 % len];
        }
      }
      return this;
    };
    const errors = {};
    function E2(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E2(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E2(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i4 = val.length;
      const start2 = val[0] === "-" ? 1 : 0;
      for (; i4 >= start2 + 4; i4 -= 3) {
        res = `_${val.slice(i4 - 3, i4)}${res}`;
      }
      return `${val.slice(0, i4)}${res}`;
    }
    function checkBounds(buf, offset2, byteLength2) {
      validateNumber(offset2, "offset");
      if (buf[offset2] === void 0 || buf[offset2 + byteLength2] === void 0) {
        boundsError(offset2, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min2, max2, buf, offset2, byteLength2) {
      if (value > max2 || value < min2) {
        const n3 = typeof min2 === "bigint" ? "n" : "";
        let range;
        {
          if (min2 === 0 || min2 === BigInt(0)) {
            range = `>= 0${n3} and < 2${n3} ** ${(byteLength2 + 1) * 8}${n3}`;
          } else {
            range = `>= -(2${n3} ** ${(byteLength2 + 1) * 8 - 1}${n3}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n3}`;
          }
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset2, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length2, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
      }
      if (length2 < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        "offset",
        `>= ${0} and <= ${length2}`,
        value
      );
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string, units) {
      units = units || Infinity;
      let codePoint;
      const length2 = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i4 = 0; i4 < length2; ++i4) {
        codePoint = string.charCodeAt(i4);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i4 + 1 === length2) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i4 = 0; i4 < str.length; ++i4) {
        byteArray.push(str.charCodeAt(i4) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c2, hi, lo;
      const byteArray = [];
      for (let i4 = 0; i4 < str.length; ++i4) {
        if ((units -= 2) < 0) break;
        c2 = str.charCodeAt(i4);
        hi = c2 >> 8;
        lo = c2 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset2, length2) {
      let i4;
      for (i4 = 0; i4 < length2; ++i4) {
        if (i4 + offset2 >= dst.length || i4 >= src2.length) break;
        dst[i4 + offset2] = src2[i4];
      }
      return i4;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = (function() {
      const alphabet2 = "0123456789abcdef";
      const table = new Array(256);
      for (let i4 = 0; i4 < 16; ++i4) {
        const i16 = i4 * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet2[i4] + alphabet2[j2];
        }
      }
      return table;
    })();
    function defineBigIntMethod(fn2) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  })(buffer);
  return buffer;
}
var bufferExports = requireBuffer();
if (typeof window !== "undefined") {
  if (!window.Buffer) {
    window.Buffer = bufferExports.Buffer;
  }
  if (!window.global) {
    window.global = window;
  }
  if (!window.process) {
    window.process = {};
  }
  if (!window.process?.env) {
    window.process = { env: {} };
  }
}
var define_process_env_default$1 = {};
const SECURE_SITE_SDK = define_process_env_default$1["NEXT_PUBLIC_SECURE_SITE_SDK_URL"] || "https://secure.walletconnect.org/sdk";
const DEFAULT_LOG_LEVEL = define_process_env_default$1["NEXT_PUBLIC_DEFAULT_LOG_LEVEL"] || "error";
const W3mFrameConstants = {
  APP_EVENT_KEY: "@w3m-app/",
  FRAME_EVENT_KEY: "@w3m-frame/",
  RPC_METHOD_KEY: "RPC_",
  STORAGE_KEY: "@w3m-storage/",
  SESSION_TOKEN_KEY: "SESSION_TOKEN_KEY",
  EMAIL_LOGIN_USED_KEY: "EMAIL_LOGIN_USED_KEY",
  LAST_USED_CHAIN_KEY: "LAST_USED_CHAIN_KEY",
  LAST_EMAIL_LOGIN_TIME: "LAST_EMAIL_LOGIN_TIME",
  EMAIL: "EMAIL",
  PREFERRED_ACCOUNT_TYPE: "PREFERRED_ACCOUNT_TYPE",
  SMART_ACCOUNT_ENABLED: "SMART_ACCOUNT_ENABLED",
  SMART_ACCOUNT_ENABLED_NETWORKS: "SMART_ACCOUNT_ENABLED_NETWORKS",
  SOCIAL_USERNAME: "SOCIAL_USERNAME",
  SOCIAL: "@w3m/connected_social",
  APP_SWITCH_NETWORK: "@w3m-app/SWITCH_NETWORK",
  APP_CONNECT_EMAIL: "@w3m-app/CONNECT_EMAIL",
  APP_CONNECT_DEVICE: "@w3m-app/CONNECT_DEVICE",
  APP_CONNECT_OTP: "@w3m-app/CONNECT_OTP",
  APP_CONNECT_SOCIAL: "@w3m-app/CONNECT_SOCIAL",
  APP_GET_SOCIAL_REDIRECT_URI: "@w3m-app/GET_SOCIAL_REDIRECT_URI",
  APP_GET_USER: "@w3m-app/GET_USER",
  APP_SIGN_OUT: "@w3m-app/SIGN_OUT",
  APP_IS_CONNECTED: "@w3m-app/IS_CONNECTED",
  APP_GET_CHAIN_ID: "@w3m-app/GET_CHAIN_ID",
  APP_RPC_REQUEST: "@w3m-app/RPC_REQUEST",
  APP_UPDATE_EMAIL: "@w3m-app/UPDATE_EMAIL",
  APP_UPDATE_EMAIL_PRIMARY_OTP: "@w3m-app/UPDATE_EMAIL_PRIMARY_OTP",
  APP_UPDATE_EMAIL_SECONDARY_OTP: "@w3m-app/UPDATE_EMAIL_SECONDARY_OTP",
  APP_AWAIT_UPDATE_EMAIL: "@w3m-app/AWAIT_UPDATE_EMAIL",
  APP_SYNC_THEME: "@w3m-app/SYNC_THEME",
  APP_SYNC_DAPP_DATA: "@w3m-app/SYNC_DAPP_DATA",
  APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS: "@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS",
  APP_INIT_SMART_ACCOUNT: "@w3m-app/INIT_SMART_ACCOUNT",
  APP_SET_PREFERRED_ACCOUNT: "@w3m-app/SET_PREFERRED_ACCOUNT",
  APP_CONNECT_FARCASTER: "@w3m-app/CONNECT_FARCASTER",
  APP_GET_FARCASTER_URI: "@w3m-app/GET_FARCASTER_URI",
  FRAME_SWITCH_NETWORK_ERROR: "@w3m-frame/SWITCH_NETWORK_ERROR",
  FRAME_SWITCH_NETWORK_SUCCESS: "@w3m-frame/SWITCH_NETWORK_SUCCESS",
  FRAME_CONNECT_EMAIL_ERROR: "@w3m-frame/CONNECT_EMAIL_ERROR",
  FRAME_CONNECT_EMAIL_SUCCESS: "@w3m-frame/CONNECT_EMAIL_SUCCESS",
  FRAME_CONNECT_DEVICE_ERROR: "@w3m-frame/CONNECT_DEVICE_ERROR",
  FRAME_CONNECT_DEVICE_SUCCESS: "@w3m-frame/CONNECT_DEVICE_SUCCESS",
  FRAME_CONNECT_OTP_SUCCESS: "@w3m-frame/CONNECT_OTP_SUCCESS",
  FRAME_CONNECT_OTP_ERROR: "@w3m-frame/CONNECT_OTP_ERROR",
  FRAME_CONNECT_SOCIAL_SUCCESS: "@w3m-frame/CONNECT_SOCIAL_SUCCESS",
  FRAME_CONNECT_SOCIAL_ERROR: "@w3m-frame/CONNECT_SOCIAL_ERROR",
  FRAME_CONNECT_FARCASTER_SUCCESS: "@w3m-frame/CONNECT_FARCASTER_SUCCESS",
  FRAME_CONNECT_FARCASTER_ERROR: "@w3m-frame/CONNECT_FARCASTER_ERROR",
  FRAME_GET_FARCASTER_URI_SUCCESS: "@w3m-frame/GET_FARCASTER_URI_SUCCESS",
  FRAME_GET_FARCASTER_URI_ERROR: "@w3m-frame/GET_FARCASTER_URI_ERROR",
  FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS: "@w3m-frame/GET_SOCIAL_REDIRECT_URI_SUCCESS",
  FRAME_GET_SOCIAL_REDIRECT_URI_ERROR: "@w3m-frame/GET_SOCIAL_REDIRECT_URI_ERROR",
  FRAME_GET_USER_SUCCESS: "@w3m-frame/GET_USER_SUCCESS",
  FRAME_GET_USER_ERROR: "@w3m-frame/GET_USER_ERROR",
  FRAME_SIGN_OUT_SUCCESS: "@w3m-frame/SIGN_OUT_SUCCESS",
  FRAME_SIGN_OUT_ERROR: "@w3m-frame/SIGN_OUT_ERROR",
  FRAME_IS_CONNECTED_SUCCESS: "@w3m-frame/IS_CONNECTED_SUCCESS",
  FRAME_IS_CONNECTED_ERROR: "@w3m-frame/IS_CONNECTED_ERROR",
  FRAME_GET_CHAIN_ID_SUCCESS: "@w3m-frame/GET_CHAIN_ID_SUCCESS",
  FRAME_GET_CHAIN_ID_ERROR: "@w3m-frame/GET_CHAIN_ID_ERROR",
  FRAME_RPC_REQUEST_SUCCESS: "@w3m-frame/RPC_REQUEST_SUCCESS",
  FRAME_RPC_REQUEST_ERROR: "@w3m-frame/RPC_REQUEST_ERROR",
  FRAME_SESSION_UPDATE: "@w3m-frame/SESSION_UPDATE",
  FRAME_UPDATE_EMAIL_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SUCCESS",
  FRAME_UPDATE_EMAIL_ERROR: "@w3m-frame/UPDATE_EMAIL_ERROR",
  FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS",
  FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR",
  FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS",
  FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR: "@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR",
  FRAME_SYNC_THEME_SUCCESS: "@w3m-frame/SYNC_THEME_SUCCESS",
  FRAME_SYNC_THEME_ERROR: "@w3m-frame/SYNC_THEME_ERROR",
  FRAME_SYNC_DAPP_DATA_SUCCESS: "@w3m-frame/SYNC_DAPP_DATA_SUCCESS",
  FRAME_SYNC_DAPP_DATA_ERROR: "@w3m-frame/SYNC_DAPP_DATA_ERROR",
  FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS: "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS",
  FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR: "@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR",
  FRAME_INIT_SMART_ACCOUNT_SUCCESS: "@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS",
  FRAME_INIT_SMART_ACCOUNT_ERROR: "@w3m-frame/INIT_SMART_ACCOUNT_ERROR",
  FRAME_SET_PREFERRED_ACCOUNT_SUCCESS: "@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS",
  FRAME_SET_PREFERRED_ACCOUNT_ERROR: "@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR",
  RPC_RESPONSE_TYPE_ERROR: "RPC_RESPONSE_ERROR",
  RPC_RESPONSE_TYPE_TX: "RPC_RESPONSE_TRANSACTION_HASH",
  RPC_RESPONSE_TYPE_OBJECT: "RPC_RESPONSE_OBJECT"
};
const W3mFrameRpcConstants = {
  SAFE_RPC_METHODS: [
    "eth_accounts",
    "eth_blockNumber",
    "eth_call",
    "eth_chainId",
    "eth_estimateGas",
    "eth_feeHistory",
    "eth_gasPrice",
    "eth_getAccount",
    "eth_getBalance",
    "eth_getBlockByHash",
    "eth_getBlockByNumber",
    "eth_getBlockReceipts",
    "eth_getBlockTransactionCountByHash",
    "eth_getBlockTransactionCountByNumber",
    "eth_getCode",
    "eth_getFilterChanges",
    "eth_getFilterLogs",
    "eth_getLogs",
    "eth_getProof",
    "eth_getStorageAt",
    "eth_getTransactionByBlockHashAndIndex",
    "eth_getTransactionByBlockNumberAndIndex",
    "eth_getTransactionByHash",
    "eth_getTransactionCount",
    "eth_getTransactionReceipt",
    "eth_getUncleCountByBlockHash",
    "eth_getUncleCountByBlockNumber",
    "eth_maxPriorityFeePerGas",
    "eth_newBlockFilter",
    "eth_newFilter",
    "eth_newPendingTransactionFilter",
    "eth_sendRawTransaction",
    "eth_syncing",
    "eth_uninstallFilter",
    "wallet_getCapabilities",
    "wallet_getCallsStatus",
    "eth_getUserOperationReceipt",
    "eth_estimateUserOperationGas",
    "eth_getUserOperationByHash",
    "eth_supportedEntryPoints"
  ],
  NOT_SAFE_RPC_METHODS: [
    "personal_sign",
    "eth_signTypedData_v4",
    "eth_sendTransaction",
    "solana_signMessage",
    "solana_signTransaction",
    "solana_signAllTransactions",
    "solana_signAndSendTransaction",
    "wallet_sendCalls",
    "wallet_grantPermissions",
    "eth_sendUserOperation"
  ],
  GET_CHAIN_ID: "eth_chainId",
  RPC_METHOD_NOT_ALLOWED_MESSAGE: "Requested RPC call is not allowed",
  RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: "Action not allowed",
  ACCOUNT_TYPES: {
    EOA: "eoa",
    SMART_ACCOUNT: "smartAccount"
  }
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key2 in object) {
      if (Object.prototype.hasOwnProperty.call(object, key2)) {
        keys.push(key2);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data2) => {
  const t2 = typeof data2;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data2) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data2)) {
        return ZodParsedType.array;
      }
      if (data2 === null) {
        return ZodParsedType.null;
      }
      if (data2.then && typeof data2.then === "function" && data2.catch && typeof data2.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data2 instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data2 instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data2 instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i4 = 0;
          while (i4 < issue.path.length) {
            const el = issue.path[i4];
            const terminal = i4 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i4++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data: data2, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m3) => !!m3).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data: data2, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key: key2, value } = pair;
      if (key2.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key2.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key2.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key2.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent2, value, path, key2) {
    this._cachedPath = [];
    this.parent = parent2;
    this.data = value;
    this._path = path;
    this._key = key2;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data2, params) {
    const result = this.safeParse(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data2, params) {
    var _a3;
    const ctx = {
      common: {
        issues: [],
        async: (_a3 = params === null || params === void 0 ? void 0 : params.async) !== null && _a3 !== void 0 ? _a3 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const result = this._parseSync({ data: data2, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data2, params) {
    const result = await this.safeParseAsync(data2, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data2, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: data2,
      parsedType: getParsedType(data2)
    };
    const maybeAsyncResult = this._parse({ data: data2, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data2) => {
          if (!data2) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a3) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex2 = datetimeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data2) => regex2.test(data2), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a3;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a3 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a3 !== void 0 ? _a3 : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a3;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a3 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a3 !== void 0 ? _a3 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a3;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a3 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a3 !== void 0 ? _a3 : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i4) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i4));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i4) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i4));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key2 in schema.shape) {
      const fieldSchema = schema.shape[key2];
      newShape[key2] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape2 = this._def.shape();
    const keys = util.objectKeys(shape2);
    return this._cached = { shape: shape2, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape: shape2, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key2 in ctx.data) {
        if (!shapeKeys.includes(key2)) {
          extraKeys.push(key2);
        }
      }
    }
    const pairs = [];
    for (const key2 of shapeKeys) {
      const keyValidator = shape2[key2];
      const value = ctx.data[key2];
      pairs.push({
        key: { status: "valid", value: key2 },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key2)),
        alwaysSet: key2 in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key2 of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key2 },
            value: { status: "valid", value: ctx.data[key2] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key2 of extraKeys) {
        const value = ctx.data[key2];
        pairs.push({
          key: { status: "valid", value: key2 },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key2)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key2 in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key2 = await pair.key;
          syncPairs.push({
            key: key2,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a3, _b2, _c2, _d2;
          const defaultError = (_c2 = (_b2 = (_a3 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d2 = errorUtil.errToObj(message).message) !== null && _d2 !== void 0 ? _d2 : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key2, schema) {
    return this.augment({ [key2]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape2 = {};
    util.objectKeys(mask).forEach((key2) => {
      if (mask[key2] && this.shape[key2]) {
        shape2[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape2
    });
  }
  omit(mask) {
    const shape2 = {};
    util.objectKeys(this.shape).forEach((key2) => {
      if (!mask[key2]) {
        shape2[key2] = this.shape[key2];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape2
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key2) => {
      const fieldSchema = this.shape[key2];
      if (mask && !mask[key2]) {
        newShape[key2] = fieldSchema;
      } else {
        newShape[key2] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key2) => {
      if (mask && !mask[key2]) {
        newShape[key2] = this.shape[key2];
      } else {
        const fieldSchema = this.shape[key2];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key2] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape2, params) => {
  return new ZodObject({
    shape: () => shape2,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape2, params) => {
  return new ZodObject({
    shape: () => shape2,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape2, params) => {
  return new ZodObject({
    shape: shape2,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a2[key2], b2[key2]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left2, right2]) => handleParsed(left2, right2));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left2, right2, params) => {
  return new ZodIntersection({
    left: left2,
    right: right2,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key2 in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, key2)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key2], ctx.path, key2))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key2, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key2, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key2 = await pair.key;
          const value = await pair.value;
          if (key2.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key2.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key2.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key2 = pair.key;
        const value = pair.value;
        if (key2.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key2.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key2.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i4) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i4)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await Reflect.apply(fn2, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn2, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values2, params) {
  return new ZodEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2) {
    return ZodEnum.create(values2);
  }
  exclude(values2) {
    return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values2, params) => {
  return new ZodNativeEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data2) => {
      return this._def.type.parseAsync(data2, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect2 = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg2) => {
        addIssueToContext(ctx, arg2);
        if (arg2.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect2.type === "preprocess") {
      const processed = effect2.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect2.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect2.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect2.type === "transform") {
      if (ctx.common.async === false) {
        const base3 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base3))
          return base3;
        const result = effect2.transform(base3.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {
          if (!isValid(base3))
            return base3;
          return Promise.resolve(effect2.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect2);
  }
}
ZodEffects.create = (schema, effect2, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect: effect2,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data2 = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data2 = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data2 = ctx.data;
    return this._def.type._parse({
      data: data2,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
const custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data2, ctx) => {
      var _a3, _b2;
      if (!check(data2)) {
        const p2 = typeof params === "function" ? params(data2) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b2 = (_a3 = p2.fatal) !== null && _a3 !== void 0 ? _a3 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data2) => data2 instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce$1 = {
  string: ((arg2) => ZodString.create({ ...arg2, coerce: true })),
  number: ((arg2) => ZodNumber.create({ ...arg2, coerce: true })),
  boolean: ((arg2) => ZodBoolean.create({
    ...arg2,
    coerce: true
  })),
  bigint: ((arg2) => ZodBigInt.create({ ...arg2, coerce: true })),
  date: ((arg2) => ZodDate.create({ ...arg2, coerce: true }))
};
const NEVER = INVALID;
var z$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce: coerce$1,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const zError = z$3.object({ message: z$3.string() });
function zType(key2) {
  return z$3.literal(W3mFrameConstants[key2]);
}
z$3.object({
  accessList: z$3.array(z$3.string()),
  blockHash: z$3.string().nullable(),
  blockNumber: z$3.string().nullable(),
  chainId: z$3.string().or(z$3.number()),
  from: z$3.string(),
  gas: z$3.string(),
  hash: z$3.string(),
  input: z$3.string().nullable(),
  maxFeePerGas: z$3.string(),
  maxPriorityFeePerGas: z$3.string(),
  nonce: z$3.string(),
  r: z$3.string(),
  s: z$3.string(),
  to: z$3.string(),
  transactionIndex: z$3.string().nullable(),
  type: z$3.string(),
  v: z$3.string(),
  value: z$3.string()
});
const AppSwitchNetworkRequest = z$3.object({ chainId: z$3.string().or(z$3.number()) });
const AppConnectEmailRequest = z$3.object({ email: z$3.string().email() });
const AppConnectOtpRequest = z$3.object({ otp: z$3.string() });
const AppConnectSocialRequest = z$3.object({ uri: z$3.string() });
const AppGetUserRequest = z$3.object({
  chainId: z$3.optional(z$3.string().or(z$3.number())),
  preferredAccountType: z$3.optional(z$3.string())
});
const AppGetSocialRedirectUriRequest = z$3.object({
  provider: z$3.enum(["google", "github", "apple", "facebook", "x", "discord"])
});
const AppUpdateEmailRequest = z$3.object({ email: z$3.string().email() });
const AppUpdateEmailPrimaryOtpRequest = z$3.object({ otp: z$3.string() });
const AppUpdateEmailSecondaryOtpRequest = z$3.object({ otp: z$3.string() });
const AppSyncThemeRequest = z$3.object({
  themeMode: z$3.optional(z$3.enum(["light", "dark"])),
  themeVariables: z$3.optional(z$3.record(z$3.string(), z$3.string().or(z$3.number()))),
  w3mThemeVariables: z$3.optional(z$3.record(z$3.string(), z$3.string()))
});
const AppSyncDappDataRequest = z$3.object({
  metadata: z$3.object({
    name: z$3.string(),
    description: z$3.string(),
    url: z$3.string(),
    icons: z$3.array(z$3.string())
  }).optional(),
  sdkVersion: z$3.string(),
  projectId: z$3.string()
});
const AppSetPreferredAccountRequest = z$3.object({ type: z$3.string() });
const FrameConnectEmailResponse = z$3.object({
  action: z$3.enum(["VERIFY_DEVICE", "VERIFY_OTP"])
});
const FrameGetFarcasterUriResponse = z$3.object({
  url: z$3.string()
});
const FrameConnectFarcasterResponse = z$3.object({
  userName: z$3.string()
});
const FrameConnectSocialResponse = z$3.object({
  email: z$3.string(),
  address: z$3.string(),
  chainId: z$3.string().or(z$3.number()),
  accounts: z$3.array(z$3.object({
    address: z$3.string(),
    type: z$3.enum([
      W3mFrameRpcConstants.ACCOUNT_TYPES.EOA,
      W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
    ])
  })).optional(),
  userName: z$3.string().optional()
});
const FrameUpdateEmailResponse = z$3.object({
  action: z$3.enum(["VERIFY_PRIMARY_OTP", "VERIFY_SECONDARY_OTP"])
});
const FrameGetUserResponse = z$3.object({
  email: z$3.string().email().optional().nullable(),
  address: z$3.string(),
  chainId: z$3.string().or(z$3.number()),
  smartAccountDeployed: z$3.optional(z$3.boolean()),
  accounts: z$3.array(z$3.object({
    address: z$3.string(),
    type: z$3.enum([
      W3mFrameRpcConstants.ACCOUNT_TYPES.EOA,
      W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
    ])
  })).optional(),
  preferredAccountType: z$3.optional(z$3.string())
});
const FrameGetSocialRedirectUriResponse = z$3.object({ uri: z$3.string() });
const FrameIsConnectedResponse = z$3.object({ isConnected: z$3.boolean() });
const FrameGetChainIdResponse = z$3.object({ chainId: z$3.string().or(z$3.number()) });
const FrameSwitchNetworkResponse = z$3.object({ chainId: z$3.string().or(z$3.number()) });
const FrameUpdateEmailSecondaryOtpResponse = z$3.object({ newEmail: z$3.string().email() });
const FrameGetSmartAccountEnabledNetworksResponse = z$3.object({
  smartAccountEnabledNetworks: z$3.array(z$3.number())
});
z$3.object({
  address: z$3.string(),
  isDeployed: z$3.boolean()
});
const FrameSetPreferredAccountResponse = z$3.object({ type: z$3.string(), address: z$3.string() });
const RpcResponse = z$3.any();
const RpcEthAccountsRequest = z$3.object({
  method: z$3.literal("eth_accounts")
});
const RpcEthBlockNumber = z$3.object({
  method: z$3.literal("eth_blockNumber")
});
const RpcEthCall = z$3.object({
  method: z$3.literal("eth_call"),
  params: z$3.array(z$3.any())
});
const RpcEthChainId = z$3.object({
  method: z$3.literal("eth_chainId")
});
const RpcEthEstimateGas = z$3.object({
  method: z$3.literal("eth_estimateGas"),
  params: z$3.array(z$3.any())
});
const RpcEthFeeHistory = z$3.object({
  method: z$3.literal("eth_feeHistory"),
  params: z$3.array(z$3.any())
});
const RpcEthGasPrice = z$3.object({
  method: z$3.literal("eth_gasPrice")
});
const RpcEthGetAccount = z$3.object({
  method: z$3.literal("eth_getAccount"),
  params: z$3.array(z$3.any())
});
const RpcEthGetBalance = z$3.object({
  method: z$3.literal("eth_getBalance"),
  params: z$3.array(z$3.any())
});
const RpcEthGetBlockyByHash = z$3.object({
  method: z$3.literal("eth_getBlockByHash"),
  params: z$3.array(z$3.any())
});
const RpcEthGetBlockByNumber = z$3.object({
  method: z$3.literal("eth_getBlockByNumber"),
  params: z$3.array(z$3.any())
});
const RpcEthGetBlockReceipts = z$3.object({
  method: z$3.literal("eth_getBlockReceipts"),
  params: z$3.array(z$3.any())
});
const RcpEthGetBlockTransactionCountByHash = z$3.object({
  method: z$3.literal("eth_getBlockTransactionCountByHash"),
  params: z$3.array(z$3.any())
});
const RcpEthGetBlockTransactionCountByNumber = z$3.object({
  method: z$3.literal("eth_getBlockTransactionCountByNumber"),
  params: z$3.array(z$3.any())
});
const RpcEthGetCode = z$3.object({
  method: z$3.literal("eth_getCode"),
  params: z$3.array(z$3.any())
});
const RpcEthGetFilter = z$3.object({
  method: z$3.literal("eth_getFilterChanges"),
  params: z$3.array(z$3.any())
});
const RpcEthGetFilterLogs = z$3.object({
  method: z$3.literal("eth_getFilterLogs"),
  params: z$3.array(z$3.any())
});
const RpcEthGetLogs = z$3.object({
  method: z$3.literal("eth_getLogs"),
  params: z$3.array(z$3.any())
});
const RpcEthGetProof = z$3.object({
  method: z$3.literal("eth_getProof"),
  params: z$3.array(z$3.any())
});
const RpcEthGetStorageAt = z$3.object({
  method: z$3.literal("eth_getStorageAt"),
  params: z$3.array(z$3.any())
});
const RpcEthGetTransactionByBlockHashAndIndex = z$3.object({
  method: z$3.literal("eth_getTransactionByBlockHashAndIndex"),
  params: z$3.array(z$3.any())
});
const RpcEthGetTransactionByBlockNumberAndIndex = z$3.object({
  method: z$3.literal("eth_getTransactionByBlockNumberAndIndex"),
  params: z$3.array(z$3.any())
});
const RpcEthGetTransactionByHash = z$3.object({
  method: z$3.literal("eth_getTransactionByHash"),
  params: z$3.array(z$3.any())
});
const RpcEthGetTransactionCount = z$3.object({
  method: z$3.literal("eth_getTransactionCount"),
  params: z$3.array(z$3.any())
});
const RpcEthGetTransactionReceipt = z$3.object({
  method: z$3.literal("eth_getTransactionReceipt"),
  params: z$3.array(z$3.any())
});
const RpcEthGetUncleCountByBlockHash = z$3.object({
  method: z$3.literal("eth_getUncleCountByBlockHash"),
  params: z$3.array(z$3.any())
});
const RpcEthGetUncleCountByBlockNumber = z$3.object({
  method: z$3.literal("eth_getUncleCountByBlockNumber"),
  params: z$3.array(z$3.any())
});
const RpcEthMaxPriorityFeePerGas = z$3.object({
  method: z$3.literal("eth_maxPriorityFeePerGas")
});
const RpcEthNewBlockFilter = z$3.object({
  method: z$3.literal("eth_newBlockFilter")
});
const RpcEthNewFilter = z$3.object({
  method: z$3.literal("eth_newFilter"),
  params: z$3.array(z$3.any())
});
const RpcEthNewPendingTransactionFilter = z$3.object({
  method: z$3.literal("eth_newPendingTransactionFilter")
});
const RpcEthSendRawTransaction = z$3.object({
  method: z$3.literal("eth_sendRawTransaction"),
  params: z$3.array(z$3.any())
});
const RpcEthSyncing = z$3.object({
  method: z$3.literal("eth_syncing"),
  params: z$3.array(z$3.any())
});
const RpcUnistallFilter = z$3.object({
  method: z$3.literal("eth_uninstallFilter"),
  params: z$3.array(z$3.any())
});
const RpcPersonalSignRequest = z$3.object({
  method: z$3.literal("personal_sign"),
  params: z$3.array(z$3.any())
});
const RpcEthSignTypedDataV4 = z$3.object({
  method: z$3.literal("eth_signTypedData_v4"),
  params: z$3.array(z$3.any())
});
const RpcEthSendTransactionRequest = z$3.object({
  method: z$3.literal("eth_sendTransaction"),
  params: z$3.array(z$3.any())
});
const RpcSolanaSignMessageRequest = z$3.object({
  method: z$3.literal("solana_signMessage"),
  params: z$3.object({
    message: z$3.string(),
    pubkey: z$3.string()
  })
});
const RpcSolanaSignTransactionRequest = z$3.object({
  method: z$3.literal("solana_signTransaction"),
  params: z$3.object({
    transaction: z$3.string()
  })
});
const RpcSolanaSignAllTransactionsRequest = z$3.object({
  method: z$3.literal("solana_signAllTransactions"),
  params: z$3.object({
    transactions: z$3.array(z$3.string())
  })
});
const RpcSolanaSignAndSendTransactionRequest = z$3.object({
  method: z$3.literal("solana_signAndSendTransaction"),
  params: z$3.object({
    transaction: z$3.string(),
    options: z$3.object({
      skipPreflight: z$3.boolean().optional(),
      preflightCommitment: z$3.enum([
        "processed",
        "confirmed",
        "finalized",
        "recent",
        "single",
        "singleGossip",
        "root",
        "max"
      ]).optional(),
      maxRetries: z$3.number().optional(),
      minContextSlot: z$3.number().optional()
    }).optional()
  })
});
const WalletSendCallsRequest = z$3.object({
  method: z$3.literal("wallet_sendCalls"),
  params: z$3.array(z$3.object({
    chainId: z$3.string().or(z$3.number()).optional(),
    from: z$3.string().optional(),
    version: z$3.string().optional(),
    capabilities: z$3.any().optional(),
    calls: z$3.array(z$3.object({
      to: z$3.string().startsWith("0x"),
      data: z$3.string().startsWith("0x").optional(),
      value: z$3.string().optional()
    }))
  }))
});
const WalletGetCallsReceiptRequest = z$3.object({
  method: z$3.literal("wallet_getCallsStatus"),
  params: z$3.array(z$3.string())
});
const WalletGetCapabilitiesRequest = z$3.object({
  method: z$3.literal("wallet_getCapabilities")
});
const WalletGrantPermissionsRequest = z$3.object({
  method: z$3.literal("wallet_grantPermissions"),
  params: z$3.array(z$3.any())
});
const FrameSession = z$3.object({
  token: z$3.string()
});
const EventSchema = z$3.object({
  id: z$3.string().optional()
});
const W3mFrameSchema = {
  appEvent: EventSchema.extend({
    type: zType("APP_SWITCH_NETWORK"),
    payload: AppSwitchNetworkRequest
  }).or(EventSchema.extend({
    type: zType("APP_CONNECT_EMAIL"),
    payload: AppConnectEmailRequest
  })).or(EventSchema.extend({ type: zType("APP_CONNECT_DEVICE") })).or(EventSchema.extend({ type: zType("APP_CONNECT_OTP"), payload: AppConnectOtpRequest })).or(EventSchema.extend({
    type: zType("APP_CONNECT_SOCIAL"),
    payload: AppConnectSocialRequest
  })).or(EventSchema.extend({ type: zType("APP_GET_FARCASTER_URI") })).or(EventSchema.extend({ type: zType("APP_CONNECT_FARCASTER") })).or(EventSchema.extend({
    type: zType("APP_GET_USER"),
    payload: z$3.optional(AppGetUserRequest)
  })).or(EventSchema.extend({
    type: zType("APP_GET_SOCIAL_REDIRECT_URI"),
    payload: AppGetSocialRedirectUriRequest
  })).or(EventSchema.extend({ type: zType("APP_SIGN_OUT") })).or(EventSchema.extend({
    type: zType("APP_IS_CONNECTED"),
    payload: z$3.optional(FrameSession)
  })).or(EventSchema.extend({ type: zType("APP_GET_CHAIN_ID") })).or(EventSchema.extend({ type: zType("APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS") })).or(EventSchema.extend({ type: zType("APP_INIT_SMART_ACCOUNT") })).or(EventSchema.extend({
    type: zType("APP_SET_PREFERRED_ACCOUNT"),
    payload: AppSetPreferredAccountRequest
  })).or(EventSchema.extend({
    type: zType("APP_RPC_REQUEST"),
    payload: RpcPersonalSignRequest.or(RpcEthSendTransactionRequest).or(RpcEthAccountsRequest).or(RpcEthBlockNumber).or(RpcEthCall).or(RpcEthChainId).or(RpcEthEstimateGas).or(RpcEthFeeHistory).or(RpcEthGasPrice).or(RpcEthGetAccount).or(RpcEthGetBalance).or(RpcEthGetBlockyByHash).or(RpcEthGetBlockByNumber).or(RpcEthGetBlockReceipts).or(RcpEthGetBlockTransactionCountByHash).or(RcpEthGetBlockTransactionCountByNumber).or(RpcEthGetCode).or(RpcEthGetFilter).or(RpcEthGetFilterLogs).or(RpcEthGetLogs).or(RpcEthGetProof).or(RpcEthGetStorageAt).or(RpcEthGetTransactionByBlockHashAndIndex).or(RpcEthGetTransactionByBlockNumberAndIndex).or(RpcEthGetTransactionByHash).or(RpcEthGetTransactionCount).or(RpcEthGetTransactionReceipt).or(RpcEthGetUncleCountByBlockHash).or(RpcEthGetUncleCountByBlockNumber).or(RpcEthMaxPriorityFeePerGas).or(RpcEthNewBlockFilter).or(RpcEthNewFilter).or(RpcEthNewPendingTransactionFilter).or(RpcEthSendRawTransaction).or(RpcEthSyncing).or(RpcUnistallFilter).or(RpcPersonalSignRequest).or(RpcEthSignTypedDataV4).or(RpcEthSendTransactionRequest).or(RpcSolanaSignMessageRequest).or(RpcSolanaSignTransactionRequest).or(RpcSolanaSignAllTransactionsRequest).or(RpcSolanaSignAndSendTransactionRequest).or(WalletGetCallsReceiptRequest).or(WalletSendCallsRequest).or(WalletGetCapabilitiesRequest).or(WalletGrantPermissionsRequest)
  })).or(EventSchema.extend({ type: zType("APP_UPDATE_EMAIL"), payload: AppUpdateEmailRequest })).or(EventSchema.extend({
    type: zType("APP_UPDATE_EMAIL_PRIMARY_OTP"),
    payload: AppUpdateEmailPrimaryOtpRequest
  })).or(EventSchema.extend({
    type: zType("APP_UPDATE_EMAIL_SECONDARY_OTP"),
    payload: AppUpdateEmailSecondaryOtpRequest
  })).or(EventSchema.extend({ type: zType("APP_SYNC_THEME"), payload: AppSyncThemeRequest })).or(EventSchema.extend({
    type: zType("APP_SYNC_DAPP_DATA"),
    payload: AppSyncDappDataRequest
  })),
  frameEvent: EventSchema.extend({ type: zType("FRAME_SWITCH_NETWORK_ERROR"), payload: zError }).or(EventSchema.extend({
    type: zType("FRAME_SWITCH_NETWORK_SUCCESS"),
    payload: FrameSwitchNetworkResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_CONNECT_EMAIL_SUCCESS"),
    payload: FrameConnectEmailResponse
  })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_EMAIL_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_GET_FARCASTER_URI_SUCCESS"),
    payload: FrameGetFarcasterUriResponse
  })).or(EventSchema.extend({ type: zType("FRAME_GET_FARCASTER_URI_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_CONNECT_FARCASTER_SUCCESS"),
    payload: FrameConnectFarcasterResponse
  })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_FARCASTER_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_OTP_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_OTP_SUCCESS") })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_DEVICE_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_CONNECT_DEVICE_SUCCESS") })).or(EventSchema.extend({
    type: zType("FRAME_CONNECT_SOCIAL_SUCCESS"),
    payload: FrameConnectSocialResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_CONNECT_SOCIAL_ERROR"),
    payload: zError
  })).or(EventSchema.extend({ type: zType("FRAME_GET_USER_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_GET_USER_SUCCESS"),
    payload: FrameGetUserResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_GET_SOCIAL_REDIRECT_URI_ERROR"),
    payload: zError
  })).or(EventSchema.extend({
    type: zType("FRAME_GET_SOCIAL_REDIRECT_URI_SUCCESS"),
    payload: FrameGetSocialRedirectUriResponse
  })).or(EventSchema.extend({ type: zType("FRAME_SIGN_OUT_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_SIGN_OUT_SUCCESS") })).or(EventSchema.extend({ type: zType("FRAME_IS_CONNECTED_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_IS_CONNECTED_SUCCESS"),
    payload: FrameIsConnectedResponse
  })).or(EventSchema.extend({ type: zType("FRAME_GET_CHAIN_ID_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_GET_CHAIN_ID_SUCCESS"),
    payload: FrameGetChainIdResponse
  })).or(EventSchema.extend({ type: zType("FRAME_RPC_REQUEST_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_RPC_REQUEST_SUCCESS"), payload: RpcResponse })).or(EventSchema.extend({ type: zType("FRAME_SESSION_UPDATE"), payload: FrameSession })).or(EventSchema.extend({ type: zType("FRAME_UPDATE_EMAIL_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_UPDATE_EMAIL_SUCCESS"),
    payload: FrameUpdateEmailResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR"),
    payload: zError
  })).or(EventSchema.extend({ type: zType("FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS") })).or(EventSchema.extend({
    type: zType("FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR"),
    payload: zError
  })).or(EventSchema.extend({
    type: zType("FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS"),
    payload: FrameUpdateEmailSecondaryOtpResponse
  })).or(EventSchema.extend({ type: zType("FRAME_SYNC_THEME_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_SYNC_THEME_SUCCESS") })).or(EventSchema.extend({ type: zType("FRAME_SYNC_DAPP_DATA_ERROR"), payload: zError })).or(EventSchema.extend({ type: zType("FRAME_SYNC_DAPP_DATA_SUCCESS") })).or(EventSchema.extend({
    type: zType("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS"),
    payload: FrameGetSmartAccountEnabledNetworksResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR"),
    payload: zError
  })).or(EventSchema.extend({ type: zType("FRAME_INIT_SMART_ACCOUNT_ERROR"), payload: zError })).or(EventSchema.extend({
    type: zType("FRAME_SET_PREFERRED_ACCOUNT_SUCCESS"),
    payload: FrameSetPreferredAccountResponse
  })).or(EventSchema.extend({
    type: zType("FRAME_SET_PREFERRED_ACCOUNT_ERROR"),
    payload: zError
  }))
};
const W3mFrameStorage = {
  set(key2, value) {
    if (W3mFrameHelpers.isClient) {
      localStorage.setItem(`${W3mFrameConstants.STORAGE_KEY}${key2}`, value);
    }
  },
  get(key2) {
    if (W3mFrameHelpers.isClient) {
      return localStorage.getItem(`${W3mFrameConstants.STORAGE_KEY}${key2}`);
    }
    return null;
  },
  delete(key2, social) {
    if (W3mFrameHelpers.isClient) {
      if (social) {
        localStorage.removeItem(key2);
      } else {
        localStorage.removeItem(`${W3mFrameConstants.STORAGE_KEY}${key2}`);
      }
    }
  }
};
const RegexUtil = {
  transactionHash: /^0x(?:[A-Fa-f0-9]{64})$/u,
  signedMessage: /^0x(?:[a-fA-F0-9]{62,})$/u
};
const EMAIL_MINIMUM_TIMEOUT = 30 * 1e3;
const W3mFrameHelpers = {
  checkIfAllowedToTriggerEmail() {
    const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
    if (lastEmailLoginTime) {
      const difference = Date.now() - Number(lastEmailLoginTime);
      if (difference < EMAIL_MINIMUM_TIMEOUT) {
        const cooldownSec = Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1e3);
        throw new Error(`Please try again after ${cooldownSec} seconds`);
      }
    }
  },
  getTimeToNextEmailLogin() {
    const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
    if (lastEmailLoginTime) {
      const difference = Date.now() - Number(lastEmailLoginTime);
      if (difference < EMAIL_MINIMUM_TIMEOUT) {
        return Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1e3);
      }
    }
    return 0;
  },
  checkIfRequestExists(request) {
    return W3mFrameRpcConstants.NOT_SAFE_RPC_METHODS.includes(request.method) || W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(request.method);
  },
  getResponseType(response) {
    const isPayloadString = typeof response === "string";
    const isTransactionHash = isPayloadString && (response?.match(RegexUtil.transactionHash) || response?.match(RegexUtil.signedMessage));
    if (isTransactionHash) {
      return W3mFrameConstants.RPC_RESPONSE_TYPE_TX;
    }
    return W3mFrameConstants.RPC_RESPONSE_TYPE_OBJECT;
  },
  checkIfRequestIsSafe(request) {
    return W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(request.method);
  },
  isClient: typeof window !== "undefined"
};
class W3mFrame {
  constructor(projectId2, isAppClient = false, chainId = "eip155:1") {
    this.iframe = null;
    this.rpcUrl = ConstantsUtil$2.BLOCKCHAIN_API_RPC_URL;
    this.events = {
      registerFrameEventHandler: (id, callback, signal) => {
        function eventHandler({ data: data2 }) {
          if (!data2.type?.includes(W3mFrameConstants.FRAME_EVENT_KEY)) {
            return;
          }
          const frameEvent = W3mFrameSchema.frameEvent.parse(data2);
          if (frameEvent.id === id) {
            callback(frameEvent);
            window.removeEventListener("message", eventHandler);
          }
        }
        if (W3mFrameHelpers.isClient) {
          window.addEventListener("message", eventHandler);
          signal.addEventListener("abort", () => {
            window.removeEventListener("message", eventHandler);
          });
        }
      },
      onFrameEvent: (callback) => {
        if (W3mFrameHelpers.isClient) {
          window.addEventListener("message", ({ data: data2 }) => {
            if (!data2.type?.includes(W3mFrameConstants.FRAME_EVENT_KEY)) {
              return;
            }
            const frameEvent = W3mFrameSchema.frameEvent.parse(data2);
            callback(frameEvent);
          });
        }
      },
      onAppEvent: (callback) => {
        if (W3mFrameHelpers.isClient) {
          window.addEventListener("message", ({ data: data2 }) => {
            if (!data2.type?.includes(W3mFrameConstants.APP_EVENT_KEY)) {
              return;
            }
            const appEvent = W3mFrameSchema.appEvent.parse(data2);
            callback(appEvent);
          });
        }
      },
      postAppEvent: (event) => {
        if (W3mFrameHelpers.isClient) {
          if (!this.iframe?.contentWindow) {
            throw new Error("W3mFrame: iframe is not set");
          }
          W3mFrameSchema.appEvent.parse(event);
          this.iframe.contentWindow.postMessage(event, "*");
        }
      },
      postFrameEvent: (event) => {
        if (W3mFrameHelpers.isClient) {
          if (!parent) {
            throw new Error("W3mFrame: parent is not set");
          }
          W3mFrameSchema.frameEvent.parse(event);
          parent.postMessage(event, "*");
        }
      }
    };
    this.projectId = projectId2;
    this.frameLoadPromise = new Promise((resolve, reject) => {
      this.frameLoadPromiseResolver = { resolve, reject };
    });
    if (isAppClient) {
      this.frameLoadPromise = new Promise((resolve, reject) => {
        this.frameLoadPromiseResolver = { resolve, reject };
      });
      if (W3mFrameHelpers.isClient) {
        const iframe = document.createElement("iframe");
        iframe.id = "w3m-iframe";
        iframe.src = `${SECURE_SITE_SDK}?projectId=${projectId2}&chainId=${chainId}`;
        iframe.name = "w3m-secure-iframe";
        iframe.style.position = "fixed";
        iframe.style.zIndex = "999999";
        iframe.style.display = "none";
        iframe.style.animationDelay = "0s, 50ms";
        iframe.style.borderBottomLeftRadius = `clamp(0px, var(--wui-border-radius-l), 44px)`;
        iframe.style.borderBottomRightRadius = `clamp(0px, var(--wui-border-radius-l), 44px)`;
        document.body.appendChild(iframe);
        this.iframe = iframe;
        this.iframe.onload = () => {
          this.frameLoadPromiseResolver?.resolve(void 0);
        };
        this.iframe.onerror = () => {
          this.frameLoadPromiseResolver?.reject("Unable to load email login dependency");
        };
      }
    }
  }
  get networks() {
    const data2 = [
      "eip155:1",
      "eip155:5",
      "eip155:11155111",
      "eip155:10",
      "eip155:420",
      "eip155:42161",
      "eip155:421613",
      "eip155:137",
      "eip155:80001",
      "eip155:42220",
      "eip155:1313161554",
      "eip155:1313161555",
      "eip155:56",
      "eip155:97",
      "eip155:43114",
      "eip155:43113",
      "eip155:324",
      "eip155:280",
      "eip155:100",
      "eip155:8453",
      "eip155:84531",
      "eip155:84532",
      "eip155:7777777",
      "eip155:999",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
    ].map((id) => ({
      [id]: {
        rpcUrl: `${this.rpcUrl}/v1/?chainId=${id}&projectId=${this.projectId}`,
        chainId: id
      }
    }));
    return Object.assign({}, ...data2);
  }
}
var quickFormatUnescaped;
var hasRequiredQuickFormatUnescaped;
function requireQuickFormatUnescaped() {
  if (hasRequiredQuickFormatUnescaped) return quickFormatUnescaped;
  hasRequiredQuickFormatUnescaped = 1;
  function tryStringify(o2) {
    try {
      return JSON.stringify(o2);
    } catch (e2) {
      return '"[Circular]"';
    }
  }
  quickFormatUnescaped = format;
  function format(f2, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset2 = 1;
    if (typeof f2 === "object" && f2 !== null) {
      var len = args.length + offset2;
      if (len === 1) return f2;
      var objects = new Array(len);
      objects[0] = ss(f2);
      for (var index2 = 1; index2 < len; index2++) {
        objects[index2] = ss(args[index2]);
      }
      return objects.join(" ");
    }
    if (typeof f2 !== "string") {
      return f2;
    }
    var argLen = args.length;
    if (argLen === 0) return f2;
    var str = "";
    var a2 = 1 - offset2;
    var lastPos = -1;
    var flen = f2 && f2.length || 0;
    for (var i4 = 0; i4 < flen; ) {
      if (f2.charCodeAt(i4) === 37 && i4 + 1 < flen) {
        lastPos = lastPos > -1 ? lastPos : 0;
        switch (f2.charCodeAt(i4 + 1)) {
          case 100:
          // 'd'
          case 102:
            if (a2 >= argLen)
              break;
            if (args[a2] == null) break;
            if (lastPos < i4)
              str += f2.slice(lastPos, i4);
            str += Number(args[a2]);
            lastPos = i4 + 2;
            i4++;
            break;
          case 105:
            if (a2 >= argLen)
              break;
            if (args[a2] == null) break;
            if (lastPos < i4)
              str += f2.slice(lastPos, i4);
            str += Math.floor(Number(args[a2]));
            lastPos = i4 + 2;
            i4++;
            break;
          case 79:
          // 'O'
          case 111:
          // 'o'
          case 106:
            if (a2 >= argLen)
              break;
            if (args[a2] === void 0) break;
            if (lastPos < i4)
              str += f2.slice(lastPos, i4);
            var type = typeof args[a2];
            if (type === "string") {
              str += "'" + args[a2] + "'";
              lastPos = i4 + 2;
              i4++;
              break;
            }
            if (type === "function") {
              str += args[a2].name || "<anonymous>";
              lastPos = i4 + 2;
              i4++;
              break;
            }
            str += ss(args[a2]);
            lastPos = i4 + 2;
            i4++;
            break;
          case 115:
            if (a2 >= argLen)
              break;
            if (lastPos < i4)
              str += f2.slice(lastPos, i4);
            str += String(args[a2]);
            lastPos = i4 + 2;
            i4++;
            break;
          case 37:
            if (lastPos < i4)
              str += f2.slice(lastPos, i4);
            str += "%";
            lastPos = i4 + 2;
            i4++;
            a2--;
            break;
        }
        ++a2;
      }
      ++i4;
    }
    if (lastPos === -1)
      return f2;
    else if (lastPos < flen) {
      str += f2.slice(lastPos);
    }
    return str;
  }
  return quickFormatUnescaped;
}
var browser$2;
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2;
  hasRequiredBrowser$2 = 1;
  const format = requireQuickFormatUnescaped();
  browser$2 = pino;
  const _console = pfGlobalThisOrFallback().console || {};
  const stdSerializers = {
    mapHttpRequest: mock,
    mapHttpResponse: mock,
    wrapRequestSerializer: passthrough,
    wrapResponseSerializer: passthrough,
    wrapErrorSerializer: passthrough,
    req: mock,
    res: mock,
    err: asErrValue
  };
  function shouldSerialize(serialize2, serializers) {
    if (Array.isArray(serialize2)) {
      const hasToFilter = serialize2.filter(function(k2) {
        return k2 !== "!stdSerializers.err";
      });
      return hasToFilter;
    } else if (serialize2 === true) {
      return Object.keys(serializers);
    }
    return false;
  }
  function pino(opts) {
    opts = opts || {};
    opts.browser = opts.browser || {};
    const transmit2 = opts.browser.transmit;
    if (transmit2 && typeof transmit2.send !== "function") {
      throw Error("pino: transmit option must have a send function");
    }
    const proto = opts.browser.write || _console;
    if (opts.browser.write) opts.browser.asObject = true;
    const serializers = opts.serializers || {};
    const serialize2 = shouldSerialize(opts.browser.serialize, serializers);
    let stdErrSerialize = opts.browser.serialize;
    if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1) stdErrSerialize = false;
    const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
    if (typeof proto === "function") {
      proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
    }
    if (opts.enabled === false) opts.level = "silent";
    const level = opts.level || "info";
    const logger = Object.create(proto);
    if (!logger.log) logger.log = noop2;
    Object.defineProperty(logger, "levelVal", {
      get: getLevelVal
    });
    Object.defineProperty(logger, "level", {
      get: getLevel,
      set: setLevel
    });
    const setOpts = {
      transmit: transmit2,
      serialize: serialize2,
      asObject: opts.browser.asObject,
      levels,
      timestamp: getTimeFunction(opts)
    };
    logger.levels = pino.levels;
    logger.level = level;
    logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop2;
    logger.serializers = serializers;
    logger._serialize = serialize2;
    logger._stdErrSerialize = stdErrSerialize;
    logger.child = child;
    if (transmit2) logger._logEvent = createLogEventShape();
    function getLevelVal() {
      return this.level === "silent" ? Infinity : this.levels.values[this.level];
    }
    function getLevel() {
      return this._level;
    }
    function setLevel(level2) {
      if (level2 !== "silent" && !this.levels.values[level2]) {
        throw Error("unknown level " + level2);
      }
      this._level = level2;
      set(setOpts, logger, "error", "log");
      set(setOpts, logger, "fatal", "error");
      set(setOpts, logger, "warn", "error");
      set(setOpts, logger, "info", "log");
      set(setOpts, logger, "debug", "log");
      set(setOpts, logger, "trace", "log");
    }
    function child(bindings, childOptions) {
      if (!bindings) {
        throw new Error("missing bindings for child Pino");
      }
      childOptions = childOptions || {};
      if (serialize2 && bindings.serializers) {
        childOptions.serializers = bindings.serializers;
      }
      const childOptionsSerializers = childOptions.serializers;
      if (serialize2 && childOptionsSerializers) {
        var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
        var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize2;
        delete bindings.serializers;
        applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
      }
      function Child(parent2) {
        this._childLevel = (parent2._childLevel | 0) + 1;
        this.error = bind(parent2, bindings, "error");
        this.fatal = bind(parent2, bindings, "fatal");
        this.warn = bind(parent2, bindings, "warn");
        this.info = bind(parent2, bindings, "info");
        this.debug = bind(parent2, bindings, "debug");
        this.trace = bind(parent2, bindings, "trace");
        if (childSerializers) {
          this.serializers = childSerializers;
          this._serialize = childSerialize;
        }
        if (transmit2) {
          this._logEvent = createLogEventShape(
            [].concat(parent2._logEvent.bindings, bindings)
          );
        }
      }
      Child.prototype = this;
      return new Child(this);
    }
    return logger;
  }
  pino.levels = {
    values: {
      fatal: 60,
      error: 50,
      warn: 40,
      info: 30,
      debug: 20,
      trace: 10
    },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal"
    }
  };
  pino.stdSerializers = stdSerializers;
  pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
  function set(opts, logger, level, fallback2) {
    const proto = Object.getPrototypeOf(logger);
    logger[level] = logger.levelVal > logger.levels.values[level] ? noop2 : proto[level] ? proto[level] : _console[level] || _console[fallback2] || noop2;
    wrap(opts, logger, level);
  }
  function wrap(opts, logger, level) {
    if (!opts.transmit && logger[level] === noop2) return;
    logger[level] = /* @__PURE__ */ (function(write2) {
      return function LOG() {
        const ts = opts.timestamp();
        const args = new Array(arguments.length);
        const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
        for (var i4 = 0; i4 < args.length; i4++) args[i4] = arguments[i4];
        if (opts.serialize && !opts.asObject) {
          applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
        }
        if (opts.asObject) write2.call(proto, asObject(this, level, args, ts));
        else write2.apply(proto, args);
        if (opts.transmit) {
          const transmitLevel = opts.transmit.level || logger.level;
          const transmitValue = pino.levels.values[transmitLevel];
          const methodValue = pino.levels.values[level];
          if (methodValue < transmitValue) return;
          transmit(this, {
            ts,
            methodLevel: level,
            methodValue,
            transmitValue: pino.levels.values[opts.transmit.level || logger.level],
            send: opts.transmit.send,
            val: logger.levelVal
          }, args);
        }
      };
    })(logger[level]);
  }
  function asObject(logger, level, args, ts) {
    if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
    const argsCloned = args.slice();
    let msg = argsCloned[0];
    const o2 = {};
    if (ts) {
      o2.time = ts;
    }
    o2.level = pino.levels.values[level];
    let lvl = (logger._childLevel | 0) + 1;
    if (lvl < 1) lvl = 1;
    if (msg !== null && typeof msg === "object") {
      while (lvl-- && typeof argsCloned[0] === "object") {
        Object.assign(o2, argsCloned.shift());
      }
      msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
    } else if (typeof msg === "string") msg = format(argsCloned.shift(), argsCloned);
    if (msg !== void 0) o2.msg = msg;
    return o2;
  }
  function applySerializers(args, serialize2, serializers, stdErrSerialize) {
    for (const i4 in args) {
      if (stdErrSerialize && args[i4] instanceof Error) {
        args[i4] = pino.stdSerializers.err(args[i4]);
      } else if (typeof args[i4] === "object" && !Array.isArray(args[i4])) {
        for (const k2 in args[i4]) {
          if (serialize2 && serialize2.indexOf(k2) > -1 && k2 in serializers) {
            args[i4][k2] = serializers[k2](args[i4][k2]);
          }
        }
      }
    }
  }
  function bind(parent2, bindings, level) {
    return function() {
      const args = new Array(1 + arguments.length);
      args[0] = bindings;
      for (var i4 = 1; i4 < args.length; i4++) {
        args[i4] = arguments[i4 - 1];
      }
      return parent2[level].apply(this, args);
    };
  }
  function transmit(logger, opts, args) {
    const send = opts.send;
    const ts = opts.ts;
    const methodLevel = opts.methodLevel;
    const methodValue = opts.methodValue;
    const val = opts.val;
    const bindings = logger._logEvent.bindings;
    applySerializers(
      args,
      logger._serialize || Object.keys(logger.serializers),
      logger.serializers,
      logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
    );
    logger._logEvent.ts = ts;
    logger._logEvent.messages = args.filter(function(arg2) {
      return bindings.indexOf(arg2) === -1;
    });
    logger._logEvent.level.label = methodLevel;
    logger._logEvent.level.value = methodValue;
    send(methodLevel, logger._logEvent, val);
    logger._logEvent = createLogEventShape(bindings);
  }
  function createLogEventShape(bindings) {
    return {
      ts: 0,
      messages: [],
      bindings: bindings || [],
      level: { label: "", value: 0 }
    };
  }
  function asErrValue(err) {
    const obj = {
      type: err.constructor.name,
      msg: err.message,
      stack: err.stack
    };
    for (const key2 in err) {
      if (obj[key2] === void 0) {
        obj[key2] = err[key2];
      }
    }
    return obj;
  }
  function getTimeFunction(opts) {
    if (typeof opts.timestamp === "function") {
      return opts.timestamp;
    }
    if (opts.timestamp === false) {
      return nullTime;
    }
    return epochTime;
  }
  function mock() {
    return {};
  }
  function passthrough(a2) {
    return a2;
  }
  function noop2() {
  }
  function nullTime() {
    return false;
  }
  function epochTime() {
    return Date.now();
  }
  function unixTime() {
    return Math.round(Date.now() / 1e3);
  }
  function isoTime() {
    return new Date(Date.now()).toISOString();
  }
  function pfGlobalThisOrFallback() {
    function defd(o2) {
      return typeof o2 !== "undefined" && o2;
    }
    try {
      if (typeof globalThis !== "undefined") return globalThis;
      Object.defineProperty(Object.prototype, "globalThis", {
        get: function() {
          delete Object.prototype.globalThis;
          return this.globalThis = this;
        },
        configurable: true
      });
      return globalThis;
    } catch (e2) {
      return defd(self) || defd(window) || defd(this) || {};
    }
  }
  return browser$2;
}
var browserExports$1 = requireBrowser$2();
const Ot$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
const JSONStringify = (data2) => JSON.stringify(data2, (_2, value) => typeof value === "bigint" ? value.toString() + "n" : value);
const JSONParse = (json) => {
  const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
  const serializedData = json.replace(numbersBiggerThanMaxInt, '$1"$2n"$3');
  return JSON.parse(serializedData, (_2, value) => {
    const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
    if (isCustomFormatBigInt)
      return BigInt(value.substring(0, value.length - 1));
    return value;
  });
};
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSONParse(value);
  } catch (_a3) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSONStringify(value) || "";
}
const c$4 = { level: "info" }, n$6 = "custom_context", l$2 = 1e3 * 1024;
class O {
  constructor(e2) {
    this.nodeValue = e2, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
}
let d$2 = class d {
  constructor(e2) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e2, this.sizeInBytes = 0;
  }
  append(e2) {
    const t2 = new O(e2);
    if (t2.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e2} with size ${t2.size}`);
    for (; this.size + t2.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = t2), this.tail = t2) : (this.head = t2, this.tail = t2), this.lengthInNodes++, this.sizeInBytes += t2.size;
  }
  shift() {
    if (!this.head) return;
    const e2 = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e2.size;
  }
  toArray() {
    const e2 = [];
    let t2 = this.head;
    for (; t2 !== null; ) e2.push(t2.value), t2 = t2.next;
    return e2;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e2 = this.head;
    return { next: () => {
      if (!e2) return { done: true, value: null };
      const t2 = e2.value;
      return e2 = e2.next, { done: false, value: t2 };
    } };
  }
};
let L$1 = class L {
  constructor(e2, t2 = l$2) {
    this.level = e2 ?? "error", this.levelValue = browserExports$1.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t2, this.logs = new d$2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e2, t2) {
    t2 === browserExports$1.levels.values.error ? console.error(e2) : t2 === browserExports$1.levels.values.warn ? console.warn(e2) : t2 === browserExports$1.levels.values.debug ? console.debug(e2) : t2 === browserExports$1.levels.values.trace ? console.trace(e2) : console.log(e2);
  }
  appendToLogs(e2) {
    this.logs.append(safeJsonStringify({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e2 }));
    const t2 = typeof e2 == "string" ? JSON.parse(e2).level : e2.level;
    t2 >= this.levelValue && this.forwardToConsole(e2, t2);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new d$2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e2) {
    const t2 = this.getLogArray();
    return t2.push(safeJsonStringify({ extraMetadata: e2 })), new Blob(t2, { type: "application/json" });
  }
};
let m$1 = class m {
  constructor(e2, t2 = l$2) {
    this.baseChunkLogger = new L$1(e2, t2);
  }
  write(e2) {
    this.baseChunkLogger.appendToLogs(e2);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e2) {
    return this.baseChunkLogger.logsToBlob(e2);
  }
  downloadLogsBlobInBrowser(e2) {
    const t2 = URL.createObjectURL(this.logsToBlob(e2)), o2 = document.createElement("a");
    o2.href = t2, o2.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(o2), o2.click(), document.body.removeChild(o2), URL.revokeObjectURL(t2);
  }
};
let B$1 = class B {
  constructor(e2, t2 = l$2) {
    this.baseChunkLogger = new L$1(e2, t2);
  }
  write(e2) {
    this.baseChunkLogger.appendToLogs(e2);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e2) {
    return this.baseChunkLogger.logsToBlob(e2);
  }
};
var x$1 = Object.defineProperty, S$2 = Object.defineProperties, _$1 = Object.getOwnPropertyDescriptors, p$2 = Object.getOwnPropertySymbols, T$1 = Object.prototype.hasOwnProperty, z$2 = Object.prototype.propertyIsEnumerable, f$4 = (r2, e2, t2) => e2 in r2 ? x$1(r2, e2, { enumerable: true, configurable: true, writable: true, value: t2 }) : r2[e2] = t2, i$6 = (r2, e2) => {
  for (var t2 in e2 || (e2 = {})) T$1.call(e2, t2) && f$4(r2, t2, e2[t2]);
  if (p$2) for (var t2 of p$2(e2)) z$2.call(e2, t2) && f$4(r2, t2, e2[t2]);
  return r2;
}, g$1 = (r2, e2) => S$2(r2, _$1(e2));
function k$1(r2) {
  return g$1(i$6({}, r2), { level: r2?.level || c$4.level });
}
function v$1(r2, e2 = n$6) {
  return r2[e2] || "";
}
function b$2(r2, e2, t2 = n$6) {
  return r2[t2] = e2, r2;
}
function y$3(r2, e2 = n$6) {
  let t2 = "";
  return typeof r2.bindings > "u" ? t2 = v$1(r2, e2) : t2 = r2.bindings().context || "", t2;
}
function w(r2, e2, t2 = n$6) {
  const o2 = y$3(r2, t2);
  return o2.trim() ? `${o2}/${e2}` : e2;
}
function E$1(r2, e2, t2 = n$6) {
  const o2 = w(r2, e2, t2), a2 = r2.child({ context: o2 });
  return b$2(a2, o2, t2);
}
function C$1(r2) {
  var e2, t2;
  const o2 = new m$1((e2 = r2.opts) == null ? void 0 : e2.level, r2.maxSizeInBytes);
  return { logger: Ot$1(g$1(i$6({}, r2.opts), { level: "trace", browser: g$1(i$6({}, (t2 = r2.opts) == null ? void 0 : t2.browser), { write: (a2) => o2.write(a2) }) })), chunkLoggerController: o2 };
}
function I$1(r2) {
  var e2;
  const t2 = new B$1((e2 = r2.opts) == null ? void 0 : e2.level, r2.maxSizeInBytes);
  return { logger: Ot$1(g$1(i$6({}, r2.opts), { level: "trace" }), t2), chunkLoggerController: t2 };
}
function A$1(r2) {
  return typeof r2.loggerOverride < "u" && typeof r2.loggerOverride != "string" ? { logger: r2.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C$1(r2) : I$1(r2);
}
class W3mFrameLogger {
  constructor(projectId2) {
    const loggerOptions = k$1({
      level: DEFAULT_LOG_LEVEL
    });
    const { logger, chunkLoggerController } = A$1({
      opts: loggerOptions
    });
    this.logger = E$1(logger, this.constructor.name);
    this.chunkLoggerController = chunkLoggerController;
    if (typeof window !== "undefined" && this.chunkLoggerController?.downloadLogsBlobInBrowser) {
      if (!window.downloadAppKitLogsBlob) {
        window.downloadAppKitLogsBlob = {};
      }
      window.downloadAppKitLogsBlob["sdk"] = () => {
        if (this.chunkLoggerController?.downloadLogsBlobInBrowser) {
          this.chunkLoggerController.downloadLogsBlobInBrowser({
            projectId: projectId2
          });
        }
      };
    }
  }
}
class W3mFrameProvider {
  constructor(projectId2, chainId) {
    this.openRpcRequests = [];
    this.w3mLogger = new W3mFrameLogger(projectId2);
    this.w3mFrame = new W3mFrame(projectId2, true, chainId);
  }
  getLoginEmailUsed() {
    return Boolean(W3mFrameStorage.get(W3mFrameConstants.EMAIL_LOGIN_USED_KEY));
  }
  getEmail() {
    return W3mFrameStorage.get(W3mFrameConstants.EMAIL);
  }
  async connectEmail(payload) {
    try {
      W3mFrameHelpers.checkIfAllowedToTriggerEmail();
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_EMAIL,
        payload
      });
      this.setNewLastEmailLoginTime();
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error connecting email");
      throw error;
    }
  }
  async connectDevice() {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_DEVICE
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error connecting device");
      throw error;
    }
  }
  async connectOtp(payload) {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_OTP,
        payload
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error connecting otp");
      throw error;
    }
  }
  async isConnected() {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_IS_CONNECTED
      });
      if (!response.isConnected) {
        this.deleteAuthLoginCache();
      }
      return response;
    } catch (error) {
      this.deleteAuthLoginCache();
      this.w3mLogger.logger.error({ error }, "Error checking connection");
      throw error;
    }
  }
  async getChainId() {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_GET_CHAIN_ID
      });
      this.setLastUsedChainId(response.chainId);
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error getting chain id");
      throw error;
    }
  }
  async getSocialRedirectUri(payload) {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_GET_SOCIAL_REDIRECT_URI,
        payload
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error getting social redirect uri");
      throw error;
    }
  }
  async updateEmail(payload) {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_UPDATE_EMAIL,
        payload
      });
      this.setNewLastEmailLoginTime();
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error updating email");
      throw error;
    }
  }
  async updateEmailPrimaryOtp(payload) {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_UPDATE_EMAIL_PRIMARY_OTP,
        payload
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error updating email primary otp");
      throw error;
    }
  }
  async updateEmailSecondaryOtp(payload) {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_UPDATE_EMAIL_SECONDARY_OTP,
        payload
      });
      this.setLoginSuccess(response.newEmail);
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error updating email secondary otp");
      throw error;
    }
  }
  async syncTheme(payload) {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_SYNC_THEME,
        payload
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error syncing theme");
      throw error;
    }
  }
  async syncDappData(payload) {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_SYNC_DAPP_DATA,
        payload
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error syncing dapp data");
      throw error;
    }
  }
  async getSmartAccountEnabledNetworks() {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS
      });
      this.persistSmartAccountEnabledNetworks(response.smartAccountEnabledNetworks);
      return response;
    } catch (error) {
      this.persistSmartAccountEnabledNetworks([]);
      this.w3mLogger.logger.error({ error }, "Error getting smart account enabled networks");
      throw error;
    }
  }
  async setPreferredAccount(type) {
    try {
      return this.appEvent({
        type: W3mFrameConstants.APP_SET_PREFERRED_ACCOUNT,
        payload: { type }
      });
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error setting preferred account");
      throw error;
    }
  }
  async connect(payload) {
    try {
      const chainId = payload?.chainId ?? this.getLastUsedChainId() ?? 1;
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_GET_USER,
        payload: { ...payload, chainId }
      });
      this.setLoginSuccess(response.email);
      this.setLastUsedChainId(response.chainId);
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error connecting");
      throw error;
    }
  }
  async connectSocial(uri) {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_SOCIAL,
        payload: { uri }
      });
      if (response.userName) {
        this.setSocialLoginSuccess(response.userName);
      }
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error connecting social");
      throw error;
    }
  }
  async getFarcasterUri() {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_GET_FARCASTER_URI
      });
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error getting farcaster uri");
      throw error;
    }
  }
  async connectFarcaster() {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_CONNECT_FARCASTER
      });
      if (response.userName) {
        this.setSocialLoginSuccess(response.userName);
      }
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error connecting farcaster");
      throw error;
    }
  }
  async switchNetwork(chainId) {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_SWITCH_NETWORK,
        payload: { chainId }
      });
      this.setLastUsedChainId(response.chainId);
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error switching network");
      throw error;
    }
  }
  async disconnect() {
    try {
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_SIGN_OUT
      });
      this.deleteAuthLoginCache();
      return response;
    } catch (error) {
      this.w3mLogger.logger.error({ error }, "Error disconnecting");
      throw error;
    }
  }
  async request(req) {
    try {
      if (W3mFrameRpcConstants.GET_CHAIN_ID === req.method) {
        return this.getLastUsedChainId();
      }
      this.rpcRequestHandler?.(req);
      const response = await this.appEvent({
        type: W3mFrameConstants.APP_RPC_REQUEST,
        payload: req
      });
      this.rpcSuccessHandler?.(response, req);
      return response;
    } catch (error) {
      this.rpcErrorHandler?.(error, req);
      this.w3mLogger.logger.error({ error }, "Error requesting");
      throw error;
    }
  }
  onRpcRequest(callback) {
    this.rpcRequestHandler = callback;
  }
  onRpcSuccess(callback) {
    this.rpcSuccessHandler = callback;
  }
  onRpcError(callback) {
    this.rpcErrorHandler = callback;
  }
  onIsConnected(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_GET_USER_SUCCESS) {
        callback(event.payload);
      }
    });
  }
  onNotConnected(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_IS_CONNECTED_ERROR) {
        callback();
      }
      if (event.type === W3mFrameConstants.FRAME_IS_CONNECTED_SUCCESS && !event.payload.isConnected) {
        callback();
      }
    });
  }
  async getCapabilities() {
    try {
      const capabilities = await this.request({
        method: "wallet_getCapabilities"
      });
      return capabilities || {};
    } catch {
      return {};
    }
  }
  onSetPreferredAccount(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS) {
        callback(event.payload);
      } else if (event.type === W3mFrameConstants.FRAME_SET_PREFERRED_ACCOUNT_ERROR) {
        callback({ type: W3mFrameRpcConstants.ACCOUNT_TYPES.EOA });
      }
    });
  }
  onGetSmartAccountEnabledNetworks(callback) {
    this.w3mFrame.events.onFrameEvent((event) => {
      if (event.type === W3mFrameConstants.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS) {
        callback(event.payload.smartAccountEnabledNetworks);
      } else if (event.type === W3mFrameConstants.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR) {
        callback([]);
      }
    });
  }
  getAvailableChainIds() {
    return Object.keys(this.w3mFrame.networks);
  }
  rejectRpcRequests() {
    try {
      this.openRpcRequests.forEach(({ abortController, method }) => {
        if (!W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(method)) {
          abortController.abort();
        }
      });
      this.openRpcRequests = [];
    } catch (e2) {
      this.w3mLogger.logger.error({ error: e2 }, "Error aborting RPC request");
    }
  }
  async appEvent(event) {
    await this.w3mFrame.frameLoadPromise;
    const type = event.type.replace("@w3m-app/", "");
    return new Promise((resolve, reject) => {
      const id = Math.random().toString(36).substring(7);
      this.w3mLogger.logger.info?.({ event, id }, "Sending app event");
      this.w3mFrame.events.postAppEvent({ ...event, id });
      const abortController = new AbortController();
      if (type === "RPC_REQUEST") {
        const rpcEvent = event;
        this.openRpcRequests = [...this.openRpcRequests, { ...rpcEvent.payload, abortController }];
      }
      abortController.signal.addEventListener("abort", () => {
        if (type === "RPC_REQUEST") {
          reject(new Error("Request was aborted"));
        }
      });
      function handler(framEvent) {
        if (framEvent.type === `@w3m-frame/${type}_SUCCESS`) {
          if ("payload" in framEvent) {
            resolve(framEvent.payload);
          }
          resolve(void 0);
        } else if (framEvent.type === `@w3m-frame/${type}_ERROR`) {
          if ("payload" in framEvent) {
            reject(new Error(framEvent.payload?.message || "An error occurred"));
          }
          reject(new Error("An error occurred"));
        }
      }
      this.w3mFrame.events.registerFrameEventHandler(id, handler, abortController.signal);
    });
  }
  setNewLastEmailLoginTime() {
    W3mFrameStorage.set(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
  }
  setSocialLoginSuccess(username) {
    W3mFrameStorage.set(W3mFrameConstants.SOCIAL_USERNAME, username);
  }
  setLoginSuccess(email) {
    if (email) {
      W3mFrameStorage.set(W3mFrameConstants.EMAIL, email);
    }
    W3mFrameStorage.set(W3mFrameConstants.EMAIL_LOGIN_USED_KEY, "true");
    W3mFrameStorage.delete(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
  }
  deleteAuthLoginCache() {
    W3mFrameStorage.delete(W3mFrameConstants.EMAIL_LOGIN_USED_KEY);
    W3mFrameStorage.delete(W3mFrameConstants.EMAIL);
    W3mFrameStorage.delete(W3mFrameConstants.LAST_USED_CHAIN_KEY);
    W3mFrameStorage.delete(W3mFrameConstants.SOCIAL_USERNAME);
    W3mFrameStorage.delete(W3mFrameConstants.SOCIAL, true);
  }
  setLastUsedChainId(chainId) {
    W3mFrameStorage.set(W3mFrameConstants.LAST_USED_CHAIN_KEY, String(chainId));
  }
  getLastUsedChainId() {
    return Number(W3mFrameStorage.get(W3mFrameConstants.LAST_USED_CHAIN_KEY));
  }
  persistSmartAccountEnabledNetworks(networks) {
    W3mFrameStorage.set(W3mFrameConstants.SMART_ACCOUNT_ENABLED_NETWORKS, networks.join(","));
  }
}
const state$9 = proxy({
  transactions: [],
  coinbaseTransactions: {},
  transactionsByYear: {},
  lastNetworkInView: void 0,
  loading: false,
  empty: false,
  next: void 0
});
const TransactionsController = {
  state: state$9,
  subscribe(callback) {
    return subscribe(state$9, () => callback(state$9));
  },
  setLastNetworkInView(lastNetworkInView) {
    state$9.lastNetworkInView = lastNetworkInView;
  },
  async fetchTransactions(accountAddress, onramp) {
    const { projectId: projectId2 } = OptionsController.state;
    if (!projectId2 || !accountAddress) {
      throw new Error("Transactions can't be fetched without a projectId and an accountAddress");
    }
    state$9.loading = true;
    try {
      const response = await BlockchainApiController.fetchTransactions({
        account: accountAddress,
        projectId: projectId2,
        cursor: state$9.next,
        onramp,
        // Coinbase transaction history state updates require the latest data
        cache: onramp === "coinbase" ? "no-cache" : void 0,
        chainId: NetworkController.state.caipNetwork?.id
      });
      const nonSpamTransactions = this.filterSpamTransactions(response.data);
      const sameChainTransactions = this.filterByConnectedChain(nonSpamTransactions);
      const filteredTransactions = [...state$9.transactions, ...sameChainTransactions];
      state$9.loading = false;
      if (onramp === "coinbase") {
        state$9.coinbaseTransactions = this.groupTransactionsByYearAndMonth(state$9.coinbaseTransactions, response.data);
      } else {
        state$9.transactions = filteredTransactions;
        state$9.transactionsByYear = this.groupTransactionsByYearAndMonth(state$9.transactionsByYear, sameChainTransactions);
      }
      state$9.empty = filteredTransactions.length === 0;
      state$9.next = response.next ? response.next : void 0;
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "ERROR_FETCH_TRANSACTIONS",
        properties: {
          address: accountAddress,
          projectId: projectId2,
          cursor: state$9.next,
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      SnackController.showError("Failed to fetch transactions");
      state$9.loading = false;
      state$9.empty = true;
      state$9.next = void 0;
    }
  },
  groupTransactionsByYearAndMonth(transactionsMap = {}, transactions = []) {
    const grouped = transactionsMap;
    transactions.forEach((transaction) => {
      const year = new Date(transaction.metadata.minedAt).getFullYear();
      const month = new Date(transaction.metadata.minedAt).getMonth();
      const yearTransactions = grouped[year] ?? {};
      const monthTransactions = yearTransactions[month] ?? [];
      const newMonthTransactions = monthTransactions.filter((tx) => tx.id !== transaction.id);
      grouped[year] = {
        ...yearTransactions,
        [month]: [...newMonthTransactions, transaction].sort((a2, b2) => new Date(b2.metadata.minedAt).getTime() - new Date(a2.metadata.minedAt).getTime())
      };
    });
    return grouped;
  },
  filterSpamTransactions(transactions) {
    return transactions.filter((transaction) => {
      const isAllSpam = transaction.transfers.every((transfer) => transfer.nft_info?.flags.is_spam === true);
      return !isAllSpam;
    });
  },
  filterByConnectedChain(transactions) {
    const chainId = NetworkController.state.caipNetwork?.id;
    const filteredTransactions = transactions.filter((transaction) => transaction.metadata.chain === chainId);
    return filteredTransactions;
  },
  clearCursor() {
    state$9.next = void 0;
  },
  resetTransactions() {
    state$9.transactions = [];
    state$9.transactionsByYear = {};
    state$9.lastNetworkInView = void 0;
    state$9.loading = false;
    state$9.empty = false;
    state$9.next = void 0;
  }
};
const state$8 = proxy({
  wcError: false,
  buffering: false
});
const ConnectionController = {
  state: state$8,
  subscribeKey(key2, callback) {
    return subscribeKey(state$8, key2, callback);
  },
  _getClient(chain) {
    return ChainController.getConnectionControllerClient(chain);
  },
  setClient(client2) {
    state$8._client = ref(client2);
  },
  async connectWalletConnect() {
    StorageUtil.setConnectedConnector("WALLET_CONNECT");
    await this._getClient().connectWalletConnect((uri) => {
      state$8.wcUri = uri;
      state$8.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
    });
  },
  async connectExternal(options, chain) {
    await this._getClient(chain).connectExternal?.(options);
    ChainController.setActiveChain(chain);
    StorageUtil.setConnectedConnector(options.type);
  },
  async reconnectExternal(options) {
    await this._getClient().reconnectExternal?.(options);
    StorageUtil.setConnectedConnector(options.type);
  },
  async setPreferredAccountType(accountType) {
    ModalController.setLoading(true);
    const authConnector2 = ConnectorController.getAuthConnector();
    if (!authConnector2) {
      return;
    }
    await authConnector2?.provider.setPreferredAccount(accountType);
    await this.reconnectExternal(authConnector2);
    ModalController.setLoading(false);
    EventsController.sendEvent({
      type: "track",
      event: "SET_PREFERRED_ACCOUNT_TYPE",
      properties: { accountType, network: NetworkController.state.caipNetwork?.id || "" }
    });
  },
  async signMessage(message) {
    return this._getClient().signMessage(message);
  },
  parseUnits(value, decimals) {
    return this._getClient().parseUnits(value, decimals);
  },
  formatUnits(value, decimals) {
    return this._getClient().formatUnits(value, decimals);
  },
  async sendTransaction(args) {
    return this._getClient().sendTransaction(args);
  },
  async estimateGas(args) {
    return this._getClient().estimateGas(args);
  },
  async writeContract(args) {
    return this._getClient().writeContract(args);
  },
  async getEnsAddress(value) {
    return this._getClient().getEnsAddress(value);
  },
  async getEnsAvatar(value) {
    return this._getClient().getEnsAvatar(value);
  },
  checkInstalled(ids, chain) {
    return this._getClient(chain).checkInstalled?.(ids) || false;
  },
  resetWcConnection() {
    state$8.wcUri = void 0;
    state$8.wcPairingExpiry = void 0;
    state$8.wcLinking = void 0;
    state$8.recentWallet = void 0;
    TransactionsController.resetTransactions();
    StorageUtil.deleteWalletConnectDeepLink();
  },
  setWcLinking(wcLinking) {
    state$8.wcLinking = wcLinking;
  },
  setWcError(wcError) {
    state$8.wcError = wcError;
    state$8.buffering = false;
  },
  setRecentWallet(wallet) {
    state$8.recentWallet = wallet;
  },
  setBuffering(buffering) {
    state$8.buffering = buffering;
  },
  async disconnect() {
    const client2 = this._getClient();
    try {
      await client2.disconnect();
      this.resetWcConnection();
    } catch (error) {
      throw new Error("Failed to disconnect");
    }
  }
};
const SwapApiUtil = {
  async getTokenList() {
    const caipNetwork = NetworkController.state.caipNetwork;
    const response = await BlockchainApiController.fetchSwapTokens({
      chainId: caipNetwork?.id,
      projectId: OptionsController.state.projectId
    });
    const tokens = response?.tokens?.map((token2) => ({
      ...token2,
      eip2612: false,
      quantity: {
        decimals: "0",
        numeric: "0"
      },
      price: 0,
      value: 0
    })) || [];
    return tokens;
  },
  async fetchGasPrice() {
    const projectId2 = OptionsController.state.projectId;
    const caipNetwork = NetworkController.state.caipNetwork;
    if (!caipNetwork) {
      return null;
    }
    try {
      switch (caipNetwork.chain) {
        case "solana":
          const lamportsPerSignature = (await ConnectionController.estimateGas({ chainNamespace: "solana" })).toString();
          return {
            standard: lamportsPerSignature,
            fast: lamportsPerSignature,
            instant: lamportsPerSignature
          };
        case "evm":
        default:
          return await BlockchainApiController.fetchGasPrice({
            projectId: projectId2,
            chainId: caipNetwork.id
          });
      }
    } catch {
      return null;
    }
  },
  async fetchSwapAllowance({ tokenAddress, userAddress, sourceTokenAmount, sourceTokenDecimals }) {
    const projectId2 = OptionsController.state.projectId;
    const response = await BlockchainApiController.fetchSwapAllowance({
      projectId: projectId2,
      tokenAddress,
      userAddress
    });
    if (response?.allowance && sourceTokenAmount && sourceTokenDecimals) {
      const parsedValue = ConnectionController.parseUnits(sourceTokenAmount, sourceTokenDecimals) || 0;
      const hasAllowance = BigInt(response.allowance) >= parsedValue;
      return hasAllowance;
    }
    return false;
  },
  async getMyTokensWithBalance(forceUpdate) {
    const address = AccountController.state.address;
    const caipNetwork = NetworkController.state.caipNetwork;
    if (!address || !caipNetwork) {
      return [];
    }
    const response = await BlockchainApiController.getBalance(address, caipNetwork.id, forceUpdate);
    const balances = response.balances.filter((balance) => balance.quantity.decimals !== "0");
    AccountController.setTokenBalance(balances, ChainController.state.activeChain);
    return this.mapBalancesToSwapTokens(balances);
  },
  mapBalancesToSwapTokens(balances) {
    return balances?.map((token2) => ({
      ...token2,
      address: token2?.address ? token2.address : NetworkController.getActiveNetworkTokenAddress(),
      decimals: parseInt(token2.quantity.decimals, 10),
      logoUri: token2.iconUrl,
      eip2612: false
    })) || [];
  }
};
const state$7 = proxy({
  view: "Connect",
  history: ["Connect"],
  transactionStack: []
});
const RouterController = {
  state: state$7,
  subscribeKey(key2, callback) {
    return subscribeKey(state$7, key2, callback);
  },
  pushTransactionStack(action) {
    state$7.transactionStack.push(action);
  },
  popTransactionStack(cancel) {
    const action = state$7.transactionStack.pop();
    if (!action) {
      return;
    }
    if (cancel) {
      this.goBack();
      action?.onCancel?.();
    } else {
      if (action.goBack) {
        this.goBack();
      } else if (action.view) {
        this.reset(action.view);
      }
      action?.onSuccess?.();
    }
  },
  push(view, data2) {
    if (view !== state$7.view) {
      state$7.view = view;
      state$7.history.push(view);
      state$7.data = data2;
    }
  },
  reset(view) {
    state$7.view = view;
    state$7.history = [view];
  },
  replace(view, data2) {
    if (state$7.history.length >= 1 && state$7.history.at(-1) !== view) {
      state$7.view = view;
      state$7.history[state$7.history.length - 1] = view;
      state$7.data = data2;
    }
  },
  goBack() {
    if (state$7.history.length > 1) {
      state$7.history.pop();
      const [last] = state$7.history.slice(-1);
      if (last) {
        state$7.view = last;
      }
    }
  },
  goBackToIndex(historyIndex) {
    if (state$7.history.length > 1) {
      state$7.history = state$7.history.slice(0, historyIndex + 1);
      const [last] = state$7.history.slice(-1);
      if (last) {
        state$7.view = last;
      }
    }
  }
};
const SwapCalculationUtil = {
  getGasPriceInEther(gas, gasPrice) {
    const totalGasCostInWei = gasPrice * gas;
    const totalGasCostInEther = Number(totalGasCostInWei) / 1e18;
    return totalGasCostInEther;
  },
  getGasPriceInUSD(networkPrice, gas, gasPrice) {
    const totalGasCostInEther = SwapCalculationUtil.getGasPriceInEther(gas, gasPrice);
    const networkPriceInUSD = NumberUtil.bigNumber(networkPrice);
    const gasCostInUSD = networkPriceInUSD.multipliedBy(totalGasCostInEther);
    return gasCostInUSD.toNumber();
  },
  getPriceImpact({ sourceTokenAmount, sourceTokenPriceInUSD, toTokenPriceInUSD, toTokenAmount }) {
    const inputValue = NumberUtil.bigNumber(sourceTokenAmount).multipliedBy(sourceTokenPriceInUSD);
    const outputValue = NumberUtil.bigNumber(toTokenAmount).multipliedBy(toTokenPriceInUSD);
    const priceImpact = inputValue.minus(outputValue).dividedBy(inputValue).multipliedBy(100);
    return priceImpact.toNumber();
  },
  getMaxSlippage(slippage, toTokenAmount) {
    const slippageToleranceDecimal = NumberUtil.bigNumber(slippage).dividedBy(100);
    const maxSlippageAmount = NumberUtil.multiply(toTokenAmount, slippageToleranceDecimal);
    return maxSlippageAmount.toNumber();
  },
  getProviderFee(sourceTokenAmount, feePercentage = 85e-4) {
    const providerFee = NumberUtil.bigNumber(sourceTokenAmount).multipliedBy(feePercentage);
    return providerFee.toString();
  },
  isInsufficientNetworkTokenForGas(networkBalanceInUSD, gasPriceInUSD) {
    const gasPrice = gasPriceInUSD || "0";
    if (NumberUtil.bigNumber(networkBalanceInUSD).isZero()) {
      return true;
    }
    return NumberUtil.bigNumber(NumberUtil.bigNumber(gasPrice)).isGreaterThan(networkBalanceInUSD);
  },
  isInsufficientSourceTokenForSwap(sourceTokenAmount, sourceTokenAddress, balance) {
    const sourceTokenBalance = balance?.find((token2) => token2.address === sourceTokenAddress)?.quantity?.numeric;
    const isInSufficientBalance = NumberUtil.bigNumber(sourceTokenBalance || "0").isLessThan(sourceTokenAmount);
    return isInSufficientBalance;
  },
  getToTokenAmount({ sourceToken, toToken, sourceTokenPrice, toTokenPrice, sourceTokenAmount }) {
    if (sourceTokenAmount === "0") {
      return "0";
    }
    if (!sourceToken || !toToken) {
      return "0";
    }
    const sourceTokenDecimals = sourceToken.decimals;
    const sourceTokenPriceInUSD = sourceTokenPrice;
    const toTokenDecimals = toToken.decimals;
    const toTokenPriceInUSD = toTokenPrice;
    if (toTokenPriceInUSD <= 0) {
      return "0";
    }
    const providerFee = NumberUtil.bigNumber(sourceTokenAmount).multipliedBy(85e-4);
    const adjustedSourceTokenAmount = NumberUtil.bigNumber(sourceTokenAmount).minus(providerFee);
    const sourceAmountInSmallestUnit = adjustedSourceTokenAmount.multipliedBy(NumberUtil.bigNumber(10).pow(sourceTokenDecimals));
    const priceRatio = NumberUtil.bigNumber(sourceTokenPriceInUSD).dividedBy(toTokenPriceInUSD);
    const decimalDifference = sourceTokenDecimals - toTokenDecimals;
    const toTokenAmountInSmallestUnit = sourceAmountInSmallestUnit.multipliedBy(priceRatio).dividedBy(NumberUtil.bigNumber(10).pow(decimalDifference));
    const toTokenAmount = toTokenAmountInSmallestUnit.dividedBy(NumberUtil.bigNumber(10).pow(toTokenDecimals));
    const amount = toTokenAmount.toFixed(toTokenDecimals).toString();
    return amount;
  }
};
const INITIAL_GAS_LIMIT = 15e4;
const TO_AMOUNT_DECIMALS = 6;
const initialState = {
  // Loading states
  initializing: false,
  initialized: false,
  loadingPrices: false,
  loadingQuote: false,
  loadingApprovalTransaction: false,
  loadingBuildTransaction: false,
  loadingTransaction: false,
  // Error states
  fetchError: false,
  // Approval & Swap transaction states
  approvalTransaction: void 0,
  swapTransaction: void 0,
  transactionError: void 0,
  // Input values
  sourceToken: void 0,
  sourceTokenAmount: "",
  sourceTokenPriceInUSD: 0,
  toToken: void 0,
  toTokenAmount: "",
  toTokenPriceInUSD: 0,
  networkPrice: "0",
  networkBalanceInUSD: "0",
  networkTokenSymbol: "",
  inputError: void 0,
  // Request values
  slippage: ConstantsUtil$1.CONVERT_SLIPPAGE_TOLERANCE,
  // Tokens
  tokens: void 0,
  popularTokens: void 0,
  suggestedTokens: void 0,
  foundTokens: void 0,
  myTokensWithBalance: void 0,
  tokensPriceMap: {},
  // Calculations
  gasFee: "0",
  gasPriceInUSD: 0,
  priceImpact: void 0,
  maxSlippage: void 0,
  providerFee: void 0
};
const state$6 = proxy(initialState);
const SwapController = {
  state: state$6,
  subscribe(callback) {
    return subscribe(state$6, () => callback(state$6));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$6, key2, callback);
  },
  getParams() {
    const address = AccountController.state.address;
    const networkAddress = NetworkController.getActiveNetworkTokenAddress();
    const type = StorageUtil.getConnectedConnector();
    const authConnector2 = ConnectorController.getAuthConnector();
    if (!address) {
      throw new Error("No address found to swap the tokens from.");
    }
    const caipAddress = AccountController.state.caipAddress;
    const invalidToToken = !state$6.toToken?.address || !state$6.toToken?.decimals;
    const invalidSourceToken = !state$6.sourceToken?.address || !state$6.sourceToken?.decimals || !NumberUtil.bigNumber(state$6.sourceTokenAmount).isGreaterThan(0);
    const invalidSourceTokenAmount = !state$6.sourceTokenAmount;
    return {
      networkAddress,
      fromAddress: address,
      fromCaipAddress: AccountController.state.caipAddress,
      sourceTokenAddress: state$6.sourceToken?.address,
      toTokenAddress: state$6.toToken?.address,
      toTokenAmount: state$6.toTokenAmount,
      toTokenDecimals: state$6.toToken?.decimals,
      sourceTokenAmount: state$6.sourceTokenAmount,
      sourceTokenDecimals: state$6.sourceToken?.decimals,
      invalidToToken,
      invalidSourceToken,
      invalidSourceTokenAmount,
      availableToSwap: caipAddress && !invalidToToken && !invalidSourceToken && !invalidSourceTokenAmount,
      isAuthConnector: authConnector2?.walletFeatures && type === "AUTH"
    };
  },
  setSourceToken(sourceToken) {
    if (!sourceToken) {
      state$6.sourceToken = sourceToken;
      state$6.sourceTokenAmount = "";
      state$6.sourceTokenPriceInUSD = 0;
      return;
    }
    state$6.sourceToken = sourceToken;
    this.setTokenPrice(sourceToken.address, "sourceToken");
  },
  setSourceTokenAmount(amount) {
    state$6.sourceTokenAmount = amount;
  },
  setToToken(toToken) {
    if (!toToken) {
      state$6.toToken = toToken;
      state$6.toTokenAmount = "";
      state$6.toTokenPriceInUSD = 0;
      return;
    }
    state$6.toToken = toToken;
    this.setTokenPrice(toToken.address, "toToken");
  },
  setToTokenAmount(amount) {
    state$6.toTokenAmount = amount ? NumberUtil.formatNumberToLocalString(amount, TO_AMOUNT_DECIMALS) : "";
  },
  async setTokenPrice(address, target) {
    const { availableToSwap } = this.getParams();
    let price = state$6.tokensPriceMap[address] || 0;
    if (!price) {
      state$6.loadingPrices = true;
      price = await this.getAddressPrice(address);
    }
    if (target === "sourceToken") {
      state$6.sourceTokenPriceInUSD = price;
    } else if (target === "toToken") {
      state$6.toTokenPriceInUSD = price;
    }
    if (state$6.loadingPrices) {
      state$6.loadingPrices = false;
      if (availableToSwap) {
        this.swapTokens();
      }
    }
  },
  switchTokens() {
    if (state$6.initializing || !state$6.initialized) {
      return;
    }
    const newSourceToken = state$6.toToken ? { ...state$6.toToken } : void 0;
    const newToToken = state$6.sourceToken ? { ...state$6.sourceToken } : void 0;
    const newSourceTokenAmount = newSourceToken && state$6.toTokenAmount === "" ? "1" : state$6.toTokenAmount;
    this.setSourceToken(newSourceToken);
    this.setToToken(newToToken);
    this.setSourceTokenAmount(newSourceTokenAmount);
    this.setToTokenAmount("");
    this.swapTokens();
  },
  resetState() {
    state$6.myTokensWithBalance = initialState.myTokensWithBalance;
    state$6.tokensPriceMap = initialState.tokensPriceMap;
    state$6.initialized = initialState.initialized;
    state$6.sourceToken = initialState.sourceToken;
    state$6.sourceTokenAmount = initialState.sourceTokenAmount;
    state$6.sourceTokenPriceInUSD = initialState.sourceTokenPriceInUSD;
    state$6.toToken = initialState.toToken;
    state$6.toTokenAmount = initialState.toTokenAmount;
    state$6.toTokenPriceInUSD = initialState.toTokenPriceInUSD;
    state$6.networkPrice = initialState.networkPrice;
    state$6.networkTokenSymbol = initialState.networkTokenSymbol;
    state$6.networkBalanceInUSD = initialState.networkBalanceInUSD;
    state$6.inputError = initialState.inputError;
  },
  resetValues() {
    const { networkAddress } = this.getParams();
    const networkToken = state$6.tokens?.find((token2) => token2.address === networkAddress);
    this.setSourceToken(networkToken);
    this.setToToken(void 0);
  },
  getApprovalLoadingState() {
    return state$6.loadingApprovalTransaction;
  },
  clearError() {
    state$6.transactionError = void 0;
  },
  async initializeState() {
    if (state$6.initializing) {
      return;
    }
    state$6.initializing = true;
    if (!state$6.initialized) {
      try {
        await this.fetchTokens();
        state$6.initialized = true;
      } catch (error) {
        state$6.initialized = false;
        SnackController.showError("Failed to initialize swap");
        RouterController.goBack();
      }
    }
    state$6.initializing = false;
  },
  async fetchTokens() {
    const { networkAddress } = this.getParams();
    await this.getTokenList();
    await this.getNetworkTokenPrice();
    await this.getMyTokensWithBalance();
    const networkToken = state$6.tokens?.find((token2) => token2.address === networkAddress);
    if (networkToken) {
      state$6.networkTokenSymbol = networkToken.symbol;
      this.setSourceToken(networkToken);
      this.setSourceTokenAmount("1");
    }
  },
  async getTokenList() {
    const tokens = await SwapApiUtil.getTokenList();
    state$6.tokens = tokens;
    state$6.popularTokens = tokens.sort((aTokenInfo, bTokenInfo) => {
      if (aTokenInfo.symbol < bTokenInfo.symbol) {
        return -1;
      }
      if (aTokenInfo.symbol > bTokenInfo.symbol) {
        return 1;
      }
      return 0;
    });
    state$6.suggestedTokens = tokens.filter((token2) => {
      if (ConstantsUtil$1.SWAP_SUGGESTED_TOKENS.includes(token2.symbol)) {
        return true;
      }
      return false;
    }, {});
  },
  async getAddressPrice(address) {
    const existPrice = state$6.tokensPriceMap[address];
    if (existPrice) {
      return existPrice;
    }
    const response = await BlockchainApiController.fetchTokenPrice({
      projectId: OptionsController.state.projectId,
      addresses: [address]
    });
    const fungibles = response.fungibles || [];
    const allTokens = [...state$6.tokens || [], ...state$6.myTokensWithBalance || []];
    const symbol = allTokens?.find((token2) => token2.address === address)?.symbol;
    const price = fungibles.find((p2) => p2.symbol.toLowerCase() === symbol?.toLowerCase())?.price || 0;
    const priceAsFloat = parseFloat(price.toString());
    state$6.tokensPriceMap[address] = priceAsFloat;
    return priceAsFloat;
  },
  async getNetworkTokenPrice() {
    const { networkAddress } = this.getParams();
    const response = await BlockchainApiController.fetchTokenPrice({
      projectId: OptionsController.state.projectId,
      addresses: [networkAddress]
    }).catch(() => {
      SnackController.showError("Failed to fetch network token price");
      return { fungibles: [] };
    });
    const token2 = response.fungibles?.[0];
    const price = token2?.price.toString() || "0";
    state$6.tokensPriceMap[networkAddress] = parseFloat(price);
    state$6.networkTokenSymbol = token2?.symbol || "";
    state$6.networkPrice = price;
  },
  async getMyTokensWithBalance(forceUpdate) {
    const balances = await SwapApiUtil.getMyTokensWithBalance(forceUpdate);
    if (!balances) {
      return;
    }
    await this.getInitialGasPrice();
    this.setBalances(balances);
  },
  setBalances(balances) {
    const { networkAddress } = this.getParams();
    const caipNetwork = NetworkController.state.caipNetwork;
    if (!caipNetwork) {
      return;
    }
    const networkToken = balances.find((token2) => token2.address === networkAddress);
    balances.forEach((token2) => {
      state$6.tokensPriceMap[token2.address] = token2.price || 0;
    });
    state$6.myTokensWithBalance = balances.filter((token2) => token2.address.startsWith(caipNetwork.id));
    state$6.networkBalanceInUSD = networkToken ? NumberUtil.multiply(networkToken.quantity.numeric, networkToken.price).toString() : "0";
  },
  async getInitialGasPrice() {
    const res = await SwapApiUtil.fetchGasPrice();
    if (!res) {
      return { gasPrice: null, gasPriceInUSD: null };
    }
    switch (NetworkController.state.caipNetwork?.chain) {
      case "solana":
        state$6.gasFee = res.standard;
        state$6.gasPriceInUSD = NumberUtil.multiply(res.standard, state$6.networkPrice).dividedBy(1e9).toNumber();
        return {
          gasPrice: BigInt(state$6.gasFee),
          gasPriceInUSD: Number(state$6.gasPriceInUSD)
        };
      case "evm":
      default:
        const value = res.standard;
        const gasFee = BigInt(value);
        const gasLimit = BigInt(INITIAL_GAS_LIMIT);
        const gasPrice = SwapCalculationUtil.getGasPriceInUSD(state$6.networkPrice, gasLimit, gasFee);
        state$6.gasFee = value;
        state$6.gasPriceInUSD = gasPrice;
        return { gasPrice: gasFee, gasPriceInUSD: gasPrice };
    }
  },
  // -- Swap -------------------------------------- //
  async swapTokens() {
    const address = AccountController.state.address;
    const sourceToken = state$6.sourceToken;
    const toToken = state$6.toToken;
    const haveSourceTokenAmount = NumberUtil.bigNumber(state$6.sourceTokenAmount).isGreaterThan(0);
    if (!toToken || !sourceToken || state$6.loadingPrices || !haveSourceTokenAmount) {
      return;
    }
    state$6.loadingQuote = true;
    const amountDecimal = NumberUtil.bigNumber(state$6.sourceTokenAmount).multipliedBy(10 ** sourceToken.decimals);
    const quoteResponse = await BlockchainApiController.fetchSwapQuote({
      userAddress: address,
      projectId: OptionsController.state.projectId,
      from: sourceToken.address,
      to: toToken.address,
      gasPrice: state$6.gasFee,
      amount: amountDecimal.toString()
    });
    state$6.loadingQuote = false;
    const quoteToAmount = quoteResponse?.quotes?.[0]?.toAmount;
    if (!quoteToAmount) {
      return;
    }
    const toTokenAmount = NumberUtil.bigNumber(quoteToAmount).dividedBy(10 ** toToken.decimals).toString();
    this.setToTokenAmount(toTokenAmount);
    const isInsufficientToken = this.hasInsufficientToken(state$6.sourceTokenAmount, sourceToken.address);
    if (isInsufficientToken) {
      state$6.inputError = "Insufficient balance";
    } else {
      state$6.inputError = void 0;
      this.setTransactionDetails();
    }
  },
  // -- Create Transactions -------------------------------------- //
  async getTransaction() {
    const { fromCaipAddress, availableToSwap } = this.getParams();
    const sourceToken = state$6.sourceToken;
    const toToken = state$6.toToken;
    if (!fromCaipAddress || !availableToSwap || !sourceToken || !toToken || state$6.loadingQuote) {
      return void 0;
    }
    try {
      state$6.loadingBuildTransaction = true;
      const hasAllowance = await SwapApiUtil.fetchSwapAllowance({
        userAddress: fromCaipAddress,
        tokenAddress: sourceToken.address,
        sourceTokenAmount: state$6.sourceTokenAmount,
        sourceTokenDecimals: sourceToken.decimals
      });
      let transaction = void 0;
      if (hasAllowance) {
        transaction = await this.createSwapTransaction();
      } else {
        transaction = await this.createAllowanceTransaction();
      }
      state$6.loadingBuildTransaction = false;
      state$6.fetchError = false;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to check allowance");
      state$6.loadingBuildTransaction = false;
      state$6.approvalTransaction = void 0;
      state$6.swapTransaction = void 0;
      state$6.fetchError = true;
      return void 0;
    }
  },
  async createAllowanceTransaction() {
    const { fromCaipAddress, fromAddress, sourceTokenAddress, toTokenAddress } = this.getParams();
    if (!fromCaipAddress || !toTokenAddress) {
      return void 0;
    }
    if (!sourceTokenAddress) {
      throw new Error("createAllowanceTransaction - No source token address found.");
    }
    try {
      const response = await BlockchainApiController.generateApproveCalldata({
        projectId: OptionsController.state.projectId,
        from: sourceTokenAddress,
        to: toTokenAddress,
        userAddress: fromCaipAddress
      });
      const gasLimit = await ConnectionController.estimateGas({
        address: fromAddress,
        to: CoreHelperUtil.getPlainAddress(response.tx.to),
        data: response.tx.data
      });
      const transaction = {
        data: response.tx.data,
        to: CoreHelperUtil.getPlainAddress(response.tx.from),
        gas: gasLimit,
        gasPrice: BigInt(response.tx.eip155.gasPrice),
        value: BigInt(response.tx.value),
        toAmount: state$6.toTokenAmount
      };
      state$6.swapTransaction = void 0;
      state$6.approvalTransaction = transaction;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to create approval transaction");
      state$6.approvalTransaction = void 0;
      state$6.swapTransaction = void 0;
      state$6.fetchError = true;
      return void 0;
    }
  },
  async createSwapTransaction() {
    const { networkAddress, fromCaipAddress, sourceTokenAmount } = this.getParams();
    const sourceToken = state$6.sourceToken;
    const toToken = state$6.toToken;
    if (!fromCaipAddress || !sourceTokenAmount || !sourceToken || !toToken) {
      return void 0;
    }
    const amount = ConnectionController.parseUnits(sourceTokenAmount, sourceToken.decimals).toString();
    try {
      const response = await BlockchainApiController.generateSwapCalldata({
        projectId: OptionsController.state.projectId,
        userAddress: fromCaipAddress,
        from: sourceToken.address,
        to: toToken.address,
        amount
      });
      const isSourceTokenIsNetworkToken = sourceToken.address === networkAddress;
      const gas = BigInt(response.tx.eip155.gas);
      const gasPrice = BigInt(response.tx.eip155.gasPrice);
      const transaction = {
        data: response.tx.data,
        to: CoreHelperUtil.getPlainAddress(response.tx.to),
        gas,
        gasPrice,
        value: isSourceTokenIsNetworkToken ? BigInt(amount) : BigInt("0"),
        toAmount: state$6.toTokenAmount
      };
      state$6.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state$6.networkPrice, gas, gasPrice);
      state$6.approvalTransaction = void 0;
      state$6.swapTransaction = transaction;
      return transaction;
    } catch (error) {
      RouterController.goBack();
      SnackController.showError("Failed to create transaction");
      state$6.approvalTransaction = void 0;
      state$6.swapTransaction = void 0;
      state$6.fetchError = true;
      return void 0;
    }
  },
  // -- Send Transactions --------------------------------- //
  async sendTransactionForApproval(data2) {
    const { fromAddress, isAuthConnector } = this.getParams();
    state$6.loadingApprovalTransaction = true;
    const approveLimitMessage = `Approve limit increase in your wallet`;
    if (isAuthConnector) {
      RouterController.pushTransactionStack({
        view: null,
        goBack: true,
        onSuccess() {
          SnackController.showLoading(approveLimitMessage);
        }
      });
    } else {
      SnackController.showLoading(approveLimitMessage);
    }
    try {
      await ConnectionController.sendTransaction({
        address: fromAddress,
        to: data2.to,
        data: data2.data,
        value: BigInt(data2.value),
        gasPrice: BigInt(data2.gasPrice)
      });
      await this.swapTokens();
      await this.getTransaction();
      state$6.approvalTransaction = void 0;
      state$6.loadingApprovalTransaction = false;
    } catch (err) {
      const error = err;
      state$6.transactionError = error?.shortMessage;
      state$6.loadingApprovalTransaction = false;
      SnackController.showError(error?.shortMessage || "Transaction error");
    }
  },
  async sendTransactionForSwap(data2) {
    if (!data2) {
      return void 0;
    }
    const { fromAddress, toTokenAmount, isAuthConnector } = this.getParams();
    state$6.loadingTransaction = true;
    const snackbarPendingMessage = `Swapping ${state$6.sourceToken?.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${state$6.toToken?.symbol}`;
    const snackbarSuccessMessage = `Swapped ${state$6.sourceToken?.symbol} to ${NumberUtil.formatNumberToLocalString(toTokenAmount, 3)} ${state$6.toToken?.symbol}`;
    if (isAuthConnector) {
      RouterController.pushTransactionStack({
        view: "Account",
        goBack: false,
        onSuccess() {
          SnackController.showLoading(snackbarPendingMessage);
          SwapController.resetState();
        }
      });
    } else {
      SnackController.showLoading("Confirm transaction in your wallet");
    }
    try {
      const forceUpdateAddresses = [state$6.sourceToken?.address, state$6.toToken?.address].join(",");
      const transactionHash = await ConnectionController.sendTransaction({
        address: fromAddress,
        to: data2.to,
        data: data2.data,
        gas: data2.gas,
        gasPrice: BigInt(data2.gasPrice),
        value: data2.value
      });
      state$6.loadingTransaction = false;
      SnackController.showSuccess(snackbarSuccessMessage);
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_SUCCESS",
        properties: {
          network: NetworkController.state.caipNetwork?.id || "",
          swapFromToken: this.state.sourceToken?.symbol || "",
          swapToToken: this.state.toToken?.symbol || "",
          swapFromAmount: this.state.sourceTokenAmount || "",
          swapToAmount: this.state.toTokenAmount || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      SwapController.resetState();
      if (!isAuthConnector) {
        RouterController.replace("Account");
      }
      SwapController.getMyTokensWithBalance(forceUpdateAddresses);
      return transactionHash;
    } catch (err) {
      const error = err;
      state$6.transactionError = error?.shortMessage;
      state$6.loadingTransaction = false;
      SnackController.showError(error?.shortMessage || "Transaction error");
      EventsController.sendEvent({
        type: "track",
        event: "SWAP_ERROR",
        properties: {
          network: NetworkController.state.caipNetwork?.id || "",
          swapFromToken: this.state.sourceToken?.symbol || "",
          swapToToken: this.state.toToken?.symbol || "",
          swapFromAmount: this.state.sourceTokenAmount || "",
          swapToAmount: this.state.toTokenAmount || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      return void 0;
    }
  },
  // -- Checks -------------------------------------------- //
  hasInsufficientToken(sourceTokenAmount, sourceTokenAddress) {
    const isInsufficientSourceTokenForSwap = SwapCalculationUtil.isInsufficientSourceTokenForSwap(sourceTokenAmount, sourceTokenAddress, state$6.myTokensWithBalance);
    const insufficientNetworkTokenForGas = SwapCalculationUtil.isInsufficientNetworkTokenForGas(state$6.networkBalanceInUSD, state$6.gasPriceInUSD);
    return insufficientNetworkTokenForGas || isInsufficientSourceTokenForSwap;
  },
  // -- Calculations -------------------------------------- //
  setTransactionDetails() {
    const { toTokenAddress, toTokenDecimals } = this.getParams();
    if (!toTokenAddress || !toTokenDecimals) {
      return;
    }
    state$6.gasPriceInUSD = SwapCalculationUtil.getGasPriceInUSD(state$6.networkPrice, BigInt(state$6.gasFee), BigInt(INITIAL_GAS_LIMIT));
    state$6.priceImpact = SwapCalculationUtil.getPriceImpact({
      sourceTokenAmount: state$6.sourceTokenAmount,
      sourceTokenPriceInUSD: state$6.sourceTokenPriceInUSD,
      toTokenPriceInUSD: state$6.toTokenPriceInUSD,
      toTokenAmount: state$6.toTokenAmount
    });
    state$6.maxSlippage = SwapCalculationUtil.getMaxSlippage(state$6.slippage, state$6.toTokenAmount);
    state$6.providerFee = SwapCalculationUtil.getProviderFee(state$6.sourceTokenAmount);
  }
};
const state$5 = proxy({
  isConnected: false,
  currentTab: 0,
  tokenBalance: [],
  smartAccountDeployed: false,
  addressLabels: /* @__PURE__ */ new Map(),
  allAccounts: []
});
const AccountController = {
  state: state$5,
  replaceState(newState) {
    if (!newState) {
      return;
    }
    Object.assign(state$5, ref(newState));
  },
  subscribe(callback) {
    return ChainController.subscribeChainProp("accountState", (accountState2) => {
      if (accountState2) {
        return callback(accountState2);
      }
      return void 0;
    });
  },
  subscribeKey(property, callback) {
    let prev2 = void 0;
    return ChainController.subscribeChainProp("accountState", (accountState2) => {
      if (accountState2) {
        const nextValue = accountState2[property];
        if (prev2 !== nextValue) {
          prev2 = nextValue;
          callback(nextValue);
        }
      }
    });
  },
  setIsConnected(isConnected, chain) {
    ChainController.setAccountProp("isConnected", isConnected, chain);
  },
  getChainIsConnected(chain) {
    return ChainController.getAccountProp("isConnected", chain);
  },
  setCaipAddress(caipAddress, chain) {
    const newCaipAddress = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : void 0;
    ChainController.setAccountProp("caipAddress", caipAddress, chain);
    ChainController.setAccountProp("address", newCaipAddress, chain);
  },
  setBalance(balance, balanceSymbol, chain) {
    ChainController.setAccountProp("balance", balance, chain);
    ChainController.setAccountProp("balanceSymbol", balanceSymbol, chain);
  },
  setProfileName(profileName, chain) {
    ChainController.setAccountProp("profileName", profileName, chain);
  },
  setProfileImage(profileImage, chain) {
    ChainController.setAccountProp("profileImage", profileImage, chain);
  },
  setAddressExplorerUrl(explorerUrl, chain) {
    ChainController.setAccountProp("addressExplorerUrl", explorerUrl, chain);
  },
  setSmartAccountDeployed(isDeployed, chain) {
    ChainController.setAccountProp("smartAccountDeployed", isDeployed, chain);
  },
  setCurrentTab(currentTab) {
    ChainController.setAccountProp("currentTab", currentTab, ChainController.state.activeChain);
  },
  setTokenBalance(tokenBalance, chain) {
    if (tokenBalance) {
      ChainController.setAccountProp("tokenBalance", tokenBalance, chain);
    }
  },
  setShouldUpdateToAddress(address, chain) {
    ChainController.setAccountProp("shouldUpdateToAddress", address, chain);
  },
  setAllAccounts(accounts, chain) {
    ChainController.setAccountProp("allAccounts", accounts, chain);
  },
  addAddressLabel(address, label, chain) {
    const map = ChainController.getAccountProp("addressLabels", chain) || /* @__PURE__ */ new Map();
    map.set(address, label);
    ChainController.setAccountProp("addressLabels", map, ChainController.state.activeChain);
  },
  removeAddressLabel(address, chain) {
    const map = ChainController.getAccountProp("addressLabels", chain) || /* @__PURE__ */ new Map();
    map.delete(address);
    ChainController.setAccountProp("addressLabels", map, ChainController.state.activeChain);
  },
  setConnectedWalletInfo(connectedWalletInfo, chain) {
    ChainController.setAccountProp("connectedWalletInfo", connectedWalletInfo, chain);
  },
  setPreferredAccountType(preferredAccountType, chain) {
    ChainController.setAccountProp("preferredAccountType", preferredAccountType, chain);
  },
  setSocialProvider(socialProvider, chain) {
    if (socialProvider) {
      ChainController.setAccountProp("socialProvider", socialProvider, chain);
    }
  },
  setSocialWindow(socialWindow, chain) {
    if (socialWindow) {
      ChainController.setAccountProp("socialWindow", ref(socialWindow), chain);
    }
  },
  setFarcasterUrl(farcasterUrl, chain) {
    if (farcasterUrl) {
      ChainController.setAccountProp("farcasterUrl", farcasterUrl, chain);
    }
  },
  async fetchTokenBalance() {
    const chainId = NetworkController.state.caipNetwork?.id;
    const chain = NetworkController.state.caipNetwork?.chain;
    const address = AccountController.state.address;
    try {
      if (address && chainId && chain) {
        const response = await BlockchainApiController.getBalance(address, chainId);
        const filteredBalances = response.balances.filter((balance) => balance.quantity.decimals !== "0");
        this.setTokenBalance(filteredBalances, chain);
        SwapController.setBalances(SwapApiUtil.mapBalancesToSwapTokens(response.balances));
      }
    } catch (error) {
      SnackController.showError("Failed to fetch token balance");
    }
  },
  resetAccount(chain) {
    ChainController.resetAccount(chain);
  }
};
const state$4 = proxy({
  loading: false,
  open: false,
  shake: false
});
const ModalController = {
  state: state$4,
  subscribe(callback) {
    return subscribe(state$4, () => callback(state$4));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$4, key2, callback);
  },
  async open(options) {
    await ApiController.state.prefetchPromise;
    const connected = AccountController.state.isConnected;
    if (options?.view) {
      RouterController.reset(options.view);
    } else if (connected) {
      RouterController.reset("Account");
    } else {
      RouterController.reset("Connect");
    }
    state$4.open = true;
    PublicStateController.set({ open: true });
    EventsController.sendEvent({
      type: "track",
      event: "MODAL_OPEN",
      properties: { connected }
    });
  },
  close() {
    const connected = AccountController.state.isConnected || false;
    state$4.open = false;
    PublicStateController.set({ open: false });
    EventsController.sendEvent({
      type: "track",
      event: "MODAL_CLOSE",
      properties: { connected }
    });
  },
  setLoading(loading) {
    state$4.loading = loading;
    PublicStateController.set({ loading });
  },
  shake() {
    if (state$4.shake) {
      return;
    }
    state$4.shake = true;
    setTimeout(() => {
      state$4.shake = false;
    }, 500);
  }
};
const USDC_CURRENCY_DEFAULT = {
  id: "2b92315d-eab7-5bef-84fa-089a131333f5",
  name: "USD Coin",
  symbol: "USDC",
  networks: [
    {
      name: "ethereum-mainnet",
      display_name: "Ethereum",
      chain_id: "1",
      contract_address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    },
    {
      name: "polygon-mainnet",
      display_name: "Polygon",
      chain_id: "137",
      contract_address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
    }
  ]
};
const USD_CURRENCY_DEFAULT = {
  id: "USD",
  payment_method_limits: [
    {
      id: "card",
      min: "10.00",
      max: "7500.00"
    },
    {
      id: "ach_bank_account",
      min: "10.00",
      max: "25000.00"
    }
  ]
};
const defaultState = {
  providers: ONRAMP_PROVIDERS,
  selectedProvider: null,
  error: null,
  purchaseCurrency: USDC_CURRENCY_DEFAULT,
  paymentCurrency: USD_CURRENCY_DEFAULT,
  purchaseCurrencies: [USDC_CURRENCY_DEFAULT],
  paymentCurrencies: [],
  quotesLoading: false
};
const state$3 = proxy(defaultState);
const OnRampController = {
  state: state$3,
  subscribe(callback) {
    return subscribe(state$3, () => callback(state$3));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$3, key2, callback);
  },
  setSelectedProvider(provider) {
    if (provider && provider.name === "meld") {
      const pubKey = MELD_PROD_PUBLIC_KEY;
      const currency = ChainController.state.activeChain === ConstantsUtil$2.CHAIN.SOLANA ? "SOL" : "USDC";
      const address = AccountController.state.address ?? "";
      const url = new URL(provider.url);
      url.searchParams.append("publicKey", pubKey);
      url.searchParams.append("destinationCurrencyCode", currency);
      url.searchParams.append("walletAddress", address);
      provider.url = url.toString();
    }
    state$3.selectedProvider = provider;
  },
  setPurchaseCurrency(currency) {
    state$3.purchaseCurrency = currency;
  },
  setPaymentCurrency(currency) {
    state$3.paymentCurrency = currency;
  },
  setPurchaseAmount(amount) {
    this.state.purchaseAmount = amount;
  },
  setPaymentAmount(amount) {
    this.state.paymentAmount = amount;
  },
  async getAvailableCurrencies() {
    const options = await BlockchainApiController.getOnrampOptions();
    state$3.purchaseCurrencies = options.purchaseCurrencies;
    state$3.paymentCurrencies = options.paymentCurrencies;
    state$3.paymentCurrency = options.paymentCurrencies[0] || USD_CURRENCY_DEFAULT;
    state$3.purchaseCurrency = options.purchaseCurrencies[0] || USDC_CURRENCY_DEFAULT;
    await ApiController.fetchCurrencyImages(options.paymentCurrencies.map((currency) => currency.id));
    await ApiController.fetchTokenImages(options.purchaseCurrencies.map((currency) => currency.symbol));
  },
  async getQuote() {
    state$3.quotesLoading = true;
    try {
      const quote = await BlockchainApiController.getOnrampQuote({
        purchaseCurrency: state$3.purchaseCurrency,
        paymentCurrency: state$3.paymentCurrency,
        amount: state$3.paymentAmount?.toString() || "0",
        network: state$3.purchaseCurrency?.symbol
      });
      state$3.quotesLoading = false;
      state$3.purchaseAmount = Number(quote.purchaseAmount.amount);
      return quote;
    } catch (error) {
      state$3.error = error.message;
      state$3.quotesLoading = false;
      return null;
    } finally {
      state$3.quotesLoading = false;
    }
  },
  resetState() {
    state$3.providers = ONRAMP_PROVIDERS;
    state$3.selectedProvider = null;
    state$3.error = null;
    state$3.purchaseCurrency = USDC_CURRENCY_DEFAULT;
    state$3.paymentCurrency = USD_CURRENCY_DEFAULT;
    state$3.purchaseCurrencies = [USDC_CURRENCY_DEFAULT];
    state$3.paymentCurrencies = [];
    state$3.paymentAmount = void 0;
    state$3.purchaseAmount = void 0;
    state$3.quotesLoading = false;
  }
};
const state$2 = proxy({
  loading: false
});
const SendController = {
  state: state$2,
  subscribe(callback) {
    return subscribe(state$2, () => callback(state$2));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$2, key2, callback);
  },
  setToken(token2) {
    if (token2) {
      state$2.token = ref(token2);
    }
  },
  setTokenAmount(sendTokenAmount) {
    state$2.sendTokenAmount = sendTokenAmount;
  },
  setReceiverAddress(receiverAddress) {
    state$2.receiverAddress = receiverAddress;
  },
  setReceiverProfileImageUrl(receiverProfileImageUrl) {
    state$2.receiverProfileImageUrl = receiverProfileImageUrl;
  },
  setReceiverProfileName(receiverProfileName) {
    state$2.receiverProfileName = receiverProfileName;
  },
  setGasPrice(gasPrice) {
    state$2.gasPrice = gasPrice;
  },
  setGasPriceInUsd(gasPriceInUSD) {
    state$2.gasPriceInUSD = gasPriceInUSD;
  },
  setLoading(loading) {
    state$2.loading = loading;
  },
  sendToken() {
    switch (ChainController.state.activeCaipNetwork?.chain) {
      case "evm":
        this.sendEvmToken();
        return;
      case "solana":
        this.sendSolanaToken();
        return;
      default:
        throw new Error("Unsupported chain");
    }
  },
  sendEvmToken() {
    if (this.state.token?.address && this.state.sendTokenAmount && this.state.receiverAddress) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: this.state.token.address,
          amount: this.state.sendTokenAmount,
          network: NetworkController.state.caipNetwork?.id || ""
        }
      });
      this.sendERC20Token({
        receiverAddress: this.state.receiverAddress,
        tokenAddress: this.state.token.address,
        sendTokenAmount: this.state.sendTokenAmount,
        decimals: this.state.token.quantity.decimals
      });
    } else if (this.state.receiverAddress && this.state.sendTokenAmount && this.state.gasPrice && this.state.token?.quantity.decimals) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: this.state.token?.symbol,
          amount: this.state.sendTokenAmount,
          network: NetworkController.state.caipNetwork?.id || ""
        }
      });
      this.sendNativeToken({
        receiverAddress: this.state.receiverAddress,
        sendTokenAmount: this.state.sendTokenAmount,
        gasPrice: this.state.gasPrice,
        decimals: this.state.token.quantity.decimals
      });
    }
  },
  async sendNativeToken(params) {
    RouterController.pushTransactionStack({
      view: "Account",
      goBack: false
    });
    const to = params.receiverAddress;
    const address = AccountController.state.address;
    const value = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
    const data2 = "0x";
    try {
      await ConnectionController.sendTransaction({
        to,
        address,
        data: data2,
        value,
        gasPrice: params.gasPrice
      });
      SnackController.showSuccess("Transaction started");
      EventsController.sendEvent({
        type: "track",
        event: "SEND_SUCCESS",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: this.state.token?.symbol || "",
          amount: params.sendTokenAmount,
          network: NetworkController.state.caipNetwork?.id || ""
        }
      });
      this.resetSend();
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "SEND_ERROR",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          token: this.state.token?.symbol || "",
          amount: params.sendTokenAmount,
          network: NetworkController.state.caipNetwork?.id || ""
        }
      });
      SnackController.showError("Something went wrong");
    }
  },
  async sendERC20Token(params) {
    RouterController.pushTransactionStack({
      view: "Account",
      goBack: false
    });
    const amount = ConnectionController.parseUnits(params.sendTokenAmount.toString(), Number(params.decimals));
    try {
      if (AccountController.state.address && params.sendTokenAmount && params.receiverAddress && params.tokenAddress) {
        await ConnectionController.writeContract({
          fromAddress: AccountController.state.address,
          tokenAddress: CoreHelperUtil.getPlainAddress(params.tokenAddress),
          receiverAddress: params.receiverAddress,
          tokenAmount: amount,
          method: "transfer",
          abi: erc20ABI
        });
        SnackController.showSuccess("Transaction started");
        this.resetSend();
      }
    } catch (error) {
      SnackController.showError("Something went wrong");
    }
  },
  sendSolanaToken() {
    if (!this.state.sendTokenAmount || !this.state.receiverAddress) {
      SnackController.showError("Please enter a valid amount and receiver address");
      return;
    }
    RouterController.pushTransactionStack({
      view: "Account",
      goBack: false
    });
    ConnectionController.sendTransaction({
      chainNamespace: "solana",
      to: this.state.receiverAddress,
      value: this.state.sendTokenAmount
    }).then(() => {
      this.resetSend();
      AccountController.fetchTokenBalance();
    }).catch((error) => {
      SnackController.showError("Failed to send transaction. Please try again.");
      console.error("SendController:sendToken - failed to send solana transaction", error);
    });
  },
  resetSend() {
    state$2.token = void 0;
    state$2.sendTokenAmount = void 0;
    state$2.receiverAddress = void 0;
    state$2.receiverProfileImageUrl = void 0;
    state$2.receiverProfileName = void 0;
    state$2.loading = false;
  }
};
const state$1 = proxy({
  message: "",
  open: false,
  triggerRect: {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  },
  variant: "shade"
});
const TooltipController = {
  state: state$1,
  subscribe(callback) {
    return subscribe(state$1, () => callback(state$1));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state$1, key2, callback);
  },
  showTooltip({ message, triggerRect, variant }) {
    state$1.open = true;
    state$1.message = message;
    state$1.triggerRect = triggerRect;
    state$1.variant = variant;
  },
  hide() {
    state$1.open = false;
    state$1.message = "";
    state$1.triggerRect = {
      width: 0,
      height: 0,
      top: 0,
      left: 0
    };
  }
};
const SLIP44_MSB = 2147483648;
const EnsUtil = {
  convertEVMChainIdToCoinType(chainId) {
    if (chainId >= SLIP44_MSB) {
      throw new Error("Invalid chainId");
    }
    return (SLIP44_MSB | chainId) >>> 0;
  }
};
const state = proxy({
  suggestions: [],
  loading: false
});
const EnsController = {
  state,
  subscribe(callback) {
    return subscribe(state, () => callback(state));
  },
  subscribeKey(key2, callback) {
    return subscribeKey(state, key2, callback);
  },
  async resolveName(name) {
    try {
      return await BlockchainApiController.lookupEnsName(name);
    } catch (e2) {
      const error = e2;
      throw new Error(error?.reasons?.[0]?.description || "Error resolving name");
    }
  },
  async isNameRegistered(name) {
    try {
      await BlockchainApiController.lookupEnsName(name);
      return true;
    } catch {
      return false;
    }
  },
  async getSuggestions(name) {
    try {
      state.loading = true;
      state.suggestions = [];
      const response = await BlockchainApiController.getEnsNameSuggestions(name);
      state.suggestions = response.suggestions.map((suggestion) => ({
        ...suggestion,
        name: suggestion.name.replace(ConstantsUtil$2.WC_NAME_SUFFIX, "")
      })) || [];
      return state.suggestions;
    } catch (e2) {
      const errorMessage = this.parseEnsApiError(e2, "Error fetching name suggestions");
      throw new Error(errorMessage);
    } finally {
      state.loading = false;
    }
  },
  async getNamesForAddress(address) {
    try {
      const network = NetworkController.state.caipNetwork;
      if (!network) {
        return [];
      }
      const response = await BlockchainApiController.reverseLookupEnsName({ address });
      return response;
    } catch (e2) {
      const errorMessage = this.parseEnsApiError(e2, "Error fetching names for address");
      throw new Error(errorMessage);
    }
  },
  async registerName(name) {
    const network = NetworkController.state.caipNetwork;
    if (!network) {
      throw new Error("Network not found");
    }
    const address = AccountController.state.address;
    const emailConnector = ConnectorController.getAuthConnector();
    if (!address || !emailConnector) {
      throw new Error("Address or auth connector not found");
    }
    state.loading = true;
    try {
      const message = JSON.stringify({
        name: `${name}${ConstantsUtil$2.WC_NAME_SUFFIX}`,
        attributes: {},
        timestamp: Math.floor(Date.now() / 1e3)
      });
      RouterController.pushTransactionStack({
        view: "RegisterAccountNameSuccess",
        goBack: false,
        replace: true,
        onCancel() {
          state.loading = false;
        }
      });
      const signature2 = await ConnectionController.signMessage(message);
      const networkId = NetworkUtil$1.caipNetworkIdToNumber(network.id);
      if (!networkId) {
        throw new Error("Network not found");
      }
      const coinType = EnsUtil.convertEVMChainIdToCoinType(networkId);
      await BlockchainApiController.registerEnsName({
        coinType,
        address,
        signature: signature2,
        message
      });
      AccountController.setProfileName(`${name}${ConstantsUtil$2.WC_NAME_SUFFIX}`, ChainController.state.activeChain);
      RouterController.replace("RegisterAccountNameSuccess");
    } catch (e2) {
      const errorMessage = this.parseEnsApiError(e2, `Error registering name ${name}`);
      RouterController.replace("RegisterAccountName");
      throw new Error(errorMessage);
    } finally {
      state.loading = false;
    }
  },
  validateName(name) {
    return /^[a-zA-Z0-9-]{4,}$/u.test(name);
  },
  parseEnsApiError(error, defaultError) {
    const ensError = error;
    return ensError?.reasons?.[0]?.description || defaultError;
  }
};
const namespaceImageIds = {
  // Ethereum
  evm: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
  // Solana
  solana: "a1b58899-f671-4276-6a5e-56ca5bd59700"
};
const AssetUtil = {
  async fetchWalletImage(imageId) {
    if (!imageId) {
      return void 0;
    }
    await ApiController._fetchWalletImage(imageId);
    return this.getWalletImageById(imageId);
  },
  getWalletImageById(imageId) {
    if (!imageId) {
      return void 0;
    }
    return AssetController.state.walletImages[imageId];
  },
  getWalletImage(wallet) {
    if (wallet?.image_url) {
      return wallet?.image_url;
    }
    if (wallet?.image_id) {
      return AssetController.state.walletImages[wallet.image_id];
    }
    return void 0;
  },
  getNetworkImage(network) {
    if (network?.imageUrl) {
      return network?.imageUrl;
    }
    if (network?.imageId) {
      return AssetController.state.networkImages[network.imageId];
    }
    return void 0;
  },
  getNetworkImageById(imageId) {
    if (!imageId) {
      return void 0;
    }
    return AssetController.state.networkImages[imageId];
  },
  getConnectorImage(connector) {
    if (connector?.imageUrl) {
      return connector.imageUrl;
    }
    if (connector?.imageId) {
      return AssetController.state.connectorImages[connector.imageId];
    }
    return void 0;
  },
  getChainImage(chain) {
    return AssetController.state.networkImages[namespaceImageIds[chain]];
  }
};
const RouterUtil = {
  goBackOrCloseModal() {
    if (RouterController.state.history.length > 1) {
      RouterController.goBack();
    } else {
      ModalController.close();
    }
  },
  navigateAfterNetworkSwitch() {
    const { history } = RouterController.state;
    const networkSelectIndex = history.findIndex((name) => name === "Networks");
    if (networkSelectIndex >= 1) {
      RouterController.goBackToIndex(networkSelectIndex - 1);
    } else {
      ModalController.close();
    }
  },
  navigateAfterPreferredAccountTypeSelect() {
    const { isSiweEnabled } = OptionsController.state;
    if (isSiweEnabled && ChainController.state.activeChain === ConstantsUtil$2.CHAIN.EVM) {
      RouterController.push("ConnectingSiwe");
    } else {
      RouterController.push("Account");
    }
  }
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2 = globalThis, e$5 = t$2.ShadowRoot && (void 0 === t$2.ShadyCSS || t$2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$3 = Symbol(), o$8 = /* @__PURE__ */ new WeakMap();
let n$5 = class n {
  constructor(t2, e2, o2) {
    if (this._$cssResult$ = true, o2 !== s$3) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t2, this.t = e2;
  }
  get styleSheet() {
    let t2 = this.o;
    const s2 = this.t;
    if (e$5 && void 0 === t2) {
      const e2 = void 0 !== s2 && 1 === s2.length;
      e2 && (t2 = o$8.get(s2)), void 0 === t2 && ((this.o = t2 = new CSSStyleSheet()).replaceSync(this.cssText), e2 && o$8.set(s2, t2));
    }
    return t2;
  }
  toString() {
    return this.cssText;
  }
};
const r$5 = (t2) => new n$5("string" == typeof t2 ? t2 : t2 + "", void 0, s$3), i$5 = (t2, ...e2) => {
  const o2 = 1 === t2.length ? t2[0] : e2.reduce(((e3, s2, o3) => e3 + ((t3) => {
    if (true === t3._$cssResult$) return t3.cssText;
    if ("number" == typeof t3) return t3;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t3 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s2) + t2[o3 + 1]), t2[0]);
  return new n$5(o2, t2, s$3);
}, S$1 = (s2, o2) => {
  if (e$5) s2.adoptedStyleSheets = o2.map(((t2) => t2 instanceof CSSStyleSheet ? t2 : t2.styleSheet));
  else for (const e2 of o2) {
    const o3 = document.createElement("style"), n22 = t$2.litNonce;
    void 0 !== n22 && o3.setAttribute("nonce", n22), o3.textContent = e2.cssText, s2.appendChild(o3);
  }
}, c$3 = e$5 ? (t2) => t2 : (t2) => t2 instanceof CSSStyleSheet ? ((t3) => {
  let e2 = "";
  for (const s2 of t3.cssRules) e2 += s2.cssText;
  return r$5(e2);
})(t2) : t2;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: i$4, defineProperty: e$4, getOwnPropertyDescriptor: h$3, getOwnPropertyNames: r$4, getOwnPropertySymbols: o$7, getPrototypeOf: n$4 } = Object, a$1 = globalThis, c$2 = a$1.trustedTypes, l$1 = c$2 ? c$2.emptyScript : "", p$1 = a$1.reactiveElementPolyfillSupport, d$1 = (t2, s2) => t2, u$1 = { toAttribute(t2, s2) {
  switch (s2) {
    case Boolean:
      t2 = t2 ? l$1 : null;
      break;
    case Object:
    case Array:
      t2 = null == t2 ? t2 : JSON.stringify(t2);
  }
  return t2;
}, fromAttribute(t2, s2) {
  let i22 = t2;
  switch (s2) {
    case Boolean:
      i22 = null !== t2;
      break;
    case Number:
      i22 = null === t2 ? null : Number(t2);
      break;
    case Object:
    case Array:
      try {
        i22 = JSON.parse(t2);
      } catch (t3) {
        i22 = null;
      }
  }
  return i22;
} }, f$3 = (t2, s2) => !i$4(t2, s2), b$1 = { attribute: true, type: String, converter: u$1, reflect: false, useDefault: false, hasChanged: f$3 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a$1.litPropertyMetadata ?? (a$1.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let y$2 = class y extends HTMLElement {
  static addInitializer(t2) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t2);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t2, s2 = b$1) {
    if (s2.state && (s2.attribute = false), this._$Ei(), this.prototype.hasOwnProperty(t2) && ((s2 = Object.create(s2)).wrapped = true), this.elementProperties.set(t2, s2), !s2.noAccessor) {
      const i22 = Symbol(), h2 = this.getPropertyDescriptor(t2, i22, s2);
      void 0 !== h2 && e$4(this.prototype, t2, h2);
    }
  }
  static getPropertyDescriptor(t2, s2, i22) {
    const { get: e2, set: r2 } = h$3(this.prototype, t2) ?? { get() {
      return this[s2];
    }, set(t3) {
      this[s2] = t3;
    } };
    return { get: e2, set(s3) {
      const h2 = e2?.call(this);
      r2?.call(this, s3), this.requestUpdate(t2, h2, i22);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t2) {
    return this.elementProperties.get(t2) ?? b$1;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$1("elementProperties"))) return;
    const t2 = n$4(this);
    t2.finalize(), void 0 !== t2.l && (this.l = [...t2.l]), this.elementProperties = new Map(t2.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$1("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d$1("properties"))) {
      const t3 = this.properties, s2 = [...r$4(t3), ...o$7(t3)];
      for (const i22 of s2) this.createProperty(i22, t3[i22]);
    }
    const t2 = this[Symbol.metadata];
    if (null !== t2) {
      const s2 = litPropertyMetadata.get(t2);
      if (void 0 !== s2) for (const [t3, i22] of s2) this.elementProperties.set(t3, i22);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t3, s2] of this.elementProperties) {
      const i22 = this._$Eu(t3, s2);
      void 0 !== i22 && this._$Eh.set(i22, t3);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s2) {
    const i22 = [];
    if (Array.isArray(s2)) {
      const e2 = new Set(s2.flat(1 / 0).reverse());
      for (const s3 of e2) i22.unshift(c$3(s3));
    } else void 0 !== s2 && i22.push(c$3(s2));
    return i22;
  }
  static _$Eu(t2, s2) {
    const i22 = s2.attribute;
    return false === i22 ? void 0 : "string" == typeof i22 ? i22 : "string" == typeof t2 ? t2.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise(((t2) => this.enableUpdating = t2)), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach(((t2) => t2(this)));
  }
  addController(t2) {
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t2), void 0 !== this.renderRoot && this.isConnected && t2.hostConnected?.();
  }
  removeController(t2) {
    this._$EO?.delete(t2);
  }
  _$E_() {
    const t2 = /* @__PURE__ */ new Map(), s2 = this.constructor.elementProperties;
    for (const i22 of s2.keys()) this.hasOwnProperty(i22) && (t2.set(i22, this[i22]), delete this[i22]);
    t2.size > 0 && (this._$Ep = t2);
  }
  createRenderRoot() {
    const t2 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$1(t2, this.constructor.elementStyles), t2;
  }
  connectedCallback() {
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), this._$EO?.forEach(((t2) => t2.hostConnected?.()));
  }
  enableUpdating(t2) {
  }
  disconnectedCallback() {
    this._$EO?.forEach(((t2) => t2.hostDisconnected?.()));
  }
  attributeChangedCallback(t2, s2, i22) {
    this._$AK(t2, i22);
  }
  _$ET(t2, s2) {
    const i22 = this.constructor.elementProperties.get(t2), e2 = this.constructor._$Eu(t2, i22);
    if (void 0 !== e2 && true === i22.reflect) {
      const h2 = (void 0 !== i22.converter?.toAttribute ? i22.converter : u$1).toAttribute(s2, i22.type);
      this._$Em = t2, null == h2 ? this.removeAttribute(e2) : this.setAttribute(e2, h2), this._$Em = null;
    }
  }
  _$AK(t2, s2) {
    const i22 = this.constructor, e2 = i22._$Eh.get(t2);
    if (void 0 !== e2 && this._$Em !== e2) {
      const t3 = i22.getPropertyOptions(e2), h2 = "function" == typeof t3.converter ? { fromAttribute: t3.converter } : void 0 !== t3.converter?.fromAttribute ? t3.converter : u$1;
      this._$Em = e2;
      const r2 = h2.fromAttribute(s2, t3.type);
      this[e2] = r2 ?? this._$Ej?.get(e2) ?? r2, this._$Em = null;
    }
  }
  requestUpdate(t2, s2, i22) {
    if (void 0 !== t2) {
      const e2 = this.constructor, h2 = this[t2];
      if (i22 ?? (i22 = e2.getPropertyOptions(t2)), !((i22.hasChanged ?? f$3)(h2, s2) || i22.useDefault && i22.reflect && h2 === this._$Ej?.get(t2) && !this.hasAttribute(e2._$Eu(t2, i22)))) return;
      this.C(t2, s2, i22);
    }
    false === this.isUpdatePending && (this._$ES = this._$EP());
  }
  C(t2, s2, { useDefault: i22, reflect: e2, wrapped: h2 }, r2) {
    i22 && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(t2) && (this._$Ej.set(t2, r2 ?? s2 ?? this[t2]), true !== h2 || void 0 !== r2) || (this._$AL.has(t2) || (this.hasUpdated || i22 || (s2 = void 0), this._$AL.set(t2, s2)), true === e2 && this._$Em !== t2 && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(t2));
  }
  async _$EP() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t3) {
      Promise.reject(t3);
    }
    const t2 = this.scheduleUpdate();
    return null != t2 && await t2, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [t4, s3] of this._$Ep) this[t4] = s3;
        this._$Ep = void 0;
      }
      const t3 = this.constructor.elementProperties;
      if (t3.size > 0) for (const [s3, i22] of t3) {
        const { wrapped: t4 } = i22, e2 = this[s3];
        true !== t4 || this._$AL.has(s3) || void 0 === e2 || this.C(s3, void 0, i22, e2);
      }
    }
    let t2 = false;
    const s2 = this._$AL;
    try {
      t2 = this.shouldUpdate(s2), t2 ? (this.willUpdate(s2), this._$EO?.forEach(((t3) => t3.hostUpdate?.())), this.update(s2)) : this._$EM();
    } catch (s3) {
      throw t2 = false, this._$EM(), s3;
    }
    t2 && this._$AE(s2);
  }
  willUpdate(t2) {
  }
  _$AE(t2) {
    this._$EO?.forEach(((t3) => t3.hostUpdated?.())), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t2)), this.updated(t2);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    this._$Eq && (this._$Eq = this._$Eq.forEach(((t3) => this._$ET(t3, this[t3])))), this._$EM();
  }
  updated(t2) {
  }
  firstUpdated(t2) {
  }
};
y$2.elementStyles = [], y$2.shadowRootOptions = { mode: "open" }, y$2[d$1("elementProperties")] = /* @__PURE__ */ new Map(), y$2[d$1("finalized")] = /* @__PURE__ */ new Map(), p$1?.({ ReactiveElement: y$2 }), (a$1.reactiveElementVersions ?? (a$1.reactiveElementVersions = [])).push("2.1.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1 = globalThis, i$3 = t$1.trustedTypes, s$2 = i$3 ? i$3.createPolicy("lit-html", { createHTML: (t2) => t2 }) : void 0, e$3 = "$lit$", h$2 = `lit$${Math.random().toFixed(9).slice(2)}$`, o$6 = "?" + h$2, n$3 = `<${o$6}>`, r$3 = document, l = () => r$3.createComment(""), c$1 = (t2) => null === t2 || "object" != typeof t2 && "function" != typeof t2, a = Array.isArray, u = (t2) => a(t2) || "function" == typeof t2?.[Symbol.iterator], d2 = "[ 	\n\f\r]", f$2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v = /-->/g, _ = />/g, m2 = RegExp(`>|${d2}(?:([^\\s"'>=/]+)(${d2}*=${d2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), p = /'/g, g = /"/g, $ = /^(?:script|style|textarea|title)$/i, y$1 = (t2) => (i22, ...s2) => ({ _$litType$: t2, strings: i22, values: s2 }), x = y$1(1), b = y$1(2), T = Symbol.for("lit-noChange"), E = Symbol.for("lit-nothing"), A = /* @__PURE__ */ new WeakMap(), C = r$3.createTreeWalker(r$3, 129);
function P(t2, i22) {
  if (!a(t2) || !t2.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== s$2 ? s$2.createHTML(i22) : i22;
}
const V$1 = (t2, i22) => {
  const s2 = t2.length - 1, o2 = [];
  let r2, l2 = 2 === i22 ? "<svg>" : 3 === i22 ? "<math>" : "", c2 = f$2;
  for (let i32 = 0; i32 < s2; i32++) {
    const s3 = t2[i32];
    let a2, u2, d22 = -1, y22 = 0;
    for (; y22 < s3.length && (c2.lastIndex = y22, u2 = c2.exec(s3), null !== u2); ) y22 = c2.lastIndex, c2 === f$2 ? "!--" === u2[1] ? c2 = v : void 0 !== u2[1] ? c2 = _ : void 0 !== u2[2] ? ($.test(u2[2]) && (r2 = RegExp("</" + u2[2], "g")), c2 = m2) : void 0 !== u2[3] && (c2 = m2) : c2 === m2 ? ">" === u2[0] ? (c2 = r2 ?? f$2, d22 = -1) : void 0 === u2[1] ? d22 = -2 : (d22 = c2.lastIndex - u2[2].length, a2 = u2[1], c2 = void 0 === u2[3] ? m2 : '"' === u2[3] ? g : p) : c2 === g || c2 === p ? c2 = m2 : c2 === v || c2 === _ ? c2 = f$2 : (c2 = m2, r2 = void 0);
    const x2 = c2 === m2 && t2[i32 + 1].startsWith("/>") ? " " : "";
    l2 += c2 === f$2 ? s3 + n$3 : d22 >= 0 ? (o2.push(a2), s3.slice(0, d22) + e$3 + s3.slice(d22) + h$2 + x2) : s3 + h$2 + (-2 === d22 ? i32 : x2);
  }
  return [P(t2, l2 + (t2[s2] || "<?>") + (2 === i22 ? "</svg>" : 3 === i22 ? "</math>" : "")), o2];
};
class N {
  constructor({ strings: t2, _$litType$: s2 }, n22) {
    let r2;
    this.parts = [];
    let c2 = 0, a2 = 0;
    const u2 = t2.length - 1, d22 = this.parts, [f2, v2] = V$1(t2, s2);
    if (this.el = N.createElement(f2, n22), C.currentNode = this.el.content, 2 === s2 || 3 === s2) {
      const t3 = this.el.content.firstChild;
      t3.replaceWith(...t3.childNodes);
    }
    for (; null !== (r2 = C.nextNode()) && d22.length < u2; ) {
      if (1 === r2.nodeType) {
        if (r2.hasAttributes()) for (const t3 of r2.getAttributeNames()) if (t3.endsWith(e$3)) {
          const i22 = v2[a2++], s3 = r2.getAttribute(t3).split(h$2), e2 = /([.?@])?(.*)/.exec(i22);
          d22.push({ type: 1, index: c2, name: e2[2], strings: s3, ctor: "." === e2[1] ? H : "?" === e2[1] ? I : "@" === e2[1] ? L2 : k }), r2.removeAttribute(t3);
        } else t3.startsWith(h$2) && (d22.push({ type: 6, index: c2 }), r2.removeAttribute(t3));
        if ($.test(r2.tagName)) {
          const t3 = r2.textContent.split(h$2), s3 = t3.length - 1;
          if (s3 > 0) {
            r2.textContent = i$3 ? i$3.emptyScript : "";
            for (let i22 = 0; i22 < s3; i22++) r2.append(t3[i22], l()), C.nextNode(), d22.push({ type: 2, index: ++c2 });
            r2.append(t3[s3], l());
          }
        }
      } else if (8 === r2.nodeType) if (r2.data === o$6) d22.push({ type: 2, index: c2 });
      else {
        let t3 = -1;
        for (; -1 !== (t3 = r2.data.indexOf(h$2, t3 + 1)); ) d22.push({ type: 7, index: c2 }), t3 += h$2.length - 1;
      }
      c2++;
    }
  }
  static createElement(t2, i22) {
    const s2 = r$3.createElement("template");
    return s2.innerHTML = t2, s2;
  }
}
function S(t2, i22, s2 = t2, e2) {
  if (i22 === T) return i22;
  let h2 = void 0 !== e2 ? s2._$Co?.[e2] : s2._$Cl;
  const o2 = c$1(i22) ? void 0 : i22._$litDirective$;
  return h2?.constructor !== o2 && (h2?._$AO?.(false), void 0 === o2 ? h2 = void 0 : (h2 = new o2(t2), h2._$AT(t2, s2, e2)), void 0 !== e2 ? (s2._$Co ?? (s2._$Co = []))[e2] = h2 : s2._$Cl = h2), void 0 !== h2 && (i22 = S(t2, h2._$AS(t2, i22.values), h2, e2)), i22;
}
class M {
  constructor(t2, i22) {
    this._$AV = [], this._$AN = void 0, this._$AD = t2, this._$AM = i22;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t2) {
    const { el: { content: i22 }, parts: s2 } = this._$AD, e2 = (t2?.creationScope ?? r$3).importNode(i22, true);
    C.currentNode = e2;
    let h2 = C.nextNode(), o2 = 0, n22 = 0, l2 = s2[0];
    for (; void 0 !== l2; ) {
      if (o2 === l2.index) {
        let i32;
        2 === l2.type ? i32 = new R(h2, h2.nextSibling, this, t2) : 1 === l2.type ? i32 = new l2.ctor(h2, l2.name, l2.strings, this, t2) : 6 === l2.type && (i32 = new z$1(h2, this, t2)), this._$AV.push(i32), l2 = s2[++n22];
      }
      o2 !== l2?.index && (h2 = C.nextNode(), o2++);
    }
    return C.currentNode = r$3, e2;
  }
  p(t2) {
    let i22 = 0;
    for (const s2 of this._$AV) void 0 !== s2 && (void 0 !== s2.strings ? (s2._$AI(t2, s2, i22), i22 += s2.strings.length - 2) : s2._$AI(t2[i22])), i22++;
  }
}
class R {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t2, i22, s2, e2) {
    this.type = 2, this._$AH = E, this._$AN = void 0, this._$AA = t2, this._$AB = i22, this._$AM = s2, this.options = e2, this._$Cv = e2?.isConnected ?? true;
  }
  get parentNode() {
    let t2 = this._$AA.parentNode;
    const i22 = this._$AM;
    return void 0 !== i22 && 11 === t2?.nodeType && (t2 = i22.parentNode), t2;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t2, i22 = this) {
    t2 = S(this, t2, i22), c$1(t2) ? t2 === E || null == t2 || "" === t2 ? (this._$AH !== E && this._$AR(), this._$AH = E) : t2 !== this._$AH && t2 !== T && this._(t2) : void 0 !== t2._$litType$ ? this.$(t2) : void 0 !== t2.nodeType ? this.T(t2) : u(t2) ? this.k(t2) : this._(t2);
  }
  O(t2) {
    return this._$AA.parentNode.insertBefore(t2, this._$AB);
  }
  T(t2) {
    this._$AH !== t2 && (this._$AR(), this._$AH = this.O(t2));
  }
  _(t2) {
    this._$AH !== E && c$1(this._$AH) ? this._$AA.nextSibling.data = t2 : this.T(r$3.createTextNode(t2)), this._$AH = t2;
  }
  $(t2) {
    const { values: i22, _$litType$: s2 } = t2, e2 = "number" == typeof s2 ? this._$AC(t2) : (void 0 === s2.el && (s2.el = N.createElement(P(s2.h, s2.h[0]), this.options)), s2);
    if (this._$AH?._$AD === e2) this._$AH.p(i22);
    else {
      const t3 = new M(e2, this), s3 = t3.u(this.options);
      t3.p(i22), this.T(s3), this._$AH = t3;
    }
  }
  _$AC(t2) {
    let i22 = A.get(t2.strings);
    return void 0 === i22 && A.set(t2.strings, i22 = new N(t2)), i22;
  }
  k(t2) {
    a(this._$AH) || (this._$AH = [], this._$AR());
    const i22 = this._$AH;
    let s2, e2 = 0;
    for (const h2 of t2) e2 === i22.length ? i22.push(s2 = new R(this.O(l()), this.O(l()), this, this.options)) : s2 = i22[e2], s2._$AI(h2), e2++;
    e2 < i22.length && (this._$AR(s2 && s2._$AB.nextSibling, e2), i22.length = e2);
  }
  _$AR(t2 = this._$AA.nextSibling, i22) {
    for (this._$AP?.(false, true, i22); t2 !== this._$AB; ) {
      const i32 = t2.nextSibling;
      t2.remove(), t2 = i32;
    }
  }
  setConnected(t2) {
    void 0 === this._$AM && (this._$Cv = t2, this._$AP?.(t2));
  }
}
class k {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t2, i22, s2, e2, h2) {
    this.type = 1, this._$AH = E, this._$AN = void 0, this.element = t2, this.name = i22, this._$AM = e2, this.options = h2, s2.length > 2 || "" !== s2[0] || "" !== s2[1] ? (this._$AH = Array(s2.length - 1).fill(new String()), this.strings = s2) : this._$AH = E;
  }
  _$AI(t2, i22 = this, s2, e2) {
    const h2 = this.strings;
    let o2 = false;
    if (void 0 === h2) t2 = S(this, t2, i22, 0), o2 = !c$1(t2) || t2 !== this._$AH && t2 !== T, o2 && (this._$AH = t2);
    else {
      const e3 = t2;
      let n22, r2;
      for (t2 = h2[0], n22 = 0; n22 < h2.length - 1; n22++) r2 = S(this, e3[s2 + n22], i22, n22), r2 === T && (r2 = this._$AH[n22]), o2 || (o2 = !c$1(r2) || r2 !== this._$AH[n22]), r2 === E ? t2 = E : t2 !== E && (t2 += (r2 ?? "") + h2[n22 + 1]), this._$AH[n22] = r2;
    }
    o2 && !e2 && this.j(t2);
  }
  j(t2) {
    t2 === E ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t2 ?? "");
  }
}
class H extends k {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t2) {
    this.element[this.name] = t2 === E ? void 0 : t2;
  }
}
class I extends k {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t2) {
    this.element.toggleAttribute(this.name, !!t2 && t2 !== E);
  }
}
class L2 extends k {
  constructor(t2, i22, s2, e2, h2) {
    super(t2, i22, s2, e2, h2), this.type = 5;
  }
  _$AI(t2, i22 = this) {
    if ((t2 = S(this, t2, i22, 0) ?? E) === T) return;
    const s2 = this._$AH, e2 = t2 === E && s2 !== E || t2.capture !== s2.capture || t2.once !== s2.once || t2.passive !== s2.passive, h2 = t2 !== E && (s2 === E || e2);
    e2 && this.element.removeEventListener(this.name, this, s2), h2 && this.element.addEventListener(this.name, this, t2), this._$AH = t2;
  }
  handleEvent(t2) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t2) : this._$AH.handleEvent(t2);
  }
}
let z$1 = class z {
  constructor(t2, i22, s2) {
    this.element = t2, this.type = 6, this._$AN = void 0, this._$AM = i22, this.options = s2;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2) {
    S(this, t2);
  }
};
const j$1 = t$1.litHtmlPolyfillSupport;
j$1?.(N, R), (t$1.litHtmlVersions ?? (t$1.litHtmlVersions = [])).push("3.3.1");
const B2 = (t2, i22, s2) => {
  const e2 = s2?.renderBefore ?? i22;
  let h2 = e2._$litPart$;
  if (void 0 === h2) {
    const t3 = s2?.renderBefore ?? null;
    e2._$litPart$ = h2 = new R(i22.insertBefore(l(), t3), t3, void 0, s2 ?? {});
  }
  return h2._$AI(t2), h2;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s$1 = globalThis;
let i$2 = class i extends y$2 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var _a3;
    const t2 = super.createRenderRoot();
    return (_a3 = this.renderOptions).renderBefore ?? (_a3.renderBefore = t2.firstChild), t2;
  }
  update(t2) {
    const r2 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this._$Do = B2(r2, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(false);
  }
  render() {
    return T;
  }
};
i$2._$litElement$ = true, i$2["finalized"] = true, s$1.litElementHydrateSupport?.({ LitElement: i$2 });
const o$5 = s$1.litElementPolyfillSupport;
o$5?.({ LitElement: i$2 });
(s$1.litElementVersions ?? (s$1.litElementVersions = [])).push("4.2.1");
const swapInputMaskBottomSvg = b`<svg class="input_mask" width="328" height="100" viewBox="0 0 328 100" fill="none">
  <mask id="path-1-inside-1_18299_4189">
    <path
      class="input_mask__border"
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M138.008 0H40C21.1438 0 11.7157 0 5.85786 5.85786C0 11.7157 0 21.1438 0 40V60C0 78.8562 0 88.2843 5.85786 94.1421C11.7157 100 21.1438 100 40 100H288C306.856 100 316.284 100 322.142 94.1421C328 88.2843 328 78.8562 328 60V40C328 21.1438 328 11.7157 322.142 5.85786C316.284 0 306.856 0 288 0H189.992C189.958 4.89122 189.786 7.76279 188.914 10.1564C187.095 15.1562 183.156 19.0947 178.156 20.9145C175.174 22 171.449 22 164 22C156.551 22 152.826 22 149.844 20.9145C144.844 19.0947 140.905 15.1562 139.086 10.1564C138.214 7.76279 138.042 4.89122 138.008 0Z"
    />
  </mask>
  <path
    class="input_mask__background"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M138.008 0H40C21.1438 0 11.7157 0 5.85786 5.85786C0 11.7157 0 21.1438 0 40V60C0 78.8562 0 88.2843 5.85786 94.1421C11.7157 100 21.1438 100 40 100H288C306.856 100 316.284 100 322.142 94.1421C328 88.2843 328 78.8562 328 60V40C328 21.1438 328 11.7157 322.142 5.85786C316.284 0 306.856 0 288 0H189.992C189.958 4.89122 189.786 7.76279 188.914 10.1564C187.095 15.1562 183.156 19.0947 178.156 20.9145C175.174 22 171.449 22 164 22C156.551 22 152.826 22 149.844 20.9145C144.844 19.0947 140.905 15.1562 139.086 10.1564C138.214 7.76279 138.042 4.89122 138.008 0Z"
  />
  <path
    class="input_mask__border"
    d="M138.008 0L139.008 -0.00694413L139.001 -1H138.008V0ZM322.142 94.1421L322.849 94.8492H322.849L322.142 94.1421ZM322.142 5.85786L322.849 5.15076L322.849 5.15076L322.142 5.85786ZM189.992 0V-1H188.999L188.992 -0.00694413L189.992 0ZM188.914 10.1564L189.854 10.4984V10.4984L188.914 10.1564ZM178.156 20.9145L177.814 19.9748V19.9748L178.156 20.9145ZM149.844 20.9145L150.186 19.9748V19.9748L149.844 20.9145ZM139.086 10.1564L138.146 10.4984V10.4984L139.086 10.1564ZM40 1H138.008V-1H40V1ZM6.56497 6.56497C9.27713 3.85281 12.8524 2.44064 18.1878 1.72332C23.552 1.00212 30.5436 1 40 1V-1C30.6002 -1 23.4497 -1.00212 17.9213 -0.25885C12.3641 0.488292 8.29646 2.00506 5.15076 5.15076L6.56497 6.56497ZM1 40C1 30.5436 1.00212 23.552 1.72332 18.1878C2.44064 12.8524 3.85281 9.27713 6.56497 6.56497L5.15076 5.15076C2.00506 8.29646 0.488292 12.3641 -0.25885 17.9213C-1.00212 23.4497 -1 30.6002 -1 40H1ZM1 60V40H-1V60H1ZM6.56497 93.435C3.85281 90.7229 2.44064 87.1476 1.72332 81.8122C1.00212 76.448 1 69.4564 1 60H-1C-1 69.3998 -1.00212 76.5503 -0.25885 82.0787C0.488292 87.6358 2.00506 91.7035 5.15076 94.8492L6.56497 93.435ZM40 99C30.5436 99 23.552 98.9979 18.1878 98.2767C12.8524 97.5594 9.27713 96.1472 6.56497 93.435L5.15076 94.8492C8.29646 97.9949 12.3641 99.5117 17.9213 100.259C23.4497 101.002 30.6002 101 40 101V99ZM288 99H40V101H288V99ZM321.435 93.435C318.723 96.1472 315.148 97.5594 309.812 98.2767C304.448 98.9979 297.456 99 288 99V101C297.4 101 304.55 101.002 310.079 100.259C315.636 99.5117 319.704 97.9949 322.849 94.8492L321.435 93.435ZM327 60C327 69.4564 326.998 76.448 326.277 81.8122C325.559 87.1476 324.147 90.7229 321.435 93.435L322.849 94.8492C325.995 91.7035 327.512 87.6358 328.259 82.0787C329.002 76.5503 329 69.3998 329 60H327ZM327 40V60H329V40H327ZM321.435 6.56497C324.147 9.27713 325.559 12.8524 326.277 18.1878C326.998 23.552 327 30.5436 327 40H329C329 30.6002 329.002 23.4497 328.259 17.9213C327.512 12.3642 325.995 8.29646 322.849 5.15076L321.435 6.56497ZM288 1C297.456 1 304.448 1.00212 309.812 1.72332C315.148 2.44064 318.723 3.85281 321.435 6.56497L322.849 5.15076C319.704 2.00506 315.636 0.488292 310.079 -0.25885C304.55 -1.00212 297.4 -1 288 -1V1ZM189.992 1H288V-1H189.992V1ZM188.992 -0.00694413C188.958 4.90792 188.778 7.60788 187.975 9.81434L189.854 10.4984C190.793 7.9177 190.958 4.87452 190.992 0.00694413L188.992 -0.00694413ZM187.975 9.81434C186.256 14.5364 182.536 18.2561 177.814 19.9748L178.498 21.8542C183.776 19.9333 187.933 15.7759 189.854 10.4984L187.975 9.81434ZM177.814 19.9748C175.039 20.9848 171.536 21 164 21V23C171.362 23 175.308 23.0152 178.498 21.8542L177.814 19.9748ZM164 21C156.464 21 152.961 20.9848 150.186 19.9748L149.502 21.8542C152.692 23.0152 156.638 23 164 23V21ZM150.186 19.9748C145.464 18.2561 141.744 14.5364 140.025 9.81434L138.146 10.4984C140.067 15.7759 144.224 19.9333 149.502 21.8542L150.186 19.9748ZM140.025 9.81434C139.222 7.60788 139.042 4.90792 139.008 -0.00694413L137.008 0.00694413C137.042 4.87452 137.207 7.9177 138.146 10.4984L140.025 9.81434Z"
    mask="url(#path-1-inside-1_18299_4189)"
  />
</svg>`;
const swapInputMaskTopSvg = b`<svg class="input_mask" width="328" height="100" viewBox="0 0 328 100" fill="none">
  <mask id="path-1-inside-1_18299_4168">
    <path
      class="input_mask__border"
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M5.85786 5.85786C0 11.7157 0 21.1438 0 40V60C0 78.8562 0 88.2843 5.85786 94.1421C11.7157 100 21.1438 100 40 100H138.008C138.042 95.1088 138.214 92.2372 139.086 89.8436C140.905 84.8438 144.844 80.9053 149.844 79.0855C152.826 78 156.551 78 164 78C171.449 78 175.174 78 178.156 79.0855C183.156 80.9053 187.095 84.8438 188.914 89.8436C189.786 92.2372 189.958 95.1088 189.992 100H288C306.856 100 316.284 100 322.142 94.1421C328 88.2843 328 78.8562 328 60V40C328 21.1438 328 11.7157 322.142 5.85786C316.284 0 306.856 0 288 0H40C21.1438 0 11.7157 0 5.85786 5.85786Z"
    />
  </mask>
  <path
    class="input_mask__background"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.85786 5.85786C0 11.7157 0 21.1438 0 40V60C0 78.8562 0 88.2843 5.85786 94.1421C11.7157 100 21.1438 100 40 100H138.008C138.042 95.1088 138.214 92.2372 139.086 89.8436C140.905 84.8438 144.844 80.9053 149.844 79.0855C152.826 78 156.551 78 164 78C171.449 78 175.174 78 178.156 79.0855C183.156 80.9053 187.095 84.8438 188.914 89.8436C189.786 92.2372 189.958 95.1088 189.992 100H288C306.856 100 316.284 100 322.142 94.1421C328 88.2843 328 78.8562 328 60V40C328 21.1438 328 11.7157 322.142 5.85786C316.284 0 306.856 0 288 0H40C21.1438 0 11.7157 0 5.85786 5.85786Z"
  />
  <path
    class="input_mask__border"
    d="M138.008 100V101H139.001L139.008 100.007L138.008 100ZM139.086 89.8436L138.146 89.5016L139.086 89.8436ZM149.844 79.0855L150.186 80.0252L149.844 79.0855ZM178.156 79.0855L177.814 80.0252L178.156 79.0855ZM188.914 89.8436L189.854 89.5016L188.914 89.8436ZM189.992 100L188.992 100.007L188.999 101H189.992V100ZM322.142 94.1421L322.849 94.8492H322.849L322.142 94.1421ZM322.142 5.85786L322.849 5.15076L322.849 5.15076L322.142 5.85786ZM1 40C1 30.5436 1.00212 23.552 1.72332 18.1878C2.44064 12.8524 3.85281 9.27713 6.56497 6.56497L5.15076 5.15076C2.00506 8.29646 0.488292 12.3641 -0.25885 17.9213C-1.00212 23.4497 -1 30.6002 -1 40H1ZM1 60V40H-1V60H1ZM6.56497 93.435C3.85281 90.7229 2.44064 87.1476 1.72332 81.8122C1.00212 76.448 1 69.4564 1 60H-1C-1 69.3998 -1.00212 76.5503 -0.25885 82.0787C0.488292 87.6358 2.00506 91.7035 5.15076 94.8492L6.56497 93.435ZM40 99C30.5436 99 23.552 98.9979 18.1878 98.2767C12.8524 97.5594 9.27713 96.1472 6.56497 93.435L5.15076 94.8492C8.29646 97.9949 12.3641 99.5117 17.9213 100.259C23.4497 101.002 30.6002 101 40 101V99ZM138.008 99H40V101H138.008V99ZM139.008 100.007C139.042 95.0921 139.222 92.3921 140.025 90.1857L138.146 89.5016C137.207 92.0823 137.042 95.1255 137.008 99.9931L139.008 100.007ZM140.025 90.1857C141.744 85.4636 145.464 81.7439 150.186 80.0252L149.502 78.1458C144.224 80.0667 140.067 84.2241 138.146 89.5016L140.025 90.1857ZM150.186 80.0252C152.961 79.0152 156.464 79 164 79V77C156.638 77 152.692 76.9848 149.502 78.1458L150.186 80.0252ZM164 79C171.536 79 175.039 79.0152 177.814 80.0252L178.498 78.1458C175.308 76.9848 171.362 77 164 77V79ZM177.814 80.0252C182.536 81.7439 186.256 85.4636 187.975 90.1857L189.854 89.5016C187.933 84.2241 183.776 80.0667 178.498 78.1458L177.814 80.0252ZM187.975 90.1857C188.778 92.3921 188.958 95.0921 188.992 100.007L190.992 99.9931C190.958 95.1255 190.793 92.0823 189.854 89.5016L187.975 90.1857ZM288 99H189.992V101H288V99ZM321.435 93.435C318.723 96.1472 315.148 97.5594 309.812 98.2767C304.448 98.9979 297.456 99 288 99V101C297.4 101 304.55 101.002 310.079 100.259C315.636 99.5117 319.704 97.9949 322.849 94.8492L321.435 93.435ZM327 60C327 69.4564 326.998 76.448 326.277 81.8122C325.559 87.1476 324.147 90.7229 321.435 93.435L322.849 94.8492C325.995 91.7035 327.512 87.6358 328.259 82.0787C329.002 76.5503 329 69.3998 329 60H327ZM327 40V60H329V40H327ZM321.435 6.56497C324.147 9.27713 325.559 12.8524 326.277 18.1878C326.998 23.552 327 30.5436 327 40H329C329 30.6002 329.002 23.4497 328.259 17.9213C327.512 12.3642 325.995 8.29646 322.849 5.15076L321.435 6.56497ZM288 1C297.456 1 304.448 1.00212 309.812 1.72332C315.148 2.44064 318.723 3.85281 321.435 6.56497L322.849 5.15076C319.704 2.00506 315.636 0.488292 310.079 -0.25885C304.55 -1.00212 297.4 -1 288 -1V1ZM40 1H288V-1H40V1ZM6.56497 6.56497C9.27713 3.85281 12.8524 2.44064 18.1878 1.72332C23.552 1.00212 30.5436 1 40 1V-1C30.6002 -1 23.4497 -1.00212 17.9213 -0.25885C12.3641 0.488292 8.29646 2.00506 5.15076 5.15076L6.56497 6.56497Z"
    mask="url(#path-1-inside-1_18299_4168)"
  />
</svg>`;
let themeTag = void 0;
let darkModeTag = void 0;
let lightModeTag = void 0;
function initializeTheming(themeVariables, themeMode) {
  themeTag = document.createElement("style");
  darkModeTag = document.createElement("style");
  lightModeTag = document.createElement("style");
  themeTag.textContent = createRootStyles(themeVariables).core.cssText;
  darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
  lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  document.head.appendChild(themeTag);
  document.head.appendChild(darkModeTag);
  document.head.appendChild(lightModeTag);
  setColorTheme(themeMode);
}
function setColorTheme(themeMode) {
  if (darkModeTag && lightModeTag) {
    if (themeMode === "light") {
      darkModeTag.removeAttribute("media");
      lightModeTag.media = "enabled";
    } else {
      lightModeTag.removeAttribute("media");
      darkModeTag.media = "enabled";
    }
  }
}
function setThemeVariables(themeVariables) {
  if (themeTag && darkModeTag && lightModeTag) {
    themeTag.textContent = createRootStyles(themeVariables).core.cssText;
    darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
    lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
  }
}
function createRootStyles(themeVariables) {
  return {
    core: i$5`
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      @keyframes w3m-shake {
        0% {
          transform: scale(1) rotate(0deg);
        }
        20% {
          transform: scale(1) rotate(-1deg);
        }
        40% {
          transform: scale(1) rotate(1.5deg);
        }
        60% {
          transform: scale(1) rotate(-1.5deg);
        }
        80% {
          transform: scale(1) rotate(1deg);
        }
        100% {
          transform: scale(1) rotate(0deg);
        }
      }
      @keyframes w3m-iframe-fade-out {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      @keyframes w3m-iframe-zoom-in {
        0% {
          transform: translateY(50px);
          opacity: 0;
        }
        100% {
          transform: translateY(0px);
          opacity: 1;
        }
      }
      @keyframes w3m-iframe-zoom-in-mobile {
        0% {
          transform: scale(0.95);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      :root {
        --w3m-modal-width: 360px;
        --w3m-color-mix-strength: ${r$5(themeVariables?.["--w3m-color-mix-strength"] ? `${themeVariables["--w3m-color-mix-strength"]}%` : "0%")};
        --w3m-font-family: ${r$5(themeVariables?.["--w3m-font-family"] || "Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;")};
        --w3m-font-size-master: ${r$5(themeVariables?.["--w3m-font-size-master"] || "10px")};
        --w3m-border-radius-master: ${r$5(themeVariables?.["--w3m-border-radius-master"] || "4px")};
        --w3m-z-index: ${r$5(themeVariables?.["--w3m-z-index"] || 999)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-title-6: calc(var(--w3m-font-size-master) * 2.2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-title-6: -0.88px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;
        --wui-spacing-5xl: 95px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-2lg: 48px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;
        --wui-icon-size-xxl: 28px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-color-success-100: var(--wui-color-success-base-100);

        --wui-color-error-100: var(--wui-color-error-base-100);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-box-shadow-blue: var(--wui-color-accent-glass-020);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 20%, transparent);

          --wui-color-accent-100: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 100%,
            transparent
          );
          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-color-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-color-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-color-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-color-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-300)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-300)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );
        }
      }
    `,
    light: i$5`
      :root {
        --w3m-color-mix: ${r$5(themeVariables?.["--w3m-color-mix"] || "#fff")};
        --w3m-accent: ${r$5(getW3mThemeVariables(themeVariables, "dark")["--w3m-accent"])};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: ${r$5(getW3mThemeVariables(themeVariables, "dark")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(230, 100%, 67%, 1);
        --wui-color-blueberry-090: hsla(231, 76%, 61%, 1);
        --wui-color-blueberry-080: hsla(230, 59%, 55%, 1);
        --wui-color-blueberry-050: hsla(231, 100%, 70%, 0.1);

        --wui-color-fg-100: #e4e7e7;
        --wui-color-fg-125: #d0d5d5;
        --wui-color-fg-150: #a8b1b1;
        --wui-color-fg-175: #a8b0b0;
        --wui-color-fg-200: #949e9e;
        --wui-color-fg-225: #868f8f;
        --wui-color-fg-250: #788080;
        --wui-color-fg-275: #788181;
        --wui-color-fg-300: #6e7777;

        --wui-color-bg-100: #141414;
        --wui-color-bg-125: #191a1a;
        --wui-color-bg-150: #1e1f1f;
        --wui-color-bg-175: #222525;
        --wui-color-bg-200: #272a2a;
        --wui-color-bg-225: #2c3030;
        --wui-color-bg-250: #313535;
        --wui-color-bg-275: #363b3b;
        --wui-color-bg-300: #3b4040;

        --wui-color-success-base-100: #26d962;
        --wui-color-error-base-100: #f25a67;

        --wui-color-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-color-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-color-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-color-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-color-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-color-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-color-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-color-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-color-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-color-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-color-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-color-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-color-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-color-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-color-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-color-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-color-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-color-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-color-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-color-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-color-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-color-gray-glass-090: rgba(255, 255, 255, 0.9);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;
      }
    `,
    dark: i$5`
      :root {
        --w3m-color-mix: ${r$5(themeVariables?.["--w3m-color-mix"] || "#000")};
        --w3m-accent: ${r$5(getW3mThemeVariables(themeVariables, "light")["--w3m-accent"])};
        --w3m-default: #000;

        --wui-color-modal-bg-base: ${r$5(getW3mThemeVariables(themeVariables, "light")["--w3m-background"])};
        --wui-color-accent-base-100: var(--w3m-accent);

        --wui-color-blueberry-100: hsla(231, 100%, 70%, 1);
        --wui-color-blueberry-090: hsla(231, 97%, 72%, 1);
        --wui-color-blueberry-080: hsla(231, 92%, 74%, 1);

        --wui-color-fg-100: #141414;
        --wui-color-fg-125: #2d3131;
        --wui-color-fg-150: #474d4d;
        --wui-color-fg-175: #636d6d;
        --wui-color-fg-200: #798686;
        --wui-color-fg-225: #828f8f;
        --wui-color-fg-250: #8b9797;
        --wui-color-fg-275: #95a0a0;
        --wui-color-fg-300: #9ea9a9;

        --wui-color-bg-100: #ffffff;
        --wui-color-bg-125: #f5fafa;
        --wui-color-bg-150: #f3f8f8;
        --wui-color-bg-175: #eef4f4;
        --wui-color-bg-200: #eaf1f1;
        --wui-color-bg-225: #e5eded;
        --wui-color-bg-250: #e1e9e9;
        --wui-color-bg-275: #dce7e7;
        --wui-color-bg-300: #d8e3e3;

        --wui-color-success-base-100: #26b562;
        --wui-color-error-base-100: #f05142;

        --wui-color-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-color-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-color-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-color-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-color-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-color-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-color-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-color-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-color-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-color-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-color-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-color-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-color-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-color-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-color-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-color-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-color-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-color-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-color-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-color-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-color-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-color-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-color-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-color-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-color-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-color-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-color-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-color-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-color-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-color-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-color-gray-glass-090: rgba(0, 0, 0, 0.9);
      }
    `
  };
}
const resetStyles = i$5`
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`;
const elementStyles = i$5`
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition:
      color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      background-color var(--wui-duration-lg) var(--wui-ease-out-power-1),
      border var(--wui-duration-lg) var(--wui-ease-out-power-1),
      box-shadow var(--wui-duration-lg) var(--wui-ease-out-power-1);
    will-change: background-color, color, border, box-shadow;
    outline: none;
    border: none;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-005);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }
  }

  button:disabled > wui-icon-box {
    opacity: 0.5;
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`;
const colorStyles = i$5`
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }
`;
function standardCustomElement(tagName, descriptor) {
  const { kind, elements } = descriptor;
  return {
    kind,
    elements,
    finisher(clazz) {
      if (!customElements.get(tagName)) {
        customElements.define(tagName, clazz);
      }
    }
  };
}
function legacyCustomElement(tagName, clazz) {
  if (!customElements.get(tagName)) {
    customElements.define(tagName, clazz);
  }
  return clazz;
}
function customElement(tagName) {
  return function create(classOrDescriptor) {
    return typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
  };
}
const styles$2d = i$5`
  :host {
    display: block;
    border-radius: clamp(0px, var(--wui-border-radius-l), 44px);
    box-shadow: 0 0 0 1px var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-modal-bg);
    overflow: hidden;
  }
`;
var __decorate$2P = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiCard = class WuiCard2 extends i$2 {
  render() {
    return x`<slot></slot>`;
  }
};
WuiCard.styles = [resetStyles, styles$2d];
WuiCard = __decorate$2P([
  customElement("wui-card")
], WuiCard);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$4 = { attribute: true, type: String, converter: u$1, reflect: false, hasChanged: f$3 }, r$2 = (t2 = o$4, e2, r2) => {
  const { kind: n22, metadata: i4 } = r2;
  let s2 = globalThis.litPropertyMetadata.get(i4);
  if (void 0 === s2 && globalThis.litPropertyMetadata.set(i4, s2 = /* @__PURE__ */ new Map()), "setter" === n22 && ((t2 = Object.create(t2)).wrapped = true), s2.set(r2.name, t2), "accessor" === n22) {
    const { name: o2 } = r2;
    return { set(r3) {
      const n3 = e2.get.call(this);
      e2.set.call(this, r3), this.requestUpdate(o2, n3, t2);
    }, init(e3) {
      return void 0 !== e3 && this.C(o2, void 0, t2, e3), e3;
    } };
  }
  if ("setter" === n22) {
    const { name: o2 } = r2;
    return function(r3) {
      const n3 = this[o2];
      e2.call(this, r3), this.requestUpdate(o2, n3, t2);
    };
  }
  throw Error("Unsupported decorator location: " + n22);
};
function n$2(t2) {
  return (e2, o2) => "object" == typeof o2 ? r$2(t2, e2, o2) : ((t3, e3, o3) => {
    const r2 = e3.hasOwnProperty(o3);
    return e3.constructor.createProperty(o3, t3), r2 ? Object.getOwnPropertyDescriptor(e3, o3) : void 0;
  })(t2, e2, o2);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$1(r2) {
  return n$2({ ...r2, state: true, attribute: false });
}
const styles$2c = i$5`
  :host {
    display: flex;
    aspect-ratio: 1 / 1;
    color: var(--local-color);
    width: var(--local-width);
  }

  svg {
    width: inherit;
    height: inherit;
    object-fit: contain;
    object-position: center;
  }
`;
const addSvg = b`<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7.0023 0.875C7.48571 0.875 7.8776 1.26675 7.8776 1.75V6.125H12.2541C12.7375 6.125 13.1294 6.51675 13.1294 7C13.1294 7.48325 12.7375 7.875 12.2541 7.875H7.8776V12.25C7.8776 12.7332 7.48571 13.125 7.0023 13.125C6.51889 13.125 6.12701 12.7332 6.12701 12.25V7.875H1.75054C1.26713 7.875 0.875244 7.48325 0.875244 7C0.875244 6.51675 1.26713 6.125 1.75054 6.125H6.12701V1.75C6.12701 1.26675 6.51889 0.875 7.0023 0.875Z"
    fill="#667dff"
  /></svg
>`;
const allWalletsSvg = b`<svg fill="none" viewBox="0 0 24 24">
  <path
    style="fill: var(--wui-color-accent-100);"
    d="M10.2 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM10.2 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0Z"
  />
</svg>`;
const arrowBottomCircleSvg = b`<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10.5 2.42908C6.31875 2.42908 2.92859 5.81989 2.92859 10.0034C2.92859 14.1869 6.31875 17.5777 10.5 17.5777C14.6813 17.5777 18.0714 14.1869 18.0714 10.0034C18.0714 5.81989 14.6813 2.42908 10.5 2.42908ZM0.928589 10.0034C0.928589 4.71596 5.21355 0.429077 10.5 0.429077C15.7865 0.429077 20.0714 4.71596 20.0714 10.0034C20.0714 15.2908 15.7865 19.5777 10.5 19.5777C5.21355 19.5777 0.928589 15.2908 0.928589 10.0034ZM10.5 5.75003C11.0523 5.75003 11.5 6.19774 11.5 6.75003L11.5 10.8343L12.7929 9.54137C13.1834 9.15085 13.8166 9.15085 14.2071 9.54137C14.5976 9.9319 14.5976 10.5651 14.2071 10.9556L11.2071 13.9556C10.8166 14.3461 10.1834 14.3461 9.79291 13.9556L6.79291 10.9556C6.40239 10.5651 6.40239 9.9319 6.79291 9.54137C7.18343 9.15085 7.8166 9.15085 8.20712 9.54137L9.50002 10.8343L9.50002 6.75003C9.50002 6.19774 9.94773 5.75003 10.5 5.75003Z"
    clip-rule="evenodd"
  /></svg
>`;
const appStoreSvg = b`
<svg width="36" height="36">
  <path
    d="M28.724 0H7.271A7.269 7.269 0 0 0 0 7.272v21.46A7.268 7.268 0 0 0 7.271 36H28.73A7.272 7.272 0 0 0 36 28.728V7.272A7.275 7.275 0 0 0 28.724 0Z"
    fill="url(#a)"
  />
  <path
    d="m17.845 8.271.729-1.26a1.64 1.64 0 1 1 2.843 1.638l-7.023 12.159h5.08c1.646 0 2.569 1.935 1.853 3.276H6.434a1.632 1.632 0 0 1-1.638-1.638c0-.909.73-1.638 1.638-1.638h4.176l5.345-9.265-1.67-2.898a1.642 1.642 0 0 1 2.844-1.638l.716 1.264Zm-6.317 17.5-1.575 2.732a1.64 1.64 0 1 1-2.844-1.638l1.17-2.025c1.323-.41 2.398-.095 3.249.931Zm13.56-4.954h4.262c.909 0 1.638.729 1.638 1.638 0 .909-.73 1.638-1.638 1.638h-2.367l1.597 2.772c.45.788.185 1.782-.602 2.241a1.642 1.642 0 0 1-2.241-.603c-2.69-4.666-4.711-8.159-6.052-10.485-1.372-2.367-.391-4.743.576-5.549 1.075 1.846 2.682 4.631 4.828 8.348Z"
    fill="#fff"
  />
  <defs>
    <linearGradient id="a" x1="18" y1="0" x2="18" y2="36" gradientUnits="userSpaceOnUse">
      <stop stop-color="#18BFFB" />
      <stop offset="1" stop-color="#2072F3" />
    </linearGradient>
  </defs>
</svg>`;
const appleSvg = b`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#000" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const arrowBottomSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 1.99a1 1 0 0 1 1 1v7.58l2.46-2.46a1 1 0 0 1 1.41 1.42L7.7 13.69a1 1 0 0 1-1.41 0L2.12 9.53A1 1 0 0 1 3.54 8.1L6 10.57V3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowLeftSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13 7.99a1 1 0 0 1-1 1H4.4l2.46 2.46a1 1 0 1 1-1.41 1.41L1.29 8.7a1 1 0 0 1 0-1.41L5.46 3.1a1 1 0 0 1 1.41 1.42L4.41 6.99H12a1 1 0 0 1 1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowRightSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1 7.99a1 1 0 0 1 1-1h7.58L7.12 4.53A1 1 0 1 1 8.54 3.1l4.16 4.17a1 1 0 0 1 0 1.41l-4.16 4.17a1 1 0 1 1-1.42-1.41l2.46-2.46H2a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const arrowTopSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 13.99a1 1 0 0 1-1-1V5.4L3.54 7.86a1 1 0 0 1-1.42-1.41L6.3 2.28a1 1 0 0 1 1.41 0l4.17 4.17a1 1 0 1 1-1.41 1.41L8 5.4v7.59a1 1 0 0 1-1 1Z"
    clip-rule="evenodd"
  />
</svg>`;
const bankSvg = b`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.61391 1.57124C5.85142 1.42873 6.14813 1.42873 6.38564 1.57124L11.0793 4.38749C11.9179 4.89067 11.5612 6.17864 10.5832 6.17864H9.96398V10.0358H10.2854C10.6996 10.0358 11.0354 10.3716 11.0354 10.7858C11.0354 11.2 10.6996 11.5358 10.2854 11.5358H1.71416C1.29995 11.5358 0.964172 11.2 0.964172 10.7858C0.964172 10.3716 1.29995 10.0358 1.71416 10.0358H2.03558L2.03558 6.17864H1.41637C0.438389 6.17864 0.0816547 4.89066 0.920263 4.38749L5.61391 1.57124ZM3.53554 6.17864V10.0358H5.24979V6.17864H3.53554ZM6.74976 6.17864V10.0358H8.46401V6.17864H6.74976ZM8.64913 4.67864H3.35043L5.99978 3.089L8.64913 4.67864Z"
    fill="currentColor"
  /></svg
>`;
const browserSvg$1 = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4 6.4a1 1 0 0 1-.46.89 6.98 6.98 0 0 0 .38 6.18A7 7 0 0 0 16.46 7.3a1 1 0 0 1-.47-.92 7 7 0 0 0-12 .03Zm-2.02-.5a9 9 0 1 1 16.03 8.2A9 9 0 0 1 1.98 5.9Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.03 8.63c-1.46-.3-2.72-.75-3.6-1.35l-.02-.01-.14-.11a1 1 0 0 1 1.2-1.6l.1.08c.6.4 1.52.74 2.69 1 .16-.99.39-1.88.67-2.65.3-.79.68-1.5 1.15-2.02A2.58 2.58 0 0 1 9.99 1c.8 0 1.45.44 1.92.97.47.52.84 1.23 1.14 2.02.29.77.52 1.66.68 2.64a8 8 0 0 0 2.7-1l.26-.18h.48a1 1 0 0 1 .12 2c-.86.51-2.01.91-3.34 1.18a22.24 22.24 0 0 1-.03 3.19c1.45.29 2.7.73 3.58 1.31a1 1 0 0 1-1.1 1.68c-.6-.4-1.56-.76-2.75-1-.15.8-.36 1.55-.6 2.2-.3.79-.67 1.5-1.14 2.02-.47.53-1.12.97-1.92.97-.8 0-1.45-.44-1.91-.97a6.51 6.51 0 0 1-1.15-2.02c-.24-.65-.44-1.4-.6-2.2-1.18.24-2.13.6-2.73.99a1 1 0 1 1-1.1-1.67c.88-.58 2.12-1.03 3.57-1.31a22.03 22.03 0 0 1-.04-3.2Zm2.2-1.7c.15-.86.34-1.61.58-2.24.24-.65.51-1.12.76-1.4.25-.28.4-.29.42-.29.03 0 .17.01.42.3.25.27.52.74.77 1.4.23.62.43 1.37.57 2.22a19.96 19.96 0 0 1-3.52 0Zm-.18 4.6a20.1 20.1 0 0 1-.03-2.62 21.95 21.95 0 0 0 3.94 0 20.4 20.4 0 0 1-.03 2.63 21.97 21.97 0 0 0-3.88 0Zm.27 2c.13.66.3 1.26.49 1.78.24.65.51 1.12.76 1.4.25.28.4.29.42.29.03 0 .17-.01.42-.3.25-.27.52-.74.77-1.4.19-.5.36-1.1.49-1.78a20.03 20.03 0 0 0-3.35 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const cardSvg = b`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M4.16072 2C4.17367 2 4.18665 2 4.19968 2L7.83857 2C8.36772 1.99998 8.82398 1.99996 9.19518 2.04018C9.5895 2.0829 9.97577 2.17811 10.3221 2.42971C10.5131 2.56849 10.6811 2.73647 10.8198 2.92749C11.0714 3.27379 11.1666 3.66007 11.2094 4.0544C11.2496 4.42561 11.2496 4.88188 11.2495 5.41105V7.58896C11.2496 8.11812 11.2496 8.57439 11.2094 8.94561C11.1666 9.33994 11.0714 9.72621 10.8198 10.0725C10.6811 10.2635 10.5131 10.4315 10.3221 10.5703C9.97577 10.8219 9.5895 10.9171 9.19518 10.9598C8.82398 11 8.36772 11 7.83856 11H4.16073C3.63157 11 3.17531 11 2.80411 10.9598C2.40979 10.9171 2.02352 10.8219 1.67722 10.5703C1.48621 10.4315 1.31824 10.2635 1.17946 10.0725C0.927858 9.72621 0.832652 9.33994 0.78993 8.94561C0.749713 8.5744 0.749733 8.11813 0.749757 7.58896L0.749758 5.45C0.749758 5.43697 0.749758 5.42399 0.749757 5.41104C0.749733 4.88188 0.749713 4.42561 0.78993 4.0544C0.832652 3.66007 0.927858 3.27379 1.17946 2.92749C1.31824 2.73647 1.48621 2.56849 1.67722 2.42971C2.02352 2.17811 2.40979 2.0829 2.80411 2.04018C3.17531 1.99996 3.63157 1.99998 4.16072 2ZM2.96567 3.53145C2.69897 3.56034 2.60687 3.60837 2.55888 3.64324C2.49521 3.6895 2.43922 3.74549 2.39296 3.80916C2.35809 3.85715 2.31007 3.94926 2.28117 4.21597C2.26629 4.35335 2.25844 4.51311 2.25431 4.70832H9.74498C9.74085 4.51311 9.733 4.35335 9.71812 4.21597C9.68922 3.94926 9.6412 3.85715 9.60633 3.80916C9.56007 3.74549 9.50408 3.6895 9.44041 3.64324C9.39242 3.60837 9.30031 3.56034 9.03362 3.53145C8.75288 3.50103 8.37876 3.5 7.79961 3.5H4.19968C3.62053 3.5 3.24641 3.50103 2.96567 3.53145ZM9.74956 6.20832H2.24973V7.55C2.24973 8.12917 2.25076 8.5033 2.28117 8.78404C2.31007 9.05074 2.35809 9.14285 2.39296 9.19084C2.43922 9.25451 2.49521 9.31051 2.55888 9.35677C2.60687 9.39163 2.69897 9.43966 2.96567 9.46856C3.24641 9.49897 3.62053 9.5 4.19968 9.5H7.79961C8.37876 9.5 8.75288 9.49897 9.03362 9.46856C9.30032 9.43966 9.39242 9.39163 9.44041 9.35677C9.50408 9.31051 9.56007 9.25451 9.60633 9.19084C9.6412 9.14285 9.68922 9.05075 9.71812 8.78404C9.74854 8.5033 9.74956 8.12917 9.74956 7.55V6.20832ZM6.74963 8C6.74963 7.58579 7.08541 7.25 7.49961 7.25H8.2496C8.6638 7.25 8.99958 7.58579 8.99958 8C8.99958 8.41422 8.6638 8.75 8.2496 8.75H7.49961C7.08541 8.75 6.74963 8.41422 6.74963 8Z"
    fill="currentColor"
  /></svg
>`;
const checkmarkBoldSvg = b`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M12.9576 2.23383C13.3807 2.58873 13.4361 3.21947 13.0812 3.64263L6.37159 11.6426C6.19161 11.8572 5.92989 11.9865 5.65009 11.999C5.3703 12.0115 5.09808 11.9062 4.89965 11.7085L0.979321 7.80331C0.588042 7.41354 0.586817 6.78038 0.976585 6.3891C1.36635 5.99782 1.99952 5.99659 2.3908 6.38636L5.53928 9.52268L11.5488 2.35742C11.9037 1.93426 12.5344 1.87893 12.9576 2.23383Z"
    clip-rule="evenodd"
  />
</svg>`;
const checkmarkSvg = b`<svg
  width="28"
  height="28"
  viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M25.5297 4.92733C26.1221 5.4242 26.1996 6.30724 25.7027 6.89966L12.2836 22.8997C12.0316 23.2001 11.6652 23.3811 11.2735 23.3986C10.8817 23.4161 10.5006 23.2686 10.2228 22.9919L2.38218 15.1815C1.83439 14.6358 1.83268 13.7494 2.37835 13.2016C2.92403 12.6538 3.81046 12.6521 4.35825 13.1978L11.1183 19.9317L23.5573 5.10036C24.0542 4.50794 24.9372 4.43047 25.5297 4.92733Z"
    fill="#26D962"/>
</svg>
`;
const chevronBottomSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1.46 4.96a1 1 0 0 1 1.41 0L8 10.09l5.13-5.13a1 1 0 1 1 1.41 1.41l-5.83 5.84a1 1 0 0 1-1.42 0L1.46 6.37a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronLeftSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronRightSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.96 14.54a1 1 0 0 1 0-1.41L10.09 8 4.96 2.87a1 1 0 0 1 1.41-1.41l5.84 5.83a1 1 0 0 1 0 1.42l-5.84 5.83a1 1 0 0 1-1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const chevronTopSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.54 11.04a1 1 0 0 1-1.41 0L8 5.92l-5.13 5.12a1 1 0 1 1-1.41-1.41l5.83-5.84a1 1 0 0 1 1.42 0l5.83 5.84a1 1 0 0 1 0 1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const chromeStoreSvg = b`<svg width="36" height="36" fill="none">
  <path
    fill="#fff"
    fill-opacity=".05"
    d="M0 14.94c0-5.55 0-8.326 1.182-10.4a9 9 0 0 1 3.359-3.358C6.614 0 9.389 0 14.94 0h6.12c5.55 0 8.326 0 10.4 1.182a9 9 0 0 1 3.358 3.359C36 6.614 36 9.389 36 14.94v6.12c0 5.55 0 8.326-1.182 10.4a9 9 0 0 1-3.359 3.358C29.386 36 26.611 36 21.06 36h-6.12c-5.55 0-8.326 0-10.4-1.182a9 9 0 0 1-3.358-3.359C0 29.386 0 26.611 0 21.06v-6.12Z"
  />
  <path
    stroke="#fff"
    stroke-opacity=".05"
    d="M14.94.5h6.12c2.785 0 4.84 0 6.46.146 1.612.144 2.743.43 3.691.97a8.5 8.5 0 0 1 3.172 3.173c.541.948.826 2.08.971 3.692.145 1.62.146 3.675.146 6.459v6.12c0 2.785 0 4.84-.146 6.46-.145 1.612-.43 2.743-.97 3.691a8.5 8.5 0 0 1-3.173 3.172c-.948.541-2.08.826-3.692.971-1.62.145-3.674.146-6.459.146h-6.12c-2.784 0-4.84 0-6.46-.146-1.612-.145-2.743-.43-3.691-.97a8.5 8.5 0 0 1-3.172-3.173c-.541-.948-.827-2.08-.971-3.692C.5 25.9.5 23.845.5 21.06v-6.12c0-2.784 0-4.84.146-6.46.144-1.612.43-2.743.97-3.691A8.5 8.5 0 0 1 4.79 1.617C5.737 1.076 6.869.79 8.48.646 10.1.5 12.156.5 14.94.5Z"
  />
  <path
    fill="url(#a)"
    d="M17.998 10.8h12.469a14.397 14.397 0 0 0-24.938.001l6.234 10.798.006-.001a7.19 7.19 0 0 1 6.23-10.799Z"
  />
  <path
    fill="url(#b)"
    d="m24.237 21.598-6.234 10.798A14.397 14.397 0 0 0 30.47 10.798H18.002l-.002.006a7.191 7.191 0 0 1 6.237 10.794Z"
  />
  <path
    fill="url(#c)"
    d="M11.765 21.601 5.531 10.803A14.396 14.396 0 0 0 18.001 32.4l6.235-10.798-.004-.004a7.19 7.19 0 0 1-12.466.004Z"
  />
  <path fill="#fff" d="M18 25.2a7.2 7.2 0 1 0 0-14.4 7.2 7.2 0 0 0 0 14.4Z" />
  <path fill="#1A73E8" d="M18 23.7a5.7 5.7 0 1 0 0-11.4 5.7 5.7 0 0 0 0 11.4Z" />
  <defs>
    <linearGradient
      id="a"
      x1="6.294"
      x2="41.1"
      y1="5.995"
      y2="5.995"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#D93025" />
      <stop offset="1" stop-color="#EA4335" />
    </linearGradient>
    <linearGradient
      id="b"
      x1="20.953"
      x2="37.194"
      y1="32.143"
      y2="2.701"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#FCC934" />
      <stop offset="1" stop-color="#FBBC04" />
    </linearGradient>
    <linearGradient
      id="c"
      x1="25.873"
      x2="9.632"
      y1="31.2"
      y2="1.759"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#1E8E3E" />
      <stop offset="1" stop-color="#34A853" />
    </linearGradient>
  </defs>
</svg>`;
const clockSvg = b`<svg width="14" height="14" viewBox="0 0 14 14" fill="none">
  <path 
    fill-rule="evenodd" 
    clip-rule="evenodd" 
    d="M7.00235 2C4.24 2 2.00067 4.23858 2.00067 7C2.00067 9.76142 4.24 12 7.00235 12C9.7647 12 12.004 9.76142 12.004 7C12.004 4.23858 9.7647 2 7.00235 2ZM0 7C0 3.13401 3.13506 0 7.00235 0C10.8696 0 14.0047 3.13401 14.0047 7C14.0047 10.866 10.8696 14 7.00235 14C3.13506 14 0 10.866 0 7ZM7.00235 3C7.55482 3 8.00269 3.44771 8.00269 4V6.58579L9.85327 8.43575C10.2439 8.82627 10.2439 9.45944 9.85327 9.84996C9.46262 10.2405 8.82924 10.2405 8.43858 9.84996L6.29501 7.70711C6.10741 7.51957 6.00201 7.26522 6.00201 7V4C6.00201 3.44771 6.44988 3 7.00235 3Z" 
    fill="currentColor"
  />
</svg>`;
const closeSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const coinPlaceholderSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 3a7 7 0 0 0-6.85 8.44l8.29-8.3C10.97 3.06 10.49 3 10 3Zm3.49.93-9.56 9.56c.32.55.71 1.06 1.16 1.5L15 5.1a7.03 7.03 0 0 0-1.5-1.16Zm2.7 2.8-9.46 9.46a7 7 0 0 0 9.46-9.46ZM1.99 5.9A9 9 0 1 1 18 14.09 9 9 0 0 1 1.98 5.91Z"
    clip-rule="evenodd"
  />
</svg>`;
const compassSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm10.66-2.65a1 1 0 0 1 .23 1.06L9.83 9.24a1 1 0 0 1-.59.58l-2.83 1.06A1 1 0 0 1 5.13 9.6l1.06-2.82a1 1 0 0 1 .58-.59L9.6 5.12a1 1 0 0 1 1.06.23ZM7.9 7.89l-.13.35.35-.13.12-.35-.34.13Z"
    clip-rule="evenodd"
  />
</svg>`;
const copySvg = b`<svg
  xmlns="http://www.w3.org/2000/svg"
  width="16"
  height="16"
  viewBox="0 0 16 16"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M9.21498 1.28565H10.5944C11.1458 1.28562 11.6246 1.2856 12.0182 1.32093C12.4353 1.35836 12.853 1.44155 13.2486 1.66724C13.7005 1.92498 14.0749 2.29935 14.3326 2.75122C14.5583 3.14689 14.6415 3.56456 14.6789 3.9817C14.7143 4.37531 14.7142 4.85403 14.7142 5.40545V6.78489C14.7142 7.33631 14.7143 7.81503 14.6789 8.20865C14.6415 8.62578 14.5583 9.04345 14.3326 9.43912C14.0749 9.89099 13.7005 10.2654 13.2486 10.5231C12.853 10.7488 12.4353 10.832 12.0182 10.8694C11.7003 10.8979 11.3269 10.9034 10.9045 10.9045C10.9034 11.3269 10.8979 11.7003 10.8694 12.0182C10.832 12.4353 10.7488 12.853 10.5231 13.2486C10.2654 13.7005 9.89099 14.0749 9.43912 14.3326C9.04345 14.5583 8.62578 14.6415 8.20865 14.6789C7.81503 14.7143 7.33631 14.7142 6.78489 14.7142H5.40545C4.85403 14.7142 4.37531 14.7143 3.9817 14.6789C3.56456 14.6415 3.14689 14.5583 2.75122 14.3326C2.29935 14.0749 1.92498 13.7005 1.66724 13.2486C1.44155 12.853 1.35836 12.4353 1.32093 12.0182C1.2856 11.6246 1.28562 11.1458 1.28565 10.5944V9.21498C1.28562 8.66356 1.2856 8.18484 1.32093 7.79122C1.35836 7.37409 1.44155 6.95642 1.66724 6.56074C1.92498 6.10887 2.29935 5.73451 2.75122 5.47677C3.14689 5.25108 3.56456 5.16789 3.9817 5.13045C4.2996 5.10192 4.67301 5.09645 5.09541 5.09541C5.09645 4.67302 5.10192 4.2996 5.13045 3.9817C5.16789 3.56456 5.25108 3.14689 5.47676 2.75122C5.73451 2.29935 6.10887 1.92498 6.56074 1.66724C6.95642 1.44155 7.37409 1.35836 7.79122 1.32093C8.18484 1.2856 8.66356 1.28562 9.21498 1.28565ZM5.09541 7.09552C4.68397 7.09667 4.39263 7.10161 4.16046 7.12245C3.88053 7.14757 3.78516 7.18949 3.74214 7.21403C3.60139 7.29431 3.48478 7.41091 3.4045 7.55166C3.37997 7.59468 3.33804 7.69005 3.31292 7.96999C3.28659 8.26345 3.28565 8.65147 3.28565 9.25708V10.5523C3.28565 11.1579 3.28659 11.5459 3.31292 11.8394C3.33804 12.1193 3.37997 12.2147 3.4045 12.2577C3.48478 12.3985 3.60139 12.5151 3.74214 12.5954C3.78516 12.6199 3.88053 12.6618 4.16046 12.6869C4.45393 12.7133 4.84195 12.7142 5.44755 12.7142H6.74279C7.3484 12.7142 7.73641 12.7133 8.02988 12.6869C8.30981 12.6618 8.40518 12.6199 8.44821 12.5954C8.58895 12.5151 8.70556 12.3985 8.78584 12.2577C8.81038 12.2147 8.8523 12.1193 8.87742 11.8394C8.89825 11.6072 8.90319 11.3159 8.90435 10.9045C8.48219 10.9034 8.10898 10.8979 7.79122 10.8694C7.37409 10.832 6.95641 10.7488 6.56074 10.5231C6.10887 10.2654 5.73451 9.89099 5.47676 9.43912C5.25108 9.04345 5.16789 8.62578 5.13045 8.20865C5.10194 7.89089 5.09645 7.51767 5.09541 7.09552ZM7.96999 3.31292C7.69005 3.33804 7.59468 3.37997 7.55166 3.4045C7.41091 3.48478 7.29431 3.60139 7.21403 3.74214C7.18949 3.78516 7.14757 3.88053 7.12245 4.16046C7.09611 4.45393 7.09517 4.84195 7.09517 5.44755V6.74279C7.09517 7.3484 7.09611 7.73641 7.12245 8.02988C7.14757 8.30981 7.18949 8.40518 7.21403 8.4482C7.29431 8.58895 7.41091 8.70556 7.55166 8.78584C7.59468 8.81038 7.69005 8.8523 7.96999 8.87742C8.26345 8.90376 8.65147 8.9047 9.25708 8.9047H10.5523C11.1579 8.9047 11.5459 8.90376 11.8394 8.87742C12.1193 8.8523 12.2147 8.81038 12.2577 8.78584C12.3985 8.70556 12.5151 8.58895 12.5954 8.4482C12.6199 8.40518 12.6618 8.30981 12.6869 8.02988C12.7133 7.73641 12.7142 7.3484 12.7142 6.74279V5.44755C12.7142 4.84195 12.7133 4.45393 12.6869 4.16046C12.6618 3.88053 12.6199 3.78516 12.5954 3.74214C12.5151 3.60139 12.3985 3.48478 12.2577 3.4045C12.2147 3.37997 12.1193 3.33804 11.8394 3.31292C11.5459 3.28659 11.1579 3.28565 10.5523 3.28565H9.25708C8.65147 3.28565 8.26345 3.28659 7.96999 3.31292Z"
    fill="#788181"
  /></svg
>`;
const cursorSvg = b` <svg fill="none" viewBox="0 0 13 4">
  <path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`;
const cursorTransparentSvg = b`<svg fill="none" viewBox="0 0 14 6">
  <path style="fill: var(--wui-color-bg-150);" d="M0 1h14L9.21 5.12a3.31 3.31 0 0 1-4.49 0L0 1Z" />
  <path
    style="stroke: var(--wui-color-inverse-100);"
    stroke-opacity=".05"
    d="M1.33 1.5h11.32L8.88 4.75l-.01.01a2.81 2.81 0 0 1-3.8 0l-.02-.01L1.33 1.5Z"
  />
  <path
    style="fill: var(--wui-color-bg-150);"
    d="M1.25.71h11.5L9.21 3.88a3.31 3.31 0 0 1-4.49 0L1.25.71Z"
  />
</svg> `;
const desktopSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13.66 2H6.34c-1.07 0-1.96 0-2.68.08-.74.08-1.42.25-2.01.68a4 4 0 0 0-.89.89c-.43.6-.6 1.27-.68 2.01C0 6.38 0 7.26 0 8.34v.89c0 1.07 0 1.96.08 2.68.08.74.25 1.42.68 2.01a4 4 0 0 0 .89.89c.6.43 1.27.6 2.01.68a27 27 0 0 0 2.68.08h7.32a27 27 0 0 0 2.68-.08 4.03 4.03 0 0 0 2.01-.68 4 4 0 0 0 .89-.89c.43-.6.6-1.27.68-2.01.08-.72.08-1.6.08-2.68v-.89c0-1.07 0-1.96-.08-2.68a4.04 4.04 0 0 0-.68-2.01 4 4 0 0 0-.89-.89c-.6-.43-1.27-.6-2.01-.68C15.62 2 14.74 2 13.66 2ZM2.82 4.38c.2-.14.48-.25 1.06-.31C4.48 4 5.25 4 6.4 4h7.2c1.15 0 1.93 0 2.52.07.58.06.86.17 1.06.31a2 2 0 0 1 .44.44c.14.2.25.48.31 1.06.07.6.07 1.37.07 2.52v.77c0 1.15 0 1.93-.07 2.52-.06.58-.17.86-.31 1.06a2 2 0 0 1-.44.44c-.2.14-.48.25-1.06.32-.6.06-1.37.06-2.52.06H6.4c-1.15 0-1.93 0-2.52-.06-.58-.07-.86-.18-1.06-.32a2 2 0 0 1-.44-.44c-.14-.2-.25-.48-.31-1.06C2 11.1 2 10.32 2 9.17V8.4c0-1.15 0-1.93.07-2.52.06-.58.17-.86.31-1.06a2 2 0 0 1 .44-.44Z"
    clip-rule="evenodd"
  />
  <path fill="currentColor" d="M6.14 17.57a1 1 0 1 0 0 2h7.72a1 1 0 1 0 0-2H6.14Z" />
</svg>`;
const disconnectSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.07 1h.57a1 1 0 0 1 0 2h-.52c-.98 0-1.64 0-2.14.06-.48.05-.7.14-.84.24-.13.1-.25.22-.34.35-.1.14-.2.35-.25.83-.05.5-.05 1.16-.05 2.15v2.74c0 .99 0 1.65.05 2.15.05.48.14.7.25.83.1.14.2.25.34.35.14.1.36.2.84.25.5.05 1.16.05 2.14.05h.52a1 1 0 0 1 0 2h-.57c-.92 0-1.69 0-2.3-.07a3.6 3.6 0 0 1-1.8-.61c-.3-.22-.57-.49-.8-.8a3.6 3.6 0 0 1-.6-1.79C.5 11.11.5 10.35.5 9.43V6.58c0-.92 0-1.7.06-2.31a3.6 3.6 0 0 1 .62-1.8c.22-.3.48-.57.79-.79a3.6 3.6 0 0 1 1.8-.61C4.37 1 5.14 1 6.06 1ZM9.5 3a1 1 0 0 1 1.42 0l4.28 4.3a1 1 0 0 1 0 1.4L10.93 13a1 1 0 0 1-1.42-1.42L12.1 9H6.8a1 1 0 1 1 0-2h5.3L9.51 4.42a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;
const discordSvg = b`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`;
const etherscanSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
  />
</svg>`;
const extensionSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.71 2.99a.57.57 0 0 0-.57.57 1 1 0 0 1-1 1c-.58 0-.96 0-1.24.03-.27.03-.37.07-.42.1a.97.97 0 0 0-.36.35c-.04.08-.09.21-.11.67a2.57 2.57 0 0 1 0 5.13c.02.45.07.6.11.66.09.15.21.28.36.36.07.04.21.1.67.12a2.57 2.57 0 0 1 5.12 0c.46-.03.6-.08.67-.12a.97.97 0 0 0 .36-.36c.03-.04.07-.14.1-.41.02-.29.03-.66.03-1.24a1 1 0 0 1 1-1 .57.57 0 0 0 0-1.15 1 1 0 0 1-1-1c0-.58 0-.95-.03-1.24a1.04 1.04 0 0 0-.1-.42.97.97 0 0 0-.36-.36 1.04 1.04 0 0 0-.42-.1c-.28-.02-.65-.02-1.24-.02a1 1 0 0 1-1-1 .57.57 0 0 0-.57-.57ZM5.15 13.98a1 1 0 0 0 .99-1v-.78a.57.57 0 0 1 1.14 0v.78a1 1 0 0 0 .99 1H8.36a66.26 66.26 0 0 0 .73 0 3.78 3.78 0 0 0 1.84-.38c.46-.26.85-.64 1.1-1.1.23-.4.32-.8.36-1.22.02-.2.03-.4.03-.63a2.57 2.57 0 0 0 0-4.75c0-.23-.01-.44-.03-.63a2.96 2.96 0 0 0-.35-1.22 2.97 2.97 0 0 0-1.1-1.1c-.4-.22-.8-.31-1.22-.35a8.7 8.7 0 0 0-.64-.04 2.57 2.57 0 0 0-4.74 0c-.23 0-.44.02-.63.04-.42.04-.83.13-1.22.35-.46.26-.84.64-1.1 1.1-.33.57-.37 1.2-.39 1.84a21.39 21.39 0 0 0 0 .72v.1a1 1 0 0 0 1 .99h.78a.57.57 0 0 1 0 1.15h-.77a1 1 0 0 0-1 .98v.1a63.87 63.87 0 0 0 0 .73c0 .64.05 1.27.38 1.83.26.47.64.85 1.1 1.11.56.32 1.2.37 1.84.38a20.93 20.93 0 0 0 .72 0h.1Z"
    clip-rule="evenodd"
  />
</svg>`;
const externalLinkSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.74 3.99a1 1 0 0 1 1-1H11a1 1 0 0 1 1 1v6.26a1 1 0 0 1-2 0V6.4l-6.3 6.3a1 1 0 0 1-1.4-1.42l6.29-6.3H4.74a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const facebookSvg = b`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
        />
      </g>
    </g>
    <path
      fill="#1877F2"
      d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
    />
    <path
      fill="#fff"
      d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
    />
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const farcasterSvg = b`<svg style="border-radius: 9999px; overflow: hidden;"  fill="none" viewBox="0 0 1000 1000">
  <rect width="1000" height="1000" rx="9999" ry="9999" fill="#855DCD"/>
  <path fill="#855DCD" d="M0 0h1000v1000H0V0Z" />
  <path
    fill="#fff"
    d="M320 248h354v504h-51.96V521.13h-.5c-5.76-63.8-59.31-113.81-124.54-113.81s-118.78 50-124.53 113.81h-.5V752H320V248Z"
  />
  <path
    fill="#fff"
    d="m225 320 21.16 71.46h17.9v289.09a16.29 16.29 0 0 0-16.28 16.24v19.49h-3.25a16.3 16.3 0 0 0-16.28 16.24V752h182.26v-19.48a16.22 16.22 0 0 0-16.28-16.24h-3.25v-19.5a16.22 16.22 0 0 0-16.28-16.23h-19.52V320H225Zm400.3 360.55a16.3 16.3 0 0 0-15.04 10.02 16.2 16.2 0 0 0-1.24 6.22v19.49h-3.25a16.29 16.29 0 0 0-16.27 16.24V752h182.24v-19.48a16.23 16.23 0 0 0-16.27-16.24h-3.25v-19.5a16.2 16.2 0 0 0-10.04-15 16.3 16.3 0 0 0-6.23-1.23v-289.1h17.9L775 320H644.82v360.55H625.3Z"
  />
</svg>`;
const filtersSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 3a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm2.63 5.25a1 1 0 0 1 1-1h8.75a1 1 0 1 1 0 2H3.63a1 1 0 0 1-1-1Zm2.62 5.25a1 1 0 0 1 1-1h3.5a1 1 0 0 1 0 2h-3.5a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const githubSvg = b`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const googleSvg$1 = b`<svg fill="none" viewBox="0 0 40 40">
  <path
    fill="#4285F4"
    d="M32.74 20.3c0-.93-.08-1.81-.24-2.66H20.26v5.03h7a6 6 0 0 1-2.62 3.91v3.28h4.22c2.46-2.27 3.88-5.6 3.88-9.56Z"
  />
  <path
    fill="#34A853"
    d="M20.26 33a12.4 12.4 0 0 0 8.6-3.14l-4.22-3.28a7.74 7.74 0 0 1-4.38 1.26 7.76 7.76 0 0 1-7.28-5.36H8.65v3.36A12.99 12.99 0 0 0 20.26 33Z"
  />
  <path
    fill="#FBBC05"
    d="M12.98 22.47a7.79 7.79 0 0 1 0-4.94v-3.36H8.65a12.84 12.84 0 0 0 0 11.66l3.37-2.63.96-.73Z"
  />
  <path
    fill="#EA4335"
    d="M20.26 12.18a7.1 7.1 0 0 1 4.98 1.93l3.72-3.72A12.47 12.47 0 0 0 20.26 7c-5.08 0-9.47 2.92-11.6 7.17l4.32 3.36a7.76 7.76 0 0 1 7.28-5.35Z"
  />
</svg>`;
const helpCircleSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M8.51 5.66a.83.83 0 0 0-.57-.2.83.83 0 0 0-.52.28.8.8 0 0 0-.25.52 1 1 0 0 1-2 0c0-.75.34-1.43.81-1.91a2.75 2.75 0 0 1 4.78 1.92c0 1.24-.8 1.86-1.25 2.2l-.04.03c-.47.36-.5.43-.5.65a1 1 0 1 1-2 0c0-1.25.8-1.86 1.24-2.2l.04-.04c.47-.36.5-.43.5-.65 0-.3-.1-.49-.24-.6ZM9.12 11.87a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"
    clip-rule="evenodd"
  />
</svg>`;
const imageSvg = b`<svg width="14" height="14" viewBox="0 0 14 14" fill="none">
  <path d="M4.98926 3.73932C4.2989 3.73932 3.73926 4.29896 3.73926 4.98932C3.73926 5.67968 4.2989 6.23932 4.98926 6.23932C5.67962 6.23932 6.23926 5.67968 6.23926 4.98932C6.23926 4.29896 5.67962 3.73932 4.98926 3.73932Z" fill="currentColor"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M7.60497 0.500001H6.39504C5.41068 0.499977 4.59185 0.499958 3.93178 0.571471C3.24075 0.64634 2.60613 0.809093 2.04581 1.21619C1.72745 1.44749 1.44749 1.72745 1.21619 2.04581C0.809093 2.60613 0.64634 3.24075 0.571471 3.93178C0.499958 4.59185 0.499977 5.41065 0.500001 6.39501V7.57815C0.499998 8.37476 0.499995 9.05726 0.534869 9.62725C0.570123 10.2034 0.644114 10.7419 0.828442 11.2302C0.925651 11.4877 1.05235 11.7287 1.21619 11.9542C1.44749 12.2726 1.72745 12.5525 2.04581 12.7838C2.60613 13.1909 3.24075 13.3537 3.93178 13.4285C4.59185 13.5001 5.41066 13.5 6.39503 13.5H7.60496C8.58933 13.5 9.40815 13.5001 10.0682 13.4285C10.7593 13.3537 11.3939 13.1909 11.9542 12.7838C12.2726 12.5525 12.5525 12.2726 12.7838 11.9542C13.1909 11.3939 13.3537 10.7593 13.4285 10.0682C13.5 9.40816 13.5 8.58935 13.5 7.60497V6.39505C13.5 5.41068 13.5 4.59185 13.4285 3.93178C13.3537 3.24075 13.1909 2.60613 12.7838 2.04581C12.5525 1.72745 12.2726 1.44749 11.9542 1.21619C11.3939 0.809093 10.7593 0.64634 10.0682 0.571471C9.40816 0.499958 8.58933 0.499977 7.60497 0.500001ZM3.22138 2.83422C3.38394 2.71612 3.62634 2.61627 4.14721 2.55984C4.68679 2.50138 5.39655 2.5 6.45 2.5H7.55C8.60345 2.5 9.31322 2.50138 9.8528 2.55984C10.3737 2.61627 10.6161 2.71612 10.7786 2.83422C10.9272 2.94216 11.0578 3.07281 11.1658 3.22138C11.2839 3.38394 11.3837 3.62634 11.4402 4.14721C11.4986 4.68679 11.5 5.39655 11.5 6.45V6.49703C10.9674 6.11617 10.386 5.84936 9.74213 5.81948C8.40536 5.75745 7.3556 6.73051 6.40509 7.84229C6.33236 7.92737 6.27406 7.98735 6.22971 8.02911L6.1919 8.00514L6.17483 7.99427C6.09523 7.94353 5.98115 7.87083 5.85596 7.80302C5.56887 7.64752 5.18012 7.4921 4.68105 7.4921C4.66697 7.4921 4.6529 7.49239 4.63884 7.49299C3.79163 7.52878 3.09922 8.1106 2.62901 8.55472C2.58751 8.59392 2.54594 8.6339 2.50435 8.6745C2.50011 8.34653 2.5 7.97569 2.5 7.55V6.45C2.5 5.39655 2.50138 4.68679 2.55984 4.14721C2.61627 3.62634 2.71612 3.38394 2.83422 3.22138C2.94216 3.07281 3.07281 2.94216 3.22138 2.83422ZM10.3703 8.14825C10.6798 8.37526 11.043 8.71839 11.4832 9.20889C11.4744 9.44992 11.4608 9.662 11.4402 9.8528C11.3837 10.3737 11.2839 10.6161 11.1658 10.7786C11.0578 10.9272 10.9272 11.0578 10.7786 11.1658C10.6161 11.2839 10.3737 11.3837 9.8528 11.4402C9.31322 11.4986 8.60345 11.5 7.55 11.5H6.45C5.39655 11.5 4.68679 11.4986 4.14721 11.4402C3.62634 11.3837 3.38394 11.2839 3.22138 11.1658C3.15484 11.1174 3.0919 11.0645 3.03298 11.0075C3.10126 10.9356 3.16806 10.8649 3.23317 10.7959L3.29772 10.7276C3.55763 10.4525 3.78639 10.2126 4.00232 10.0087C4.22016 9.80294 4.39412 9.66364 4.53524 9.57742C4.63352 9.51738 4.69022 9.49897 4.71275 9.49345C4.76387 9.49804 4.81803 9.51537 4.90343 9.56162C4.96409 9.59447 5.02355 9.63225 5.11802 9.69238L5.12363 9.69595C5.20522 9.74789 5.32771 9.82587 5.46078 9.89278C5.76529 10.0459 6.21427 10.186 6.74977 10.0158C7.21485 9.86796 7.59367 9.52979 7.92525 9.14195C8.91377 7.98571 9.38267 7.80495 9.64941 7.81733C9.7858 7.82366 10.0101 7.884 10.3703 8.14825Z" fill="currentColor"/>
</svg>`;
const infoCircleSvg = b`<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    d="M6 10.49a1 1 0 1 0 2 0v-2a1 1 0 0 0-2 0v2ZM7 4.49a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 14.99a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm5-7a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const mailSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.83 1.34h6.34c.68 0 1.26 0 1.73.04.5.05.97.15 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73v3.71c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.47.03-1.05.03-1.73.03H4.83c-.68 0-1.26 0-1.73-.04-.5-.04-.97-.14-1.42-.4-.52-.29-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.41A20.9 20.9 0 0 1 0 9.88v-3.7c0-.7 0-1.27.04-1.74.05-.5.14-.97.4-1.42.3-.52.72-.95 1.24-1.24.45-.25.92-.35 1.42-.4.47-.04 1.05-.04 1.73-.04ZM3.28 3.38c-.36.03-.51.08-.6.14-.21.11-.39.29-.5.5a.8.8 0 0 0-.08.19l5.16 3.44c.45.3 1.03.3 1.48 0L13.9 4.2a.79.79 0 0 0-.08-.2c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.13-.37-.04-.86-.04-1.6-.04H4.88c-.73 0-1.22 0-1.6.04ZM14 6.54 9.85 9.31a3.33 3.33 0 0 1-3.7 0L2 6.54v3.3c0 .74 0 1.22.03 1.6.04.36.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h6.25c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6v-3.3Z"
    clip-rule="evenodd"
  />
</svg>`;
const mobileSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path fill="currentColor" d="M10.81 5.81a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3 4.75A4.75 4.75 0 0 1 7.75 0h4.5A4.75 4.75 0 0 1 17 4.75v10.5A4.75 4.75 0 0 1 12.25 20h-4.5A4.75 4.75 0 0 1 3 15.25V4.75ZM7.75 2A2.75 2.75 0 0 0 5 4.75v10.5A2.75 2.75 0 0 0 7.75 18h4.5A2.75 2.75 0 0 0 15 15.25V4.75A2.75 2.75 0 0 0 12.25 2h-4.5Z"
    clip-rule="evenodd"
  />
</svg>`;
const moreSvg = b`<svg fill="none" viewBox="0 0 41 40">
  <path
    style="fill: var(--wui-color-fg-100);"
    fill-opacity=".05"
    d="M.6 20a20 20 0 1 1 40 0 20 20 0 0 1-40 0Z"
  />
  <path
    fill="#949E9E"
    d="M15.6 20.31a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM23.1 20.31a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0ZM28.1 22.81a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z"
  />
</svg>`;
const networkPlaceholderSvg = b`<svg fill="none" viewBox="0 0 22 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M16.32 13.62a3.14 3.14 0 1 1-.99 1.72l-1.6-.93a3.83 3.83 0 0 1-3.71 1 3.66 3.66 0 0 1-1.74-1l-1.6.94a3.14 3.14 0 1 1-1-1.73l1.6-.94a3.7 3.7 0 0 1 0-2 3.81 3.81 0 0 1 1.8-2.33c.29-.17.6-.3.92-.38V6.1a3.14 3.14 0 1 1 2 0l-.01.02v1.85H12a3.82 3.82 0 0 1 2.33 1.8 3.7 3.7 0 0 1 .39 2.91l1.6.93ZM2.6 16.54a1.14 1.14 0 0 0 1.98-1.14 1.14 1.14 0 0 0-1.98 1.14ZM11 2.01a1.14 1.14 0 1 0 0 2.28 1.14 1.14 0 0 0 0-2.28Zm1.68 10.45c.08-.19.14-.38.16-.58v-.05l.02-.13v-.13a1.92 1.92 0 0 0-.24-.8l-.11-.15a1.89 1.89 0 0 0-.74-.6 1.86 1.86 0 0 0-.77-.17h-.19a1.97 1.97 0 0 0-.89.34 1.98 1.98 0 0 0-.61.74 1.99 1.99 0 0 0-.16.9v.05a1.87 1.87 0 0 0 .24.74l.1.15c.12.16.26.3.42.42l.16.1.13.07.04.02a1.84 1.84 0 0 0 .76.17h.17a2 2 0 0 0 .91-.35 1.78 1.78 0 0 0 .52-.58l.03-.05a.84.84 0 0 0 .05-.11Zm5.15 4.5a1.14 1.14 0 0 0 1.14-1.97 1.13 1.13 0 0 0-1.55.41c-.32.55-.13 1.25.41 1.56Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.63 9.43a1.5 1.5 0 1 0 1.5-2.6 1.5 1.5 0 0 0-1.5 2.6Zm.32-1.55a.5.5 0 0 1 .68-.19.5.5 0 0 1 .18.68.5.5 0 0 1-.68.19.5.5 0 0 1-.18-.68ZM17.94 8.88a1.5 1.5 0 1 1-2.6-1.5 1.5 1.5 0 1 1 2.6 1.5ZM16.9 7.69a.5.5 0 0 0-.68.19.5.5 0 0 0 .18.68.5.5 0 0 0 .68-.19.5.5 0 0 0-.18-.68ZM9.75 17.75a1.5 1.5 0 1 1 2.6 1.5 1.5 1.5 0 1 1-2.6-1.5Zm1.05 1.18a.5.5 0 0 0 .68-.18.5.5 0 0 0-.18-.68.5.5 0 0 0-.68.18.5.5 0 0 0 .18.68Z"
    clip-rule="evenodd"
  />
</svg>`;
const nftPlaceholderSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.13 1h1.71c1.46 0 2.63 0 3.56.1.97.1 1.8.33 2.53.85a5 5 0 0 1 1.1 1.11c.53.73.75 1.56.86 2.53.1.93.1 2.1.1 3.55v1.72c0 1.45 0 2.62-.1 3.55-.1.97-.33 1.8-.86 2.53a5 5 0 0 1-1.1 1.1c-.73.53-1.56.75-2.53.86-.93.1-2.1.1-3.55.1H9.13c-1.45 0-2.62 0-3.56-.1-.96-.1-1.8-.33-2.52-.85a5 5 0 0 1-1.1-1.11 5.05 5.05 0 0 1-.86-2.53c-.1-.93-.1-2.1-.1-3.55V9.14c0-1.45 0-2.62.1-3.55.1-.97.33-1.8.85-2.53a5 5 0 0 1 1.1-1.1 5.05 5.05 0 0 1 2.53-.86C6.51 1 7.67 1 9.13 1ZM5.79 3.09a3.1 3.1 0 0 0-1.57.48 3 3 0 0 0-.66.67c-.24.32-.4.77-.48 1.56-.1.82-.1 1.88-.1 3.4v1.6c0 1.15 0 2.04.05 2.76l.41-.42c.5-.5.93-.92 1.32-1.24.41-.33.86-.6 1.43-.7a3 3 0 0 1 .94 0c.35.06.66.2.95.37a17.11 17.11 0 0 0 .8.45c.1-.08.2-.2.41-.4l.04-.03a27 27 0 0 1 1.95-1.84 4.03 4.03 0 0 1 1.91-.94 4 4 0 0 1 1.25 0c.73.11 1.33.46 1.91.94l.64.55V9.2c0-1.52 0-2.58-.1-3.4a3.1 3.1 0 0 0-.48-1.56 3 3 0 0 0-.66-.67 3.1 3.1 0 0 0-1.56-.48C13.37 3 12.3 3 10.79 3h-1.6c-1.52 0-2.59 0-3.4.09Zm11.18 10-.04-.05a26.24 26.24 0 0 0-1.83-1.74c-.45-.36-.73-.48-.97-.52a2 2 0 0 0-.63 0c-.24.04-.51.16-.97.52-.46.38-1.01.93-1.83 1.74l-.02.02c-.17.18-.34.34-.49.47a2.04 2.04 0 0 1-1.08.5 1.97 1.97 0 0 1-1.25-.27l-.79-.46-.02-.02a.65.65 0 0 0-.24-.1 1 1 0 0 0-.31 0c-.08.02-.21.06-.49.28-.3.24-.65.59-1.2 1.14l-.56.56-.65.66a3 3 0 0 0 .62.6c.33.24.77.4 1.57.49.81.09 1.88.09 3.4.09h1.6c1.52 0 2.58 0 3.4-.09a3.1 3.1 0 0 0 1.56-.48 3 3 0 0 0 .66-.67c.24-.32.4-.77.49-1.56l.07-1.12Zm-8.02-1.03ZM4.99 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const offSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 0a1 1 0 0 1 1 1v5.38a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1ZM5.26 2.6a1 1 0 0 1-.28 1.39 5.46 5.46 0 1 0 6.04 0 1 1 0 1 1 1.1-1.67 7.46 7.46 0 1 1-8.25 0 1 1 0 0 1 1.4.28Z"
    clip-rule="evenodd"
  />
</svg>`;
const playStoreSvg = b` <svg
  width="36"
  height="36"
  fill="none"
>
  <path
    d="M0 8a8 8 0 0 1 8-8h20a8 8 0 0 1 8 8v20a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8Z"
    fill="#fff"
    fill-opacity=".05"
  />
  <path
    d="m18.262 17.513-8.944 9.49v.01a2.417 2.417 0 0 0 3.56 1.452l.026-.017 10.061-5.803-4.703-5.132Z"
    fill="#EA4335"
  />
  <path
    d="m27.307 15.9-.008-.008-4.342-2.52-4.896 4.36 4.913 4.912 4.325-2.494a2.42 2.42 0 0 0 .008-4.25Z"
    fill="#FBBC04"
  />
  <path
    d="M9.318 8.997c-.05.202-.084.403-.084.622V26.39c0 .218.025.42.084.621l9.246-9.247-9.246-8.768Z"
    fill="#4285F4"
  />
  <path
    d="m18.33 18 4.627-4.628-10.053-5.828a2.427 2.427 0 0 0-3.586 1.444L18.329 18Z"
    fill="#34A853"
  />
  <path
    d="M8 .5h20A7.5 7.5 0 0 1 35.5 8v20a7.5 7.5 0 0 1-7.5 7.5H8A7.5 7.5 0 0 1 .5 28V8A7.5 7.5 0 0 1 8 .5Z"
    stroke="#fff"
    stroke-opacity=".05"
  />
</svg>`;
const plusSvg = b`<svg
  width="13"
  height="12"
  viewBox="0 0 13 12"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M0.794373 5.99982C0.794373 5.52643 1.17812 5.14268 1.6515 5.14268H5.643V1.15109C5.643 0.677701 6.02675 0.293946 6.50012 0.293945C6.9735 0.293946 7.35725 0.677701 7.35725 1.15109V5.14268H11.3488C11.8221 5.14268 12.2059 5.52643 12.2059 5.99982C12.2059 6.47321 11.8221 6.85696 11.3488 6.85696H7.35725V10.8486C7.35725 11.3219 6.9735 11.7057 6.50012 11.7057C6.02675 11.7057 5.643 11.3219 5.643 10.8486V6.85696H1.6515C1.17812 6.85696 0.794373 6.47321 0.794373 5.99982Z"
  /></svg
>`;
const qrCodeIcon = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M3 6a3 3 0 0 1 3-3h1a1 1 0 1 0 0-2H6a5 5 0 0 0-5 5v1a1 1 0 0 0 2 0V6ZM13 1a1 1 0 1 0 0 2h1a3 3 0 0 1 3 3v1a1 1 0 1 0 2 0V6a5 5 0 0 0-5-5h-1ZM3 13a1 1 0 1 0-2 0v1a5 5 0 0 0 5 5h1a1 1 0 1 0 0-2H6a3 3 0 0 1-3-3v-1ZM19 13a1 1 0 1 0-2 0v1a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1.01a5 5 0 0 0 5-5v-1ZM5.3 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05A1.5 1.5 0 0 0 9.2 8.14c.06-.2.06-.43.06-.89s0-.7-.06-.89A1.5 1.5 0 0 0 8.14 5.3c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM10.8 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM5.26 12.75c0-.46 0-.7.05-.89a1.5 1.5 0 0 1 1.06-1.06c.19-.05.42-.05.89-.05.46 0 .7 0 .88.05.52.14.93.54 1.06 1.06.06.2.06.43.06.89s0 .7-.06.89a1.5 1.5 0 0 1-1.06 1.06c-.19.05-.42.05-.88.05-.47 0-.7 0-.9-.05a1.5 1.5 0 0 1-1.05-1.06c-.05-.2-.05-.43-.05-.89ZM10.8 11.86c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06Z"
  />
</svg>`;
const recycleHorizontalSvg = b`<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    d="M8.8071 0.292893C9.19763 0.683417 9.19763 1.31658 8.8071 1.70711L6.91421 3.6H11.8404C14.3368 3.6 16.5533 5.1975 17.3427 7.56588L17.4487 7.88377C17.6233 8.40772 17.3402 8.97404 16.8162 9.14868C16.2923 9.32333 15.726 9.04017 15.5513 8.51623L15.4453 8.19834C14.9281 6.64664 13.476 5.6 11.8404 5.6H6.91421L8.8071 7.49289C9.19763 7.88342 9.19763 8.51658 8.8071 8.90711C8.41658 9.29763 7.78341 9.29763 7.39289 8.90711L3.79289 5.30711C3.40236 4.91658 3.40236 4.28342 3.79289 3.89289L7.39289 0.292893C7.78341 -0.0976311 8.41658 -0.0976311 8.8071 0.292893ZM4.18377 10.8513C4.70771 10.6767 5.27403 10.9598 5.44868 11.4838L5.55464 11.8017C6.07188 13.3534 7.52401 14.4 9.15964 14.4L14.0858 14.4L12.1929 12.5071C11.8024 12.1166 11.8024 11.4834 12.1929 11.0929C12.5834 10.7024 13.2166 10.7024 13.6071 11.0929L17.2071 14.6929C17.5976 15.0834 17.5976 15.7166 17.2071 16.1071L13.6071 19.7071C13.2166 20.0976 12.5834 20.0976 12.1929 19.7071C11.8024 19.3166 11.8024 18.6834 12.1929 18.2929L14.0858 16.4L9.15964 16.4C6.66314 16.4 4.44674 14.8025 3.65728 12.4341L3.55131 12.1162C3.37667 11.5923 3.65983 11.026 4.18377 10.8513Z"
  /></svg
>`;
const refreshSvg = b`<svg fill="none" viewBox="0 0 14 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.94 1.04a1 1 0 0 1 .7 1.23l-.48 1.68a5.85 5.85 0 0 1 8.53 4.32 5.86 5.86 0 0 1-11.4 2.56 1 1 0 0 1 1.9-.57 3.86 3.86 0 1 0 1.83-4.5l1.87.53a1 1 0 0 1-.55 1.92l-4.1-1.15a1 1 0 0 1-.69-1.23l1.16-4.1a1 1 0 0 1 1.23-.7Z"
    clip-rule="evenodd"
  />
</svg>`;
const searchSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.36 4.21a5.14 5.14 0 1 0 0 10.29 5.14 5.14 0 0 0 0-10.29ZM1.64 9.36a7.71 7.71 0 1 1 14 4.47l2.52 2.5a1.29 1.29 0 1 1-1.82 1.83l-2.51-2.51A7.71 7.71 0 0 1 1.65 9.36Z"
    clip-rule="evenodd"
  />
</svg>`;
const sendSvg = b`<svg fill="none" viewBox="0 0 21 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.3808 4.34812C13.72 4.47798 12.8501 4.7587 11.5748 5.17296L9.00869 6.00646C6.90631 6.68935 5.40679 7.17779 4.38121 7.63178C3.87166 7.85734 3.5351 8.05091 3.32022 8.22035C3.11183 8.38466 3.07011 8.48486 3.05969 8.51817C2.98058 8.77103 2.98009 9.04195 3.05831 9.29509C3.06861 9.32844 3.10998 9.42878 3.31777 9.59384C3.53205 9.76404 3.86792 9.95881 4.37667 10.1862C5.29287 10.5957 6.58844 11.0341 8.35529 11.6164L10.8876 8.59854C11.2426 8.17547 11.8733 8.12028 12.2964 8.47528C12.7195 8.83029 12.7746 9.46104 12.4196 9.88412L9.88738 12.9019C10.7676 14.5408 11.4244 15.7406 11.9867 16.5718C12.299 17.0333 12.5491 17.3303 12.7539 17.5117C12.9526 17.6877 13.0586 17.711 13.0932 17.7154C13.3561 17.7484 13.6228 17.7009 13.8581 17.5791C13.8891 17.563 13.9805 17.5046 14.1061 17.2708C14.2357 17.0298 14.3679 16.6647 14.5015 16.1237C14.7705 15.0349 14.9912 13.4733 15.2986 11.2843L15.6738 8.61249C15.8603 7.28456 15.9857 6.37917 15.9989 5.7059C16.012 5.03702 15.9047 4.8056 15.8145 4.69183C15.7044 4.55297 15.5673 4.43792 15.4114 4.35365C15.2837 4.28459 15.0372 4.2191 14.3808 4.34812ZM7.99373 13.603C6.11919 12.9864 4.6304 12.4902 3.5606 12.0121C2.98683 11.7557 2.4778 11.4808 2.07383 11.1599C1.66337 10.8339 1.31312 10.4217 1.14744 9.88551C0.949667 9.24541 0.950886 8.56035 1.15094 7.92096C1.31852 7.38534 1.67024 6.97442 2.08185 6.64985C2.48697 6.33041 2.99697 6.05734 3.57166 5.80295C4.70309 5.3021 6.30179 4.78283 8.32903 4.12437L11.0196 3.25042C12.2166 2.86159 13.2017 2.54158 13.9951 2.38566C14.8065 2.22618 15.6202 2.19289 16.3627 2.59437C16.7568 2.80747 17.1035 3.09839 17.3818 3.4495C17.9062 4.111 18.0147 4.91815 17.9985 5.74496C17.9827 6.55332 17.8386 7.57903 17.6636 8.82534L17.2701 11.6268C16.9737 13.7376 16.7399 15.4022 16.4432 16.6034C16.2924 17.2135 16.1121 17.7632 15.8678 18.2176C15.6197 18.6794 15.2761 19.0971 14.7777 19.3551C14.1827 19.6632 13.5083 19.7833 12.8436 19.6997C12.2867 19.6297 11.82 19.3563 11.4277 19.0087C11.0415 18.6666 10.6824 18.213 10.3302 17.6925C9.67361 16.722 8.92648 15.342 7.99373 13.603Z"
    clip-rule="evenodd"
  />
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="21"
    height="20"
    viewBox="0 0 21 20"
    fill="none"
  ></svg></svg
>`;
const swapHorizontalSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.76.3a1 1 0 0 1 0 1.4L4.07 4.4h9a1 1 0 1 1 0 2h-9l2.69 2.68a1 1 0 1 1-1.42 1.42L.95 6.09a1 1 0 0 1 0-1.4l4.4-4.4a1 1 0 0 1 1.4 0Zm6.49 9.21a1 1 0 0 1 1.41 0l4.39 4.4a1 1 0 0 1 0 1.4l-4.39 4.4a1 1 0 0 1-1.41-1.42l2.68-2.68h-9a1 1 0 0 1 0-2h9l-2.68-2.68a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const swapHorizontalBoldSvg = b`<svg width="10" height="10" viewBox="0 0 10 10">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.77986 0.566631C4.0589 0.845577 4.0589 1.29784 3.77986 1.57678L3.08261 2.2738H6.34184C6.73647 2.2738 7.05637 2.5936 7.05637 2.98808C7.05637 3.38257 6.73647 3.70237 6.34184 3.70237H3.08261L3.77986 4.39938C4.0589 4.67833 4.0589 5.13059 3.77986 5.40954C3.50082 5.68848 3.04841 5.68848 2.76937 5.40954L0.852346 3.49316C0.573306 3.21421 0.573306 2.76195 0.852346 2.48301L2.76937 0.566631C3.04841 0.287685 3.50082 0.287685 3.77986 0.566631ZM6.22 4.59102C6.49904 4.31208 6.95145 4.31208 7.23049 4.59102L9.14751 6.5074C9.42655 6.78634 9.42655 7.23861 9.14751 7.51755L7.23049 9.43393C6.95145 9.71287 6.49904 9.71287 6.22 9.43393C5.94096 9.15498 5.94096 8.70272 6.22 8.42377L6.91725 7.72676L3.65802 7.72676C3.26339 7.72676 2.94349 7.40696 2.94349 7.01247C2.94349 6.61798 3.26339 6.29819 3.65802 6.29819L6.91725 6.29819L6.22 5.60117C5.94096 5.32223 5.94096 4.86997 6.22 4.59102Z"
    clip-rule="evenodd"
  />
</svg>`;
const swapHorizontalMediumSvg = b`<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M13.7306 3.24213C14.0725 3.58384 14.0725 4.13786 13.7306 4.47957L10.7418 7.46737C10.4 7.80908 9.84581 7.80908 9.50399 7.46737C9.16216 7.12567 9.16216 6.57165 9.50399 6.22994L10.9986 4.73585H5.34082C4.85741 4.73585 4.46553 4.3441 4.46553 3.86085C4.46553 3.3776 4.85741 2.98585 5.34082 2.98585L10.9986 2.98585L9.50399 1.49177C9.16216 1.15006 9.16216 0.596037 9.50399 0.254328C9.84581 -0.0873803 10.4 -0.0873803 10.7418 0.254328L13.7306 3.24213ZM9.52515 10.1352C9.52515 10.6185 9.13327 11.0102 8.64986 11.0102L2.9921 11.0102L4.48669 12.5043C4.82852 12.846 4.82852 13.4001 4.48669 13.7418C4.14487 14.0835 3.59066 14.0835 3.24884 13.7418L0.26003 10.754C0.0958806 10.5899 0.0036621 10.3673 0.00366211 10.1352C0.00366212 9.90318 0.0958806 9.68062 0.26003 9.51652L3.24884 6.52872C3.59066 6.18701 4.14487 6.18701 4.48669 6.52872C4.82851 6.87043 4.82851 7.42445 4.48669 7.76616L2.9921 9.26024L8.64986 9.26024C9.13327 9.26024 9.52515 9.65199 9.52515 10.1352Z"
    fill="currentColor"
  />
</svg>

`;
const swapHorizontalRoundedBoldSvg = b`<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20" fill="none">
  <path 
    fill="currentColor"
    fill-rule="evenodd" 
    clip-rule="evenodd" 
    d="M8.3071 0.292893C8.69763 0.683417 8.69763 1.31658 8.3071 1.70711L6.41421 3.6H11.3404C13.8368 3.6 16.0533 5.1975 16.8427 7.56588L16.9487 7.88377C17.1233 8.40772 16.8402 8.97404 16.3162 9.14868C15.7923 9.32333 15.226 9.04017 15.0513 8.51623L14.9453 8.19834C14.4281 6.64664 12.976 5.6 11.3404 5.6H6.41421L8.3071 7.49289C8.69763 7.88342 8.69763 8.51658 8.3071 8.90711C7.91658 9.29763 7.28341 9.29763 6.89289 8.90711L3.29289 5.30711C2.90236 4.91658 2.90236 4.28342 3.29289 3.89289L6.89289 0.292893C7.28341 -0.0976311 7.91658 -0.0976311 8.3071 0.292893ZM3.68377 10.8513C4.20771 10.6767 4.77403 10.9598 4.94868 11.4838L5.05464 11.8017C5.57188 13.3534 7.024 14.4 8.65964 14.4L13.5858 14.4L11.6929 12.5071C11.3024 12.1166 11.3024 11.4834 11.6929 11.0929C12.0834 10.7024 12.7166 10.7024 13.1071 11.0929L16.7071 14.6929C17.0976 15.0834 17.0976 15.7166 16.7071 16.1071L13.1071 19.7071C12.7166 20.0976 12.0834 20.0976 11.6929 19.7071C11.3024 19.3166 11.3024 18.6834 11.6929 18.2929L13.5858 16.4L8.65964 16.4C6.16314 16.4 3.94674 14.8025 3.15728 12.4341L3.05131 12.1162C2.87667 11.5923 3.15983 11.026 3.68377 10.8513Z" 
  />
</svg>`;
const swapVerticalSvg = b`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.48 2.18a1 1 0 0 1 1.41 0l2.68 2.68a1 1 0 1 1-1.41 1.42l-.98-.98v4.56a1 1 0 0 1-2 0V5.3l-.97.98A1 1 0 0 1 .79 4.86l2.69-2.68Zm6.34 2.93a1 1 0 0 1 1 1v4.56l.97-.98a1 1 0 1 1 1.42 1.42l-2.69 2.68a1 1 0 0 1-1.41 0l-2.68-2.68a1 1 0 0 1 1.41-1.42l.98.98V6.1a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;
const telegramSvg = b`<svg width="32" height="32" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <g clip-path="url(#a)">
    <path fill="url(#b)" d="M0 0h32v32H0z"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M7.034 15.252c4.975-2.167 8.293-3.596 9.953-4.287 4.74-1.971 5.725-2.314 6.366-2.325.142-.002.457.033.662.198.172.14.22.33.243.463.022.132.05.435.028.671-.257 2.7-1.368 9.248-1.933 12.27-.24 1.28-.71 1.708-1.167 1.75-.99.091-1.743-.655-2.703-1.284-1.502-.985-2.351-1.598-3.81-2.558-1.684-1.11-.592-1.721.368-2.718.252-.261 4.619-4.233 4.703-4.594.01-.045.02-.213-.08-.301-.1-.09-.246-.059-.353-.035-.15.034-2.55 1.62-7.198 4.758-.682.468-1.298.696-1.851.684-.61-.013-1.782-.344-2.653-.628-1.069-.347-1.918-.53-1.845-1.12.039-.308.462-.623 1.27-.944Z" fill="#fff"/>
  </g>
  <path d="M.5 16C.5 7.44 7.44.5 16 .5 24.56.5 31.5 7.44 31.5 16c0 8.56-6.94 15.5-15.5 15.5C7.44 31.5.5 24.56.5 16Z" stroke="#141414" stroke-opacity=".05"/>
  <defs>
    <linearGradient id="b" x1="1600" y1="0" x2="1600" y2="3176.27" gradientUnits="userSpaceOnUse">
      <stop stop-color="#2AABEE"/>
      <stop offset="1" stop-color="#229ED9"/>
    </linearGradient>
    <clipPath id="a">
      <path d="M0 16C0 7.163 7.163 0 16 0s16 7.163 16 16-7.163 16-16 16S0 24.837 0 16Z" fill="#fff"/>
    </clipPath>
  </defs>
</svg>`;
const threeDotsSvg = b`<svg width="14" height="15" viewBox="0 0 14 15" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M7 3.71875C6.0335 3.71875 5.25 2.93525 5.25 1.96875C5.25 1.00225 6.0335 0.21875 7 0.21875C7.9665 0.21875 8.75 1.00225 8.75 1.96875C8.75 2.93525 7.9665 3.71875 7 3.71875Z" fill="#949E9E"/>
  <path d="M7 8.96875C6.0335 8.96875 5.25 8.18525 5.25 7.21875C5.25 6.25225 6.0335 5.46875 7 5.46875C7.9665 5.46875 8.75 6.25225 8.75 7.21875C8.75 8.18525 7.9665 8.96875 7 8.96875Z" fill="#949E9E"/>
  <path d="M5.25 12.4688C5.25 13.4352 6.0335 14.2187 7 14.2187C7.9665 14.2187 8.75 13.4352 8.75 12.4688C8.75 11.5023 7.9665 10.7188 7 10.7188C6.0335 10.7188 5.25 11.5023 5.25 12.4688Z" fill="#949E9E"/>
</svg>`;
const twitchSvg = b`<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;
const twitterIconSvg = b`<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
  />
</svg>`;
const verifySvg = b`<svg fill="none" viewBox="0 0 28 28">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M18.1 4.76c-.42-.73-1.33-1.01-2.09-.66l-1.42.66c-.37.18-.8.18-1.18 0l-1.4-.65a1.63 1.63 0 0 0-2.1.66l-.84 1.45c-.2.34-.53.59-.92.67l-1.7.35c-.83.17-1.39.94-1.3 1.78l.19 1.56c.04.39-.08.78-.33 1.07l-1.12 1.3c-.52.6-.52 1.5 0 2.11L5 16.38c.25.3.37.68.33 1.06l-.18 1.57c-.1.83.46 1.6 1.28 1.78l1.7.35c.4.08.73.32.93.66l.84 1.43a1.63 1.63 0 0 0 2.09.66l1.41-.66c.37-.17.8-.17 1.18 0l1.43.67c.76.35 1.66.07 2.08-.65l.86-1.45c.2-.34.54-.58.92-.66l1.68-.35A1.63 1.63 0 0 0 22.84 19l-.18-1.57a1.4 1.4 0 0 1 .33-1.06l1.12-1.32c.52-.6.52-1.5 0-2.11l-1.12-1.3a1.4 1.4 0 0 1-.33-1.07l.18-1.57c.1-.83-.46-1.6-1.28-1.77l-1.68-.35a1.4 1.4 0 0 1-.92-.66l-.86-1.47Zm-3.27-3.2a4.43 4.43 0 0 1 5.69 1.78l.54.93 1.07.22a4.43 4.43 0 0 1 3.5 4.84l-.11.96.7.83a4.43 4.43 0 0 1 .02 5.76l-.72.85.1.96a4.43 4.43 0 0 1-3.5 4.84l-1.06.22-.54.92a4.43 4.43 0 0 1-5.68 1.77l-.84-.4-.82.39a4.43 4.43 0 0 1-5.7-1.79l-.51-.89-1.09-.22a4.43 4.43 0 0 1-3.5-4.84l.1-.96-.72-.85a4.43 4.43 0 0 1 .01-5.76l.71-.83-.1-.95a4.43 4.43 0 0 1 3.5-4.84l1.08-.23.53-.9a4.43 4.43 0 0 1 5.7-1.8l.81.38.83-.39ZM18.2 9.4c.65.42.84 1.28.42 1.93l-4.4 6.87a1.4 1.4 0 0 1-2.26.14L9.5 15.39a1.4 1.4 0 0 1 2.15-1.8l1.23 1.48 3.38-5.26a1.4 1.4 0 0 1 1.93-.42Z"
    clip-rule="evenodd"
  />
</svg>`;
const verifyFilledSvg = b`<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="m4.1 12.43-.45-.78-.93-.2a1.65 1.65 0 0 1-1.31-1.8l.1-.86-.61-.71a1.65 1.65 0 0 1 0-2.16l.6-.7-.09-.85c-.1-.86.47-1.64 1.3-1.81l.94-.2.45-.78A1.65 1.65 0 0 1 6.23.9l.77.36.78-.36c.77-.36 1.69-.07 2.12.66l.47.8.91.2c.84.17 1.4.95 1.31 1.8l-.1.86.6.7c.54.62.54 1.54.01 2.16l-.6.71.09.86c.1.85-.47 1.63-1.3 1.8l-.92.2-.47.79a1.65 1.65 0 0 1-2.12.66L7 12.74l-.77.36c-.78.35-1.7.07-2.13-.67Zm5.74-6.9a1 1 0 1 0-1.68-1.07L6.32 7.3l-.55-.66a1 1 0 0 0-1.54 1.28l1.43 1.71a1 1 0 0 0 1.61-.1l2.57-4Z"
    clip-rule="evenodd"
  />
</svg>`;
const walletPlaceholderSvg = b`
  <svg fill="none" viewBox="0 0 48 44">
    <path
      style="fill: var(--wui-color-bg-300);"
      d="M4.56 8.64c-1.23 1.68-1.23 4.08-1.23 8.88v8.96c0 4.8 0 7.2 1.23 8.88.39.55.87 1.02 1.41 1.42C7.65 38 10.05 38 14.85 38h14.3c4.8 0 7.2 0 8.88-1.22a6.4 6.4 0 0 0 1.41-1.42c.83-1.14 1.1-2.6 1.19-4.92a6.4 6.4 0 0 0 5.16-4.65c.21-.81.21-1.8.21-3.79 0-1.98 0-2.98-.22-3.79a6.4 6.4 0 0 0-5.15-4.65c-.1-2.32-.36-3.78-1.19-4.92a6.4 6.4 0 0 0-1.41-1.42C36.35 6 33.95 6 29.15 6h-14.3c-4.8 0-7.2 0-8.88 1.22a6.4 6.4 0 0 0-1.41 1.42Z"
    />
    <path
      style="fill: var(--wui-color-fg-200);"
      fill-rule="evenodd"
      d="M2.27 11.33a6.4 6.4 0 0 1 6.4-6.4h26.66a6.4 6.4 0 0 1 6.4 6.4v1.7a6.4 6.4 0 0 1 5.34 6.3v5.34a6.4 6.4 0 0 1-5.34 6.3v1.7a6.4 6.4 0 0 1-6.4 6.4H8.67a6.4 6.4 0 0 1-6.4-6.4V11.33ZM39.6 31.07h-6.93a9.07 9.07 0 1 1 0-18.14h6.93v-1.6a4.27 4.27 0 0 0-4.27-4.26H8.67a4.27 4.27 0 0 0-4.27 4.26v21.34a4.27 4.27 0 0 0 4.27 4.26h26.66a4.27 4.27 0 0 0 4.27-4.26v-1.6Zm-6.93-16a6.93 6.93 0 0 0 0 13.86h8a4.27 4.27 0 0 0 4.26-4.26v-5.34a4.27 4.27 0 0 0-4.26-4.26h-8Z"
      clip-rule="evenodd"
    />
  </svg>
`;
const walletSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
    clip-rule="evenodd"
  />
</svg>`;
const walletConnectSvg = b`<svg fill="none" viewBox="0 0 96 67">
  <path
    fill="currentColor"
    d="M25.32 18.8a32.56 32.56 0 0 1 45.36 0l1.5 1.47c.63.62.63 1.61 0 2.22l-5.15 5.05c-.31.3-.82.3-1.14 0l-2.07-2.03a22.71 22.71 0 0 0-31.64 0l-2.22 2.18c-.31.3-.82.3-1.14 0l-5.15-5.05a1.55 1.55 0 0 1 0-2.22l1.65-1.62Zm56.02 10.44 4.59 4.5c.63.6.63 1.6 0 2.21l-20.7 20.26c-.62.61-1.63.61-2.26 0L48.28 41.83a.4.4 0 0 0-.56 0L33.03 56.21c-.63.61-1.64.61-2.27 0L10.07 35.95a1.55 1.55 0 0 1 0-2.22l4.59-4.5a1.63 1.63 0 0 1 2.27 0L31.6 43.63a.4.4 0 0 0 .57 0l14.69-14.38a1.63 1.63 0 0 1 2.26 0l14.69 14.38a.4.4 0 0 0 .57 0l14.68-14.38a1.63 1.63 0 0 1 2.27 0Z"
  />
  <path
    stroke="#000"
    stroke-opacity=".1"
    d="M25.67 19.15a32.06 32.06 0 0 1 44.66 0l1.5 1.48c.43.42.43 1.09 0 1.5l-5.15 5.05a.31.31 0 0 1-.44 0l-2.07-2.03a23.21 23.21 0 0 0-32.34 0l-2.22 2.18a.31.31 0 0 1-.44 0l-5.15-5.05a1.05 1.05 0 0 1 0-1.5l1.65-1.63ZM81 29.6l4.6 4.5c.42.41.42 1.09 0 1.5l-20.7 20.26c-.43.43-1.14.43-1.57 0L48.63 41.47a.9.9 0 0 0-1.26 0L32.68 55.85c-.43.43-1.14.43-1.57 0L10.42 35.6a1.05 1.05 0 0 1 0-1.5l4.59-4.5a1.13 1.13 0 0 1 1.57 0l14.68 14.38a.9.9 0 0 0 1.27 0l-.35-.35.35.35L47.22 29.6a1.13 1.13 0 0 1 1.56 0l14.7 14.38a.9.9 0 0 0 1.26 0L79.42 29.6a1.13 1.13 0 0 1 1.57 0Z"
  />
</svg>`;
const warningCircleSvg = b`<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M11 6.67a1 1 0 1 0-2 0v2.66a1 1 0 0 0 2 0V6.67ZM10 14.5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 1a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm-7 9a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"
    clip-rule="evenodd"
  />
</svg>`;
const lightbulbSvg$1 = b`<svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M5.00177 1.78569C3.8179 1.78569 2.85819 2.74508 2.85819 3.92855C2.85819 4.52287 3.09928 5.05956 3.49077 5.4485L3.5005 5.45817C3.64381 5.60054 3.76515 5.72108 3.85631 5.81845C3.93747 5.90512 4.05255 6.03218 4.12889 6.1805C4.16999 6.26034 4.19 6.30843 4.21768 6.39385C4.22145 6.40546 4.22499 6.41703 4.22833 6.42855H5.77521C5.77854 6.41703 5.78208 6.40547 5.78585 6.39385C5.81353 6.30843 5.83354 6.26034 5.87464 6.1805C5.95098 6.03218 6.06606 5.90512 6.14722 5.81845C6.23839 5.72108 6.35973 5.60053 6.50304 5.45816L6.51276 5.4485C6.90425 5.05956 7.14534 4.52287 7.14534 3.92855C7.14534 2.74508 6.18563 1.78569 5.00177 1.78569ZM5.71629 7.85712H4.28724C4.28724 8.21403 4.28876 8.40985 4.30703 8.54571C4.30727 8.54748 4.30751 8.54921 4.30774 8.55091C4.30944 8.55115 4.31118 8.55138 4.31295 8.55162C4.44884 8.56989 4.64474 8.5714 5.00177 8.5714C5.3588 8.5714 5.55469 8.56989 5.69059 8.55162C5.69236 8.55138 5.69409 8.55115 5.69579 8.55091C5.69603 8.54921 5.69627 8.54748 5.6965 8.54571C5.71477 8.40985 5.71629 8.21403 5.71629 7.85712ZM2.85819 7.14283C2.85819 6.9948 2.85796 6.91114 2.8548 6.85032C2.85461 6.84656 2.85441 6.84309 2.85421 6.83988C2.84393 6.8282 2.83047 6.81334 2.81301 6.79469C2.74172 6.71856 2.63908 6.61643 2.48342 6.46178C1.83307 5.81566 1.42914 4.91859 1.42914 3.92855C1.42914 1.9561 3.02866 0.357117 5.00177 0.357117C6.97487 0.357117 8.57439 1.9561 8.57439 3.92855C8.57439 4.91859 8.17047 5.81566 7.52012 6.46178C7.36445 6.61643 7.26182 6.71856 7.19053 6.79469C7.17306 6.81334 7.1596 6.8282 7.14932 6.83988C7.14912 6.84309 7.14892 6.84656 7.14873 6.85032C7.14557 6.91114 7.14534 6.9948 7.14534 7.14283V7.85712C7.14534 7.87009 7.14535 7.88304 7.14535 7.89598C7.14541 8.19889 7.14547 8.49326 7.11281 8.73606C7.076 9.00978 6.98631 9.32212 6.72678 9.58156C6.46726 9.841 6.15481 9.93065 5.881 9.96745C5.63813 10.0001 5.34365 10 5.04064 9.99998C5.0277 9.99998 5.01474 9.99998 5.00177 9.99998C4.98879 9.99998 4.97583 9.99998 4.96289 9.99998C4.65988 10 4.36541 10.0001 4.12253 9.96745C3.84872 9.93065 3.53628 9.841 3.27675 9.58156C3.01722 9.32212 2.92753 9.00978 2.89072 8.73606C2.85807 8.49326 2.85812 8.19889 2.85818 7.89598C2.85819 7.88304 2.85819 7.87008 2.85819 7.85712V7.14283ZM7.1243 6.86977C7.12366 6.87069 7.1233 6.87116 7.12327 6.87119C7.12323 6.87123 7.12356 6.87076 7.1243 6.86977ZM2.88027 6.8712C2.88025 6.87119 2.87988 6.8707 2.87921 6.86975C2.87995 6.87072 2.88028 6.8712 2.88027 6.8712Z" fill="#949E9E"/>
</svg>`;
const idSvg = b`<svg
 xmlns="http://www.w3.org/2000/svg"
 width="28"
 height="28"
 viewBox="0 0 28 28"
 fill="none">
  <path
    fill="#949E9E"
    fill-rule="evenodd"
    d="M7.974 2.975h12.052c1.248 0 2.296 0 3.143.092.89.096 1.723.307 2.461.844a4.9 4.9 0 0 1 1.084 1.084c.537.738.748 1.57.844 2.461.092.847.092 1.895.092 3.143v6.802c0 1.248 0 2.296-.092 3.143-.096.89-.307 1.723-.844 2.461a4.9 4.9 0 0 1-1.084 1.084c-.738.537-1.57.748-2.461.844-.847.092-1.895.092-3.143.092H7.974c-1.247 0-2.296 0-3.143-.092-.89-.096-1.723-.307-2.461-.844a4.901 4.901 0 0 1-1.084-1.084c-.537-.738-.748-1.571-.844-2.461C.35 19.697.35 18.649.35 17.4v-6.802c0-1.248 0-2.296.092-3.143.096-.89.307-1.723.844-2.461A4.9 4.9 0 0 1 2.37 3.91c.738-.537 1.571-.748 2.461-.844.847-.092 1.895-.092 3.143-.092ZM5.133 5.85c-.652.071-.936.194-1.117.326a2.1 2.1 0 0 0-.465.465c-.132.181-.255.465-.325 1.117-.074.678-.076 1.573-.076 2.917v6.65c0 1.344.002 2.239.076 2.917.07.652.193.936.325 1.117a2.1 2.1 0 0 0 .465.465c.181.132.465.255 1.117.326.678.073 1.574.075 2.917.075h11.9c1.344 0 2.239-.002 2.917-.075.652-.071.936-.194 1.117-.326.179-.13.335-.286.465-.465.132-.181.255-.465.326-1.117.073-.678.075-1.573.075-2.917v-6.65c0-1.344-.002-2.239-.075-2.917-.071-.652-.194-.936-.326-1.117a2.1 2.1 0 0 0-.465-.465c-.181-.132-.465-.255-1.117-.326-.678-.073-1.573-.075-2.917-.075H8.05c-1.343 0-2.239.002-2.917.075Zm.467 7.275a3.15 3.15 0 1 1 6.3 0 3.15 3.15 0 0 1-6.3 0Zm8.75-1.75a1.4 1.4 0 0 1 1.4-1.4h3.5a1.4 1.4 0 0 1 0 2.8h-3.5a1.4 1.4 0 0 1-1.4-1.4Zm0 5.25a1.4 1.4 0 0 1 1.4-1.4H21a1.4 1.4 0 1 1 0 2.8h-5.25a1.4 1.4 0 0 1-1.4-1.4Z"
    clip-rule="evenodd"/>
</svg>`;
const xSvg = b`<svg fill="none" viewBox="0 0 41 40">
  <g clip-path="url(#a)">
    <path fill="#000" d="M.8 0h40v40H.8z" />
    <path
      fill="#fff"
      d="m22.63 18.46 7.14-8.3h-1.69l-6.2 7.2-4.96-7.2H11.2l7.5 10.9-7.5 8.71h1.7l6.55-7.61 5.23 7.61h5.72l-7.77-11.31Zm-9.13-7.03h2.6l11.98 17.13h-2.6L13.5 11.43Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M.8 20a20 20 0 1 1 40 0 20 20 0 0 1-40 0Z" /></clipPath>
  </defs>
</svg>`;
var __decorate$2O = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const svgOptions$1 = {
  add: addSvg,
  allWallets: allWalletsSvg,
  arrowBottomCircle: arrowBottomCircleSvg,
  appStore: appStoreSvg,
  apple: appleSvg,
  arrowBottom: arrowBottomSvg,
  arrowLeft: arrowLeftSvg,
  arrowRight: arrowRightSvg,
  arrowTop: arrowTopSvg,
  bank: bankSvg,
  browser: browserSvg$1,
  card: cardSvg,
  checkmark: checkmarkSvg,
  checkmarkBold: checkmarkBoldSvg,
  chevronBottom: chevronBottomSvg,
  chevronLeft: chevronLeftSvg,
  chevronRight: chevronRightSvg,
  chevronTop: chevronTopSvg,
  chromeStore: chromeStoreSvg,
  clock: clockSvg,
  close: closeSvg,
  compass: compassSvg,
  coinPlaceholder: coinPlaceholderSvg,
  copy: copySvg,
  cursor: cursorSvg,
  cursorTransparent: cursorTransparentSvg,
  desktop: desktopSvg,
  disconnect: disconnectSvg,
  discord: discordSvg,
  etherscan: etherscanSvg,
  extension: extensionSvg,
  externalLink: externalLinkSvg,
  facebook: facebookSvg,
  farcaster: farcasterSvg,
  filters: filtersSvg,
  github: githubSvg,
  google: googleSvg$1,
  helpCircle: helpCircleSvg,
  image: imageSvg,
  id: idSvg,
  infoCircle: infoCircleSvg,
  lightbulb: lightbulbSvg$1,
  mail: mailSvg,
  mobile: mobileSvg,
  more: moreSvg,
  networkPlaceholder: networkPlaceholderSvg,
  nftPlaceholder: nftPlaceholderSvg,
  off: offSvg,
  playStore: playStoreSvg,
  plus: plusSvg,
  qrCode: qrCodeIcon,
  recycleHorizontal: recycleHorizontalSvg,
  refresh: refreshSvg,
  search: searchSvg,
  send: sendSvg,
  swapHorizontal: swapHorizontalSvg,
  swapHorizontalMedium: swapHorizontalMediumSvg,
  swapHorizontalBold: swapHorizontalBoldSvg,
  swapHorizontalRoundedBold: swapHorizontalRoundedBoldSvg,
  swapVertical: swapVerticalSvg,
  telegram: telegramSvg,
  threeDots: threeDotsSvg,
  twitch: twitchSvg,
  twitter: xSvg,
  twitterIcon: twitterIconSvg,
  verify: verifySvg,
  verifyFilled: verifyFilledSvg,
  wallet: walletSvg,
  walletConnect: walletConnectSvg,
  walletPlaceholder: walletPlaceholderSvg,
  warningCircle: warningCircleSvg,
  x: xSvg
};
let WuiIcon = class WuiIcon2 extends i$2 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "copy";
    this.color = "fg-300";
  }
  render() {
    this.style.cssText = `
      --local-color: ${`var(--wui-color-${this.color});`}
      --local-width: ${`var(--wui-icon-size-${this.size});`}
    `;
    return x`${svgOptions$1[this.name]}`;
  }
};
WuiIcon.styles = [resetStyles, colorStyles, styles$2c];
__decorate$2O([
  n$2()
], WuiIcon.prototype, "size", void 0);
__decorate$2O([
  n$2()
], WuiIcon.prototype, "name", void 0);
__decorate$2O([
  n$2()
], WuiIcon.prototype, "color", void 0);
WuiIcon = __decorate$2O([
  customElement("wui-icon")
], WuiIcon);
const styles$2b = i$5`
  :host {
    display: block;
    width: var(--local-width);
    height: var(--local-height);
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
  }
`;
var __decorate$2N = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiImage = class WuiImage2 extends i$2 {
  constructor() {
    super(...arguments);
    this.src = "./path/to/image.jpg";
    this.alt = "Image";
    this.size = void 0;
  }
  render() {
    this.style.cssText = `
      --local-width: ${this.size ? `var(--wui-icon-size-${this.size});` : "100%"};
      --local-height: ${this.size ? `var(--wui-icon-size-${this.size});` : "100%"};
      `;
    return x`<img src=${this.src} alt=${this.alt} @error=${this.handleImageError} />`;
  }
  handleImageError() {
    this.dispatchEvent(new CustomEvent("onLoadError", { bubbles: true, composed: true }));
  }
};
WuiImage.styles = [resetStyles, colorStyles, styles$2b];
__decorate$2N([
  n$2()
], WuiImage.prototype, "src", void 0);
__decorate$2N([
  n$2()
], WuiImage.prototype, "alt", void 0);
__decorate$2N([
  n$2()
], WuiImage.prototype, "size", void 0);
WuiImage = __decorate$2N([
  customElement("wui-image")
], WuiImage);
const styles$2a = i$5`
  :host {
    display: block;
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
  }

  svg {
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
    fill: none;
    stroke: transparent;
    stroke-linecap: round;
  }

  use {
    stroke: var(--wui-color-accent-100);
    stroke-width: 2px;
    stroke-dasharray: 54, 118;
    stroke-dashoffset: 172;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$2M = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLoadingHexagon = class WuiLoadingHexagon2 extends i$2 {
  render() {
    return x`
      <svg viewBox="0 0 54 59">
        <path
          id="wui-loader-path"
          d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"
        />
        <use xlink:href="#wui-loader-path"></use>
      </svg>
    `;
  }
};
WuiLoadingHexagon.styles = [resetStyles, styles$2a];
WuiLoadingHexagon = __decorate$2M([
  customElement("wui-loading-hexagon")
], WuiLoadingHexagon);
const styles$29 = i$5`
  :host {
    display: flex;
  }

  :host([data-size='sm']) > svg {
    width: 12px;
    height: 12px;
  }

  :host([data-size='md']) > svg {
    width: 16px;
    height: 16px;
  }

  :host([data-size='lg']) > svg {
    width: 24px;
    height: 24px;
  }

  :host([data-size='xl']) > svg {
    width: 32px;
    height: 32px;
  }

  svg {
    animation: rotate 2s linear infinite;
  }

  circle {
    fill: none;
    stroke: var(--local-color);
    stroke-width: 4px;
    stroke-dasharray: 1, 124;
    stroke-dashoffset: 0;
    stroke-linecap: round;
    animation: dash 1.5s ease-in-out infinite;
  }

  :host([data-size='md']) > svg > circle {
    stroke-width: 6px;
  }

  :host([data-size='sm']) > svg > circle {
    stroke-width: 8px;
  }

  @keyframes rotate {
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes dash {
    0% {
      stroke-dasharray: 1, 124;
      stroke-dashoffset: 0;
    }

    50% {
      stroke-dasharray: 90, 124;
      stroke-dashoffset: -35;
    }

    100% {
      stroke-dashoffset: -125;
    }
  }
`;
var __decorate$2L = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLoadingSpinner = class WuiLoadingSpinner2 extends i$2 {
  constructor() {
    super(...arguments);
    this.color = "accent-100";
    this.size = "lg";
  }
  render() {
    this.style.cssText = `--local-color: ${this.color === "inherit" ? "inherit" : `var(--wui-color-${this.color})`}`;
    this.dataset["size"] = this.size;
    return x`<svg viewBox="25 25 50 50">
      <circle r="20" cy="50" cx="50"></circle>
    </svg>`;
  }
};
WuiLoadingSpinner.styles = [resetStyles, styles$29];
__decorate$2L([
  n$2()
], WuiLoadingSpinner.prototype, "color", void 0);
__decorate$2L([
  n$2()
], WuiLoadingSpinner.prototype, "size", void 0);
WuiLoadingSpinner = __decorate$2L([
  customElement("wui-loading-spinner")
], WuiLoadingSpinner);
const styles$28 = i$5`
  :host {
    display: block;
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  svg {
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  rect {
    fill: none;
    stroke: var(--wui-color-accent-100);
    stroke-width: 4px;
    stroke-linecap: round;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;
var __decorate$2K = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLoadingThumbnail = class WuiLoadingThumbnail2 extends i$2 {
  constructor() {
    super(...arguments);
    this.radius = 36;
  }
  render() {
    return this.svgLoaderTemplate();
  }
  svgLoaderTemplate() {
    const radius = this.radius > 50 ? 50 : this.radius;
    const standardValue = 36;
    const radiusFactor = standardValue - radius;
    const dashArrayStart = 116 + radiusFactor;
    const dashArrayEnd = 245 + radiusFactor;
    const dashOffset = 360 + radiusFactor * 1.75;
    return x`
      <svg viewBox="0 0 110 110" width="110" height="110">
        <rect
          x="2"
          y="2"
          width="106"
          height="106"
          rx=${radius}
          stroke-dasharray="${dashArrayStart} ${dashArrayEnd}"
          stroke-dashoffset=${dashOffset}
        />
      </svg>
    `;
  }
};
WuiLoadingThumbnail.styles = [resetStyles, styles$28];
__decorate$2K([
  n$2({ type: Number })
], WuiLoadingThumbnail.prototype, "radius", void 0);
WuiLoadingThumbnail = __decorate$2K([
  customElement("wui-loading-thumbnail")
], WuiLoadingThumbnail);
const styles$27 = i$5`
  :host {
    display: block;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-200) 5%,
      var(--wui-color-bg-200) 48%,
      var(--wui-color-bg-300) 55%,
      var(--wui-color-bg-300) 60%,
      var(--wui-color-bg-300) calc(60% + 10px),
      var(--wui-color-bg-200) calc(60% + 12px),
      var(--wui-color-bg-200) 100%
    );
    background-size: 250%;
    animation: shimmer 3s linear infinite reverse;
  }

  :host([variant='light']) {
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-150) 5%,
      var(--wui-color-bg-150) 48%,
      var(--wui-color-bg-200) 55%,
      var(--wui-color-bg-200) 60%,
      var(--wui-color-bg-200) calc(60% + 10px),
      var(--wui-color-bg-150) calc(60% + 12px),
      var(--wui-color-bg-150) 100%
    );
    background-size: 250%;
  }

  @keyframes shimmer {
    from {
      background-position: -250% 0;
    }
    to {
      background-position: 250% 0;
    }
  }
`;
var __decorate$2J = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiShimmer = class WuiShimmer2 extends i$2 {
  constructor() {
    super(...arguments);
    this.width = "";
    this.height = "";
    this.borderRadius = "m";
    this.variant = "default";
  }
  render() {
    this.style.cssText = `
      width: ${this.width};
      height: ${this.height};
      border-radius: ${`clamp(0px,var(--wui-border-radius-${this.borderRadius}), 40px)`};
    `;
    return x`<slot></slot>`;
  }
};
WuiShimmer.styles = [styles$27];
__decorate$2J([
  n$2()
], WuiShimmer.prototype, "width", void 0);
__decorate$2J([
  n$2()
], WuiShimmer.prototype, "height", void 0);
__decorate$2J([
  n$2()
], WuiShimmer.prototype, "borderRadius", void 0);
__decorate$2J([
  n$2()
], WuiShimmer.prototype, "variant", void 0);
WuiShimmer = __decorate$2J([
  customElement("wui-shimmer")
], WuiShimmer);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t = { ATTRIBUTE: 1, CHILD: 2 }, e$2 = (t2) => (...e2) => ({ _$litDirective$: t2, values: e2 });
let i$1 = class i2 {
  constructor(t2) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t2, e2, i4) {
    this._$Ct = t2, this._$AM = e2, this._$Ci = i4;
  }
  _$AS(t2, e2) {
    return this.update(t2, e2);
  }
  update(t2, e2) {
    return this.render(...e2);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$1 = e$2(class extends i$1 {
  constructor(t$12) {
    if (super(t$12), t$12.type !== t.ATTRIBUTE || "class" !== t$12.name || t$12.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t2) {
    return " " + Object.keys(t2).filter(((s2) => t2[s2])).join(" ") + " ";
  }
  update(s2, [i4]) {
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== s2.strings && (this.nt = new Set(s2.strings.join(" ").split(/\s/).filter(((t2) => "" !== t2))));
      for (const t2 in i4) i4[t2] && !this.nt?.has(t2) && this.st.add(t2);
      return this.render(i4);
    }
    const r2 = s2.element.classList;
    for (const t2 of this.st) t2 in i4 || (r2.remove(t2), this.st.delete(t2));
    for (const t2 in i4) {
      const s3 = !!i4[t2];
      s3 === this.st.has(t2) || this.nt?.has(t2) || (s3 ? (r2.add(t2), this.st.add(t2)) : (r2.remove(t2), this.st.delete(t2)));
    }
    return T;
  }
});
const styles$26 = i$5`
  :host {
    display: inline-flex !important;
  }

  slot {
    width: 100%;
    display: inline-block;
    font-style: normal;
    font-family: var(--wui-font-family);
    font-feature-settings:
      'tnum' on,
      'lnum' on,
      'case' on;
    line-height: 130%;
    font-weight: var(--wui-font-weight-regular);
    overflow: inherit;
    text-overflow: inherit;
    text-align: var(--local-align);
    color: var(--local-color);
  }

  .wui-line-clamp-1 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }

  .wui-line-clamp-2 {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
  }

  .wui-font-medium-400 {
    font-size: var(--wui-font-size-medium);
    font-weight: var(--wui-font-weight-light);
    letter-spacing: var(--wui-letter-spacing-medium);
  }

  .wui-font-medium-600 {
    font-size: var(--wui-font-size-medium);
    letter-spacing: var(--wui-letter-spacing-medium);
  }

  .wui-font-title-600 {
    font-size: var(--wui-font-size-title);
    letter-spacing: var(--wui-letter-spacing-title);
  }

  .wui-font-title-6-600 {
    font-size: var(--wui-font-size-title-6);
    letter-spacing: var(--wui-letter-spacing-title-6);
  }

  .wui-font-mini-700 {
    font-size: var(--wui-font-size-mini);
    letter-spacing: var(--wui-letter-spacing-mini);
    text-transform: uppercase;
  }

  .wui-font-large-500,
  .wui-font-large-600,
  .wui-font-large-700 {
    font-size: var(--wui-font-size-large);
    letter-spacing: var(--wui-letter-spacing-large);
  }

  .wui-font-2xl-500,
  .wui-font-2xl-600,
  .wui-font-2xl-700 {
    font-size: var(--wui-font-size-2xl);
    letter-spacing: var(--wui-letter-spacing-2xl);
  }

  .wui-font-paragraph-400,
  .wui-font-paragraph-500,
  .wui-font-paragraph-600,
  .wui-font-paragraph-700 {
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
  }

  .wui-font-small-400,
  .wui-font-small-500,
  .wui-font-small-600 {
    font-size: var(--wui-font-size-small);
    letter-spacing: var(--wui-letter-spacing-small);
  }

  .wui-font-tiny-400,
  .wui-font-tiny-500,
  .wui-font-tiny-600 {
    font-size: var(--wui-font-size-tiny);
    letter-spacing: var(--wui-letter-spacing-tiny);
  }

  .wui-font-micro-700,
  .wui-font-micro-600 {
    font-size: var(--wui-font-size-micro);
    letter-spacing: var(--wui-letter-spacing-micro);
    text-transform: uppercase;
  }

  .wui-font-tiny-400,
  .wui-font-small-400,
  .wui-font-medium-400,
  .wui-font-paragraph-400 {
    font-weight: var(--wui-font-weight-light);
  }

  .wui-font-large-700,
  .wui-font-paragraph-700,
  .wui-font-micro-700,
  .wui-font-mini-700 {
    font-weight: var(--wui-font-weight-bold);
  }

  .wui-font-medium-600,
  .wui-font-medium-title-600,
  .wui-font-title-6-600,
  .wui-font-large-600,
  .wui-font-paragraph-600,
  .wui-font-small-600,
  .wui-font-tiny-600,
  .wui-font-micro-600 {
    font-weight: var(--wui-font-weight-medium);
  }

  :host([disabled]) {
    opacity: 0.4;
  }
`;
var __decorate$2I = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiText = class WuiText2 extends i$2 {
  constructor() {
    super(...arguments);
    this.variant = "paragraph-500";
    this.color = "fg-300";
    this.align = "left";
    this.lineClamp = void 0;
  }
  render() {
    const classes = {
      [`wui-font-${this.variant}`]: true,
      [`wui-color-${this.color}`]: true,
      [`wui-line-clamp-${this.lineClamp}`]: this.lineClamp ? true : false
    };
    this.style.cssText = `
      --local-align: ${this.align};
      --local-color: var(--wui-color-${this.color});
    `;
    return x`<slot class=${e$1(classes)}></slot>`;
  }
};
WuiText.styles = [resetStyles, styles$26];
__decorate$2I([
  n$2()
], WuiText.prototype, "variant", void 0);
__decorate$2I([
  n$2()
], WuiText.prototype, "color", void 0);
__decorate$2I([
  n$2()
], WuiText.prototype, "align", void 0);
__decorate$2I([
  n$2()
], WuiText.prototype, "lineClamp", void 0);
WuiText = __decorate$2I([
  customElement("wui-text")
], WuiText);
const browserSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="30" />
  <circle cx="30" cy="30" r="3" fill="#fff" />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m45.32 17.9-.88-.42.88.42.02-.05c.1-.2.21-.44.26-.7l-.82-.15.82.16a2 2 0 0 0-.24-1.4c-.13-.23-.32-.42-.47-.57a8.42 8.42 0 0 1-.04-.04l-.04-.04a2.9 2.9 0 0 0-.56-.47l-.51.86.5-.86a2 2 0 0 0-1.4-.24c-.26.05-.5.16-.69.26l-.05.02-15.05 7.25-.1.05c-1.14.55-1.85.89-2.46 1.37a7 7 0 0 0-1.13 1.14c-.5.6-.83 1.32-1.38 2.45l-.05.11-7.25 15.05-.02.05c-.1.2-.21.43-.26.69a2 2 0 0 0 .24 1.4l.85-.5-.85.5c.13.23.32.42.47.57l.04.04.04.04c.15.15.34.34.56.47a2 2 0 0 0 1.41.24l-.2-.98.2.98c.25-.05.5-.17.69-.26l.05-.02-.42-.87.42.87 15.05-7.25.1-.05c1.14-.55 1.85-.89 2.46-1.38a7 7 0 0 0 1.13-1.13 12.87 12.87 0 0 0 1.43-2.56l7.25-15.05Z"
  />
  <path
    fill="#1DC956"
    d="M33.38 32.72 30.7 29.3 15.86 44.14l.2.2a1 1 0 0 0 1.14.2l15.1-7.27a3 3 0 0 0 1.08-4.55Z"
  />
  <path
    fill="#86F999"
    d="m26.62 27.28 2.67 3.43 14.85-14.85-.2-.2a1 1 0 0 0-1.14-.2l-15.1 7.27a3 3 0 0 0-1.08 4.55Z"
  />
  <circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
</svg> `;
const daoSvg = b`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#clip0_7734_50402)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#EB8B47"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M19 52C24.5228 52 29 47.5228 29 42C29 36.4772 24.5228 32 19 32C13.4772 32 9 36.4772 9 42C9 47.5228 13.4772 52 19 52Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.8437 8.3264C42.4507 7.70891 41.5493 7.70891 41.1564 8.32641L28.978 27.4638C28.5544 28.1295 29.0326 29.0007 29.8217 29.0007H54.1783C54.9674 29.0007 55.4456 28.1295 55.022 27.4638L42.8437 8.3264Z"
      fill="white"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.3348 11.6456C42.659 11.7608 42.9061 12.1492 43.4005 12.926L50.7332 24.4488C51.2952 25.332 51.5763 25.7737 51.5254 26.1382C51.4915 26.3808 51.3698 26.6026 51.1833 26.7614C50.9031 27 50.3796 27 49.3327 27H34.6673C33.6204 27 33.0969 27 32.8167 26.7614C32.6302 26.6026 32.5085 26.3808 32.4746 26.1382C32.4237 25.7737 32.7048 25.332 33.2669 24.4488L40.5995 12.926C41.0939 12.1492 41.341 11.7608 41.6652 11.6456C41.8818 11.5687 42.1182 11.5687 42.3348 11.6456ZM35.0001 26.999C38.8661 26.999 42.0001 23.865 42.0001 19.999C42.0001 23.865 45.1341 26.999 49.0001 26.999H35.0001Z"
      fill="#FF974C"
    />
    <path
      d="M10.1061 9.35712C9.9973 9.67775 9.99867 10.0388 9.99978 10.3323C9.99989 10.3611 10 10.3893 10 10.4167V25.5833C10 25.6107 9.99989 25.6389 9.99978 25.6677C9.99867 25.9612 9.9973 26.3222 10.1061 26.6429C10.306 27.2317 10.7683 27.694 11.3571 27.8939C11.6777 28.0027 12.0388 28.0013 12.3323 28.0002C12.3611 28.0001 12.3893 28 12.4167 28H19C24.5228 28 29 23.5228 29 18C29 12.4772 24.5228 8 19 8H12.4167C12.3893 8 12.3611 7.99989 12.3323 7.99978C12.0388 7.99867 11.6778 7.9973 11.3571 8.10614C10.7683 8.306 10.306 8.76834 10.1061 9.35712Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
    <circle cx="19" cy="42" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="clip0_7734_50402">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const defiSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#1DC956"
      d="M0 25.01c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02.11 15.65.11 24.9.11h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.13 60 15.76 60 25v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-3.45 1.97-8.08 1.97-17.33 1.97H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 49.1 0 44.46 0 35.21v-10.2Z"
    />
    <path
      fill="#2BEE6C"
      d="M16.1 60c-3.82-.18-6.4-.64-8.53-1.86a15 15 0 0 1-5.6-5.6C.55 50.06.16 46.97.04 41.98L4.2 40.6a4 4 0 0 0 2.48-2.39l4.65-12.4a2 2 0 0 1 2.5-1.2l2.53.84a2 2 0 0 0 2.43-1l2.96-5.94a2 2 0 0 1 3.7.32l3.78 12.58a2 2 0 0 0 3.03 1.09l3.34-2.23a2 2 0 0 0 .65-.7l5.3-9.72a2 2 0 0 1 1.42-1.01l4.14-.69a2 2 0 0 1 1.6.44l3.9 3.24a2 2 0 0 0 2.7-.12l4.62-4.63c.08 2.2.08 4.8.08 7.93v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-2.13 1.22-4.7 1.68-8.54 1.86H16.11Z"
    />
    <path
      fill="#fff"
      d="m.07 43.03-.05-2.1 3.85-1.28a3 3 0 0 0 1.86-1.79l4.66-12.4a3 3 0 0 1 3.75-1.8l2.53.84a1 1 0 0 0 1.21-.5l2.97-5.94a3 3 0 0 1 5.56.48l3.77 12.58a1 1 0 0 0 1.51.55l3.34-2.23a1 1 0 0 0 .33-.35l5.3-9.71a3 3 0 0 1 2.14-1.53l4.13-.69a3 3 0 0 1 2.41.66l3.9 3.24a1 1 0 0 0 1.34-.06l5.28-5.28c.05.85.08 1.75.1 2.73L56 22.41a3 3 0 0 1-4.04.19l-3.9-3.25a1 1 0 0 0-.8-.21l-4.13.69a1 1 0 0 0-.72.5l-5.3 9.72a3 3 0 0 1-.97 1.05l-3.34 2.23a3 3 0 0 1-4.53-1.63l-3.78-12.58a1 1 0 0 0-1.85-.16l-2.97 5.94a3 3 0 0 1-3.63 1.5l-2.53-.84a1 1 0 0 0-1.25.6l-4.65 12.4a5 5 0 0 1-3.1 3L.07 43.02Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M45 .28v59.66l-2 .1V.19c.7.02 1.37.05 2 .1Z" />
    <path fill="#2BEE6C" d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
    <path
      stroke="#fff"
      stroke-opacity=".1"
      d="M.5 25.01c0-4.63 0-8.08.24-10.8.25-2.7.73-4.64 1.66-6.28a14.5 14.5 0 0 1 5.42-5.41C9.46 1.58 11.39 1.1 14.1.85A133 133 0 0 1 24.9.61h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.67a14.5 14.5 0 0 1 5.42 5.4c.93 1.65 1.41 3.58 1.66 6.3.24 2.71.24 6.16.24 10.79v10.2c0 4.64 0 8.08-.24 10.8-.25 2.7-.73 4.65-1.66 6.28a14.5 14.5 0 0 1-5.42 5.42c-1.63.93-3.57 1.41-6.28 1.66-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.66a14.5 14.5 0 0 1-5.42-5.42C1.47 50.66 1 48.72.74 46.01A133 133 0 0 1 .5 35.2v-10.2Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg>`;
const defiAltSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="30" />
    <path
      fill="#E87DE8"
      d="M57.98.01v19.5a4.09 4.09 0 0 0-2.63 2.29L50.7 34.2a2 2 0 0 1-2.5 1.2l-2.53-.84a2 2 0 0 0-2.42 1l-2.97 5.94a2 2 0 0 1-3.7-.32L32.8 28.6a2 2 0 0 0-3.02-1.09l-3.35 2.23a2 2 0 0 0-.64.7l-5.3 9.72a2 2 0 0 1-1.43 1.01l-4.13.69a2 2 0 0 1-1.61-.44l-3.9-3.24a2 2 0 0 0-2.69.12L2.1 42.93.02 43V.01h57.96Z"
    />
    <path
      fill="#fff"
      d="m61.95 16.94.05 2.1-3.85 1.28a3 3 0 0 0-1.86 1.79l-4.65 12.4a3 3 0 0 1-3.76 1.8l-2.53-.84a1 1 0 0 0-1.2.5l-2.98 5.94a3 3 0 0 1-5.55-.48l-3.78-12.58a1 1 0 0 0-1.5-.55l-3.35 2.23a1 1 0 0 0-.32.35l-5.3 9.72a3 3 0 0 1-2.14 1.52l-4.14.69a3 3 0 0 1-2.41-.66l-3.9-3.24a1 1 0 0 0-1.34.06l-5.28 5.28c-.05-.84-.08-1.75-.1-2.73l3.97-3.96a3 3 0 0 1 4.04-.19l3.89 3.25a1 1 0 0 0 .8.21l4.14-.68a1 1 0 0 0 .71-.51l5.3-9.71a3 3 0 0 1 .97-1.06l3.34-2.23a3 3 0 0 1 4.54 1.63l3.77 12.58a1 1 0 0 0 1.86.16l2.96-5.93a3 3 0 0 1 3.64-1.5l2.52.83a1 1 0 0 0 1.25-.6l4.66-12.4a5 5 0 0 1 3.1-2.99l4.43-1.48Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M35.5 27a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M31 0v60h-2V0h2Z" />
    <path fill="#E87DE8" d="M33.5 27a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `;
const ethSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#987DE8" rx="30" />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="m15.48 28.37 11.97-19.3a3 3 0 0 1 5.1 0l11.97 19.3a6 6 0 0 1 .9 3.14v.03a6 6 0 0 1-1.16 3.56L33.23 50.2a4 4 0 0 1-6.46 0L15.73 35.1a6 6 0 0 1-1.15-3.54v-.03a6 6 0 0 1 .9-3.16Z"
      clip-rule="evenodd"
    />
    <path
      fill="#643CDD"
      d="M30.84 10.11a1 1 0 0 0-.84-.46V24.5l12.6 5.53a2 2 0 0 0-.28-1.4L30.84 10.11Z"
    />
    <path
      fill="#BDADEB"
      d="M30 9.65a1 1 0 0 0-.85.46L17.66 28.64a2 2 0 0 0-.26 1.39L30 24.5V9.65Z"
    />
    <path
      fill="#643CDD"
      d="M30 50.54a1 1 0 0 0 .8-.4l11.24-15.38c.3-.44-.2-1-.66-.73l-9.89 5.68a3 3 0 0 1-1.5.4v10.43Z"
    />
    <path
      fill="#BDADEB"
      d="m17.97 34.76 11.22 15.37c.2.28.5.41.8.41V40.11a3 3 0 0 1-1.49-.4l-9.88-5.68c-.47-.27-.97.3-.65.73Z"
    />
    <path
      fill="#401AB3"
      d="M42.6 30.03 30 24.5v13.14a3 3 0 0 0 1.5-.4l10.14-5.83a2 2 0 0 0 .95-1.38Z"
    />
    <path
      fill="#7C5AE2"
      d="M30 37.64V24.46l-12.6 5.57a2 2 0 0 0 .97 1.39l10.13 5.82a3 3 0 0 0 1.5.4Z"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `;
const layersSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="3" />
  <path
    fill="#1FAD7E"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 29.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 19.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#86F999"
    stroke="#fff"
    stroke-width="2"
    d="m46.69 21.06-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-6.32-3.51-.18-.1c-2.33-1.3-3.72-2.06-5.22-2.33a9 9 0 0 0-3.08 0c-1.5.27-2.9 1.04-5.22 2.33l-.17.1-6.33 3.51-.05.03c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45Z"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const lockSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#C653C6" rx="3" />
  <path
    fill="#fff"
    d="M20.03 15.22C20 15.6 20 16.07 20 17v2.8c0 1.14 0 1.7-.2 2.12-.15.31-.3.5-.58.71-.37.28-1.06.42-2.43.7-.59.12-1.11.29-1.6.51a9 9 0 0 0-4.35 4.36C10 30 10 32.34 10 37c0 4.66 0 7 .84 8.8a9 9 0 0 0 4.36 4.36C17 51 19.34 51 24 51h12c4.66 0 7 0 8.8-.84a9 9 0 0 0 4.36-4.36C50 44 50 41.66 50 37c0-4.66 0-7-.84-8.8a9 9 0 0 0-4.36-4.36c-.48-.22-1-.39-1.6-.5-1.36-.29-2.05-.43-2.42-.7-.27-.22-.43-.4-.58-.72-.2-.42-.2-.98-.2-2.11V17c0-.93 0-1.4-.03-1.78a9 9 0 0 0-8.19-8.19C31.4 7 30.93 7 30 7s-1.4 0-1.78.03a9 9 0 0 0-8.19 8.19Z"
  />
  <path
    fill="#E87DE8"
    d="M22 17c0-.93 0-1.4.04-1.78a7 7 0 0 1 6.18-6.18C28.6 9 29.07 9 30 9s1.4 0 1.78.04a7 7 0 0 1 6.18 6.18c.04.39.04.85.04 1.78v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.4-.08-1.78a4 4 0 0 0-3.14-3.14C31.39 12 30.93 12 30 12s-1.4 0-1.78.08a4 4 0 0 0-3.14 3.14c-.08.39-.08.85-.08 1.78v4.5a1.5 1.5 0 0 1-3 0V17Z"
  />
  <path
    fill="#E87DE8"
    fill-rule="evenodd"
    d="M12 36.62c0-4.32 0-6.48.92-8.09a7 7 0 0 1 2.61-2.61C17.14 25 19.3 25 23.62 25h6.86c.46 0 .7 0 .9.02 2.73.22 4.37 2.43 4.62 4.98.27-2.7 2.11-5 5.02-5A6.98 6.98 0 0 1 48 31.98v5.4c0 4.32 0 6.48-.92 8.09a7 7 0 0 1-2.61 2.61c-1.61.92-3.77.92-8.09.92h-5.86c-.46 0-.7 0-.9-.02-2.73-.22-4.37-2.43-4.62-4.98-.26 2.58-1.94 4.82-4.71 4.99l-.7.01c-.55 0-.82 0-1.05-.02a7 7 0 0 1-6.52-6.52c-.02-.23-.02-.5-.02-1.05v-4.79Zm21.24-.27a4 4 0 1 0-6.48 0 31.28 31.28 0 0 1 1.57 2.23c.17.4.17.81.17 1.24V42.5a1.5 1.5 0 0 0 3 0V39.82c0-.43 0-.85.17-1.24.09-.2.58-.87 1.57-2.23Z"
    clip-rule="evenodd"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const loginSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#EB8B47"
      d="M0 24.9c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02 0 15.65 0 24.9 0h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.02 60 15.65 60 24.9v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6C48.98 60 44.35 60 35.1 60H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 48.98 0 44.35 0 35.1V24.9Z"
    />
    <path
      stroke="#062B2B"
      stroke-opacity=".1"
      d="M.5 24.9c0-4.64 0-8.08.24-10.8.25-2.7.73-4.65 1.66-6.28A14.5 14.5 0 0 1 7.82 2.4C9.46 1.47 11.39 1 14.1.74A133 133 0 0 1 24.9.5h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.66a14.5 14.5 0 0 1 5.42 5.42c.93 1.63 1.41 3.57 1.66 6.28.24 2.72.24 6.16.24 10.8v10.2c0 4.63 0 8.08-.24 10.8-.25 2.7-.73 4.64-1.66 6.28a14.5 14.5 0 0 1-5.42 5.41c-1.63.94-3.57 1.42-6.28 1.67-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.67a14.5 14.5 0 0 1-5.42-5.4C1.47 50.53 1 48.6.74 45.88A133 133 0 0 1 .5 35.1V24.9Z"
    />
    <path
      fill="#FF974C"
      stroke="#fff"
      stroke-width="2"
      d="M39.2 29.2a13 13 0 1 0-18.4 0l1.3 1.28a12.82 12.82 0 0 1 2.1 2.39 6 6 0 0 1 .6 1.47c.2.76.2 1.56.2 3.17v11.24c0 1.08 0 1.61.13 2.12a4 4 0 0 0 .41.98c.26.45.64.83 1.4 1.6l.3.29c.65.65.98.98 1.36 1.09.26.07.54.07.8 0 .38-.11.7-.44 1.36-1.1l3.48-3.47c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.47-.48c-.65-.65-.98-.98-1.09-1.36a1.5 1.5 0 0 1 0-.8c.1-.38.44-.7 1.1-1.36l.47-.48c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.48-.5c-.65-.64-.98-.97-1.08-1.35a1.5 1.5 0 0 1 0-.79c.1-.38.42-.7 1.06-1.36l5.46-5.55Z"
    />
    <circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg> `;
const networkSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#00ACE6" rx="30" />
    <circle cx="64" cy="39" r="50" fill="#1AC6FF" stroke="#fff" stroke-width="2" />
    <circle cx="78" cy="30" r="50" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="72" cy="15" r="35" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-17" r="45" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-5" r="50" stroke="#fff" stroke-width="2" />
    <circle cx="30" cy="45" r="4" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="39.5" cy="27.5" r="4" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="16" cy="24" r="4" fill="#19C6FF" stroke="#fff" stroke-width="2" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg>`;
const nftSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="3" />
    <path
      fill="#E87DE8"
      stroke="#fff"
      stroke-width="2"
      d="M52.1 47.34c0-4.24-1.44-9.55-5.9-12.4a2.86 2.86 0 0 0-1.6-3.89v-.82c0-1.19-.52-2.26-1.35-3a4.74 4.74 0 0 0-2.4-6.26v-5.5a11.31 11.31 0 1 0-22.63 0v2.15a3.34 3.34 0 0 0-1.18 5.05 4.74 4.74 0 0 0-.68 6.44A5.22 5.22 0 0 0 14 35.92c-3.06 4.13-6.1 8.3-6.1 15.64 0 2.67.37 4.86.74 6.39a20.3 20.3 0 0 0 .73 2.39l.02.04v.01l.92-.39-.92.4.26.6h38.26l.3-.49-.87-.51.86.5.02-.01.03-.07a16.32 16.32 0 0 0 .57-1.05c.36-.72.85-1.74 1.33-2.96a25.51 25.51 0 0 0 1.94-9.07Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M26.5 29.5c-3-.5-5.5-3-5.5-7v-7c0-.47 0-.7.03-.9a3 3 0 0 1 2.58-2.57c.2-.03.42-.03.89-.03 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.4 0 2.1 0 2.65.23a3 3 0 0 1 1.62 1.62c.23.55.23 1.25.23 2.65v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.5 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z"
      clip-rule="evenodd"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="3" /></clipPath>
  </defs>
</svg> `;
const nounSvg = b`<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#794CFF" rx="3" />
  <path
    fill="#987DE8"
    stroke="#fff"
    stroke-width="2"
    d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"
  />
  <path fill="#fff" d="M37.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M42.5 25h5v10h-5z" />
  <path fill="#fff" d="M19.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M24.5 25h5v10h-5z" />
  <path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;
const profileSvg = b`<svg
  viewBox="0 0 60 60"
  fill="none"
>
  <g clip-path="url(#1)">
    <rect width="60" height="60" rx="30" fill="#00ACE6" />
    <path
      d="M59 73C59 89.0163 46.0163 102 30 102C13.9837 102 1 89.0163 1 73C1 56.9837 12 44 30 44C48 44 59 56.9837 59 73Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M18.6904 19.9015C19.6264 15.3286 23.3466 11.8445 27.9708 11.2096C29.3231 11.024 30.6751 11.0238 32.0289 11.2096C36.6532 11.8445 40.3733 15.3286 41.3094 19.9015C41.4868 20.7681 41.6309 21.6509 41.7492 22.5271C41.8811 23.5041 41.8811 24.4944 41.7492 25.4715C41.6309 26.3476 41.4868 27.2304 41.3094 28.097C40.3733 32.6699 36.6532 36.154 32.0289 36.7889C30.6772 36.9744 29.3216 36.9743 27.9708 36.7889C23.3466 36.154 19.6264 32.6699 18.6904 28.097C18.513 27.2304 18.3689 26.3476 18.2506 25.4715C18.1186 24.4944 18.1186 23.5041 18.2506 22.5271C18.3689 21.6509 18.513 20.7681 18.6904 19.9015Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="24.5" cy="23.5" r="1.5" fill="white" />
    <circle cx="35.5" cy="23.5" r="1.5" fill="white" />
    <path
      d="M31 20L28 28H32"
      stroke="white"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
  </g>
  <rect x="0.5" y="0.5" width="59" height="59" rx="29.5" stroke="white" stroke-opacity="0.1" />
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" rx="30" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const systemSvg = b`<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#1)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#794CFF"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M35.1403 31.5016C35.1193 30.9637 35.388 30.4558 35.8446 30.1707C36.1207 29.9982 36.4761 29.8473 36.7921 29.7685C37.3143 29.6382 37.8664 29.7977 38.2386 30.1864C38.8507 30.8257 39.3004 31.6836 39.8033 32.408C40.2796 33.0942 41.4695 33.2512 41.9687 32.5047C42.4839 31.7341 42.9405 30.8229 43.572 30.1399C43.9375 29.7447 44.4866 29.5756 45.0111 29.6967C45.3283 29.7701 45.6863 29.9147 45.9655 30.0823C46.4269 30.3595 46.7045 30.8626 46.6928 31.4008C46.6731 32.3083 46.3764 33.2571 46.2158 34.1473C46.061 35.0048 46.9045 35.8337 47.7592 35.664C48.6464 35.4878 49.5899 35.1747 50.497 35.1391C51.0348 35.1181 51.5427 35.3868 51.8279 35.8433C52.0004 36.1195 52.1513 36.4749 52.2301 36.7908C52.3604 37.3131 52.2009 37.8651 51.8121 38.2374C51.1729 38.8495 50.3151 39.2991 49.5908 39.8019C48.9046 40.2782 48.7473 41.4683 49.4939 41.9675C50.2644 42.4827 51.1757 42.9393 51.8587 43.5708C52.2539 43.9362 52.423 44.4854 52.3018 45.0099C52.2285 45.3271 52.0839 45.6851 51.9162 45.9642C51.6391 46.4257 51.1359 46.7032 50.5978 46.6916C49.6903 46.6719 48.7417 46.3753 47.8516 46.2146C46.9939 46.0598 46.1648 46.9035 46.3346 47.7583C46.5108 48.6454 46.8239 49.5888 46.8594 50.4958C46.8805 51.0336 46.6117 51.5415 46.1552 51.8267C45.879 51.9992 45.5236 52.15 45.2077 52.2289C44.6854 52.3592 44.1334 52.1997 43.7611 51.8109C43.1491 51.1718 42.6996 50.314 42.1968 49.5897C41.7203 48.9034 40.5301 48.7463 40.0309 49.493C39.5157 50.2634 39.0592 51.1746 38.4278 51.8574C38.0623 52.2527 37.5132 52.4218 36.9887 52.3006C36.6715 52.2273 36.3135 52.0826 36.0343 51.915C35.5729 51.6379 35.2953 51.1347 35.307 50.5966C35.3267 49.6891 35.6233 48.7405 35.7839 47.8505C35.9388 46.9928 35.0951 46.1636 34.2402 46.3334C33.3531 46.5096 32.4098 46.8227 31.5028 46.8582C30.9649 46.8793 30.457 46.6105 30.1719 46.154C29.9994 45.8778 29.8485 45.5224 29.7697 45.2065C29.6394 44.6842 29.7989 44.1322 30.1877 43.7599C30.8269 43.1479 31.6847 42.6982 32.4091 42.1954C33.0954 41.7189 33.2522 40.5289 32.5056 40.0297C31.7351 39.5145 30.824 39.058 30.1411 38.4265C29.7459 38.0611 29.5768 37.5119 29.698 36.9875C29.7713 36.6702 29.9159 36.3122 30.0836 36.0331C30.3607 35.5717 30.8638 35.2941 31.402 35.3058C32.3095 35.3255 33.2583 35.6221 34.1485 35.7828C35.006 35.9376 35.8349 35.094 35.6652 34.2393C35.489 33.3521 35.1759 32.4087 35.1403 31.5016Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M20.7706 8.22357C20.9036 7.51411 21.5231 7 22.2449 7H23.7551C24.4769 7 25.0964 7.51411 25.2294 8.22357C25.5051 9.69403 25.4829 11.6321 27.1202 12.2606C27.3092 12.3331 27.4958 12.4105 27.6798 12.4926C29.2818 13.2072 30.6374 11.8199 31.8721 10.9752C32.4678 10.5676 33.2694 10.6421 33.7798 11.1525L34.8477 12.2204C35.3581 12.7308 35.4326 13.5323 35.025 14.128C34.1802 15.3627 32.7931 16.7183 33.5077 18.3202C33.5898 18.5043 33.6672 18.6909 33.7398 18.88C34.3683 20.5171 36.3061 20.4949 37.7764 20.7706C38.4859 20.9036 39 21.5231 39 22.2449V23.7551C39 24.4769 38.4859 25.0964 37.7764 25.2294C36.3061 25.5051 34.3685 25.483 33.7401 27.1201C33.6675 27.3093 33.59 27.4961 33.5079 27.6803C32.7934 29.282 34.1803 30.6374 35.025 31.8719C35.4326 32.4677 35.3581 33.2692 34.8477 33.7796L33.7798 34.8475C33.2694 35.3579 32.4678 35.4324 31.8721 35.0248C30.6376 34.1801 29.2823 32.7934 27.6806 33.508C27.4962 33.5903 27.3093 33.6678 27.12 33.7405C25.483 34.3688 25.5051 36.3062 25.2294 37.7764C25.0964 38.4859 24.4769 39 23.7551 39H22.2449C21.5231 39 20.9036 38.4859 20.7706 37.7764C20.4949 36.3062 20.517 34.3688 18.88 33.7405C18.6908 33.6678 18.5039 33.5903 18.3196 33.5081C16.7179 32.7936 15.3625 34.1804 14.1279 35.0251C13.5322 35.4327 12.7307 35.3582 12.2203 34.8478L11.1524 33.7799C10.642 33.2695 10.5675 32.4679 10.9751 31.8722C11.8198 30.6376 13.2067 29.2822 12.4922 27.6804C12.41 27.4962 12.3325 27.3093 12.2599 27.1201C11.6315 25.483 9.69392 25.5051 8.22357 25.2294C7.51411 25.0964 7 24.4769 7 23.7551V22.2449C7 21.5231 7.51411 20.9036 8.22357 20.7706C9.69394 20.4949 11.6317 20.5171 12.2602 18.88C12.3328 18.6909 12.4103 18.5042 12.4924 18.3201C13.207 16.7181 11.8198 15.3625 10.975 14.1278C10.5674 13.5321 10.6419 12.7305 11.1523 12.2201L12.2202 11.1522C12.7306 10.6418 13.5322 10.5673 14.1279 10.9749C15.3626 11.8197 16.7184 13.2071 18.3204 12.4925C18.5044 12.4105 18.6909 12.3331 18.8799 12.2606C20.5171 11.6321 20.4949 9.69403 20.7706 8.22357Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="23" cy="23" r="6" fill="#794CFF" stroke="white" stroke-width="2" />
    <circle cx="41" cy="41" r="4" fill="#794CFF" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `;
const coinbaseSvg = b`<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40" fill="none">
  <g clip-path="url(#clip0_187_29)">
    <path d="M1.18187e-05 15.8055C1.18187e-05 9.8015 -5.19442e-07 6.91338 1.69991e-08 0C4.5 3.72236e-05 9.62249 0 16.5 0L23.5 4.31399e-05C29.9349 4.31399e-05 35.5 0.000206332 40 3.73468e-05C40 2.77754 40 9.36708 40 15.8055V22.8364C40 29.2647 40 33.7962 40 40C31.5 40 29.8337 40 23.4 40H16.6C10.5092 40 6.50004 40 4.04289e-05 40C3.05176e-05 32.2453 1.18187e-05 29.6382 1.18187e-05 22.8364V15.8055Z" fill="#0052FF"/>
    <path d="M20.0236 26.5C16.4342 26.5 13.5236 23.5931 13.5236 20C13.5236 16.4069 16.4342 13.5 20.0236 13.5C23.2411 13.5 25.9134 15.8472 26.4261 18.9167H32.9731C32.4206 12.2433 26.8342 7 20.02 7C12.8411 7 7.02002 12.8211 7.02002 20C7.02002 27.1789 12.8411 33 20.02 33C26.8342 33 32.4206 27.7567 32.9731 21.0833H26.4225C25.9061 24.1528 23.2411 26.5 20.0236 26.5Z" fill="white"/>
  </g>
  <defs>
    <clipPath id="clip0_187_29">
      <rect width="40" height="40" fill="white"/>
    </clipPath>
  </defs>
</svg>`;
const moonpaySvg = b`
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#7D00FF"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        d="M28.306 15.381a3.69 3.69 0 1 0 0-7.381 3.69 3.69 0 0 0 0 7.381ZM16.987 32a8.991 8.991 0 1 1 .016-17.983A8.991 8.991 0 0 1 16.988 32Z"
        fill="#fff"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`;
const stripeSvg = b`
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#635BFF"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M18.299 15.147c0-1.028.844-1.424 2.242-1.424 2.004 0 4.536.607 6.54 1.688V9.213C24.892 8.343 22.73 8 20.541 8c-5.354 0-8.915 2.796-8.915 7.464 0 7.279 10.022 6.118 10.022 9.257 0 1.213-1.055 1.609-2.531 1.609-2.19 0-4.985-.897-7.2-2.11v6.277a18.283 18.283 0 0 0 7.2 1.503c5.485 0 9.257-2.716 9.257-7.437-.027-7.86-10.075-6.462-10.075-9.416Z"
        fill="#fff"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`;
const paypalSvg = b`
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#fff"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        d="M18.606 12.642a.781.781 0 0 0-.771.66l-1.281 8.125a.78.78 0 0 1 .77-.66h3.755a7.668 7.668 0 0 0 7.57-6.49 6.26 6.26 0 0 0 .075-.843c-.96-.504-2.089-.792-3.325-.792h-6.793Z"
        fill="#001C64"
      />
      <path
        d="M28.724 13.434c-.006.282-.03.564-.075.843a7.668 7.668 0 0 1-7.57 6.491h-3.754a.78.78 0 0 0-.771.66l-1.916 12.15a.634.634 0 0 0 .626.734h4.075a.781.781 0 0 0 .77-.66l1.074-6.807a.781.781 0 0 1 .772-.66h2.4a7.668 7.668 0 0 0 7.57-6.491c.415-2.651-.92-5.064-3.201-6.26Z"
        fill="#0070E0"
      />
      <path
        d="M13.977 7.226a.78.78 0 0 0-.771.658l-3.198 20.277a.634.634 0 0 0 .626.733h4.742l1.178-7.467 1.281-8.125a.782.782 0 0 1 .771-.66H25.4c1.237 0 2.364.289 3.325.792.065-3.4-2.74-6.208-6.599-6.208h-8.148Z"
        fill="#003087"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`;
const onrampCardSvg = b`<svg width="60" height="60" viewBox="0 0 60 60" fill="none">
<g clip-path="url(#clip0_13859_31161)">
  <path d="M0 24.8995C0 15.6481 0 11.0223 1.97053 7.56763C3.3015 5.2342 5.23468 3.30101 7.56812 1.97004C11.0228 -0.000488281 15.6485 -0.000488281 24.9 -0.000488281H35.1C44.3514 -0.000488281 48.9772 -0.000488281 52.4319 1.97004C54.7653 3.30101 56.6985 5.2342 58.0295 7.56763C60 11.0223 60 15.6481 60 24.8995V35.0995C60 44.351 60 48.9767 58.0295 52.4314C56.6985 54.7648 54.7653 56.698 52.4319 58.029C48.9772 59.9995 44.3514 59.9995 35.1 59.9995H24.9C15.6485 59.9995 11.0228 59.9995 7.56812 58.029C5.23468 56.698 3.3015 54.7648 1.97053 52.4314C0 48.9767 0 44.351 0 35.0995V24.8995Z" fill="#EB8B47"/>
  <path d="M0.5 24.8995C0.5 20.2647 0.50047 16.8216 0.744315 14.1045C0.987552 11.3941 1.46987 9.45455 2.40484 7.81536C3.69145 5.55971 5.56019 3.69096 7.81585 2.40435C9.45504 1.46938 11.3946 0.987064 14.105 0.743826C16.8221 0.499981 20.2652 0.499512 24.9 0.499512H35.1C39.7348 0.499512 43.1779 0.499981 45.895 0.743826C48.6054 0.987064 50.545 1.46938 52.1841 2.40435C54.4398 3.69096 56.3086 5.55971 57.5952 7.81536C58.5301 9.45455 59.0124 11.3941 59.2557 14.1045C59.4995 16.8216 59.5 20.2647 59.5 24.8995V35.0995C59.5 39.7343 59.4995 43.1774 59.2557 45.8945C59.0124 48.6049 58.5301 50.5445 57.5952 52.1837C56.3086 54.4393 54.4398 56.3081 52.1841 57.5947C50.545 58.5296 48.6054 59.012 45.895 59.2552C43.1779 59.499 39.7348 59.4995 35.1 59.4995H24.9C20.2652 59.4995 16.8221 59.499 14.105 59.2552C11.3946 59.012 9.45504 58.5296 7.81585 57.5947C5.56019 56.3081 3.69145 54.4393 2.40484 52.1837C1.46987 50.5445 0.987552 48.6049 0.744315 45.8945C0.50047 43.1774 0.5 39.7343 0.5 35.0995V24.8995Z" stroke="#141414" stroke-opacity="0.1"/>
  <path d="M13 26.0335C13 21.7838 13 19.659 14.0822 18.1694C14.4318 17.6883 14.8548 17.2653 15.3359 16.9157C16.8255 15.8335 18.9503 15.8335 23.2 15.8335H36.8C41.0497 15.8335 43.1745 15.8335 44.6641 16.9157C45.1452 17.2653 45.5682 17.6883 45.9178 18.1694C47 19.659 47 21.7838 47 26.0335V33.9668C47 38.2165 47 40.3414 45.9178 41.831C45.5682 42.312 45.1452 42.7351 44.6641 43.0846C43.1745 44.1668 41.0497 44.1668 36.8 44.1668H23.2C18.9503 44.1668 16.8255 44.1668 15.3359 43.0846C14.8548 42.7351 14.4318 42.312 14.0822 41.831C13 40.3414 13 38.2165 13 33.9668V26.0335Z" fill="#FF974C" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M39.5 36.667H36.6666" stroke="white" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M45.2 23.0645H14.8C14.0501 23.0645 13.6751 23.0645 13.4122 23.2554C13.3273 23.3171 13.2527 23.3918 13.191 23.4767C13 23.7395 13 24.1145 13 24.8645V27.2645C13 28.0144 13 28.3894 13.191 28.6522C13.2527 28.7371 13.3273 28.8118 13.4122 28.8735C13.6751 29.0645 14.0501 29.0645 14.8 29.0645H45.2C45.9499 29.0645 46.3249 29.0645 46.5878 28.8735C46.6727 28.8118 46.7473 28.7371 46.809 28.6522C47 28.3894 47 28.0144 47 27.2645V24.8645C47 24.1145 47 23.7395 46.809 23.4767C46.7473 23.3918 46.6727 23.3171 46.5878 23.2554C46.3249 23.0645 45.9499 23.0645 45.2 23.0645Z" fill="white" fill-opacity="0.4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
<defs>
  <clipPath id="clip0_13859_31161">
    <rect width="60" height="60" fill="white"/>
  </clipPath>
</defs>
</svg>`;
const googleSvg = b`<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect width="64" height="64" rx="30" fill="#1DC956"/>
  <rect x="0.5" y="0.5" width="63" height="63" rx="29.5" stroke="#141414" stroke-opacity="0.1"/>
  <path d="M32.4053 19.8031C35.3901 19.8031 38.0431 20.8349 40.1619 22.8247L45.9656 17.0211C42.4465 13.7416 37.8773 11.7333 32.4053 11.7333C24.4829 11.7333 17.6475 16.2841 14.3127 22.9168L21.056 28.1493C22.6589 23.359 27.136 19.8031 32.4053 19.8031Z" fill="#1DC956" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  <path d="M32.4053 52.2667C37.8773 52.2667 42.465 50.4611 45.8182 47.3658L39.2407 42.2623C37.4351 43.4783 35.1321 44.2153 32.4053 44.2153C27.136 44.2153 22.6589 40.6594 21.056 35.8691L14.3127 41.1016C17.6475 47.7159 24.4829 52.2667 32.4053 52.2667Z" fill="#2BEE6C"/>
  <path d="M21.056 35.8507L19.5636 36.993L14.3127 41.0832M39.2407 42.2623L45.8182 47.3658C42.465 50.4611 37.8773 52.2667 32.4053 52.2667C24.4829 52.2667 17.6475 47.7159 14.3127 41.1016L21.056 35.8691C22.6589 40.6594 27.136 44.2153 32.4053 44.2153C35.1321 44.2153 37.4351 43.4783 39.2407 42.2623Z" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  <path d="M51.8613 32.4606C51.8613 31.0235 51.7323 29.6417 51.4928 28.3151H32.4053V36.1638H43.3124C42.8334 38.688 41.3963 40.8252 39.2407 42.2623L45.8181 47.3658C49.6503 43.8283 51.8613 38.6327 51.8613 32.4606Z" fill="#1FAD7E" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  <path d="M21.056 35.8507C20.6507 34.6347 20.4111 33.345 20.4111 32C20.4111 30.655 20.6507 29.3653 21.056 28.1493L14.3127 22.9169C12.9309 25.6437 12.1387 28.7205 12.1387 32C12.1387 35.2795 12.9309 38.3564 14.3127 41.0831L19.5636 36.993L21.056 35.8507Z" fill="#86F999"/>
  <path d="M21.056 35.8691L14.3127 41.1016M21.056 35.8507C20.6507 34.6347 20.4111 33.345 20.4111 32C20.4111 30.655 20.6507 29.3653 21.056 28.1493L14.3127 22.9169C12.9309 25.6437 12.1387 28.7205 12.1387 32C12.1387 35.2795 12.9309 38.3564 14.3127 41.0831L19.5636 36.993L21.056 35.8507Z" stroke="white" stroke-width="2" stroke-linejoin="round"/>
</svg>
`;
const pencilSvg = b`<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
  <g clip-path="url(#clip0_241_31635)">
    <path d="M0 26.5595C0 16.6913 0 11.7572 2.1019 8.07217C3.5216 5.58317 5.58366 3.52111 8.07266 2.10141C11.7577 -0.000488281 16.6918 -0.000488281 26.56 -0.000488281H37.44C47.3082 -0.000488281 52.2423 -0.000488281 55.9273 2.10141C58.4163 3.52111 60.4784 5.58317 61.8981 8.07217C64 11.7572 64 16.6913 64 26.5595V37.4395C64 47.3077 64 52.2418 61.8981 55.9268C60.4784 58.4158 58.4163 60.4779 55.9273 61.8976C52.2423 63.9995 47.3082 63.9995 37.44 63.9995H26.56C16.6918 63.9995 11.7577 63.9995 8.07266 61.8976C5.58366 60.4779 3.5216 58.4158 2.1019 55.9268C0 52.2418 0 47.3077 0 37.4395V26.5595Z" fill="#EB8B47"/>
    <path d="M0.5 26.5595C0.5 21.6163 0.50047 17.942 0.760736 15.0418C1.02039 12.1485 1.53555 10.0742 2.53621 8.3199C3.91155 5.90869 5.90917 3.91106 8.32039 2.53572C10.0747 1.53506 12.1489 1.01991 15.0423 0.760247C17.9425 0.499981 21.6168 0.499512 26.56 0.499512H37.44C42.3832 0.499512 46.0575 0.499981 48.9577 0.760247C51.8511 1.01991 53.9253 1.53506 55.6796 2.53572C58.0908 3.91106 60.0885 5.90869 61.4638 8.3199C62.4645 10.0742 62.9796 12.1485 63.2393 15.0418C63.4995 17.942 63.5 21.6163 63.5 26.5595V37.4395C63.5 42.3827 63.4995 46.057 63.2393 48.9572C62.9796 51.8506 62.4645 53.9248 61.4638 55.6791C60.0885 58.0903 58.0908 60.088 55.6796 61.4633C53.9253 62.464 51.8511 62.9791 48.9577 63.2388C46.0575 63.499 42.3832 63.4995 37.44 63.4995H26.56C21.6168 63.4995 17.9425 63.499 15.0423 63.2388C12.1489 62.9791 10.0747 62.464 8.32039 61.4633C5.90917 60.088 3.91155 58.0903 2.53621 55.6791C1.53555 53.9248 1.02039 51.8506 0.760736 48.9572C0.50047 46.057 0.5 42.3827 0.5 37.4395V26.5595Z" stroke="#141414" stroke-opacity="0.1"/>
    <path d="M28.1042 49.2329L13.1024 51.2077L15.0772 36.2059L37.1015 14.1815C39.2441 12.039 40.3154 10.9677 41.5718 10.624C42.4205 10.3918 43.3159 10.3918 44.1645 10.624C45.421 10.9677 46.4922 12.039 48.6348 14.1815L50.1286 15.6753C52.2711 17.8179 53.3424 18.8891 53.6861 20.1456C53.9183 20.9942 53.9183 21.8896 53.6861 22.7383C53.3424 23.9947 52.2711 25.066 50.1286 27.2086L28.1042 49.2329Z" fill="#FF974C" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M38.5962 20.5376L22.4199 36.7139" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M43.7727 25.714L27.5964 41.8903" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M22.3703 36.7635C19.3258 39.808 16.0198 36.6395 16.2616 35.0324" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M27.5466 41.9399C24.5034 44.9831 28.155 48.7098 29.2738 48.0475" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M27.5468 41.9398C23.428 46.0586 18.2516 40.8822 22.3704 36.7634" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M15.8191 50.5214C15.4711 49.5823 14.728 48.8392 13.7889 48.4912" stroke="#E4E7E7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M49.2862 29.5805L34.7275 15.0219" stroke="#E4E7E7" stroke-width="2" stroke-linejoin="round"/>
  </g>
  <defs>
    <clipPath id="clip0_241_31635">
      <rect width="64" height="64" fill="white"/>
    </clipPath>
  </defs>
</svg>
`;
const lightbulbSvg = b`<svg width="64" height="64" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
  <g clip-path="url(#clip0_241_31636)">
    <path d="M0 26.5595C0 16.6913 0 11.7572 2.1019 8.07217C3.5216 5.58318 5.58366 3.52111 8.07266 2.10141C11.7577 -0.000488281 16.6918 -0.000488281 26.56 -0.000488281H37.44C47.3082 -0.000488281 52.2423 -0.000488281 55.9273 2.10141C58.4163 3.52111 60.4784 5.58318 61.8981 8.07217C64 11.7572 64 16.6913 64 26.5595V37.4395C64 47.3077 64 52.2418 61.8981 55.9269C60.4784 58.4159 58.4163 60.4779 55.9273 61.8976C52.2423 63.9995 47.3082 63.9995 37.44 63.9995H26.56C16.6918 63.9995 11.7577 63.9995 8.07266 61.8976C5.58366 60.4779 3.5216 58.4159 2.1019 55.9269C0 52.2418 0 47.3077 0 37.4395V26.5595Z" fill="#794CFF"/>
    <path d="M0.5 26.5595C0.5 21.6163 0.50047 17.942 0.760736 15.0418C1.02039 12.1485 1.53555 10.0742 2.53621 8.3199C3.91155 5.90869 5.90917 3.91106 8.32039 2.53572C10.0747 1.53506 12.1489 1.01991 15.0423 0.760247C17.9425 0.499981 21.6168 0.499512 26.56 0.499512H37.44C42.3832 0.499512 46.0575 0.499981 48.9577 0.760247C51.8511 1.01991 53.9253 1.53506 55.6796 2.53572C58.0908 3.91106 60.0885 5.90869 61.4638 8.3199C62.4645 10.0742 62.9796 12.1485 63.2393 15.0418C63.4995 17.942 63.5 21.6163 63.5 26.5595V37.4395C63.5 42.3827 63.4995 46.057 63.2393 48.9572C62.9796 51.8506 62.4645 53.9248 61.4638 55.6791C60.0885 58.0903 58.0908 60.088 55.6796 61.4633C53.9253 62.464 51.8511 62.9791 48.9577 63.2388C46.0575 63.499 42.3832 63.4995 37.44 63.4995H26.56C21.6168 63.4995 17.9425 63.499 15.0423 63.2388C12.1489 62.9791 10.0747 62.464 8.32039 61.4633C5.90917 60.088 3.91155 58.0903 2.53621 55.6791C1.53555 53.9248 1.02039 51.8506 0.760736 48.9572C0.50047 46.057 0.5 42.3827 0.5 37.4395V26.5595Z" stroke="#141414" stroke-opacity="0.1"/>
    <path d="M40 39.4595C44.7824 36.693 48 31.5222 48 25.6C48 16.7634 40.8366 9.59998 32 9.59998C23.1634 9.59998 16 16.7634 16 25.6C16 31.5222 19.2176 36.693 24 39.4595V45.8144H40V39.4595Z" fill="#906EF7"/>
    <path d="M24 49.9689C24 51.8192 24 52.7444 24.3941 53.4353C24.6603 53.902 25.0469 54.2886 25.5136 54.5548C26.2046 54.9489 27.1297 54.9489 28.98 54.9489H35.02C36.8703 54.9489 37.7954 54.9489 38.4864 54.5548C38.9531 54.2886 39.3397 53.902 39.6059 53.4353C40 52.7444 40 51.8192 40 49.9689V45.8144H24V49.9689Z" fill="#906EF7"/>
    <path d="M24 45.8144V39.4595C19.2176 36.693 16 31.5222 16 25.6C16 16.7634 23.1634 9.59998 32 9.59998C40.8366 9.59998 48 16.7634 48 25.6C48 31.5222 44.7824 36.693 40 39.4595V45.8144M24 45.8144H40M24 45.8144V49.9689C24 51.8192 24 52.7444 24.3941 53.4353C24.6603 53.902 25.0469 54.2886 25.5136 54.5548C26.2046 54.9489 27.1297 54.9489 28.98 54.9489H35.02C36.8703 54.9489 37.7954 54.9489 38.4864 54.5548C38.9531 54.2886 39.3397 53.902 39.6059 53.4353C40 52.7444 40 51.8192 40 49.9689V45.8144" stroke="white" stroke-width="2" stroke-linejoin="round"/>
    <path d="M24 49.9689C24 51.8192 24 52.7444 24.3941 53.4353C24.6603 53.902 25.0469 54.2886 25.5136 54.5548C26.2046 54.9489 27.1297 54.9489 28.98 54.9489H35.02C36.8703 54.9489 37.7954 54.9489 38.4864 54.5548C38.9531 54.2886 39.3397 53.902 39.6059 53.4353C40 52.7444 40 51.8192 40 49.9689V45.8144H24V49.9689Z" fill="#643CDD" stroke="white" stroke-width="2" stroke-linejoin="round"/>
    <path d="M29.6735 26.9101V29.1109H34.0753V26.9101C34.0753 25.6945 35.0607 24.7092 36.2762 24.7092C37.4917 24.7092 38.4771 25.6945 38.4771 26.9101C38.4771 28.1256 37.4917 29.1109 36.2762 29.1109H34.0753H29.6735H27.4726C26.2571 29.1109 25.2717 28.1256 25.2717 26.9101C25.2717 25.6945 26.2571 24.7092 27.4726 24.7092C28.6881 24.7092 29.6735 25.6945 29.6735 26.9101Z" fill="#906EF7"/>
    <path d="M29.6735 45.3183V26.9101C29.6735 25.6945 28.6881 24.7092 27.4726 24.7092V24.7092C26.2571 24.7092 25.2717 25.6945 25.2717 26.9101V26.9101C25.2717 28.1256 26.2571 29.1109 27.4726 29.1109H36.2762C37.4917 29.1109 38.4771 28.1256 38.4771 26.9101V26.9101C38.4771 25.6945 37.4917 24.7092 36.2762 24.7092V24.7092C35.0607 24.7092 34.0753 25.6945 34.0753 26.9101V45.3183" stroke="white" stroke-width="2" stroke-linejoin="round"/>
  </g>
  <defs>
    <clipPath id="clip0_241_31636">
      <rect width="64" height="64" fill="white"/>
    </clipPath>
  </defs>
</svg>
`;
const meldSvg = b`<svg width="40" height="42" viewBox="0 0 40 42" fill="none">
<path opacity="0.7" d="M19.9526 41.9076L7.3877 34.655V26.1226L19.9526 33.3751V41.9076Z" fill="url(#paint0_linear_2113_32117)"/>
<path opacity="0.7" d="M19.9521 41.9076L32.5171 34.655V26.1226L19.9521 33.3751V41.9076Z" fill="url(#paint1_linear_2113_32117)"/>
<path opacity="0.7" d="M39.9095 7.34521V21.8562L32.5166 26.1225V11.6114L39.9095 7.34521Z" fill="url(#paint2_linear_2113_32117)"/>
<path d="M39.9099 7.34536L27.345 0.0927734L19.9521 4.359L32.5171 11.6116L39.9099 7.34536Z" fill="url(#paint3_linear_2113_32117)"/>
<path d="M0 7.34536L12.5649 0.0927734L19.9519 4.359L7.387 11.6116L0 7.34536Z" fill="#F969D3"/>
<path opacity="0.7" d="M0 7.34521V21.8562L7.387 26.1225V11.6114L0 7.34521Z" fill="url(#paint4_linear_2113_32117)"/>
<defs>
<linearGradient id="paint0_linear_2113_32117" x1="18.6099" y1="41.8335" x2="7.73529" y2="8.31842" gradientUnits="userSpaceOnUse">
<stop stop-color="#E98ADA"/>
<stop offset="1" stop-color="#7E4DBD"/>
</linearGradient>
<linearGradient id="paint1_linear_2113_32117" x1="26.2346" y1="26.1226" x2="26.2346" y2="41.9076" gradientUnits="userSpaceOnUse">
<stop stop-color="#719DED"/>
<stop offset="1" stop-color="#2545BE"/>
</linearGradient>
<linearGradient id="paint2_linear_2113_32117" x1="36.213" y1="7.34521" x2="36.213" y2="26.1225" gradientUnits="userSpaceOnUse">
<stop stop-color="#93EBFF"/>
<stop offset="1" stop-color="#197DDB"/>
</linearGradient>
<linearGradient id="paint3_linear_2113_32117" x1="29.931" y1="0.0927734" x2="38.2156" y2="14.8448" gradientUnits="userSpaceOnUse">
<stop stop-color="#F969D3"/>
<stop offset="1" stop-color="#4F51C0"/>
</linearGradient>
<linearGradient id="paint4_linear_2113_32117" x1="18.1251" y1="44.2539" x2="-7.06792" y2="15.2763" gradientUnits="userSpaceOnUse">
<stop stop-color="#E98ADA"/>
<stop offset="1" stop-color="#7E4DBD"/>
</linearGradient>
</defs>
</svg>`;
const styles$25 = i$5`
  :host {
    display: block;
    width: var(--local-size);
    height: var(--local-size);
  }

  :host svg {
    width: 100%;
    height: 100%;
  }
`;
var __decorate$2H = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const svgOptions = {
  browser: browserSvg,
  dao: daoSvg,
  defi: defiSvg,
  defiAlt: defiAltSvg,
  eth: ethSvg,
  layers: layersSvg,
  lock: lockSvg,
  login: loginSvg,
  network: networkSvg,
  nft: nftSvg,
  noun: nounSvg,
  profile: profileSvg,
  system: systemSvg,
  coinbase: coinbaseSvg,
  meld: meldSvg,
  onrampCard: onrampCardSvg,
  moonpay: moonpaySvg,
  stripe: stripeSvg,
  paypal: paypalSvg,
  google: googleSvg,
  pencil: pencilSvg,
  lightbulb: lightbulbSvg
};
let WuiVisual = class WuiVisual2 extends i$2 {
  constructor() {
    super(...arguments);
    this.name = "browser";
    this.size = "md";
  }
  render() {
    this.style.cssText = `
       --local-size: var(--wui-visual-size-${this.size});
   `;
    return x`${svgOptions[this.name]}`;
  }
};
WuiVisual.styles = [resetStyles, styles$25];
__decorate$2H([
  n$2()
], WuiVisual.prototype, "name", void 0);
__decorate$2H([
  n$2()
], WuiVisual.prototype, "size", void 0);
WuiVisual = __decorate$2H([
  customElement("wui-visual")
], WuiVisual);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$3 = (o2) => o2 ?? E;
const UiHelperUtil = {
  getSpacingStyles(spacing, index2) {
    if (Array.isArray(spacing)) {
      return spacing[index2] ? `var(--wui-spacing-${spacing[index2]})` : void 0;
    } else if (typeof spacing === "string") {
      return `var(--wui-spacing-${spacing})`;
    }
    return void 0;
  },
  getFormattedDate(date) {
    return new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" }).format(date);
  },
  getHostName(url) {
    try {
      const newUrl = new URL(url);
      return newUrl.hostname;
    } catch (error) {
      return "";
    }
  },
  getTruncateString({ string, charsStart, charsEnd, truncate }) {
    if (string.length <= charsStart + charsEnd) {
      return string;
    }
    if (truncate === "end") {
      return `${string.substring(0, charsStart)}...`;
    } else if (truncate === "start") {
      return `...${string.substring(string.length - charsEnd)}`;
    }
    return `${string.substring(0, Math.floor(charsStart))}...${string.substring(string.length - Math.floor(charsEnd))}`;
  },
  generateAvatarColors(address) {
    const hash2 = address.toLowerCase().replace(/^0x/iu, "");
    const baseColor = hash2.substring(0, 6);
    const rgbColor = this.hexToRgb(baseColor);
    const masterBorderRadius = getComputedStyle(document.documentElement).getPropertyValue("--w3m-border-radius-master");
    const radius = Number(masterBorderRadius?.replace("px", ""));
    const edge = 100 - 3 * radius;
    const gradientCircle = `${edge}% ${edge}% at 65% 40%`;
    const colors = [];
    for (let i4 = 0; i4 < 5; i4 += 1) {
      const tintedColor = this.tintColor(rgbColor, 0.15 * i4);
      colors.push(`rgb(${tintedColor[0]}, ${tintedColor[1]}, ${tintedColor[2]})`);
    }
    return `
    --local-color-1: ${colors[0]};
    --local-color-2: ${colors[1]};
    --local-color-3: ${colors[2]};
    --local-color-4: ${colors[3]};
    --local-color-5: ${colors[4]};
    --local-radial-circle: ${gradientCircle}
   `;
  },
  hexToRgb(hex) {
    const bigint = parseInt(hex, 16);
    const r2 = bigint >> 16 & 255;
    const g2 = bigint >> 8 & 255;
    const b2 = bigint & 255;
    return [r2, g2, b2];
  },
  tintColor(rgb, tint) {
    const [r2, g2, b2] = rgb;
    const tintedR = Math.round(r2 + (255 - r2) * tint);
    const tintedG = Math.round(g2 + (255 - g2) * tint);
    const tintedB = Math.round(b2 + (255 - b2) * tint);
    return [tintedR, tintedG, tintedB];
  },
  isNumber(character2) {
    const regex2 = {
      number: /^[0-9]+$/u
    };
    return regex2.number.test(character2);
  },
  getColorTheme(theme2) {
    if (theme2) {
      return theme2;
    } else if (typeof window !== "undefined" && window.matchMedia) {
      if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
        return "dark";
      }
      return "light";
    }
    return "dark";
  },
  splitBalance(input) {
    const parts = input.split(".");
    if (parts.length === 2) {
      return [parts[0], parts[1]];
    }
    return ["0", "00"];
  },
  roundNumber(number, threshold, fixed) {
    const roundedNumber = number.toString().length >= threshold ? Number(number).toFixed(fixed) : number;
    return roundedNumber;
  },
  formatNumberToLocalString(value, decimals = 2) {
    if (value === void 0) {
      return "0.00";
    }
    if (typeof value === "number") {
      return value.toLocaleString("en-US", {
        maximumFractionDigits: decimals,
        minimumFractionDigits: decimals
      });
    }
    return parseFloat(value).toLocaleString("en-US", {
      maximumFractionDigits: decimals,
      minimumFractionDigits: decimals
    });
  }
};
const styles$24 = i$5`
  :host {
    display: flex;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$2G = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiFlex = class WuiFlex2 extends i$2 {
  render() {
    this.style.cssText = `
      flex-direction: ${this.flexDirection};
      flex-wrap: ${this.flexWrap};
      flex-basis: ${this.flexBasis};
      flex-grow: ${this.flexGrow};
      flex-shrink: ${this.flexShrink};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
    return x`<slot></slot>`;
  }
};
WuiFlex.styles = [resetStyles, styles$24];
__decorate$2G([
  n$2()
], WuiFlex.prototype, "flexDirection", void 0);
__decorate$2G([
  n$2()
], WuiFlex.prototype, "flexWrap", void 0);
__decorate$2G([
  n$2()
], WuiFlex.prototype, "flexBasis", void 0);
__decorate$2G([
  n$2()
], WuiFlex.prototype, "flexGrow", void 0);
__decorate$2G([
  n$2()
], WuiFlex.prototype, "flexShrink", void 0);
__decorate$2G([
  n$2()
], WuiFlex.prototype, "alignItems", void 0);
__decorate$2G([
  n$2()
], WuiFlex.prototype, "justifyContent", void 0);
__decorate$2G([
  n$2()
], WuiFlex.prototype, "columnGap", void 0);
__decorate$2G([
  n$2()
], WuiFlex.prototype, "rowGap", void 0);
__decorate$2G([
  n$2()
], WuiFlex.prototype, "gap", void 0);
__decorate$2G([
  n$2()
], WuiFlex.prototype, "padding", void 0);
__decorate$2G([
  n$2()
], WuiFlex.prototype, "margin", void 0);
WuiFlex = __decorate$2G([
  customElement("wui-flex")
], WuiFlex);
const styles$23 = i$5`
  :host {
    display: block;
    width: var(--local-width);
    height: var(--local-height);
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 8px var(--wui-color-gray-glass-005);
    overflow: hidden;
    position: relative;
  }

  :host([data-variant='generated']) {
    --mixed-local-color-1: var(--local-color-1);
    --mixed-local-color-2: var(--local-color-2);
    --mixed-local-color-3: var(--local-color-3);
    --mixed-local-color-4: var(--local-color-4);
    --mixed-local-color-5: var(--local-color-5);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host([data-variant='generated']) {
      --mixed-local-color-1: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-1)
      );
      --mixed-local-color-2: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-2)
      );
      --mixed-local-color-3: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-3)
      );
      --mixed-local-color-4: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-4)
      );
      --mixed-local-color-5: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-5)
      );
    }
  }

  :host([data-variant='generated']) {
    box-shadow: 0 0 0 8px var(--wui-color-gray-glass-005);
    background: radial-gradient(
      var(--local-radial-circle),
      #fff 0.52%,
      var(--mixed-local-color-5) 31.25%,
      var(--mixed-local-color-3) 51.56%,
      var(--mixed-local-color-2) 65.63%,
      var(--mixed-local-color-1) 82.29%,
      var(--mixed-local-color-4) 100%
    );
  }

  :host([data-variant='default']) {
    box-shadow: 0 0 0 8px var(--wui-color-gray-glass-005);
    background: radial-gradient(
      75.29% 75.29% at 64.96% 24.36%,
      #fff 0.52%,
      #f5ccfc 31.25%,
      #dba4f5 51.56%,
      #9a8ee8 65.63%,
      #6493da 82.29%,
      #6ebdea 100%
    );
  }
`;
var __decorate$2F = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiAvatar = class WuiAvatar2 extends i$2 {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.alt = void 0;
    this.address = void 0;
    this.size = "xl";
  }
  render() {
    this.style.cssText = `
    --local-width: var(--wui-icon-box-size-${this.size});
    --local-height: var(--wui-icon-box-size-${this.size});
    `;
    return x`${this.visualTemplate()}`;
  }
  visualTemplate() {
    if (this.imageSrc) {
      this.dataset["variant"] = "image";
      return x`<wui-image src=${this.imageSrc} alt=${this.alt ?? "avatar"}></wui-image>`;
    } else if (this.address) {
      this.dataset["variant"] = "generated";
      const cssColors = UiHelperUtil.generateAvatarColors(this.address);
      this.style.cssText += `
 ${cssColors}`;
      return null;
    }
    this.dataset["variant"] = "default";
    return null;
  }
};
WuiAvatar.styles = [resetStyles, styles$23];
__decorate$2F([
  n$2()
], WuiAvatar.prototype, "imageSrc", void 0);
__decorate$2F([
  n$2()
], WuiAvatar.prototype, "alt", void 0);
__decorate$2F([
  n$2()
], WuiAvatar.prototype, "address", void 0);
__decorate$2F([
  n$2()
], WuiAvatar.prototype, "size", void 0);
WuiAvatar = __decorate$2F([
  customElement("wui-avatar")
], WuiAvatar);
const styles$22 = i$5`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    background-color: var(--wui-color-gray-glass-020);
    border-radius: var(--local-border-radius);
    border: var(--local-border);
    box-sizing: content-box;
    width: var(--local-size);
    height: var(--local-size);
    min-height: var(--local-size);
    min-width: var(--local-size);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host {
      background-color: color-mix(in srgb, var(--local-bg-value) var(--local-bg-mix), transparent);
    }
  }
`;
var __decorate$2E = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiIconBox = class WuiIconBox2 extends i$2 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.backgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.background = "transparent";
    this.border = false;
    this.borderColor = "wui-color-bg-125";
    this.icon = "copy";
  }
  render() {
    const iconSize = this.iconSize || this.size;
    const isLg = this.size === "lg";
    const isXl = this.size === "xl";
    const bgMix = isLg ? "12%" : "16%";
    const borderRadius2 = isLg ? "xxs" : isXl ? "s" : "3xl";
    const isGray = this.background === "gray";
    const isOpaque = this.background === "opaque";
    const isColorChange = this.backgroundColor === "accent-100" && isOpaque || this.backgroundColor === "success-100" && isOpaque || this.backgroundColor === "error-100" && isOpaque || this.backgroundColor === "inverse-100" && isOpaque;
    let bgValueVariable = `var(--wui-color-${this.backgroundColor})`;
    if (isColorChange) {
      bgValueVariable = `var(--wui-icon-box-bg-${this.backgroundColor})`;
    } else if (isGray) {
      bgValueVariable = `var(--wui-color-gray-${this.backgroundColor})`;
    }
    this.style.cssText = `
       --local-bg-value: ${bgValueVariable};
       --local-bg-mix: ${isColorChange || isGray ? `100%` : bgMix};
       --local-border-radius: var(--wui-border-radius-${borderRadius2});
       --local-size: var(--wui-icon-box-size-${this.size});
       --local-border: ${this.borderColor === "wui-color-bg-125" ? `2px` : `1px`} solid ${this.border ? `var(--${this.borderColor})` : `transparent`}
   `;
    return x` <wui-icon color=${this.iconColor} size=${iconSize} name=${this.icon}></wui-icon> `;
  }
};
WuiIconBox.styles = [resetStyles, elementStyles, styles$22];
__decorate$2E([
  n$2()
], WuiIconBox.prototype, "size", void 0);
__decorate$2E([
  n$2()
], WuiIconBox.prototype, "backgroundColor", void 0);
__decorate$2E([
  n$2()
], WuiIconBox.prototype, "iconColor", void 0);
__decorate$2E([
  n$2()
], WuiIconBox.prototype, "iconSize", void 0);
__decorate$2E([
  n$2()
], WuiIconBox.prototype, "background", void 0);
__decorate$2E([
  n$2({ type: Boolean })
], WuiIconBox.prototype, "border", void 0);
__decorate$2E([
  n$2()
], WuiIconBox.prototype, "borderColor", void 0);
__decorate$2E([
  n$2()
], WuiIconBox.prototype, "icon", void 0);
WuiIconBox = __decorate$2E([
  customElement("wui-icon-box")
], WuiIconBox);
const styles$21 = i$5`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    background: var(--wui-color-gray-glass-002);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-color-gray-glass-005);
  }

  button:disabled {
    background: var(--wui-color-gray-glass-015);
  }

  button:disabled > wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  button:disabled > wui-flex > wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  button:disabled > wui-image,
  button:disabled > wui-flex > wui-avatar {
    filter: grayscale(1);
  }

  button:has(wui-image) {
    padding: var(--wui-spacing-3xs) var(--wui-spacing-3xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
  }

  wui-text {
    color: var(--wui-color-fg-100);
  }

  wui-flex > wui-text {
    color: var(--wui-color-fg-200);
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  wui-flex {
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-005);
    background: var(--wui-color-gray-glass-005);
    padding: 4px var(--wui-spacing-m) 4px var(--wui-spacing-xxs);
  }

  button.local-no-balance {
    border-radius: 0px;
    border: none;
    background: transparent;
  }

  wui-avatar {
    width: 20px;
    height: 20px;
    box-shadow: 0 0 0 2px var(--wui-color-accent-glass-010);
  }

  @media (max-width: 500px) {
    button {
      gap: 0px;
      padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) !important;
      height: 32px;
    }
    wui-image,
    wui-icon-box,
    button > wui-text {
      visibility: hidden;
      width: 0px;
      height: 0px;
    }
    button {
      border-radius: 0px;
      border: none;
      background: transparent;
      padding: 0px;
    }
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }

    button:active:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }
  }
`;
var __decorate$2D = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiAccountButton = class WuiAccountButton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.networkSrc = void 0;
    this.avatarSrc = void 0;
    this.balance = void 0;
    this.isUnsupportedChain = void 0;
    this.disabled = false;
    this.address = "";
    this.profileName = "";
    this.charsStart = 4;
    this.charsEnd = 6;
  }
  render() {
    return x`
      <button
        ?disabled=${this.disabled}
        class=${o$3(this.balance ? void 0 : "local-no-balance")}
      >
        ${this.balanceTemplate()}
        <wui-flex gap="xxs" alignItems="center">
          <wui-avatar
            .imageSrc=${this.avatarSrc}
            alt=${this.address}
            address=${this.address}
          ></wui-avatar>
          <wui-text variant="paragraph-600" color="inherit">
            ${this.address ? UiHelperUtil.getTruncateString({
      string: this.profileName || this.address,
      charsStart: this.profileName ? 18 : this.charsStart,
      charsEnd: this.profileName ? 0 : this.charsEnd,
      truncate: this.profileName ? "end" : "middle"
    }) : null}
          </wui-text>
        </wui-flex>
      </button>
    `;
  }
  balanceTemplate() {
    if (this.isUnsupportedChain) {
      return x` <wui-icon-box
          size="sm"
          iconColor="error-100"
          backgroundColor="error-100"
          icon="warningCircle"
        ></wui-icon-box>
        <wui-text variant="paragraph-600" color="inherit"> Switch Network</wui-text>`;
    }
    if (this.balance) {
      const networkElement = this.networkSrc ? x`<wui-image src=${this.networkSrc}></wui-image>` : x`
            <wui-icon-box
              size="sm"
              iconColor="fg-200"
              backgroundColor="fg-300"
              icon="networkPlaceholder"
            ></wui-icon-box>
          `;
      return x`
        ${networkElement}
        <wui-text variant="paragraph-600" color="inherit"> ${this.balance}</wui-text>
      `;
    }
    return null;
  }
};
WuiAccountButton.styles = [resetStyles, elementStyles, styles$21];
__decorate$2D([
  n$2()
], WuiAccountButton.prototype, "networkSrc", void 0);
__decorate$2D([
  n$2()
], WuiAccountButton.prototype, "avatarSrc", void 0);
__decorate$2D([
  n$2()
], WuiAccountButton.prototype, "balance", void 0);
__decorate$2D([
  n$2({ type: Boolean })
], WuiAccountButton.prototype, "isUnsupportedChain", void 0);
__decorate$2D([
  n$2({ type: Boolean })
], WuiAccountButton.prototype, "disabled", void 0);
__decorate$2D([
  n$2()
], WuiAccountButton.prototype, "address", void 0);
__decorate$2D([
  n$2()
], WuiAccountButton.prototype, "profileName", void 0);
__decorate$2D([
  n$2()
], WuiAccountButton.prototype, "charsStart", void 0);
__decorate$2D([
  n$2()
], WuiAccountButton.prototype, "charsEnd", void 0);
WuiAccountButton = __decorate$2D([
  customElement("wui-account-button")
], WuiAccountButton);
const styles$20 = i$5`
  :host {
    position: relative;
    background-color: var(--wui-color-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-size);
    height: var(--local-size);
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host > wui-flex {
    overflow: hidden;
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-gray-glass-010);
    pointer-events: none;
  }

  :host([name='Extension'])::after {
    border: 1px solid var(--wui-color-accent-glass-010);
  }

  :host([data-wallet-icon='allWallets']) {
    background-color: var(--wui-all-wallets-bg-100);
  }

  :host([data-wallet-icon='allWallets'])::after {
    border: 1px solid var(--wui-color-accent-glass-010);
  }

  wui-icon[data-parent-size='inherit'] {
    width: 75%;
    height: 75%;
    align-items: center;
  }

  wui-icon[data-parent-size='sm'] {
    width: 18px;
    height: 18px;
  }

  wui-icon[data-parent-size='md'] {
    width: 24px;
    height: 24px;
  }

  wui-icon[data-parent-size='lg'] {
    width: 42px;
    height: 42px;
  }

  wui-icon[data-parent-size='full'] {
    width: 100%;
    height: 100%;
  }

  :host > wui-icon-box {
    position: absolute;
    overflow: hidden;
    right: -1px;
    bottom: -2px;
    z-index: 1;
    border: 2px solid var(--wui-color-bg-150, #1e1f1f);
    padding: 1px;
  }
`;
var __decorate$2C = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiWalletImage = class WuiWalletImage2 extends i$2 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "";
    this.installed = false;
    this.badgeSize = "xs";
  }
  render() {
    let borderRadius2 = "xxs";
    if (this.size === "lg") {
      borderRadius2 = "m";
    } else if (this.size === "md") {
      borderRadius2 = "xs";
    } else {
      borderRadius2 = "xxs";
    }
    this.style.cssText = `
       --local-border-radius: var(--wui-border-radius-${borderRadius2});
       --local-size: var(--wui-wallet-image-size-${this.size});
   `;
    if (this.walletIcon) {
      this.dataset["walletIcon"] = this.walletIcon;
    }
    return x`
      <wui-flex justifyContent="center" alignItems="center"> ${this.templateVisual()} </wui-flex>
    `;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`;
    } else if (this.walletIcon) {
      return x`<wui-icon
        data-parent-size="md"
        size="md"
        color="inherit"
        name=${this.walletIcon}
      ></wui-icon>`;
    }
    return x`<wui-icon
      data-parent-size=${this.size}
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
  }
};
WuiWalletImage.styles = [resetStyles, styles$20];
__decorate$2C([
  n$2()
], WuiWalletImage.prototype, "size", void 0);
__decorate$2C([
  n$2()
], WuiWalletImage.prototype, "name", void 0);
__decorate$2C([
  n$2()
], WuiWalletImage.prototype, "imageSrc", void 0);
__decorate$2C([
  n$2()
], WuiWalletImage.prototype, "walletIcon", void 0);
__decorate$2C([
  n$2({ type: Boolean })
], WuiWalletImage.prototype, "installed", void 0);
__decorate$2C([
  n$2()
], WuiWalletImage.prototype, "badgeSize", void 0);
WuiWalletImage = __decorate$2C([
  customElement("wui-wallet-image")
], WuiWalletImage);
const styles$1$ = i$5`
  :host {
    position: relative;
    border-radius: var(--wui-border-radius-xxs);
    width: 40px;
    height: 40px;
    overflow: hidden;
    background: var(--wui-color-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--wui-spacing-4xs);
    padding: 3.75px !important;
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-gray-glass-010);
    pointer-events: none;
  }

  :host > wui-wallet-image {
    width: 14px;
    height: 14px;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > wui-flex {
    padding: 2px;
    position: fixed;
    overflow: hidden;
    left: 34px;
    bottom: 8px;
    background: var(--dark-background-150, #1e1f1f);
    border-radius: 50%;
    z-index: 2;
    display: flex;
  }
`;
var __decorate$2B = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const TOTAL_IMAGES = 4;
let WuiAllWalletsImage = class WuiAllWalletsImage2 extends i$2 {
  constructor() {
    super(...arguments);
    this.walletImages = [];
  }
  render() {
    const isPlaceholders = this.walletImages.length < TOTAL_IMAGES;
    return x`${this.walletImages.slice(0, TOTAL_IMAGES).map(({ src: src2, walletName }) => x`
            <wui-wallet-image
              size="inherit"
              imageSrc=${src2}
              name=${o$3(walletName)}
            ></wui-wallet-image>
          `)}
      ${isPlaceholders ? [...Array(TOTAL_IMAGES - this.walletImages.length)].map(() => x` <wui-wallet-image size="inherit" name=""></wui-wallet-image>`) : null}
      <wui-flex>
        <wui-icon-box
          size="xxs"
          iconSize="xxs"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>`;
  }
};
WuiAllWalletsImage.styles = [resetStyles, styles$1$];
__decorate$2B([
  n$2({ type: Array })
], WuiAllWalletsImage.prototype, "walletImages", void 0);
WuiAllWalletsImage = __decorate$2B([
  customElement("wui-all-wallets-image")
], WuiAllWalletsImage);
const styles$1_ = i$5`
  :host {
    width: var(--local-width);
    position: relative;
  }

  button {
    border: none;
    border-radius: var(--local-border-radius);
    width: var(--local-width);
    white-space: nowrap;
  }

  /* -- Sizes --------------------------------------------------- */
  button[data-size='md'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-l);
    height: 36px;
  }

  button[data-size='md'][data-icon-left='true'][data-icon-right='false'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-s);
  }

  button[data-size='md'][data-icon-right='true'][data-icon-left='false'] {
    padding: 8.2px var(--wui-spacing-s) 9px var(--wui-spacing-l);
  }

  button[data-size='lg'] {
    padding: var(--wui-spacing-m) var(--wui-spacing-2l);
    height: 48px;
  }

  /* -- Variants --------------------------------------------------------- */
  button[data-variant='main'] {
    background-color: var(--wui-color-accent-100);
    color: var(--wui-color-inverse-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='inverse'] {
    background-color: var(--wui-color-inverse-100);
    color: var(--wui-color-inverse-000);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='accent'] {
    background-color: var(--wui-color-accent-glass-010);
    color: var(--wui-color-accent-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  button[data-variant='accent-error'] {
    background: var(--wui-color-error-glass-015);
    color: var(--wui-color-error-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-error-glass-010);
  }

  button[data-variant='accent-success'] {
    background: var(--wui-color-success-glass-015);
    color: var(--wui-color-success-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-success-glass-010);
  }

  button[data-variant='neutral'] {
    background: transparent;
    color: var(--wui-color-fg-100);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  /* -- Focus states --------------------------------------------------- */
  button[data-variant='main']:focus-visible:enabled {
    background-color: var(--wui-color-accent-090);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='inverse']:focus-visible:enabled {
    background-color: var(--wui-color-inverse-100);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-gray-glass-010),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='accent']:focus-visible:enabled {
    background-color: var(--wui-color-accent-glass-010);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0 0 0 4px var(--wui-color-accent-glass-020);
  }
  button[data-variant='accent-error']:focus-visible:enabled {
    background: var(--wui-color-error-glass-015);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-error-100),
      0 0 0 4px var(--wui-color-error-glass-020);
  }
  button[data-variant='accent-success']:focus-visible:enabled {
    background: var(--wui-color-success-glass-015);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-success-100),
      0 0 0 4px var(--wui-color-success-glass-020);
  }
  button[data-variant='neutral']:focus-visible:enabled {
    background: var(--wui-color-gray-glass-005);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-gray-glass-010),
      0 0 0 4px var(--wui-color-gray-glass-002);
  }

  /* -- Hover & Active states ----------------------------------------------------------- */
  @media (hover: hover) and (pointer: fine) {
    button[data-variant='main']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='main']:active:enabled {
      background-color: var(--wui-color-accent-080);
    }

    button[data-variant='accent']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }

    button[data-variant='accent']:active:enabled {
      background-color: var(--wui-color-accent-glass-020);
    }

    button[data-variant='accent-error']:hover:enabled {
      background: var(--wui-color-error-glass-020);
      color: var(--wui-color-error-100);
    }

    button[data-variant='accent-error']:active:enabled {
      background: var(--wui-color-error-glass-030);
      color: var(--wui-color-error-100);
    }

    button[data-variant='accent-success']:hover:enabled {
      background: var(--wui-color-success-glass-020);
      color: var(--wui-color-success-100);
    }

    button[data-variant='accent-success']:active:enabled {
      background: var(--wui-color-success-glass-030);
      color: var(--wui-color-success-100);
    }

    button[data-variant='neutral']:hover:enabled {
      background: var(--wui-color-gray-glass-002);
    }

    button[data-variant='neutral']:active:enabled {
      background: var(--wui-color-gray-glass-005);
    }

    button[data-size='lg'][data-icon-left='true'][data-icon-right='false'] {
      padding-left: var(--wui-spacing-m);
    }

    button[data-size='lg'][data-icon-right='true'][data-icon-left='false'] {
      padding-right: var(--wui-spacing-m);
    }
  }

  /* -- Disabled state --------------------------------------------------- */
  button:disabled {
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    color: var(--wui-color-gray-glass-020);
    cursor: not-allowed;
  }

  button > wui-text {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
  }

  ::slotted(*) {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
  }

  wui-loading-spinner {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    opacity: var(--local-opacity-000);
  }
`;
var __decorate$2A = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const SPINNER_COLOR_BY_VARIANT = {
  main: "inverse-100",
  inverse: "inverse-000",
  accent: "accent-100",
  "accent-error": "error-100",
  "accent-success": "success-100",
  neutral: "fg-100",
  disabled: "gray-glass-020"
};
const TEXT_VARIANT_BY_SIZE = {
  lg: "paragraph-600",
  md: "small-600"
};
const SPINNER_SIZE_BY_SIZE = {
  lg: "md",
  md: "md"
};
let WuiButton = class WuiButton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.size = "lg";
    this.disabled = false;
    this.fullWidth = false;
    this.loading = false;
    this.variant = "main";
    this.hasIconLeft = false;
    this.hasIconRight = false;
    this.borderRadius = "m";
  }
  render() {
    this.style.cssText = `
    --local-width: ${this.fullWidth ? "100%" : "auto"};
    --local-opacity-100: ${this.loading ? 0 : 1};
    --local-opacity-000: ${this.loading ? 1 : 0};
    --local-border-radius: var(--wui-border-radius-${this.borderRadius});
    `;
    const textVariant = this.textVariant ?? TEXT_VARIANT_BY_SIZE[this.size];
    return x`
      <button
        data-variant=${this.variant}
        data-icon-left=${this.hasIconLeft}
        data-icon-right=${this.hasIconRight}
        data-size=${this.size}
        ?disabled=${this.disabled}
        ontouchstart
      >
        ${this.loadingTemplate()}
        <slot name="iconLeft" @slotchange=${() => this.handleSlotLeftChange()}></slot>
        <wui-text variant=${textVariant} color="inherit">
          <slot></slot>
        </wui-text>
        <slot name="iconRight" @slotchange=${() => this.handleSlotRightChange()}></slot>
      </button>
    `;
  }
  handleSlotLeftChange() {
    this.hasIconLeft = true;
  }
  handleSlotRightChange() {
    this.hasIconRight = true;
  }
  loadingTemplate() {
    if (this.loading) {
      const size2 = SPINNER_SIZE_BY_SIZE[this.size];
      const color2 = this.disabled ? SPINNER_COLOR_BY_VARIANT["disabled"] : SPINNER_COLOR_BY_VARIANT[this.variant];
      return x`<wui-loading-spinner color=${color2} size=${size2}></wui-loading-spinner>`;
    }
    return x``;
  }
};
WuiButton.styles = [resetStyles, elementStyles, styles$1_];
__decorate$2A([
  n$2()
], WuiButton.prototype, "size", void 0);
__decorate$2A([
  n$2({ type: Boolean })
], WuiButton.prototype, "disabled", void 0);
__decorate$2A([
  n$2({ type: Boolean })
], WuiButton.prototype, "fullWidth", void 0);
__decorate$2A([
  n$2({ type: Boolean })
], WuiButton.prototype, "loading", void 0);
__decorate$2A([
  n$2()
], WuiButton.prototype, "variant", void 0);
__decorate$2A([
  n$2({ type: Boolean })
], WuiButton.prototype, "hasIconLeft", void 0);
__decorate$2A([
  n$2({ type: Boolean })
], WuiButton.prototype, "hasIconRight", void 0);
__decorate$2A([
  n$2()
], WuiButton.prototype, "borderRadius", void 0);
__decorate$2A([
  n$2()
], WuiButton.prototype, "textVariant", void 0);
WuiButton = __decorate$2A([
  customElement("wui-button")
], WuiButton);
const networkSvgMd = b`<svg  viewBox="0 0 48 54" fill="none">
  <path
    d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
  />
</svg>`;
const styles$1Z = i$5`
  :host {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) 10px;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    position: relative;
  }

  wui-shimmer[data-type='network'] {
    border: none;
    -webkit-clip-path: var(--wui-path-network);
    clip-path: var(--wui-path-network);
  }

  svg {
    position: absolute;
    width: 48px;
    height: 54px;
    z-index: 1;
  }

  svg > path {
    stroke: var(--wui-color-gray-glass-010);
    stroke-width: 1px;
  }
`;
var __decorate$2z = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiCardSelectLoader = class WuiCardSelectLoader2 extends i$2 {
  constructor() {
    super(...arguments);
    this.type = "wallet";
  }
  render() {
    return x`
      ${this.shimmerTemplate()}
      <wui-shimmer width="56px" height="20px" borderRadius="xs"></wui-shimmer>
    `;
  }
  shimmerTemplate() {
    if (this.type === "network") {
      return x` <wui-shimmer
          data-type=${this.type}
          width="48px"
          height="54px"
          borderRadius="xs"
        ></wui-shimmer>
        ${networkSvgMd}`;
    }
    return x`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`;
  }
};
WuiCardSelectLoader.styles = [resetStyles, elementStyles, styles$1Z];
__decorate$2z([
  n$2()
], WuiCardSelectLoader.prototype, "type", void 0);
WuiCardSelectLoader = __decorate$2z([
  customElement("wui-card-select-loader")
], WuiCardSelectLoader);
const networkSvgSm = b`
  <svg fill="none" viewBox="0 0 36 40">
    <path
      d="M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z"
    />
  </svg>
`;
const networkSvgLg = b`<svg width="86" height="96" fill="none">
  <path
    d="M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z"
  />
</svg>`;
const styles$1Y = i$5`
  :host {
    position: relative;
    border-radius: inherit;
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-width);
    height: var(--local-height);
  }

  :host([data-round='true']) {
    background: var(--wui-color-gray-glass-002);
    border-radius: 100%;
    outline: 1px solid var(--wui-color-gray-glass-005);
  }

  svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    fill: var(--wui-color-gray-glass-002);
  }

  svg > path {
    stroke: var(--local-stroke);
  }

  wui-image {
    width: 100%;
    height: 100%;
    -webkit-clip-path: var(--local-path);
    clip-path: var(--local-path);
    background: var(--wui-color-gray-glass-002);
  }

  wui-icon {
    transform: translateY(-5%);
    width: var(--local-icon-size);
    height: var(--local-icon-size);
  }
`;
var __decorate$2y = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiNetworkImage = class WuiNetworkImage2 extends i$2 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.name = "uknown";
    this.networkImagesBySize = {
      sm: networkSvgSm,
      md: networkSvgMd,
      lg: networkSvgLg
    };
    this.selected = false;
    this.round = false;
  }
  render() {
    if (this.round) {
      this.dataset["round"] = "true";
      this.style.cssText = `
      --local-width: var(--wui-spacing-3xl);
      --local-height: var(--wui-spacing-3xl);
      --local-icon-size: var(--wui-spacing-l);
    `;
    } else {
      this.style.cssText = `

      --local-path: var(--wui-path-network-${this.size});
      --local-width:  var(--wui-width-network-${this.size});
      --local-height:  var(--wui-height-network-${this.size});
      --local-icon-size:  var(--wui-icon-size-network-${this.size});
    `;
    }
    return x`${this.templateVisual()} ${this.svgTemplate()} `;
  }
  svgTemplate() {
    if (this.round) {
      return null;
    }
    return this.networkImagesBySize[this.size];
  }
  templateVisual() {
    if (this.imageSrc) {
      return x`<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`;
    }
    return x`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiNetworkImage.styles = [resetStyles, styles$1Y];
__decorate$2y([
  n$2()
], WuiNetworkImage.prototype, "size", void 0);
__decorate$2y([
  n$2()
], WuiNetworkImage.prototype, "name", void 0);
__decorate$2y([
  n$2({ type: Object })
], WuiNetworkImage.prototype, "networkImagesBySize", void 0);
__decorate$2y([
  n$2()
], WuiNetworkImage.prototype, "imageSrc", void 0);
__decorate$2y([
  n$2({ type: Boolean })
], WuiNetworkImage.prototype, "selected", void 0);
__decorate$2y([
  n$2({ type: Boolean })
], WuiNetworkImage.prototype, "round", void 0);
WuiNetworkImage = __decorate$2y([
  customElement("wui-network-image")
], WuiNetworkImage);
const styles$1X = i$5`
  button {
    flex-direction: column;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-0);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
  }

  button > wui-text {
    color: var(--wui-color-fg-100);
    max-width: var(--wui-icon-box-size-xl);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button:disabled > wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-color-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-color-accent-glass-010);
  }
`;
var __decorate$2x = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiCardSelect = class WuiCardSelect2 extends i$2 {
  constructor() {
    super(...arguments);
    this.name = "Unknown";
    this.type = "wallet";
    this.imageSrc = void 0;
    this.disabled = false;
    this.selected = false;
    this.installed = false;
  }
  render() {
    return x`
      <button data-selected=${o$3(this.selected)} ?disabled=${this.disabled} ontouchstart>
        ${this.imageTemplate()}
        <wui-text variant="tiny-500" color=${this.selected ? "accent-100" : "inherit"}>
          ${this.name}
        </wui-text>
      </button>
    `;
  }
  imageTemplate() {
    if (this.type === "network") {
      return x`
        <wui-network-image
          .selected=${this.selected}
          imageSrc=${o$3(this.imageSrc)}
          name=${this.name}
        >
        </wui-network-image>
      `;
    }
    return x`
      <wui-wallet-image
        size="md"
        imageSrc=${o$3(this.imageSrc)}
        name=${this.name}
        .installed=${this.installed}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `;
  }
};
WuiCardSelect.styles = [resetStyles, elementStyles, styles$1X];
__decorate$2x([
  n$2()
], WuiCardSelect.prototype, "name", void 0);
__decorate$2x([
  n$2()
], WuiCardSelect.prototype, "type", void 0);
__decorate$2x([
  n$2()
], WuiCardSelect.prototype, "imageSrc", void 0);
__decorate$2x([
  n$2({ type: Boolean })
], WuiCardSelect.prototype, "disabled", void 0);
__decorate$2x([
  n$2({ type: Boolean })
], WuiCardSelect.prototype, "selected", void 0);
__decorate$2x([
  n$2({ type: Boolean })
], WuiCardSelect.prototype, "installed", void 0);
WuiCardSelect = __decorate$2x([
  customElement("wui-card-select")
], WuiCardSelect);
const styles$1W = i$5`
  a {
    border: 1px solid var(--wui-color-gray-glass-010);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  a.disabled > wui-icon,
  a.disabled > wui-image {
    filter: grayscale(1);
  }

  a[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  a[data-variant='shade'],
  a[data-variant='shadeSmall'] {
    background-color: transparent;
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  a[data-variant='success'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-color-success-glass-010);
    background-color: var(--wui-color-success-glass-010);
    color: var(--wui-color-success-100);
  }

  a[data-variant='error'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-color-error-glass-010);
    background-color: var(--wui-color-error-glass-010);
    color: var(--wui-color-error-100);
  }

  a[data-variant='transparent'] {
    column-gap: var(--wui-spacing-xxs);
    background-color: transparent;
    color: var(--wui-color-fg-150);
  }

  a[data-variant='transparent'],
  a[data-variant='success'],
  a[data-variant='shadeSmall'],
  a[data-variant='error'] {
    padding: 7px var(--wui-spacing-s) 7px 10px;
  }

  a[data-variant='transparent']:has(wui-text:first-child),
  a[data-variant='success']:has(wui-text:first-child),
  a[data-variant='shadeSmall']:has(wui-text:first-child),
  a[data-variant='error']:has(wui-text:first-child) {
    padding: 7px var(--wui-spacing-s);
  }

  a[data-variant='fill'],
  a[data-variant='shade'] {
    column-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  a[data-variant='fill']:has(wui-text:first-child),
  a[data-variant='shade']:has(wui-text:first-child) {
    padding: 9px var(--wui-spacing-m) 9px var(--wui-spacing-m);
  }

  a[data-variant='fill'] > wui-image,
  a[data-variant='shade'] > wui-image {
    width: 24px;
    height: 24px;
  }

  a[data-variant='fill'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  a[data-variant='shade'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  a[data-variant='fill'] > wui-icon,
  a[data-variant='shade'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-image,
  a[data-variant='success'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image,
  a[data-variant='error'] > wui-image {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-icon,
  a[data-variant='success'] > wui-icon,
  a[data-variant='shadeSmall'] > wui-icon,
  a[data-variant='error'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  a[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  a[data-variant='shade']:focus-visible,
  a[data-variant='shadeSmall']:focus-visible {
    background-color: var(--wui-color-gray-glass-015);
  }

  a[data-variant='transparent']:focus-visible {
    background-color: var(--wui-color-gray-glass-005);
  }

  a[data-variant='success']:focus-visible {
    background-color: var(--wui-color-success-glass-015);
  }

  a[data-variant='error']:focus-visible {
    background-color: var(--wui-color-error-glass-015);
  }

  a.disabled {
    color: var(--wui-color-gray-glass-015);
    background-color: var(--wui-color-gray-glass-015);
    pointer-events: none;
  }

  @media (hover: hover) and (pointer: fine) {
    a[data-variant='fill']:hover {
      background-color: var(--wui-color-accent-090);
    }

    a[data-variant='shade']:hover,
    a[data-variant='shadeSmall']:hover {
      background-color: var(--wui-color-gray-glass-015);
    }

    a[data-variant='transparent']:hover {
      background-color: var(--wui-color-gray-glass-005);
    }

    a[data-variant='success']:hover {
      background-color: var(--wui-color-success-glass-015);
    }

    a[data-variant='error']:hover {
      background-color: var(--wui-color-error-glass-015);
    }
  }

  a[data-variant='fill']:active {
    background-color: var(--wui-color-accent-080);
  }

  a[data-variant='shade']:active,
  a[data-variant='shadeSmall']:active {
    background-color: var(--wui-color-gray-glass-020);
  }

  a[data-variant='transparent']:active {
    background-color: var(--wui-color-gray-glass-010);
  }

  a[data-variant='success']:active {
    background-color: var(--wui-color-success-glass-020);
  }

  a[data-variant='error']:active {
    background-color: var(--wui-color-error-glass-020);
  }
`;
var __decorate$2w = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiChip = class WuiChip2 extends i$2 {
  constructor() {
    super(...arguments);
    this.variant = "fill";
    this.imageSrc = void 0;
    this.disabled = false;
    this.icon = "externalLink";
    this.href = "";
    this.text = void 0;
  }
  render() {
    const isSmall = this.variant === "success" || this.variant === "transparent" || this.variant === "shadeSmall";
    const textVariant = isSmall ? "small-600" : "paragraph-600";
    return x`
      <a
        rel="noreferrer"
        target="_blank"
        href=${this.href}
        class=${this.disabled ? "disabled" : ""}
        data-variant=${this.variant}
      >
        ${this.imageTemplate()}
        <wui-text variant=${textVariant} color="inherit">
          ${this.title ? this.title : UiHelperUtil.getHostName(this.href)}
        </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </a>
    `;
  }
  imageTemplate() {
    if (this.imageSrc) {
      return x`<wui-image src=${this.imageSrc}></wui-image>`;
    }
    return null;
  }
};
WuiChip.styles = [resetStyles, elementStyles, styles$1W];
__decorate$2w([
  n$2()
], WuiChip.prototype, "variant", void 0);
__decorate$2w([
  n$2()
], WuiChip.prototype, "imageSrc", void 0);
__decorate$2w([
  n$2({ type: Boolean })
], WuiChip.prototype, "disabled", void 0);
__decorate$2w([
  n$2()
], WuiChip.prototype, "icon", void 0);
__decorate$2w([
  n$2()
], WuiChip.prototype, "href", void 0);
__decorate$2w([
  n$2()
], WuiChip.prototype, "text", void 0);
WuiChip = __decorate$2w([
  customElement("wui-chip")
], WuiChip);
const styles$1V = i$5`
  :host {
    position: relative;
    display: block;
  }

  button {
    background: var(--wui-color-accent-100);
    border: 1px solid var(--wui-color-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    gap: var(--wui-spacing-xs);
  }

  button.loading {
    background: var(--wui-color-gray-glass-010);
    border: 1px solid var(--wui-color-gray-glass-010);
    pointer-events: none;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    border: 1px solid var(--wui-color-gray-glass-010);
  }

  button:disabled > wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button:active:enabled {
      background-color: var(--wui-color-accent-080);
    }
  }

  button:focus-visible {
    border: 1px solid var(--wui-color-gray-glass-010);
    background-color: var(--wui-color-accent-090);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-size='sm'] {
    padding: 6.75px 10px 7.25px;
  }

  ::slotted(*) {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
    opacity: var(--local-opacity-100);
    color: var(--wui-color-inverse-100);
  }

  button[data-size='md'] {
    padding: 9px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'] + wui-text {
    padding-left: var(--wui-spacing-3xs);
  }

  @media (max-width: 500px) {
    button[data-size='md'] {
      height: 32px;
      padding: 5px 12px;
    }

    button[data-size='md'] > wui-text > slot {
      font-size: 14px !important;
    }
  }

  wui-loading-spinner {
    width: 14px;
    height: 14px;
  }

  wui-loading-spinner::slotted(svg) {
    width: 10px !important;
    height: 10px !important;
  }

  button[data-size='sm'] > wui-loading-spinner {
    width: 12px;
    height: 12px;
  }
`;
var __decorate$2v = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiConnectButton = class WuiConnectButton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.loading = false;
  }
  render() {
    const textVariant = this.size === "md" ? "paragraph-600" : "small-600";
    return x`
      <button data-size=${this.size} ?disabled=${this.loading} ontouchstart>
        ${this.loadingTemplate()}
        <wui-text variant=${textVariant} color=${this.loading ? "accent-100" : "inherit"}>
          <slot></slot>
        </wui-text>
      </button>
    `;
  }
  loadingTemplate() {
    if (!this.loading) {
      return null;
    }
    return x`<wui-loading-spinner size=${this.size} color="accent-100"></wui-loading-spinner>`;
  }
};
WuiConnectButton.styles = [resetStyles, elementStyles, styles$1V];
__decorate$2v([
  n$2()
], WuiConnectButton.prototype, "size", void 0);
__decorate$2v([
  n$2({ type: Boolean })
], WuiConnectButton.prototype, "loading", void 0);
WuiConnectButton = __decorate$2v([
  customElement("wui-connect-button")
], WuiConnectButton);
const styles$1U = i$5`
  wui-flex {
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$2u = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiCtaButton = class WuiCtaButton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.label = "";
    this.buttonLabel = "";
  }
  render() {
    return x`
      <wui-flex
        justifyContent="space-between"
        alignItems="center"
        .padding=${["1xs", "2l", "1xs", "2l"]}
      >
        <wui-text variant="paragraph-500" color="fg-200">${this.label}</wui-text>
        <wui-chip-button size="sm" variant="shade" text=${this.buttonLabel} icon="chevronRight">
        </wui-chip-button>
      </wui-flex>
    `;
  }
};
WuiCtaButton.styles = [resetStyles, elementStyles, styles$1U];
__decorate$2u([
  n$2({ type: Boolean })
], WuiCtaButton.prototype, "disabled", void 0);
__decorate$2u([
  n$2()
], WuiCtaButton.prototype, "label", void 0);
__decorate$2u([
  n$2()
], WuiCtaButton.prototype, "buttonLabel", void 0);
WuiCtaButton = __decorate$2u([
  customElement("wui-cta-button")
], WuiCtaButton);
const styles$1T = i$5`
  :host {
    display: block;
    padding: var(--wui-spacing-l) var(--wui-spacing-m);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    width: 100%;
  }
`;
var __decorate$2t = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiDetailsGroup = class WuiDetailsGroup2 extends i$2 {
  render() {
    return x`
      <wui-flex gap="xl" flexDirection="column" justifyContent="space-between" alignItems="center">
        <slot></slot>
      </wui-flex>
    `;
  }
};
WuiDetailsGroup.styles = [resetStyles, elementStyles, styles$1T];
WuiDetailsGroup = __decorate$2t([
  customElement("wui-details-group")
], WuiDetailsGroup);
const styles$1S = i$5`
  :host {
    display: flex;
    flex-direction: row;
    gap: var(--wui-spacing-l);
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$2s = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiDetailsGroupItem = class WuiDetailsGroupItem2 extends i$2 {
  constructor() {
    super(...arguments);
    this.name = "";
  }
  render() {
    return x`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">${this.name}</wui-text>
        <wui-flex gap="xs" alignItems="center">
          <slot></slot>
        </wui-flex>
      </wui-flex>
    `;
  }
};
WuiDetailsGroupItem.styles = [resetStyles, elementStyles, styles$1S];
__decorate$2s([
  n$2()
], WuiDetailsGroupItem.prototype, "name", void 0);
WuiDetailsGroupItem = __decorate$2s([
  customElement("wui-details-group-item")
], WuiDetailsGroupItem);
const styles$1R = i$5`
  :host {
    z-index: calc(var(--w3m-z-index) + 1);
    width: 200px;
    padding: var(--wui-spacing-3xs);
    align-items: center;
    display: inherit;
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-fg-base-125);
    /* Dark/Elevation/L */
    box-shadow:
      0px 8px 22px -6px rgba(0, 0, 0, 0.12),
      0px 14px 64px -4px rgba(0, 0, 0, 0.12);
  }
`;
var __decorate$2r = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiDropdownMenu = class WuiDropdownMenu2 extends i$2 {
  constructor() {
    super(...arguments);
    this.actions = [];
    this.isOpen = false;
  }
  render() {
    if (!this.isOpen) {
      return null;
    }
    return x`
      <wui-flex flexDirection="column" gap="4xs">
        ${this.actions.map((action) => x`
            <wui-list-item
              icon=${action.icon}
              iconSize="sm"
              variant="icon"
              @click=${action.onClick}
            >
              <wui-text variant="small-400" color="fg-100">${action.label}</wui-text>
            </wui-list-item>
          `)}
      </wui-flex>
    `;
  }
};
WuiDropdownMenu.styles = [resetStyles, elementStyles, styles$1R];
__decorate$2r([
  n$2({ type: Array })
], WuiDropdownMenu.prototype, "actions", void 0);
__decorate$2r([
  n$2({ type: Boolean })
], WuiDropdownMenu.prototype, "isOpen", void 0);
WuiDropdownMenu = __decorate$2r([
  customElement("wui-dropdown-menu")
], WuiDropdownMenu);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const i3 = (o2) => null === o2 || "object" != typeof o2 && "function" != typeof o2, f$1 = (o2) => void 0 === o2.strings;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const s = (i4, t2) => {
  const e2 = i4._$AN;
  if (void 0 === e2) return false;
  for (const i5 of e2) i5._$AO?.(t2, false), s(i5, t2);
  return true;
}, o$2 = (i4) => {
  let t2, e2;
  do {
    if (void 0 === (t2 = i4._$AM)) break;
    e2 = t2._$AN, e2.delete(i4), i4 = t2;
  } while (0 === e2?.size);
}, r = (i4) => {
  for (let t2; t2 = i4._$AM; i4 = t2) {
    let e2 = t2._$AN;
    if (void 0 === e2) t2._$AN = e2 = /* @__PURE__ */ new Set();
    else if (e2.has(i4)) break;
    e2.add(i4), c(t2);
  }
};
function h$1(i4) {
  void 0 !== this._$AN ? (o$2(this), this._$AM = i4, r(this)) : this._$AM = i4;
}
function n$1(i4, t2 = false, e2 = 0) {
  const r2 = this._$AH, h2 = this._$AN;
  if (void 0 !== h2 && 0 !== h2.size) if (t2) if (Array.isArray(r2)) for (let i5 = e2; i5 < r2.length; i5++) s(r2[i5], false), o$2(r2[i5]);
  else null != r2 && (s(r2, false), o$2(r2));
  else s(this, i4);
}
const c = (i4) => {
  i4.type == t.CHILD && (i4._$AP ?? (i4._$AP = n$1), i4._$AQ ?? (i4._$AQ = h$1));
};
class f extends i$1 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i4, t2, e2) {
    super._$AT(i4, t2, e2), r(this), this.isConnected = i4._$AU;
  }
  _$AO(i4, t2 = true) {
    i4 !== this.isConnected && (this.isConnected = i4, i4 ? this.reconnected?.() : this.disconnected?.()), t2 && (s(this, i4), o$2(this));
  }
  setValue(t2) {
    if (f$1(this._$Ct)) this._$Ct._$AI(t2, this);
    else {
      const i4 = [...this._$Ct._$AH];
      i4[this._$Ci] = t2, this._$Ct._$AI(i4, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e = () => new h();
class h {
}
const o$1 = /* @__PURE__ */ new WeakMap(), n2 = e$2(class extends f {
  render(i22) {
    return E;
  }
  update(i22, [s2]) {
    const e2 = s2 !== this.G;
    return e2 && void 0 !== this.G && this.rt(void 0), (e2 || this.lt !== this.ct) && (this.G = s2, this.ht = i22.options?.host, this.rt(this.ct = i22.element)), E;
  }
  rt(t2) {
    if (this.isConnected || (t2 = void 0), "function" == typeof this.G) {
      const i22 = this.ht ?? globalThis;
      let s2 = o$1.get(i22);
      void 0 === s2 && (s2 = /* @__PURE__ */ new WeakMap(), o$1.set(i22, s2)), void 0 !== s2.get(this.G) && this.G.call(this.ht, void 0), s2.set(this.G, t2), void 0 !== t2 && this.G.call(this.ht, t2);
    } else this.G.value = t2;
  }
  get lt() {
    return "function" == typeof this.G ? o$1.get(this.ht ?? globalThis)?.get(this.G) : this.G?.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
const styles$1Q = i$5`
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  input {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
    color: var(--wui-color-fg-100);
    transition:
      background-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      border-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      box-shadow var(--wui-ease-inout-power-1) var(--wui-duration-md);
    will-change: background-color, border-color, box-shadow;
    caret-color: var(--wui-color-accent-100);
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-color-gray-glass-010);
  }

  input:disabled::placeholder,
  input:disabled + wui-icon {
    color: var(--wui-color-fg-300);
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }

  input:focus:enabled {
    background-color: var(--wui-color-gray-glass-005);
    -webkit-box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow:
      inset 0 0 0 1px var(--wui-color-accent-100),
      0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  input:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  wui-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
  }

  .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px var(--wui-spacing-s);
  }

  wui-icon + .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px 36px;
  }

  wui-icon[data-input='sm'] {
    left: var(--wui-spacing-s);
  }

  .wui-size-md {
    padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) var(--wui-spacing-m);
  }

  wui-icon + .wui-size-md,
  wui-loading-spinner + .wui-size-md {
    padding: 10.5px var(--wui-spacing-3xl) 10.5px var(--wui-spacing-3xl);
  }

  wui-icon[data-input='md'] {
    left: var(--wui-spacing-l);
  }

  .wui-size-lg {
    padding: var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-l);
    letter-spacing: var(--wui-letter-spacing-medium-title);
    font-size: var(--wui-font-size-medium-title);
    font-weight: var(--wui-font-weight-light);
    line-height: 130%;
    color: var(--wui-color-fg-100);
    height: 64px;
  }

  .wui-padding-right-xs {
    padding-right: var(--wui-spacing-xs);
  }

  .wui-padding-right-s {
    padding-right: var(--wui-spacing-s);
  }

  .wui-padding-right-m {
    padding-right: var(--wui-spacing-m);
  }

  .wui-padding-right-l {
    padding-right: var(--wui-spacing-l);
  }

  .wui-padding-right-xl {
    padding-right: var(--wui-spacing-xl);
  }

  .wui-padding-right-2xl {
    padding-right: var(--wui-spacing-2xl);
  }

  .wui-padding-right-3xl {
    padding-right: var(--wui-spacing-3xl);
  }

  .wui-padding-right-4xl {
    padding-right: var(--wui-spacing-4xl);
  }

  .wui-padding-right-5xl {
    padding-right: var(--wui-spacing-5xl);
  }

  wui-icon + .wui-size-lg,
  wui-loading-spinner + .wui-size-lg {
    padding-left: 50px;
  }

  wui-icon[data-input='lg'] {
    left: var(--wui-spacing-l);
  }

  .wui-size-mdl {
    padding: 17.25px var(--wui-spacing-m) 17.25px var(--wui-spacing-m);
  }
  wui-icon + .wui-size-mdl,
  wui-loading-spinner + .wui-size-mdl {
    padding: 17.25px var(--wui-spacing-3xl) 17.25px 40px;
  }
  wui-icon[data-input='mdl'] {
    left: var(--wui-spacing-m);
  }

  input:placeholder-shown ~ ::slotted(wui-input-element),
  input:placeholder-shown ~ ::slotted(wui-icon) {
    opacity: 0;
    pointer-events: none;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  ::slotted(wui-input-element),
  ::slotted(wui-icon) {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
  }

  ::slotted(wui-input-element) {
    right: var(--wui-spacing-m);
  }

  ::slotted(wui-icon) {
    right: 0px;
  }
`;
var __decorate$2q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiInputText = class WuiInputText2 extends i$2 {
  constructor() {
    super(...arguments);
    this.inputElementRef = e();
    this.size = "md";
    this.disabled = false;
    this.placeholder = "";
    this.type = "text";
    this.value = "";
  }
  render() {
    const inputClass = `wui-padding-right-${this.inputRightPadding}`;
    const sizeClass = `wui-size-${this.size}`;
    const classes = {
      [sizeClass]: true,
      [inputClass]: Boolean(this.inputRightPadding)
    };
    return x`${this.templateIcon()}
      <input
        data-testid="wui-input-text"
        ${n2(this.inputElementRef)}
        class=${e$1(classes)}
        type=${this.type}
        enterkeyhint=${o$3(this.enterKeyHint)}
        ?disabled=${this.disabled}
        placeholder=${this.placeholder}
        @input=${this.dispatchInputChangeEvent.bind(this)}
        .value=${this.value || ""}
      />
      <slot></slot>`;
  }
  templateIcon() {
    if (this.icon) {
      return x`<wui-icon
        data-input=${this.size}
        size=${this.size}
        color="inherit"
        name=${this.icon}
      ></wui-icon>`;
    }
    return null;
  }
  dispatchInputChangeEvent() {
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: this.inputElementRef.value?.value,
      bubbles: true,
      composed: true
    }));
  }
};
WuiInputText.styles = [resetStyles, elementStyles, styles$1Q];
__decorate$2q([
  n$2()
], WuiInputText.prototype, "size", void 0);
__decorate$2q([
  n$2()
], WuiInputText.prototype, "icon", void 0);
__decorate$2q([
  n$2({ type: Boolean })
], WuiInputText.prototype, "disabled", void 0);
__decorate$2q([
  n$2()
], WuiInputText.prototype, "placeholder", void 0);
__decorate$2q([
  n$2()
], WuiInputText.prototype, "type", void 0);
__decorate$2q([
  n$2()
], WuiInputText.prototype, "keyHint", void 0);
__decorate$2q([
  n$2()
], WuiInputText.prototype, "value", void 0);
__decorate$2q([
  n$2()
], WuiInputText.prototype, "inputRightPadding", void 0);
WuiInputText = __decorate$2q([
  customElement("wui-input-text")
], WuiInputText);
const styles$1P = i$5`
  :host {
    position: relative;
    display: inline-block;
  }

  wui-text {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }
`;
var __decorate$2p = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiEmailInput = class WuiEmailInput2 extends i$2 {
  constructor() {
    super(...arguments);
    this.disabled = false;
  }
  render() {
    return x`
      <wui-input-text
        type="email"
        placeholder="Email"
        icon="mail"
        size="mdl"
        .disabled=${this.disabled}
        .value=${this.value}
        data-testid="wui-email-input"
      ></wui-input-text>
      ${this.templateError()}
    `;
  }
  templateError() {
    if (this.errorMessage) {
      return x`<wui-text variant="tiny-500" color="error-100">${this.errorMessage}</wui-text>`;
    }
    return null;
  }
};
WuiEmailInput.styles = [resetStyles, styles$1P];
__decorate$2p([
  n$2()
], WuiEmailInput.prototype, "errorMessage", void 0);
__decorate$2p([
  n$2({ type: Boolean })
], WuiEmailInput.prototype, "disabled", void 0);
__decorate$2p([
  n$2()
], WuiEmailInput.prototype, "value", void 0);
WuiEmailInput = __decorate$2p([
  customElement("wui-email-input")
], WuiEmailInput);
const styles$1O = i$5`
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  .error {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }

  .base-name {
    position: absolute;
    right: 45px;
    top: 15px;
    text-align: right;
  }
`;
var __decorate$2o = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiEnsInput = class WuiEnsInput2 extends i$2 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.loading = false;
  }
  render() {
    return x`
      <wui-input-text
        value=${o$3(this.value)}
        ?disabled=${this.disabled}
        .value=${this.value || ""}
        data-testid="wui-ens-input"
        inputRightPadding="5xl"
      >
        ${this.baseNameTemplate()} ${this.errorTemplate()}${this.loadingTemplate()}
      </wui-input-text>
    `;
  }
  baseNameTemplate() {
    return x`<wui-text variant="paragraph-400" color="fg-200" class="base-name">
      ${ConstantsUtil$2.WC_NAME_SUFFIX}
    </wui-text>`;
  }
  loadingTemplate() {
    return this.loading ? x`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : null;
  }
  errorTemplate() {
    if (this.errorMessage) {
      return x`<wui-text variant="tiny-500" color="error-100" class="error"
        >${this.errorMessage}</wui-text
      >`;
    }
    return null;
  }
};
WuiEnsInput.styles = [resetStyles, styles$1O];
__decorate$2o([
  n$2()
], WuiEnsInput.prototype, "errorMessage", void 0);
__decorate$2o([
  n$2({ type: Boolean })
], WuiEnsInput.prototype, "disabled", void 0);
__decorate$2o([
  n$2()
], WuiEnsInput.prototype, "value", void 0);
__decorate$2o([
  n$2({ type: Boolean })
], WuiEnsInput.prototype, "loading", void 0);
WuiEnsInput = __decorate$2o([
  customElement("wui-ens-input")
], WuiEnsInput);
const styles$1N = i$5`
  button {
    border-radius: var(--local-border-radius);
    color: var(--wui-color-fg-100);
    padding: var(--local-padding);
  }

  @media (max-width: 700px) {
    button {
      padding: var(--wui-spacing-s);
    }
  }

  button > wui-icon {
    pointer-events: none;
  }

  button:disabled > wui-icon {
    color: var(--wui-color-bg-300) !important;
  }

  button:disabled {
    background-color: transparent;
  }
`;
var __decorate$2n = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiIconLink = class WuiIconLink2 extends i$2 {
  constructor() {
    super(...arguments);
    this.size = "md";
    this.disabled = false;
    this.icon = "copy";
    this.iconColor = "inherit";
  }
  render() {
    const borderRadius2 = this.size === "lg" ? "--wui-border-radius-xs" : "--wui-border-radius-xxs";
    const padding2 = this.size === "lg" ? "--wui-spacing-1xs" : "--wui-spacing-2xs";
    this.style.cssText = `
    --local-border-radius: var(${borderRadius2});
    --local-padding: var(${padding2});
`;
    return x`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-icon color=${this.iconColor} size=${this.size} name=${this.icon}></wui-icon>
      </button>
    `;
  }
};
WuiIconLink.styles = [resetStyles, elementStyles, colorStyles, styles$1N];
__decorate$2n([
  n$2()
], WuiIconLink.prototype, "size", void 0);
__decorate$2n([
  n$2({ type: Boolean })
], WuiIconLink.prototype, "disabled", void 0);
__decorate$2n([
  n$2()
], WuiIconLink.prototype, "icon", void 0);
__decorate$2n([
  n$2()
], WuiIconLink.prototype, "iconColor", void 0);
WuiIconLink = __decorate$2n([
  customElement("wui-icon-link")
], WuiIconLink);
const styles$1M = i$5`
  button {
    background-color: var(--wui-color-fg-300);
    border-radius: var(--wui-border-radius-4xs);
    width: 16px;
    height: 16px;
  }

  button:disabled {
    background-color: var(--wui-color-bg-300);
  }

  wui-icon {
    color: var(--wui-color-bg-200) !important;
  }

  button:focus-visible {
    background-color: var(--wui-color-fg-250);
    border: 1px solid var(--wui-color-accent-100);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-fg-250);
    }

    button:active:enabled {
      background-color: var(--wui-color-fg-225);
    }
  }
`;
var __decorate$2m = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiInputElement = class WuiInputElement2 extends i$2 {
  constructor() {
    super(...arguments);
    this.icon = "copy";
  }
  render() {
    return x`
      <button>
        <wui-icon color="inherit" size="xxs" name=${this.icon}></wui-icon>
      </button>
    `;
  }
};
WuiInputElement.styles = [resetStyles, elementStyles, styles$1M];
__decorate$2m([
  n$2()
], WuiInputElement.prototype, "icon", void 0);
WuiInputElement = __decorate$2m([
  customElement("wui-input-element")
], WuiInputElement);
const styles$1L = i$5`
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    width: 50px;
    height: 50px;
    background: var(--wui-color-gray-glass-010);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-color-gray-glass-005);
    font-family: var(--wui-font-family);
    font-size: var(--wui-font-size-large);
    font-weight: var(--wui-font-weight-regular);
    letter-spacing: var(--wui-letter-spacing-large);
    text-align: center;
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    transition:
      background-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      border-color var(--wui-ease-inout-power-1) var(--wui-duration-md),
      box-shadow var(--wui-ease-inout-power-1) var(--wui-duration-md);
    will-change: background-color, border-color, box-shadow;
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-color-gray-glass-010);
    background: var(--wui-color-gray-glass-005);
  }

  input:focus:enabled {
    background-color: var(--wui-color-gray-glass-015);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  @media (hover: hover) and (pointer: fine) {
    input:hover:enabled {
      background-color: var(--wui-color-gray-glass-015);
    }
  }
`;
var __decorate$2l = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiInputNumeric = class WuiInputNumeric2 extends i$2 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.value = "";
  }
  render() {
    return x`<input
      type="number"
      maxlength="1"
      inputmode="numeric"
      autofocus
      ?disabled=${this.disabled}
      value=${this.value}
    /> `;
  }
};
WuiInputNumeric.styles = [resetStyles, elementStyles, styles$1L];
__decorate$2l([
  n$2({ type: Boolean })
], WuiInputNumeric.prototype, "disabled", void 0);
__decorate$2l([
  n$2({ type: String })
], WuiInputNumeric.prototype, "value", void 0);
WuiInputNumeric = __decorate$2l([
  customElement("wui-input-numeric")
], WuiInputNumeric);
const styles$1K = i$5`
  button {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
    border-radius: var(--wui-border-radius-3xs);
    background-color: transparent;
    color: var(--wui-color-accent-100);
  }

  button:disabled {
    background-color: transparent;
    color: var(--wui-color-gray-glass-015);
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }
`;
var __decorate$2k = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLink = class WuiLink2 extends i$2 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
  }
  render() {
    return x`
      <button ?disabled=${this.disabled} ontouchstart>
        <slot name="iconLeft"></slot>
        <wui-text variant="small-600" color=${this.color}>
          <slot></slot>
        </wui-text>
        <slot name="iconRight"></slot>
      </button>
    `;
  }
};
WuiLink.styles = [resetStyles, elementStyles, styles$1K];
__decorate$2k([
  n$2({ type: Boolean })
], WuiLink.prototype, "disabled", void 0);
__decorate$2k([
  n$2()
], WuiLink.prototype, "color", void 0);
WuiLink = __decorate$2k([
  customElement("wui-link")
], WuiLink);
const styles$1J = i$5`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 11px 18px 11px var(--wui-spacing-s);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
    transition:
      color var(--wui-ease-out-power-1) var(--wui-duration-md),
      background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: color, background-color;
  }

  button[data-iconvariant='square'],
  button[data-iconvariant='square-blue'] {
    padding: 6px 18px 6px 9px;
  }

  button > wui-flex {
    flex: 1;
  }

  button > wui-image {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }

  button > wui-icon {
    width: 36px;
    height: 36px;
    transition: opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: opacity;
  }

  button > wui-icon-box[data-variant='blue'] {
    box-shadow: 0 0 0 2px var(--wui-color-accent-glass-005);
  }

  button > wui-icon-box[data-variant='overlay'] {
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='square-blue']::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-color-accent-glass-010);
    pointer-events: none;
  }

  button > wui-icon:last-child {
    width: 14px;
    height: 14px;
  }

  button:disabled {
    color: var(--wui-color-gray-glass-020);
  }

  button[data-loading='true'] > wui-icon {
    opacity: 0;
  }

  wui-loading-spinner {
    position: absolute;
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
  }
`;
var __decorate$2j = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListItem = class WuiListItem2 extends i$2 {
  constructor() {
    super(...arguments);
    this.variant = "icon";
    this.disabled = false;
    this.imageSrc = void 0;
    this.alt = void 0;
    this.chevron = false;
    this.loading = false;
  }
  render() {
    return x`
      <button
        ?disabled=${this.loading ? true : Boolean(this.disabled)}
        data-loading=${this.loading}
        data-iconvariant=${o$3(this.iconVariant)}
        ontouchstart
      >
        ${this.loadingTemplate()} ${this.visualTemplate()}
        <wui-flex gap="3xs">
          <slot></slot>
        </wui-flex>
        ${this.chevronTemplate()}
      </button>
    `;
  }
  visualTemplate() {
    if (this.variant === "image" && this.imageSrc) {
      return x`<wui-image src=${this.imageSrc} alt=${this.alt ?? "list item"}></wui-image>`;
    }
    if (this.iconVariant === "square" && this.icon && this.variant === "icon") {
      return x`<wui-icon name=${this.icon}></wui-icon>`;
    }
    if (this.variant === "icon" && this.icon && this.iconVariant) {
      const color2 = ["blue", "square-blue"].includes(this.iconVariant) ? "accent-100" : "fg-200";
      const size2 = this.iconVariant === "square-blue" ? "mdl" : "md";
      const iconSize = this.iconSize ? this.iconSize : size2;
      return x`
        <wui-icon-box
          data-variant=${this.iconVariant}
          icon=${this.icon}
          iconSize=${iconSize}
          background="transparent"
          iconColor=${color2}
          backgroundColor=${color2}
          size=${size2}
        ></wui-icon-box>
      `;
    }
    return null;
  }
  loadingTemplate() {
    if (this.loading) {
      return x`<wui-loading-spinner color="fg-300"></wui-loading-spinner>`;
    }
    return x``;
  }
  chevronTemplate() {
    if (this.chevron) {
      return x`<wui-icon size="inherit" color="fg-200" name="chevronRight"></wui-icon>`;
    }
    return null;
  }
};
WuiListItem.styles = [resetStyles, elementStyles, styles$1J];
__decorate$2j([
  n$2()
], WuiListItem.prototype, "icon", void 0);
__decorate$2j([
  n$2()
], WuiListItem.prototype, "iconSize", void 0);
__decorate$2j([
  n$2()
], WuiListItem.prototype, "variant", void 0);
__decorate$2j([
  n$2()
], WuiListItem.prototype, "iconVariant", void 0);
__decorate$2j([
  n$2({ type: Boolean })
], WuiListItem.prototype, "disabled", void 0);
__decorate$2j([
  n$2()
], WuiListItem.prototype, "imageSrc", void 0);
__decorate$2j([
  n$2()
], WuiListItem.prototype, "alt", void 0);
__decorate$2j([
  n$2({ type: Boolean })
], WuiListItem.prototype, "chevron", void 0);
__decorate$2j([
  n$2({ type: Boolean })
], WuiListItem.prototype, "loading", void 0);
WuiListItem = __decorate$2j([
  customElement("wui-list-item")
], WuiListItem);
var TransactionTypePastTense;
(function(TransactionTypePastTense2) {
  TransactionTypePastTense2["approve"] = "approved";
  TransactionTypePastTense2["bought"] = "bought";
  TransactionTypePastTense2["borrow"] = "borrowed";
  TransactionTypePastTense2["burn"] = "burnt";
  TransactionTypePastTense2["cancel"] = "canceled";
  TransactionTypePastTense2["claim"] = "claimed";
  TransactionTypePastTense2["deploy"] = "deployed";
  TransactionTypePastTense2["deposit"] = "deposited";
  TransactionTypePastTense2["execute"] = "executed";
  TransactionTypePastTense2["mint"] = "minted";
  TransactionTypePastTense2["receive"] = "received";
  TransactionTypePastTense2["repay"] = "repaid";
  TransactionTypePastTense2["send"] = "sent";
  TransactionTypePastTense2["sell"] = "sold";
  TransactionTypePastTense2["stake"] = "staked";
  TransactionTypePastTense2["trade"] = "swapped";
  TransactionTypePastTense2["unstake"] = "unstaked";
  TransactionTypePastTense2["withdraw"] = "withdrawn";
})(TransactionTypePastTense || (TransactionTypePastTense = {}));
const styles$1I = i$5`
  :host > wui-flex {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: 40px;
    height: 40px;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-gray-glass-005);
  }

  :host > wui-flex wui-image {
    display: block;
  }

  :host > wui-flex,
  :host > wui-flex wui-image,
  .swap-images-container,
  .swap-images-container.nft,
  wui-image.nft {
    border-top-left-radius: var(--local-left-border-radius);
    border-top-right-radius: var(--local-right-border-radius);
    border-bottom-left-radius: var(--local-left-border-radius);
    border-bottom-right-radius: var(--local-right-border-radius);
  }

  wui-icon {
    width: 20px;
    height: 20px;
  }

  wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }

  .swap-images-container {
    position: relative;
    width: 40px;
    height: 40px;
    overflow: hidden;
  }

  .swap-images-container wui-image:first-child {
    position: absolute;
    width: 40px;
    height: 40px;
    top: 0;
    left: 0%;
    clip-path: inset(0px calc(50% + 2px) 0px 0%);
  }

  .swap-images-container wui-image:last-child {
    clip-path: inset(0px 0px 0px calc(50% + 2px));
  }
`;
var __decorate$2i = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTransactionVisual = class WuiTransactionVisual2 extends i$2 {
  constructor() {
    super(...arguments);
    this.images = [];
    this.secondImage = {
      type: void 0,
      url: ""
    };
  }
  render() {
    const [firstImage, secondImage] = this.images;
    const isLeftNFT = firstImage?.type === "NFT";
    const isRightNFT = secondImage?.url ? secondImage.type === "NFT" : isLeftNFT;
    const leftRadius = isLeftNFT ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
    const rightRadius = isRightNFT ? "var(--wui-border-radius-xxs)" : "var(--wui-border-radius-s)";
    this.style.cssText = `
    --local-left-border-radius: ${leftRadius};
    --local-right-border-radius: ${rightRadius};
    `;
    return x`<wui-flex> ${this.templateVisual()} ${this.templateIcon()} </wui-flex>`;
  }
  templateVisual() {
    const [firstImage, secondImage] = this.images;
    const firstImageType = firstImage?.type;
    const haveTwoImages = this.images.length === 2;
    if (haveTwoImages && (firstImage?.url || secondImage?.url)) {
      return x`<div class="swap-images-container">
        ${firstImage?.url ? x`<wui-image src=${firstImage.url} alt="Transaction image"></wui-image>` : null}
        ${secondImage?.url ? x`<wui-image src=${secondImage.url} alt="Transaction image"></wui-image>` : null}
      </div>`;
    } else if (firstImage?.url) {
      return x`<wui-image src=${firstImage.url} alt="Transaction image"></wui-image>`;
    } else if (firstImageType === "NFT") {
      return x`<wui-icon size="inherit" color="fg-200" name="nftPlaceholder"></wui-icon>`;
    }
    return x`<wui-icon size="inherit" color="fg-200" name="coinPlaceholder"></wui-icon>`;
  }
  templateIcon() {
    let color2 = "accent-100";
    let icon = void 0;
    icon = this.getIcon();
    if (this.status) {
      color2 = this.getStatusColor();
    }
    if (!icon) {
      return null;
    }
    return x`
      <wui-icon-box
        size="xxs"
        iconColor=${color2}
        backgroundColor=${color2}
        background="opaque"
        icon=${icon}
        ?border=${true}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
    `;
  }
  getDirectionIcon() {
    switch (this.direction) {
      case "in":
        return "arrowBottom";
      case "out":
        return "arrowTop";
      default:
        return void 0;
    }
  }
  getIcon() {
    if (this.onlyDirectionIcon) {
      return this.getDirectionIcon();
    }
    if (this.type === "trade") {
      return "swapHorizontalBold";
    } else if (this.type === "approve") {
      return "checkmark";
    } else if (this.type === "cancel") {
      return "close";
    }
    return this.getDirectionIcon();
  }
  getStatusColor() {
    switch (this.status) {
      case "confirmed":
        return "success-100";
      case "failed":
        return "error-100";
      case "pending":
        return "inverse-100";
      default:
        return "accent-100";
    }
  }
};
WuiTransactionVisual.styles = [styles$1I];
__decorate$2i([
  n$2()
], WuiTransactionVisual.prototype, "type", void 0);
__decorate$2i([
  n$2()
], WuiTransactionVisual.prototype, "status", void 0);
__decorate$2i([
  n$2()
], WuiTransactionVisual.prototype, "direction", void 0);
__decorate$2i([
  n$2({ type: Boolean })
], WuiTransactionVisual.prototype, "onlyDirectionIcon", void 0);
__decorate$2i([
  n$2({ type: Array })
], WuiTransactionVisual.prototype, "images", void 0);
__decorate$2i([
  n$2({ type: Object })
], WuiTransactionVisual.prototype, "secondImage", void 0);
WuiTransactionVisual = __decorate$2i([
  customElement("wui-transaction-visual")
], WuiTransactionVisual);
const styles$1H = i$5`
  :host > wui-flex:first-child {
    align-items: center;
    column-gap: var(--wui-spacing-s);
    padding: 6.5px var(--wui-spacing-xs) 6.5px var(--wui-spacing-xs);
    width: 100%;
  }

  :host > wui-flex:first-child wui-text:nth-child(1) {
    text-transform: capitalize;
  }

  wui-transaction-visual {
    width: 40px;
    height: 40px;
  }

  wui-flex {
    flex: 1;
  }

  :host wui-flex wui-flex {
    overflow: hidden;
  }

  :host .description-container wui-text span {
    word-break: break-all;
  }

  :host .description-container wui-text {
    overflow: hidden;
  }

  :host .description-separator-icon {
    margin: 0px 6px;
  }

  :host wui-text > span {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
`;
var __decorate$2h = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTransactionListItem = class WuiTransactionListItem2 extends i$2 {
  constructor() {
    super(...arguments);
    this.type = "approve";
    this.onlyDirectionIcon = false;
    this.images = [];
    this.price = [];
    this.amount = [];
    this.symbol = [];
  }
  render() {
    return x`
      <wui-flex>
        <wui-transaction-visual
          .status=${this.status}
          direction=${o$3(this.direction)}
          type=${this.type}
          onlyDirectionIcon=${o$3(this.onlyDirectionIcon)}
          .images=${this.images}
        ></wui-transaction-visual>
        <wui-flex flexDirection="column" gap="3xs">
          <wui-text variant="paragraph-600" color="fg-100">
            ${TransactionTypePastTense[this.type] || this.type}
          </wui-text>
          <wui-flex class="description-container">
            ${this.templateDescription()} ${this.templateSecondDescription()}
          </wui-flex>
        </wui-flex>
        <wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>
      </wui-flex>
    `;
  }
  templateDescription() {
    const description = this.descriptions?.[0];
    return description ? x`
          <wui-text variant="small-500" color="fg-200">
            <span>${description}</span>
          </wui-text>
        ` : null;
  }
  templateSecondDescription() {
    const description = this.descriptions?.[1];
    return description ? x`
          <wui-icon class="description-separator-icon" size="xxs" name="arrowRight"></wui-icon>
          <wui-text variant="small-400" color="fg-200">
            <span>${description}</span>
          </wui-text>
        ` : null;
  }
};
WuiTransactionListItem.styles = [resetStyles, styles$1H];
__decorate$2h([
  n$2()
], WuiTransactionListItem.prototype, "type", void 0);
__decorate$2h([
  n$2({ type: Array })
], WuiTransactionListItem.prototype, "descriptions", void 0);
__decorate$2h([
  n$2()
], WuiTransactionListItem.prototype, "date", void 0);
__decorate$2h([
  n$2({ type: Boolean })
], WuiTransactionListItem.prototype, "onlyDirectionIcon", void 0);
__decorate$2h([
  n$2()
], WuiTransactionListItem.prototype, "status", void 0);
__decorate$2h([
  n$2()
], WuiTransactionListItem.prototype, "direction", void 0);
__decorate$2h([
  n$2({ type: Array })
], WuiTransactionListItem.prototype, "images", void 0);
__decorate$2h([
  n$2({ type: Array })
], WuiTransactionListItem.prototype, "price", void 0);
__decorate$2h([
  n$2({ type: Array })
], WuiTransactionListItem.prototype, "amount", void 0);
__decorate$2h([
  n$2({ type: Array })
], WuiTransactionListItem.prototype, "symbol", void 0);
WuiTransactionListItem = __decorate$2h([
  customElement("wui-transaction-list-item")
], WuiTransactionListItem);
const styles$1G = i$5`
  :host > wui-flex:first-child {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
  }

  wui-flex {
    display: flex;
    flex: 1;
  }
`;
var __decorate$2g = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTransactionListItemLoader = class WuiTransactionListItemLoader2 extends i$2 {
  render() {
    return x`
      <wui-flex alignItems="center">
        <wui-shimmer width="40px" height="40px"></wui-shimmer>
        <wui-flex flexDirection="column" gap="2xs">
          <wui-shimmer width="72px" height="16px" borderRadius="4xs"></wui-shimmer>
          <wui-shimmer width="148px" height="14px" borderRadius="4xs"></wui-shimmer>
        </wui-flex>
        <wui-shimmer width="24px" height="12px" borderRadius="5xs"></wui-shimmer>
      </wui-flex>
    `;
  }
};
WuiTransactionListItemLoader.styles = [resetStyles, styles$1G];
WuiTransactionListItemLoader = __decorate$2g([
  customElement("wui-transaction-list-item-loader")
], WuiTransactionListItemLoader);
const styles$1F = i$5`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    height: var(--wui-spacing-m);
    padding: 0 var(--wui-spacing-3xs) !important;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > wui-text {
    transform: translateY(5%);
  }

  :host([data-variant='main']) {
    background-color: var(--wui-color-accent-glass-015);
    color: var(--wui-color-accent-100);
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  :host([data-variant='success']) {
    background-color: var(--wui-icon-box-bg-success-100);
    color: var(--wui-color-success-100);
  }

  :host([data-variant='error']) {
    background-color: var(--wui-icon-box-bg-error-100);
    color: var(--wui-color-error-100);
  }

  :host([data-size='lg']) {
    padding: 11px 5px !important;
  }

  :host([data-size='lg']) > wui-text {
    transform: translateY(2%);
  }
`;
var __decorate$2f = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTag = class WuiTag2 extends i$2 {
  constructor() {
    super(...arguments);
    this.variant = "main";
    this.size = "lg";
  }
  render() {
    this.dataset["variant"] = this.variant;
    this.dataset["size"] = this.size;
    const textVariant = this.size === "md" ? "mini-700" : "micro-700";
    return x`
      <wui-text data-variant=${this.variant} variant=${textVariant} color="inherit">
        <slot></slot>
      </wui-text>
    `;
  }
};
WuiTag.styles = [resetStyles, styles$1F];
__decorate$2f([
  n$2()
], WuiTag.prototype, "variant", void 0);
__decorate$2f([
  n$2()
], WuiTag.prototype, "size", void 0);
WuiTag = __decorate$2f([
  customElement("wui-tag")
], WuiTag);
const styles$1E = i$5`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-300);
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }
`;
var __decorate$2e = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListWallet = class WuiListWallet2 extends i$2 {
  constructor() {
    super(...arguments);
    this.walletImages = [];
    this.imageSrc = "";
    this.name = "";
    this.installed = false;
    this.disabled = false;
    this.showAllWallets = false;
  }
  render() {
    return x`
      <button ?disabled=${this.disabled} ontouchstart>
        ${this.templateAllWallets()} ${this.templateWalletImage()}
        <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
        ${this.templateStatus()}
      </button>
    `;
  }
  templateAllWallets() {
    if (this.showAllWallets && this.imageSrc) {
      return x` <wui-all-wallets-image .imageeSrc=${this.imageSrc}> </wui-all-wallets-image> `;
    } else if (this.showAllWallets && this.walletIcon) {
      return x` <wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </wui-wallet-image> `;
    }
    return null;
  }
  templateWalletImage() {
    if (!this.showAllWallets && this.imageSrc) {
      return x`<wui-wallet-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
        .installed=${this.installed}
      ></wui-wallet-image>`;
    } else if (!this.showAllWallets && !this.imageSrc) {
      return x`<wui-wallet-image size="sm" name=${this.name}></wui-wallet-image>`;
    }
    return null;
  }
  templateStatus() {
    if (this.tagLabel && this.tagVariant) {
      return x`<wui-tag variant=${this.tagVariant}>${this.tagLabel}</wui-tag>`;
    } else if (this.icon) {
      return x`<wui-icon color="inherit" size="sm" name=${this.icon}></wui-icon>`;
    }
    return null;
  }
};
WuiListWallet.styles = [resetStyles, elementStyles, styles$1E];
__decorate$2e([
  n$2({ type: Array })
], WuiListWallet.prototype, "walletImages", void 0);
__decorate$2e([
  n$2()
], WuiListWallet.prototype, "imageSrc", void 0);
__decorate$2e([
  n$2()
], WuiListWallet.prototype, "name", void 0);
__decorate$2e([
  n$2()
], WuiListWallet.prototype, "tagLabel", void 0);
__decorate$2e([
  n$2()
], WuiListWallet.prototype, "tagVariant", void 0);
__decorate$2e([
  n$2()
], WuiListWallet.prototype, "icon", void 0);
__decorate$2e([
  n$2()
], WuiListWallet.prototype, "walletIcon", void 0);
__decorate$2e([
  n$2({ type: Boolean })
], WuiListWallet.prototype, "installed", void 0);
__decorate$2e([
  n$2({ type: Boolean })
], WuiListWallet.prototype, "disabled", void 0);
__decorate$2e([
  n$2({ type: Boolean })
], WuiListWallet.prototype, "showAllWallets", void 0);
WuiListWallet = __decorate$2e([
  customElement("wui-list-wallet")
], WuiListWallet);
const styles$1D = i$5`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-005);
    overflow: hidden;
  }

  wui-icon {
    width: 100%;
    height: 100%;
  }
`;
var __decorate$2d = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLogo = class WuiLogo2 extends i$2 {
  constructor() {
    super(...arguments);
    this.logo = "google";
  }
  render() {
    return x`<wui-icon color="inherit" size="inherit" name=${this.logo}></wui-icon> `;
  }
};
WuiLogo.styles = [resetStyles, styles$1D];
__decorate$2d([
  n$2()
], WuiLogo.prototype, "logo", void 0);
WuiLogo = __decorate$2d([
  customElement("wui-logo")
], WuiLogo);
const styles$1C = i$5`
  :host {
    display: block;
    width: 100%;
  }

  button {
    width: 100%;
    height: 56px;
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;
var __decorate$2c = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiLogoSelect = class WuiLogoSelect2 extends i$2 {
  constructor() {
    super(...arguments);
    this.logo = "google";
    this.disabled = false;
  }
  render() {
    return x`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-logo logo=${this.logo}></wui-logo>
      </button>
    `;
  }
};
WuiLogoSelect.styles = [resetStyles, elementStyles, styles$1C];
__decorate$2c([
  n$2()
], WuiLogoSelect.prototype, "logo", void 0);
__decorate$2c([
  n$2({ type: Boolean })
], WuiLogoSelect.prototype, "disabled", void 0);
WuiLogoSelect = __decorate$2c([
  customElement("wui-logo-select")
], WuiLogoSelect);
const styles$1B = i$5`
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-s) var(--wui-spacing-2xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-color-gray-glass-010);
    background-color: var(--wui-color-gray-glass-005);
    color: var(--wui-color-fg-100);
  }

  button:disabled {
    border: 1px solid var(--wui-color-gray-glass-005);
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-010);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-015);
    }
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }
`;
var __decorate$2b = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiNetworkButton = class WuiNetworkButton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.isUnsupportedChain = void 0;
    this.disabled = false;
  }
  render() {
    return x`
      <button data-testid="w3m-network-button" ?disabled=${this.disabled}>
        ${this.visualTemplate()}
        <wui-text variant="paragraph-600" color="inherit">
          <slot></slot>
        </wui-text>
      </button>
    `;
  }
  visualTemplate() {
    if (this.isUnsupportedChain) {
      return x`
        <wui-icon-box
          size="sm"
          iconColor="error-100"
          backgroundColor="error-100"
          icon="warningCircle"
        ></wui-icon-box>
      `;
    }
    if (this.imageSrc) {
      return x`<wui-image src=${this.imageSrc}></wui-image>`;
    }
    return x`
      <wui-icon-box
        size="sm"
        iconColor="inverse-100"
        backgroundColor="fg-100"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `;
  }
};
WuiNetworkButton.styles = [resetStyles, elementStyles, styles$1B];
__decorate$2b([
  n$2()
], WuiNetworkButton.prototype, "imageSrc", void 0);
__decorate$2b([
  n$2({ type: Boolean })
], WuiNetworkButton.prototype, "isUnsupportedChain", void 0);
__decorate$2b([
  n$2({ type: Boolean })
], WuiNetworkButton.prototype, "disabled", void 0);
WuiNetworkButton = __decorate$2b([
  customElement("wui-network-button")
], WuiNetworkButton);
const styles$1A = i$5`
  :host {
    position: relative;
    display: block;
  }
`;
var __decorate$2a = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiOtp = class WuiOtp2 extends i$2 {
  constructor() {
    super(...arguments);
    this.length = 6;
    this.otp = "";
    this.values = Array.from({ length: this.length }).map(() => "");
    this.numerics = [];
    this.shouldInputBeEnabled = (index2) => {
      const previousInputs = this.values.slice(0, index2);
      return previousInputs.every((input) => input !== "");
    };
    this.handleKeyDown = (e2, index2) => {
      const inputElement = e2.target;
      const input = this.getInputElement(inputElement);
      const keyArr = ["ArrowLeft", "ArrowRight", "Shift", "Delete"];
      if (!input) {
        return;
      }
      if (keyArr.includes(e2.key)) {
        e2.preventDefault();
      }
      const currentCaretPos = input.selectionStart;
      switch (e2.key) {
        case "ArrowLeft":
          if (currentCaretPos) {
            input.setSelectionRange(currentCaretPos + 1, currentCaretPos + 1);
          }
          this.focusInputField("prev", index2);
          break;
        case "ArrowRight":
          this.focusInputField("next", index2);
          break;
        case "Shift":
          this.focusInputField("next", index2);
          break;
        case "Delete":
          if (input.value === "") {
            this.focusInputField("prev", index2);
          } else {
            this.updateInput(input, index2, "");
          }
          break;
        case "Backspace":
          if (input.value === "") {
            this.focusInputField("prev", index2);
          } else {
            this.updateInput(input, index2, "");
          }
          break;
      }
    };
    this.focusInputField = (dir, index2) => {
      if (dir === "next") {
        const nextIndex = index2 + 1;
        if (!this.shouldInputBeEnabled(nextIndex)) {
          return;
        }
        const numeric = this.numerics[nextIndex < this.length ? nextIndex : index2];
        const input = numeric ? this.getInputElement(numeric) : void 0;
        if (input) {
          input.disabled = false;
          input.focus();
        }
      }
      if (dir === "prev") {
        const nextIndex = index2 - 1;
        const numeric = this.numerics[nextIndex > -1 ? nextIndex : index2];
        const input = numeric ? this.getInputElement(numeric) : void 0;
        if (input) {
          input.focus();
        }
      }
    };
  }
  firstUpdated() {
    if (this.otp) {
      this.values = this.otp.split("");
    }
    const numericElements = this.shadowRoot?.querySelectorAll("wui-input-numeric");
    if (numericElements) {
      this.numerics = Array.from(numericElements);
    }
    this.numerics[0]?.focus();
  }
  render() {
    return x`
      <wui-flex gap="xxs" data-testid="wui-otp-input">
        ${Array.from({ length: this.length }).map((_2, index2) => x`
            <wui-input-numeric
              @input=${(e2) => this.handleInput(e2, index2)}
              @click=${(e2) => this.selectInput(e2)}
              @keydown=${(e2) => this.handleKeyDown(e2, index2)}
              .disabled=${!this.shouldInputBeEnabled(index2)}
              .value=${this.values[index2] || ""}
            >
            </wui-input-numeric>
          `)}
      </wui-flex>
    `;
  }
  updateInput(element, index2, value) {
    const numeric = this.numerics[index2];
    const input = element || (numeric ? this.getInputElement(numeric) : void 0);
    if (input) {
      input.value = value;
      this.values = this.values.map((val, i4) => i4 === index2 ? value : val);
    }
  }
  selectInput(e2) {
    const targetElement = e2.target;
    if (targetElement) {
      const inputElement = this.getInputElement(targetElement);
      inputElement?.select();
    }
  }
  handleInput(e2, index2) {
    const inputElement = e2.target;
    const input = this.getInputElement(inputElement);
    if (input) {
      const inputValue = input.value;
      if (e2.inputType === "insertFromPaste") {
        this.handlePaste(input, inputValue, index2);
      } else {
        const isValid2 = UiHelperUtil.isNumber(inputValue);
        if (isValid2 && e2.data) {
          this.updateInput(input, index2, e2.data);
          this.focusInputField("next", index2);
        } else {
          this.updateInput(input, index2, "");
        }
      }
    }
    this.dispatchInputChangeEvent();
  }
  handlePaste(input, inputValue, index2) {
    const value = inputValue[0];
    const isValid2 = value && UiHelperUtil.isNumber(value);
    if (isValid2) {
      this.updateInput(input, index2, value);
      const inputString = inputValue.substring(1);
      if (index2 + 1 < this.length && inputString.length) {
        const nextNumeric = this.numerics[index2 + 1];
        const nextInput = nextNumeric ? this.getInputElement(nextNumeric) : void 0;
        if (nextInput) {
          this.handlePaste(nextInput, inputString, index2 + 1);
        }
      } else {
        this.focusInputField("next", index2);
      }
    } else {
      this.updateInput(input, index2, "");
    }
  }
  getInputElement(el) {
    if (el.shadowRoot?.querySelector("input")) {
      return el.shadowRoot.querySelector("input");
    }
    return null;
  }
  dispatchInputChangeEvent() {
    const value = this.values.join("");
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: value,
      bubbles: true,
      composed: true
    }));
  }
};
WuiOtp.styles = [resetStyles, styles$1A];
__decorate$2a([
  n$2({ type: Number })
], WuiOtp.prototype, "length", void 0);
__decorate$2a([
  n$2({ type: String })
], WuiOtp.prototype, "otp", void 0);
__decorate$2a([
  r$1()
], WuiOtp.prototype, "values", void 0);
WuiOtp = __decorate$2a([
  customElement("wui-otp")
], WuiOtp);
var browser$1 = {};
var canPromise;
var hasRequiredCanPromise;
function requireCanPromise() {
  if (hasRequiredCanPromise) return canPromise;
  hasRequiredCanPromise = 1;
  canPromise = function() {
    return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
  };
  return canPromise;
}
var qrcode = {};
var utils$5 = {};
var hasRequiredUtils$5;
function requireUtils$5() {
  if (hasRequiredUtils$5) return utils$5;
  hasRequiredUtils$5 = 1;
  let toSJISFunction;
  const CODEWORDS_COUNT = [
    0,
    // Not used
    26,
    44,
    70,
    100,
    134,
    172,
    196,
    242,
    292,
    346,
    404,
    466,
    532,
    581,
    655,
    733,
    815,
    901,
    991,
    1085,
    1156,
    1258,
    1364,
    1474,
    1588,
    1706,
    1828,
    1921,
    2051,
    2185,
    2323,
    2465,
    2611,
    2761,
    2876,
    3034,
    3196,
    3362,
    3532,
    3706
  ];
  utils$5.getSymbolSize = function getSymbolSize(version2) {
    if (!version2) throw new Error('"version" cannot be null or undefined');
    if (version2 < 1 || version2 > 40) throw new Error('"version" should be in range from 1 to 40');
    return version2 * 4 + 17;
  };
  utils$5.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
    return CODEWORDS_COUNT[version2];
  };
  utils$5.getBCHDigit = function(data2) {
    let digit = 0;
    while (data2 !== 0) {
      digit++;
      data2 >>>= 1;
    }
    return digit;
  };
  utils$5.setToSJISFunction = function setToSJISFunction(f2) {
    if (typeof f2 !== "function") {
      throw new Error('"toSJISFunc" is not a valid function.');
    }
    toSJISFunction = f2;
  };
  utils$5.isKanjiModeEnabled = function() {
    return typeof toSJISFunction !== "undefined";
  };
  utils$5.toSJIS = function toSJIS(kanji) {
    return toSJISFunction(kanji);
  };
  return utils$5;
}
var errorCorrectionLevel = {};
var hasRequiredErrorCorrectionLevel;
function requireErrorCorrectionLevel() {
  if (hasRequiredErrorCorrectionLevel) return errorCorrectionLevel;
  hasRequiredErrorCorrectionLevel = 1;
  (function(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString2(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid2(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from2(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString2(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  })(errorCorrectionLevel);
  return errorCorrectionLevel;
}
var bitBuffer;
var hasRequiredBitBuffer;
function requireBitBuffer() {
  if (hasRequiredBitBuffer) return bitBuffer;
  hasRequiredBitBuffer = 1;
  function BitBuffer() {
    this.buffer = [];
    this.length = 0;
  }
  BitBuffer.prototype = {
    get: function(index2) {
      const bufIndex = Math.floor(index2 / 8);
      return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
    },
    put: function(num, length2) {
      for (let i4 = 0; i4 < length2; i4++) {
        this.putBit((num >>> length2 - i4 - 1 & 1) === 1);
      }
    },
    getLengthInBits: function() {
      return this.length;
    },
    putBit: function(bit) {
      const bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    }
  };
  bitBuffer = BitBuffer;
  return bitBuffer;
}
var bitMatrix;
var hasRequiredBitMatrix;
function requireBitMatrix() {
  if (hasRequiredBitMatrix) return bitMatrix;
  hasRequiredBitMatrix = 1;
  function BitMatrix(size2) {
    if (!size2 || size2 < 1) {
      throw new Error("BitMatrix size must be defined and greater than 0");
    }
    this.size = size2;
    this.data = new Uint8Array(size2 * size2);
    this.reservedBit = new Uint8Array(size2 * size2);
  }
  BitMatrix.prototype.set = function(row, col, value, reserved) {
    const index2 = row * this.size + col;
    this.data[index2] = value;
    if (reserved) this.reservedBit[index2] = true;
  };
  BitMatrix.prototype.get = function(row, col) {
    return this.data[row * this.size + col];
  };
  BitMatrix.prototype.xor = function(row, col, value) {
    this.data[row * this.size + col] ^= value;
  };
  BitMatrix.prototype.isReserved = function(row, col) {
    return this.reservedBit[row * this.size + col];
  };
  bitMatrix = BitMatrix;
  return bitMatrix;
}
var alignmentPattern = {};
var hasRequiredAlignmentPattern;
function requireAlignmentPattern() {
  if (hasRequiredAlignmentPattern) return alignmentPattern;
  hasRequiredAlignmentPattern = 1;
  (function(exports) {
    const getSymbolSize = requireUtils$5().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version2) {
      if (version2 === 1) return [];
      const posCount = Math.floor(version2 / 7) + 2;
      const size2 = getSymbolSize(version2);
      const intervals = size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2;
      const positions = [size2 - 7];
      for (let i4 = 1; i4 < posCount - 1; i4++) {
        positions[i4] = positions[i4 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version2) {
      const coords = [];
      const pos = exports.getRowColCoords(version2);
      const posLength = pos.length;
      for (let i4 = 0; i4 < posLength; i4++) {
        for (let j2 = 0; j2 < posLength; j2++) {
          if (i4 === 0 && j2 === 0 || // top-left
          i4 === 0 && j2 === posLength - 1 || // bottom-left
          i4 === posLength - 1 && j2 === 0) {
            continue;
          }
          coords.push([pos[i4], pos[j2]]);
        }
      }
      return coords;
    };
  })(alignmentPattern);
  return alignmentPattern;
}
var finderPattern = {};
var hasRequiredFinderPattern;
function requireFinderPattern() {
  if (hasRequiredFinderPattern) return finderPattern;
  hasRequiredFinderPattern = 1;
  const getSymbolSize = requireUtils$5().getSymbolSize;
  const FINDER_PATTERN_SIZE = 7;
  finderPattern.getPositions = function getPositions(version2) {
    const size2 = getSymbolSize(version2);
    return [
      // top-left
      [0, 0],
      // top-right
      [size2 - FINDER_PATTERN_SIZE, 0],
      // bottom-left
      [0, size2 - FINDER_PATTERN_SIZE]
    ];
  };
  return finderPattern;
}
var maskPattern = {};
var hasRequiredMaskPattern;
function requireMaskPattern() {
  if (hasRequiredMaskPattern) return maskPattern;
  hasRequiredMaskPattern = 1;
  (function(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    const PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid2(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from2(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data2) {
      const size2 = data2.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size2; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size2; col++) {
          let module = data2.get(row, col);
          if (module === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module;
            sameCountCol = 1;
          }
          module = data2.get(col, row);
          if (module === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data2) {
      const size2 = data2.size;
      let points = 0;
      for (let row = 0; row < size2 - 1; row++) {
        for (let col = 0; col < size2 - 1; col++) {
          const last = data2.get(row, col) + data2.get(row, col + 1) + data2.get(row + 1, col) + data2.get(row + 1, col + 1);
          if (last === 4 || last === 0) points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data2) {
      const size2 = data2.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size2; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size2; col++) {
          bitsCol = bitsCol << 1 & 2047 | data2.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
          bitsRow = bitsRow << 1 & 2047 | data2.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data2) {
      let darkCount = 0;
      const modulesCount = data2.data.length;
      for (let i4 = 0; i4 < modulesCount; i4++) darkCount += data2.data[i4];
      const k2 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k2 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern2, i4, j2) {
      switch (maskPattern2) {
        case exports.Patterns.PATTERN000:
          return (i4 + j2) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i4 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j2 % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i4 + j2) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i4 / 2) + Math.floor(j2 / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i4 * j2 % 2 + i4 * j2 % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i4 * j2 % 2 + i4 * j2 % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i4 * j2 % 3 + (i4 + j2) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern2);
      }
    }
    exports.applyMask = function applyMask(pattern, data2) {
      const size2 = data2.size;
      for (let col = 0; col < size2; col++) {
        for (let row = 0; row < size2; row++) {
          if (data2.isReserved(row, col)) continue;
          data2.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data2, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p2 = 0; p2 < numPatterns; p2++) {
        setupFormatFunc(p2);
        exports.applyMask(p2, data2);
        const penalty = exports.getPenaltyN1(data2) + exports.getPenaltyN2(data2) + exports.getPenaltyN3(data2) + exports.getPenaltyN4(data2);
        exports.applyMask(p2, data2);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p2;
        }
      }
      return bestPattern;
    };
  })(maskPattern);
  return maskPattern;
}
var errorCorrectionCode = {};
var hasRequiredErrorCorrectionCode;
function requireErrorCorrectionCode() {
  if (hasRequiredErrorCorrectionCode) return errorCorrectionCode;
  hasRequiredErrorCorrectionCode = 1;
  const ECLevel = requireErrorCorrectionLevel();
  const EC_BLOCKS_TABLE = [
    // L  M  Q  H
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    1,
    2,
    2,
    4,
    1,
    2,
    4,
    4,
    2,
    4,
    4,
    4,
    2,
    4,
    6,
    5,
    2,
    4,
    6,
    6,
    2,
    5,
    8,
    8,
    4,
    5,
    8,
    8,
    4,
    5,
    8,
    11,
    4,
    8,
    10,
    11,
    4,
    9,
    12,
    16,
    4,
    9,
    16,
    16,
    6,
    10,
    12,
    18,
    6,
    10,
    17,
    16,
    6,
    11,
    16,
    19,
    6,
    13,
    18,
    21,
    7,
    14,
    21,
    25,
    8,
    16,
    20,
    25,
    8,
    17,
    23,
    25,
    9,
    17,
    23,
    34,
    9,
    18,
    25,
    30,
    10,
    20,
    27,
    32,
    12,
    21,
    29,
    35,
    12,
    23,
    34,
    37,
    12,
    25,
    34,
    40,
    13,
    26,
    35,
    42,
    14,
    28,
    38,
    45,
    15,
    29,
    40,
    48,
    16,
    31,
    43,
    51,
    17,
    33,
    45,
    54,
    18,
    35,
    48,
    57,
    19,
    37,
    51,
    60,
    19,
    38,
    53,
    63,
    20,
    40,
    56,
    66,
    21,
    43,
    59,
    70,
    22,
    45,
    62,
    74,
    24,
    47,
    65,
    77,
    25,
    49,
    68,
    81
  ];
  const EC_CODEWORDS_TABLE = [
    // L  M  Q  H
    7,
    10,
    13,
    17,
    10,
    16,
    22,
    28,
    15,
    26,
    36,
    44,
    20,
    36,
    52,
    64,
    26,
    48,
    72,
    88,
    36,
    64,
    96,
    112,
    40,
    72,
    108,
    130,
    48,
    88,
    132,
    156,
    60,
    110,
    160,
    192,
    72,
    130,
    192,
    224,
    80,
    150,
    224,
    264,
    96,
    176,
    260,
    308,
    104,
    198,
    288,
    352,
    120,
    216,
    320,
    384,
    132,
    240,
    360,
    432,
    144,
    280,
    408,
    480,
    168,
    308,
    448,
    532,
    180,
    338,
    504,
    588,
    196,
    364,
    546,
    650,
    224,
    416,
    600,
    700,
    224,
    442,
    644,
    750,
    252,
    476,
    690,
    816,
    270,
    504,
    750,
    900,
    300,
    560,
    810,
    960,
    312,
    588,
    870,
    1050,
    336,
    644,
    952,
    1110,
    360,
    700,
    1020,
    1200,
    390,
    728,
    1050,
    1260,
    420,
    784,
    1140,
    1350,
    450,
    812,
    1200,
    1440,
    480,
    868,
    1290,
    1530,
    510,
    924,
    1350,
    1620,
    540,
    980,
    1440,
    1710,
    570,
    1036,
    1530,
    1800,
    570,
    1064,
    1590,
    1890,
    600,
    1120,
    1680,
    1980,
    630,
    1204,
    1770,
    2100,
    660,
    1260,
    1860,
    2220,
    720,
    1316,
    1950,
    2310,
    750,
    1372,
    2040,
    2430
  ];
  errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
    switch (errorCorrectionLevel2) {
      case ECLevel.L:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
      case ECLevel.M:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
      case ECLevel.Q:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
      case ECLevel.H:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
      default:
        return void 0;
    }
  };
  errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
    switch (errorCorrectionLevel2) {
      case ECLevel.L:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
      case ECLevel.M:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
      case ECLevel.Q:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
      case ECLevel.H:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
      default:
        return void 0;
    }
  };
  return errorCorrectionCode;
}
var polynomial = {};
var galoisField = {};
var hasRequiredGaloisField;
function requireGaloisField() {
  if (hasRequiredGaloisField) return galoisField;
  hasRequiredGaloisField = 1;
  const EXP_TABLE = new Uint8Array(512);
  const LOG_TABLE = new Uint8Array(256);
  (function initTables() {
    let x2 = 1;
    for (let i4 = 0; i4 < 255; i4++) {
      EXP_TABLE[i4] = x2;
      LOG_TABLE[x2] = i4;
      x2 <<= 1;
      if (x2 & 256) {
        x2 ^= 285;
      }
    }
    for (let i4 = 255; i4 < 512; i4++) {
      EXP_TABLE[i4] = EXP_TABLE[i4 - 255];
    }
  })();
  galoisField.log = function log(n3) {
    if (n3 < 1) throw new Error("log(" + n3 + ")");
    return LOG_TABLE[n3];
  };
  galoisField.exp = function exp(n3) {
    return EXP_TABLE[n3];
  };
  galoisField.mul = function mul(x2, y3) {
    if (x2 === 0 || y3 === 0) return 0;
    return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y3]];
  };
  return galoisField;
}
var hasRequiredPolynomial;
function requirePolynomial() {
  if (hasRequiredPolynomial) return polynomial;
  hasRequiredPolynomial = 1;
  (function(exports) {
    const GF = requireGaloisField();
    exports.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i4 = 0; i4 < p1.length; i4++) {
        for (let j2 = 0; j2 < p2.length; j2++) {
          coeff[i4 + j2] ^= GF.mul(p1[i4], p2[j2]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i4 = 0; i4 < divisor.length; i4++) {
          result[i4] ^= GF.mul(divisor[i4], coeff);
        }
        let offset2 = 0;
        while (offset2 < result.length && result[offset2] === 0) offset2++;
        result = result.slice(offset2);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i4 = 0; i4 < degree; i4++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i4)]));
      }
      return poly;
    };
  })(polynomial);
  return polynomial;
}
var reedSolomonEncoder;
var hasRequiredReedSolomonEncoder;
function requireReedSolomonEncoder() {
  if (hasRequiredReedSolomonEncoder) return reedSolomonEncoder;
  hasRequiredReedSolomonEncoder = 1;
  const Polynomial = requirePolynomial();
  function ReedSolomonEncoder(degree) {
    this.genPoly = void 0;
    this.degree = degree;
    if (this.degree) this.initialize(this.degree);
  }
  ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
    this.degree = degree;
    this.genPoly = Polynomial.generateECPolynomial(this.degree);
  };
  ReedSolomonEncoder.prototype.encode = function encode2(data2) {
    if (!this.genPoly) {
      throw new Error("Encoder not initialized");
    }
    const paddedData = new Uint8Array(data2.length + this.degree);
    paddedData.set(data2);
    const remainder = Polynomial.mod(paddedData, this.genPoly);
    const start2 = this.degree - remainder.length;
    if (start2 > 0) {
      const buff = new Uint8Array(this.degree);
      buff.set(remainder, start2);
      return buff;
    }
    return remainder;
  };
  reedSolomonEncoder = ReedSolomonEncoder;
  return reedSolomonEncoder;
}
var version$1 = {};
var mode = {};
var versionCheck = {};
var hasRequiredVersionCheck;
function requireVersionCheck() {
  if (hasRequiredVersionCheck) return versionCheck;
  hasRequiredVersionCheck = 1;
  versionCheck.isValid = function isValid2(version2) {
    return !isNaN(version2) && version2 >= 1 && version2 <= 40;
  };
  return versionCheck;
}
var regex = {};
var hasRequiredRegex;
function requireRegex() {
  if (hasRequiredRegex) return regex;
  hasRequiredRegex = 1;
  const numeric = "[0-9]+";
  const alphanumeric = "[A-Z $%*+\\-./:]+";
  let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
  kanji = kanji.replace(/u/g, "\\u");
  const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
  regex.KANJI = new RegExp(kanji, "g");
  regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
  regex.BYTE = new RegExp(byte, "g");
  regex.NUMERIC = new RegExp(numeric, "g");
  regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
  const TEST_KANJI = new RegExp("^" + kanji + "$");
  const TEST_NUMERIC = new RegExp("^" + numeric + "$");
  const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
  regex.testKanji = function testKanji(str) {
    return TEST_KANJI.test(str);
  };
  regex.testNumeric = function testNumeric(str) {
    return TEST_NUMERIC.test(str);
  };
  regex.testAlphanumeric = function testAlphanumeric(str) {
    return TEST_ALPHANUMERIC.test(str);
  };
  return regex;
}
var hasRequiredMode;
function requireMode() {
  if (hasRequiredMode) return mode;
  hasRequiredMode = 1;
  (function(exports) {
    const VersionCheck = requireVersionCheck();
    const Regex = requireRegex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
      if (!mode2.ccBits) throw new Error("Invalid mode: " + mode2);
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid version: " + version2);
      }
      if (version2 >= 1 && version2 < 10) return mode2.ccBits[0];
      else if (version2 < 27) return mode2.ccBits[1];
      return mode2.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr)) return exports.KANJI;
      else return exports.BYTE;
    };
    exports.toString = function toString2(mode2) {
      if (mode2 && mode2.id) return mode2.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid2(mode2) {
      return mode2 && mode2.bit && mode2.ccBits;
    };
    function fromString2(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from2(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString2(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  })(mode);
  return mode;
}
var hasRequiredVersion;
function requireVersion() {
  if (hasRequiredVersion) return version$1;
  hasRequiredVersion = 1;
  (function(exports) {
    const Utils = requireUtils$5();
    const ECCode = requireErrorCorrectionCode();
    const ECLevel = requireErrorCorrectionLevel();
    const Mode = requireMode();
    const VersionCheck = requireVersionCheck();
    const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    const G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode2, length2, errorCorrectionLevel2) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode2, version2) {
      return Mode.getCharCountIndicator(mode2, version2) + 4;
    }
    function getTotalBitsFromDataArray(segments2, version2) {
      let totalBits = 0;
      segments2.forEach(function(data2) {
        const reservedBits = getReservedBitsCount(data2.mode, version2);
        totalBits += reservedBits + data2.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length2 = getTotalBitsFromDataArray(segments2, currentVersion);
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel2, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from2(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode2 === "undefined") mode2 = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version2);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode2 === Mode.MIXED) return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
      switch (mode2) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data2, errorCorrectionLevel2) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel2, ECLevel.M);
      if (Array.isArray(data2)) {
        if (data2.length > 1) {
          return getBestVersionForMixedData(data2, ecl);
        }
        if (data2.length === 0) {
          return 1;
        }
        seg = data2[0];
      } else {
        seg = data2;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version2) {
      if (!VersionCheck.isValid(version2) || version2 < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d3 = version2 << 12;
      while (Utils.getBCHDigit(d3) - G18_BCH >= 0) {
        d3 ^= G18 << Utils.getBCHDigit(d3) - G18_BCH;
      }
      return version2 << 12 | d3;
    };
  })(version$1);
  return version$1;
}
var formatInfo = {};
var hasRequiredFormatInfo;
function requireFormatInfo() {
  if (hasRequiredFormatInfo) return formatInfo;
  hasRequiredFormatInfo = 1;
  const Utils = requireUtils$5();
  const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
  const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
  const G15_BCH = Utils.getBCHDigit(G15);
  formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask) {
    const data2 = errorCorrectionLevel2.bit << 3 | mask;
    let d3 = data2 << 10;
    while (Utils.getBCHDigit(d3) - G15_BCH >= 0) {
      d3 ^= G15 << Utils.getBCHDigit(d3) - G15_BCH;
    }
    return (data2 << 10 | d3) ^ G15_MASK;
  };
  return formatInfo;
}
var segments = {};
var numericData;
var hasRequiredNumericData;
function requireNumericData() {
  if (hasRequiredNumericData) return numericData;
  hasRequiredNumericData = 1;
  const Mode = requireMode();
  function NumericData(data2) {
    this.mode = Mode.NUMERIC;
    this.data = data2.toString();
  }
  NumericData.getBitsLength = function getBitsLength(length2) {
    return 10 * Math.floor(length2 / 3) + (length2 % 3 ? length2 % 3 * 3 + 1 : 0);
  };
  NumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  NumericData.prototype.getBitsLength = function getBitsLength() {
    return NumericData.getBitsLength(this.data.length);
  };
  NumericData.prototype.write = function write2(bitBuffer2) {
    let i4, group, value;
    for (i4 = 0; i4 + 3 <= this.data.length; i4 += 3) {
      group = this.data.substr(i4, 3);
      value = parseInt(group, 10);
      bitBuffer2.put(value, 10);
    }
    const remainingNum = this.data.length - i4;
    if (remainingNum > 0) {
      group = this.data.substr(i4);
      value = parseInt(group, 10);
      bitBuffer2.put(value, remainingNum * 3 + 1);
    }
  };
  numericData = NumericData;
  return numericData;
}
var alphanumericData;
var hasRequiredAlphanumericData;
function requireAlphanumericData() {
  if (hasRequiredAlphanumericData) return alphanumericData;
  hasRequiredAlphanumericData = 1;
  const Mode = requireMode();
  const ALPHA_NUM_CHARS = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    " ",
    "$",
    "%",
    "*",
    "+",
    "-",
    ".",
    "/",
    ":"
  ];
  function AlphanumericData(data2) {
    this.mode = Mode.ALPHANUMERIC;
    this.data = data2;
  }
  AlphanumericData.getBitsLength = function getBitsLength(length2) {
    return 11 * Math.floor(length2 / 2) + 6 * (length2 % 2);
  };
  AlphanumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  AlphanumericData.prototype.getBitsLength = function getBitsLength() {
    return AlphanumericData.getBitsLength(this.data.length);
  };
  AlphanumericData.prototype.write = function write2(bitBuffer2) {
    let i4;
    for (i4 = 0; i4 + 2 <= this.data.length; i4 += 2) {
      let value = ALPHA_NUM_CHARS.indexOf(this.data[i4]) * 45;
      value += ALPHA_NUM_CHARS.indexOf(this.data[i4 + 1]);
      bitBuffer2.put(value, 11);
    }
    if (this.data.length % 2) {
      bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i4]), 6);
    }
  };
  alphanumericData = AlphanumericData;
  return alphanumericData;
}
var encodeUtf8;
var hasRequiredEncodeUtf8;
function requireEncodeUtf8() {
  if (hasRequiredEncodeUtf8) return encodeUtf8;
  hasRequiredEncodeUtf8 = 1;
  encodeUtf8 = function encodeUtf82(input) {
    var result = [];
    var size2 = input.length;
    for (var index2 = 0; index2 < size2; index2++) {
      var point = input.charCodeAt(index2);
      if (point >= 55296 && point <= 56319 && size2 > index2 + 1) {
        var second = input.charCodeAt(index2 + 1);
        if (second >= 56320 && second <= 57343) {
          point = (point - 55296) * 1024 + second - 56320 + 65536;
          index2 += 1;
        }
      }
      if (point < 128) {
        result.push(point);
        continue;
      }
      if (point < 2048) {
        result.push(point >> 6 | 192);
        result.push(point & 63 | 128);
        continue;
      }
      if (point < 55296 || point >= 57344 && point < 65536) {
        result.push(point >> 12 | 224);
        result.push(point >> 6 & 63 | 128);
        result.push(point & 63 | 128);
        continue;
      }
      if (point >= 65536 && point <= 1114111) {
        result.push(point >> 18 | 240);
        result.push(point >> 12 & 63 | 128);
        result.push(point >> 6 & 63 | 128);
        result.push(point & 63 | 128);
        continue;
      }
      result.push(239, 191, 189);
    }
    return new Uint8Array(result).buffer;
  };
  return encodeUtf8;
}
var byteData;
var hasRequiredByteData;
function requireByteData() {
  if (hasRequiredByteData) return byteData;
  hasRequiredByteData = 1;
  const encodeUtf82 = requireEncodeUtf8();
  const Mode = requireMode();
  function ByteData(data2) {
    this.mode = Mode.BYTE;
    if (typeof data2 === "string") {
      data2 = encodeUtf82(data2);
    }
    this.data = new Uint8Array(data2);
  }
  ByteData.getBitsLength = function getBitsLength(length2) {
    return length2 * 8;
  };
  ByteData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  ByteData.prototype.getBitsLength = function getBitsLength() {
    return ByteData.getBitsLength(this.data.length);
  };
  ByteData.prototype.write = function(bitBuffer2) {
    for (let i4 = 0, l2 = this.data.length; i4 < l2; i4++) {
      bitBuffer2.put(this.data[i4], 8);
    }
  };
  byteData = ByteData;
  return byteData;
}
var kanjiData;
var hasRequiredKanjiData;
function requireKanjiData() {
  if (hasRequiredKanjiData) return kanjiData;
  hasRequiredKanjiData = 1;
  const Mode = requireMode();
  const Utils = requireUtils$5();
  function KanjiData(data2) {
    this.mode = Mode.KANJI;
    this.data = data2;
  }
  KanjiData.getBitsLength = function getBitsLength(length2) {
    return length2 * 13;
  };
  KanjiData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  KanjiData.prototype.getBitsLength = function getBitsLength() {
    return KanjiData.getBitsLength(this.data.length);
  };
  KanjiData.prototype.write = function(bitBuffer2) {
    let i4;
    for (i4 = 0; i4 < this.data.length; i4++) {
      let value = Utils.toSJIS(this.data[i4]);
      if (value >= 33088 && value <= 40956) {
        value -= 33088;
      } else if (value >= 57408 && value <= 60351) {
        value -= 49472;
      } else {
        throw new Error(
          "Invalid SJIS character: " + this.data[i4] + "\nMake sure your charset is UTF-8"
        );
      }
      value = (value >>> 8 & 255) * 192 + (value & 255);
      bitBuffer2.put(value, 13);
    }
  };
  kanjiData = KanjiData;
  return kanjiData;
}
var dijkstra = { exports: {} };
var hasRequiredDijkstra;
function requireDijkstra() {
  if (hasRequiredDijkstra) return dijkstra.exports;
  hasRequiredDijkstra = 1;
  (function(module) {
    var dijkstra2 = {
      single_source_shortest_paths: function(graph, s2, d3) {
        var predecessors = {};
        var costs = {};
        costs[s2] = 0;
        var open = dijkstra2.PriorityQueue.make();
        open.push(s2, 0);
        var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u2 = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u2] || {};
          for (v2 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v2)) {
              cost_of_e = adjacent_nodes[v2];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v2];
              first_visit = typeof costs[v2] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v2] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v2, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v2] = u2;
              }
            }
          }
        }
        if (typeof d3 !== "undefined" && typeof costs[d3] === "undefined") {
          var msg = ["Could not find a path from ", s2, " to ", d3, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d3) {
        var nodes = [];
        var u2 = d3;
        while (u2) {
          nodes.push(u2);
          predecessors[u2];
          u2 = predecessors[u2];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s2, d3) {
        var predecessors = dijkstra2.single_source_shortest_paths(graph, s2, d3);
        return dijkstra2.extract_shortest_path_from_predecessor_list(
          predecessors,
          d3
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T2 = dijkstra2.PriorityQueue, t2 = {}, key2;
          opts = opts || {};
          for (key2 in T2) {
            if (T2.hasOwnProperty(key2)) {
              t2[key2] = T2[key2];
            }
          }
          t2.queue = [];
          t2.sorter = opts.sorter || T2.default_sorter;
          return t2;
        },
        default_sorter: function(a2, b2) {
          return a2.cost - b2.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    {
      module.exports = dijkstra2;
    }
  })(dijkstra);
  return dijkstra.exports;
}
var hasRequiredSegments;
function requireSegments() {
  if (hasRequiredSegments) return segments;
  hasRequiredSegments = 1;
  (function(exports) {
    const Mode = requireMode();
    const NumericData = requireNumericData();
    const AlphanumericData = requireAlphanumericData();
    const ByteData = requireByteData();
    const KanjiData = requireKanjiData();
    const Regex = requireRegex();
    const Utils = requireUtils$5();
    const dijkstra2 = requireDijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex2, mode2, str) {
      const segments2 = [];
      let result;
      while ((result = regex2.exec(str)) !== null) {
        segments2.push({
          data: result[0],
          index: result.index,
          mode: mode2,
          length: result[0].length
        });
      }
      return segments2;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length2, mode2) {
      switch (mode2) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length2);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length2);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length2);
        case Mode.BYTE:
          return ByteData.getBitsLength(length2);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i4 = 0; i4 < segs.length; i4++) {
        const seg = segs[i4];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version2) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i4 = 0; i4 < nodes.length; i4++) {
        const nodeGroup = nodes[i4];
        const currentNodeIds = [];
        for (let j2 = 0; j2 < nodeGroup.length; j2++) {
          const node2 = nodeGroup[j2];
          const key2 = "" + i4 + j2;
          currentNodeIds.push(key2);
          table[key2] = { node: node2, lastCount: 0 };
          graph[key2] = {};
          for (let n3 = 0; n3 < prevNodeIds.length; n3++) {
            const prevNodeId = prevNodeIds[n3];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node2.mode) {
              graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node2.length, node2.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node2.mode);
              table[prevNodeId].lastCount += node2.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node2.length;
              graph[prevNodeId][key2] = getSegmentBitsLength(node2.length, node2.mode) + 4 + Mode.getCharCountIndicator(node2.mode, version2);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n3 = 0; n3 < prevNodeIds.length; n3++) {
        graph[prevNodeIds[n3]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data2, modesHint) {
      let mode2;
      const bestMode = Mode.getBestModeForData(data2);
      mode2 = Mode.from(modesHint, bestMode);
      if (mode2 !== Mode.BYTE && mode2.bit < bestMode.bit) {
        throw new Error('"' + data2 + '" cannot be encoded with mode ' + Mode.toString(mode2) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode2 === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode2 = Mode.BYTE;
      }
      switch (mode2) {
        case Mode.NUMERIC:
          return new NumericData(data2);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data2);
        case Mode.KANJI:
          return new KanjiData(data2);
        case Mode.BYTE:
          return new ByteData(data2);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString2(data2, version2) {
      const segs = getSegmentsFromString(data2, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version2);
      const path = dijkstra2.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i4 = 1; i4 < path.length - 1; i4++) {
        optimizedSegs.push(graph.table[path[i4]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data2) {
      return exports.fromArray(
        getSegmentsFromString(data2, Utils.isKanjiModeEnabled())
      );
    };
  })(segments);
  return segments;
}
var hasRequiredQrcode;
function requireQrcode() {
  if (hasRequiredQrcode) return qrcode;
  hasRequiredQrcode = 1;
  const Utils = requireUtils$5();
  const ECLevel = requireErrorCorrectionLevel();
  const BitBuffer = requireBitBuffer();
  const BitMatrix = requireBitMatrix();
  const AlignmentPattern = requireAlignmentPattern();
  const FinderPattern = requireFinderPattern();
  const MaskPattern = requireMaskPattern();
  const ECCode = requireErrorCorrectionCode();
  const ReedSolomonEncoder = requireReedSolomonEncoder();
  const Version = requireVersion();
  const FormatInfo = requireFormatInfo();
  const Mode = requireMode();
  const Segments = requireSegments();
  function setupFinderPattern(matrix, version2) {
    const size2 = matrix.size;
    const pos = FinderPattern.getPositions(version2);
    for (let i4 = 0; i4 < pos.length; i4++) {
      const row = pos[i4][0];
      const col = pos[i4][1];
      for (let r2 = -1; r2 <= 7; r2++) {
        if (row + r2 <= -1 || size2 <= row + r2) continue;
        for (let c2 = -1; c2 <= 7; c2++) {
          if (col + c2 <= -1 || size2 <= col + c2) continue;
          if (r2 >= 0 && r2 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c2 >= 2 && c2 <= 4) {
            matrix.set(row + r2, col + c2, true, true);
          } else {
            matrix.set(row + r2, col + c2, false, true);
          }
        }
      }
    }
  }
  function setupTimingPattern(matrix) {
    const size2 = matrix.size;
    for (let r2 = 8; r2 < size2 - 8; r2++) {
      const value = r2 % 2 === 0;
      matrix.set(r2, 6, value, true);
      matrix.set(6, r2, value, true);
    }
  }
  function setupAlignmentPattern(matrix, version2) {
    const pos = AlignmentPattern.getPositions(version2);
    for (let i4 = 0; i4 < pos.length; i4++) {
      const row = pos[i4][0];
      const col = pos[i4][1];
      for (let r2 = -2; r2 <= 2; r2++) {
        for (let c2 = -2; c2 <= 2; c2++) {
          if (r2 === -2 || r2 === 2 || c2 === -2 || c2 === 2 || r2 === 0 && c2 === 0) {
            matrix.set(row + r2, col + c2, true, true);
          } else {
            matrix.set(row + r2, col + c2, false, true);
          }
        }
      }
    }
  }
  function setupVersionInfo(matrix, version2) {
    const size2 = matrix.size;
    const bits = Version.getEncodedBits(version2);
    let row, col, mod;
    for (let i4 = 0; i4 < 18; i4++) {
      row = Math.floor(i4 / 3);
      col = i4 % 3 + size2 - 8 - 3;
      mod = (bits >> i4 & 1) === 1;
      matrix.set(row, col, mod, true);
      matrix.set(col, row, mod, true);
    }
  }
  function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
    const size2 = matrix.size;
    const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
    let i4, mod;
    for (i4 = 0; i4 < 15; i4++) {
      mod = (bits >> i4 & 1) === 1;
      if (i4 < 6) {
        matrix.set(i4, 8, mod, true);
      } else if (i4 < 8) {
        matrix.set(i4 + 1, 8, mod, true);
      } else {
        matrix.set(size2 - 15 + i4, 8, mod, true);
      }
      if (i4 < 8) {
        matrix.set(8, size2 - i4 - 1, mod, true);
      } else if (i4 < 9) {
        matrix.set(8, 15 - i4 - 1 + 1, mod, true);
      } else {
        matrix.set(8, 15 - i4 - 1, mod, true);
      }
    }
    matrix.set(size2 - 8, 8, 1, true);
  }
  function setupData(matrix, data2) {
    const size2 = matrix.size;
    let inc = -1;
    let row = size2 - 1;
    let bitIndex = 7;
    let byteIndex = 0;
    for (let col = size2 - 1; col > 0; col -= 2) {
      if (col === 6) col--;
      while (true) {
        for (let c2 = 0; c2 < 2; c2++) {
          if (!matrix.isReserved(row, col - c2)) {
            let dark2 = false;
            if (byteIndex < data2.length) {
              dark2 = (data2[byteIndex] >>> bitIndex & 1) === 1;
            }
            matrix.set(row, col - c2, dark2);
            bitIndex--;
            if (bitIndex === -1) {
              byteIndex++;
              bitIndex = 7;
            }
          }
        }
        row += inc;
        if (row < 0 || size2 <= row) {
          row -= inc;
          inc = -inc;
          break;
        }
      }
    }
  }
  function createData(version2, errorCorrectionLevel2, segments2) {
    const buffer2 = new BitBuffer();
    segments2.forEach(function(data2) {
      buffer2.put(data2.mode.bit, 4);
      buffer2.put(data2.getLength(), Mode.getCharCountIndicator(data2.mode, version2));
      data2.write(buffer2);
    });
    const totalCodewords = Utils.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
      buffer2.put(0, 4);
    }
    while (buffer2.getLengthInBits() % 8 !== 0) {
      buffer2.putBit(0);
    }
    const remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
    for (let i4 = 0; i4 < remainingByte; i4++) {
      buffer2.put(i4 % 2 ? 17 : 236, 8);
    }
    return createCodewords(buffer2, version2, errorCorrectionLevel2);
  }
  function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
    const totalCodewords = Utils.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewords = totalCodewords - ecTotalCodewords;
    const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
    const blocksInGroup2 = totalCodewords % ecTotalBlocks;
    const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
    const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
    const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
    const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
    const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
    const rs = new ReedSolomonEncoder(ecCount);
    let offset2 = 0;
    const dcData = new Array(ecTotalBlocks);
    const ecData = new Array(ecTotalBlocks);
    let maxDataSize = 0;
    const buffer2 = new Uint8Array(bitBuffer2.buffer);
    for (let b2 = 0; b2 < ecTotalBlocks; b2++) {
      const dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
      dcData[b2] = buffer2.slice(offset2, offset2 + dataSize);
      ecData[b2] = rs.encode(dcData[b2]);
      offset2 += dataSize;
      maxDataSize = Math.max(maxDataSize, dataSize);
    }
    const data2 = new Uint8Array(totalCodewords);
    let index2 = 0;
    let i4, r2;
    for (i4 = 0; i4 < maxDataSize; i4++) {
      for (r2 = 0; r2 < ecTotalBlocks; r2++) {
        if (i4 < dcData[r2].length) {
          data2[index2++] = dcData[r2][i4];
        }
      }
    }
    for (i4 = 0; i4 < ecCount; i4++) {
      for (r2 = 0; r2 < ecTotalBlocks; r2++) {
        data2[index2++] = ecData[r2][i4];
      }
    }
    return data2;
  }
  function createSymbol(data2, version2, errorCorrectionLevel2, maskPattern2) {
    let segments2;
    if (Array.isArray(data2)) {
      segments2 = Segments.fromArray(data2);
    } else if (typeof data2 === "string") {
      let estimatedVersion = version2;
      if (!estimatedVersion) {
        const rawSegments = Segments.rawSplit(data2);
        estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
      }
      segments2 = Segments.fromString(data2, estimatedVersion || 40);
    } else {
      throw new Error("Invalid data");
    }
    const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
    if (!bestVersion) {
      throw new Error("The amount of data is too big to be stored in a QR Code");
    }
    if (!version2) {
      version2 = bestVersion;
    } else if (version2 < bestVersion) {
      throw new Error(
        "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
      );
    }
    const dataBits = createData(version2, errorCorrectionLevel2, segments2);
    const moduleCount = Utils.getSymbolSize(version2);
    const modules = new BitMatrix(moduleCount);
    setupFinderPattern(modules, version2);
    setupTimingPattern(modules);
    setupAlignmentPattern(modules, version2);
    setupFormatInfo(modules, errorCorrectionLevel2, 0);
    if (version2 >= 7) {
      setupVersionInfo(modules, version2);
    }
    setupData(modules, dataBits);
    if (isNaN(maskPattern2)) {
      maskPattern2 = MaskPattern.getBestMask(
        modules,
        setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
      );
    }
    MaskPattern.applyMask(maskPattern2, modules);
    setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
    return {
      modules,
      version: version2,
      errorCorrectionLevel: errorCorrectionLevel2,
      maskPattern: maskPattern2,
      segments: segments2
    };
  }
  qrcode.create = function create(data2, options) {
    if (typeof data2 === "undefined" || data2 === "") {
      throw new Error("No input text");
    }
    let errorCorrectionLevel2 = ECLevel.M;
    let version2;
    let mask;
    if (typeof options !== "undefined") {
      errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
      version2 = Version.from(options.version);
      mask = MaskPattern.from(options.maskPattern);
      if (options.toSJISFunc) {
        Utils.setToSJISFunction(options.toSJISFunc);
      }
    }
    return createSymbol(data2, version2, errorCorrectionLevel2, mask);
  };
  return qrcode;
}
var canvas = {};
var utils$4 = {};
var hasRequiredUtils$4;
function requireUtils$4() {
  if (hasRequiredUtils$4) return utils$4;
  hasRequiredUtils$4 = 1;
  (function(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
          return [c2, c2];
        }));
      }
      if (hexCode.length === 6) hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      const margin2 = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width2 = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width: width2,
        scale: width2 ? 4 : scale,
        margin: margin2,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale2(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr2, opts) {
      const size2 = qr2.modules.size;
      const data2 = qr2.modules.data;
      const scale = exports.getScale(size2, opts);
      const symbolSize = Math.floor((size2 + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i4 = 0; i4 < symbolSize; i4++) {
        for (let j2 = 0; j2 < symbolSize; j2++) {
          let posDst = (i4 * symbolSize + j2) * 4;
          let pxColor = opts.color.light;
          if (i4 >= scaledMargin && j2 >= scaledMargin && i4 < symbolSize - scaledMargin && j2 < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i4 - scaledMargin) / scale);
            const jSrc = Math.floor((j2 - scaledMargin) / scale);
            pxColor = palette[data2[iSrc * size2 + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  })(utils$4);
  return utils$4;
}
var hasRequiredCanvas;
function requireCanvas() {
  if (hasRequiredCanvas) return canvas;
  hasRequiredCanvas = 1;
  (function(exports) {
    const Utils = requireUtils$4();
    function clearCanvas(ctx, canvas2, size2) {
      ctx.clearRect(0, 0, canvas2.width, canvas2.height);
      if (!canvas2.style) canvas2.style = {};
      canvas2.height = size2;
      canvas2.width = size2;
      canvas2.style.height = size2 + "px";
      canvas2.style.width = size2 + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e2) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas2, options) {
      let opts = options;
      let canvasEl = canvas2;
      if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
        opts = canvas2;
        canvas2 = void 0;
      }
      if (!canvas2) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size2 = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size2, size2);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size2);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
        opts = canvas2;
        canvas2 = void 0;
      }
      if (!opts) opts = {};
      const canvasEl = exports.render(qrData, canvas2, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  })(canvas);
  return canvas;
}
var svgTag = {};
var hasRequiredSvgTag;
function requireSvgTag() {
  if (hasRequiredSvgTag) return svgTag;
  hasRequiredSvgTag = 1;
  const Utils = requireUtils$4();
  function getColorAttrib(color2, attrib) {
    const alpha2 = color2.a / 255;
    const str = attrib + '="' + color2.hex + '"';
    return alpha2 < 1 ? str + " " + attrib + '-opacity="' + alpha2.toFixed(2).slice(1) + '"' : str;
  }
  function svgCmd(cmd, x2, y3) {
    let str = cmd + x2;
    if (typeof y3 !== "undefined") str += " " + y3;
    return str;
  }
  function qrToPath(data2, size2, margin2) {
    let path = "";
    let moveBy = 0;
    let newRow = false;
    let lineLength = 0;
    for (let i4 = 0; i4 < data2.length; i4++) {
      const col = Math.floor(i4 % size2);
      const row = Math.floor(i4 / size2);
      if (!col && !newRow) newRow = true;
      if (data2[i4]) {
        lineLength++;
        if (!(i4 > 0 && col > 0 && data2[i4 - 1])) {
          path += newRow ? svgCmd("M", col + margin2, 0.5 + row + margin2) : svgCmd("m", moveBy, 0);
          moveBy = 0;
          newRow = false;
        }
        if (!(col + 1 < size2 && data2[i4 + 1])) {
          path += svgCmd("h", lineLength);
          lineLength = 0;
        }
      } else {
        moveBy++;
      }
    }
    return path;
  }
  svgTag.render = function render(qrData, options, cb) {
    const opts = Utils.getOptions(options);
    const size2 = qrData.modules.size;
    const data2 = qrData.modules.data;
    const qrcodesize = size2 + opts.margin * 2;
    const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
    const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data2, size2, opts.margin) + '"/>';
    const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
    const width2 = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
    const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width2 + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
    if (typeof cb === "function") {
      cb(null, svgTag2);
    }
    return svgTag2;
  };
  return svgTag;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$1;
  hasRequiredBrowser$1 = 1;
  const canPromise2 = requireCanPromise();
  const QRCode = requireQrcode();
  const CanvasRenderer = requireCanvas();
  const SvgRenderer = requireSvgTag();
  function renderCanvas(renderFunc, canvas2, text, opts, cb) {
    const args = [].slice.call(arguments, 1);
    const argsNum = args.length;
    const isLastArgCb = typeof args[argsNum - 1] === "function";
    if (!isLastArgCb && !canPromise2()) {
      throw new Error("Callback required as last argument");
    }
    if (isLastArgCb) {
      if (argsNum < 2) {
        throw new Error("Too few arguments provided");
      }
      if (argsNum === 2) {
        cb = text;
        text = canvas2;
        canvas2 = opts = void 0;
      } else if (argsNum === 3) {
        if (canvas2.getContext && typeof cb === "undefined") {
          cb = opts;
          opts = void 0;
        } else {
          cb = opts;
          opts = text;
          text = canvas2;
          canvas2 = void 0;
        }
      }
    } else {
      if (argsNum < 1) {
        throw new Error("Too few arguments provided");
      }
      if (argsNum === 1) {
        text = canvas2;
        canvas2 = opts = void 0;
      } else if (argsNum === 2 && !canvas2.getContext) {
        opts = text;
        text = canvas2;
        canvas2 = void 0;
      }
      return new Promise(function(resolve, reject) {
        try {
          const data2 = QRCode.create(text, opts);
          resolve(renderFunc(data2, canvas2, opts));
        } catch (e2) {
          reject(e2);
        }
      });
    }
    try {
      const data2 = QRCode.create(text, opts);
      cb(null, renderFunc(data2, canvas2, opts));
    } catch (e2) {
      cb(e2);
    }
  }
  browser$1.create = QRCode.create;
  browser$1.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
  browser$1.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
  browser$1.toString = renderCanvas.bind(null, function(data2, _2, opts) {
    return SvgRenderer.render(data2, opts);
  });
  return browser$1;
}
var browserExports = requireBrowser$1();
const QRCodeUtil = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
const CONNECTING_ERROR_MARGIN = 0.1;
const CIRCLE_SIZE_MODIFIER = 2.5;
const QRCODE_MATRIX_MARGIN = 7;
function isAdjecentDots(cy, otherCy, cellSize) {
  if (cy === otherCy) {
    return false;
  }
  const diff = cy - otherCy < 0 ? otherCy - cy : cy - otherCy;
  return diff <= cellSize + CONNECTING_ERROR_MARGIN;
}
function getMatrix(value, errorCorrectionLevel2) {
  const arr = Array.prototype.slice.call(QRCodeUtil.create(value, { errorCorrectionLevel: errorCorrectionLevel2 }).modules.data, 0);
  const sqrt = Math.sqrt(arr.length);
  return arr.reduce((rows, key2, index2) => (index2 % sqrt === 0 ? rows.push([key2]) : rows[rows.length - 1].push(key2)) && rows, []);
}
const QrCodeUtil = {
  generate(uri, size2, logoSize) {
    const dotColor = "#141414";
    const edgeColor = "transparent";
    const strokeWidth = 5;
    const dots = [];
    const matrix = getMatrix(uri, "Q");
    const cellSize = size2 / matrix.length;
    const qrList = [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 }
    ];
    qrList.forEach(({ x: x2, y: y3 }) => {
      const x1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * x2;
      const y1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * y3;
      const borderRadius2 = 0.45;
      for (let i4 = 0; i4 < qrList.length; i4 += 1) {
        const dotSize = cellSize * (QRCODE_MATRIX_MARGIN - i4 * 2);
        dots.push(b`
            <rect
              fill=${i4 === 2 ? dotColor : edgeColor}
              width=${i4 === 0 ? dotSize - strokeWidth : dotSize}
              rx= ${i4 === 0 ? (dotSize - strokeWidth) * borderRadius2 : dotSize * borderRadius2}
              ry= ${i4 === 0 ? (dotSize - strokeWidth) * borderRadius2 : dotSize * borderRadius2}
              stroke=${dotColor}
              stroke-width=${i4 === 0 ? strokeWidth : 0}
              height=${i4 === 0 ? dotSize - strokeWidth : dotSize}
              x= ${i4 === 0 ? y1 + cellSize * i4 + strokeWidth / 2 : y1 + cellSize * i4}
              y= ${i4 === 0 ? x1 + cellSize * i4 + strokeWidth / 2 : x1 + cellSize * i4}
            />
          `);
      }
    });
    const clearArenaSize = Math.floor((logoSize + 25) / cellSize);
    const matrixMiddleStart = matrix.length / 2 - clearArenaSize / 2;
    const matrixMiddleEnd = matrix.length / 2 + clearArenaSize / 2 - 1;
    const circles = [];
    matrix.forEach((row, i4) => {
      row.forEach((_2, j2) => {
        if (matrix[i4][j2]) {
          if (!(i4 < QRCODE_MATRIX_MARGIN && j2 < QRCODE_MATRIX_MARGIN || i4 > matrix.length - (QRCODE_MATRIX_MARGIN + 1) && j2 < QRCODE_MATRIX_MARGIN || i4 < QRCODE_MATRIX_MARGIN && j2 > matrix.length - (QRCODE_MATRIX_MARGIN + 1))) {
            if (!(i4 > matrixMiddleStart && i4 < matrixMiddleEnd && j2 > matrixMiddleStart && j2 < matrixMiddleEnd)) {
              const cx = i4 * cellSize + cellSize / 2;
              const cy = j2 * cellSize + cellSize / 2;
              circles.push([cx, cy]);
            }
          }
        }
      });
    });
    const circlesToConnect = {};
    circles.forEach(([cx, cy]) => {
      if (circlesToConnect[cx]) {
        circlesToConnect[cx]?.push(cy);
      } else {
        circlesToConnect[cx] = [cy];
      }
    });
    Object.entries(circlesToConnect).map(([cx, cys]) => {
      const newCys = cys.filter((cy) => cys.every((otherCy) => !isAdjecentDots(cy, otherCy, cellSize)));
      return [Number(cx), newCys];
    }).forEach(([cx, cys]) => {
      cys.forEach((cy) => {
        dots.push(b`<circle cx=${cx} cy=${cy} fill=${dotColor} r=${cellSize / CIRCLE_SIZE_MODIFIER} />`);
      });
    });
    Object.entries(circlesToConnect).filter(([_2, cys]) => cys.length > 1).map(([cx, cys]) => {
      const newCys = cys.filter((cy) => cys.some((otherCy) => isAdjecentDots(cy, otherCy, cellSize)));
      return [Number(cx), newCys];
    }).map(([cx, cys]) => {
      cys.sort((a2, b2) => a2 < b2 ? -1 : 1);
      const groups = [];
      for (const cy of cys) {
        const group = groups.find((item) => item.some((otherCy) => isAdjecentDots(cy, otherCy, cellSize)));
        if (group) {
          group.push(cy);
        } else {
          groups.push([cy]);
        }
      }
      return [cx, groups.map((item) => [item[0], item[item.length - 1]])];
    }).forEach(([cx, groups]) => {
      groups.forEach(([y1, y22]) => {
        dots.push(b`
              <line
                x1=${cx}
                x2=${cx}
                y1=${y1}
                y2=${y22}
                stroke=${dotColor}
                stroke-width=${cellSize / (CIRCLE_SIZE_MODIFIER / 2)}
                stroke-linecap="round"
              />
            `);
      });
    });
    return dots;
  }
};
const styles$1z = i$5`
  :host {
    position: relative;
    user-select: none;
    display: block;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    width: var(--local-size);
  }

  :host([data-theme='dark']) {
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px);
    background-color: var(--wui-color-inverse-100);
    padding: var(--wui-spacing-l);
  }

  :host([data-theme='light']) {
    box-shadow: 0 0 0 1px var(--wui-color-bg-125);
    background-color: var(--wui-color-bg-125);
  }

  :host([data-clear='true']) > wui-icon {
    display: none;
  }

  svg:first-child,
  wui-image,
  wui-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
  }

  wui-image {
    width: 25%;
    height: 25%;
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon {
    width: 100%;
    height: 100%;
    color: #3396ff !important;
    transform: translateY(-50%) translateX(-50%) scale(0.25);
  }
`;
var __decorate$29 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiQrCode = class WuiQrCode2 extends i$2 {
  constructor() {
    super(...arguments);
    this.uri = "";
    this.size = 0;
    this.theme = "dark";
    this.imageSrc = void 0;
    this.alt = void 0;
    this.arenaClear = void 0;
    this.farcaster = void 0;
  }
  render() {
    this.dataset["theme"] = this.theme;
    this.dataset["clear"] = String(this.arenaClear);
    this.style.cssText = `--local-size: ${this.size}px`;
    return x`${this.templateVisual()} ${this.templateSvg()}`;
  }
  templateSvg() {
    const size2 = this.theme === "light" ? this.size : this.size - 16 * 2;
    return b`
      <svg height=${size2} width=${size2}>
        ${QrCodeUtil.generate(this.uri, size2, this.arenaClear ? 0 : size2 / 4)}
      </svg>
    `;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x`<wui-image src=${this.imageSrc} alt=${this.alt ?? "logo"}></wui-image>`;
    }
    if (this.farcaster) {
      return x`<wui-icon
        class="farcaster"
        size="inherit"
        color="inherit"
        name="farcaster"
      ></wui-icon>`;
    }
    return x`<wui-icon size="inherit" color="inherit" name="walletConnect"></wui-icon>`;
  }
};
WuiQrCode.styles = [resetStyles, styles$1z];
__decorate$29([
  n$2()
], WuiQrCode.prototype, "uri", void 0);
__decorate$29([
  n$2({ type: Number })
], WuiQrCode.prototype, "size", void 0);
__decorate$29([
  n$2()
], WuiQrCode.prototype, "theme", void 0);
__decorate$29([
  n$2()
], WuiQrCode.prototype, "imageSrc", void 0);
__decorate$29([
  n$2()
], WuiQrCode.prototype, "alt", void 0);
__decorate$29([
  n$2({ type: Boolean })
], WuiQrCode.prototype, "arenaClear", void 0);
__decorate$29([
  n$2({ type: Boolean })
], WuiQrCode.prototype, "farcaster", void 0);
WuiQrCode = __decorate$29([
  customElement("wui-qr-code")
], WuiQrCode);
const styles$1y = i$5`
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }
`;
var __decorate$28 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiSearchBar = class WuiSearchBar2 extends i$2 {
  constructor() {
    super(...arguments);
    this.inputComponentRef = e();
  }
  render() {
    return x`
      <wui-input-text
        ${n2(this.inputComponentRef)}
        placeholder="Search wallet"
        icon="search"
        type="search"
        enterKeyHint="search"
        size="sm"
      >
        <wui-input-element @click=${this.clearValue} icon="close"></wui-input-element>
      </wui-input-text>
    `;
  }
  clearValue() {
    const inputComponent = this.inputComponentRef.value;
    const inputElement = inputComponent?.inputElementRef.value;
    if (inputElement) {
      inputElement.value = "";
      inputElement.focus();
      inputElement.dispatchEvent(new Event("input"));
    }
  }
};
WuiSearchBar.styles = [resetStyles, styles$1y];
WuiSearchBar = __decorate$28([
  customElement("wui-search-bar")
], WuiSearchBar);
const styles$1x = i$5`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-xs);
    align-items: center;
    padding: var(--wui-spacing-xs) var(--wui-spacing-m) var(--wui-spacing-xs) var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-005);
    box-sizing: border-box;
    max-height: 40px;
    background-color: var(--wui-color-bg-175);
    box-shadow:
      0px 14px 64px -4px rgba(0, 0, 0, 0.15),
      0px 8px 22px -6px rgba(0, 0, 0, 0.15);
  }

  :host wui-loading-spinner {
    margin-left: var(--wui-spacing-3xs);
  }
`;
var __decorate$27 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiSnackbar = class WuiSnackbar2 extends i$2 {
  constructor() {
    super(...arguments);
    this.backgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.icon = "checkmark";
    this.message = "";
    this.loading = false;
  }
  render() {
    return x`
      ${this.loading ? x`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : x`<wui-icon-box
            size="sm"
            iconSize="xs"
            iconColor=${this.iconColor}
            backgroundColor=${this.backgroundColor}
            icon=${this.icon}
            background="opaque"
          ></wui-icon-box>`}
      <wui-text variant="paragraph-500" color="fg-100">${this.message}</wui-text>
    `;
  }
};
WuiSnackbar.styles = [resetStyles, styles$1x];
__decorate$27([
  n$2()
], WuiSnackbar.prototype, "backgroundColor", void 0);
__decorate$27([
  n$2()
], WuiSnackbar.prototype, "iconColor", void 0);
__decorate$27([
  n$2()
], WuiSnackbar.prototype, "icon", void 0);
__decorate$27([
  n$2()
], WuiSnackbar.prototype, "message", void 0);
__decorate$27([
  n$2()
], WuiSnackbar.prototype, "loading", void 0);
WuiSnackbar = __decorate$27([
  customElement("wui-snackbar")
], WuiSnackbar);
const styles$1w = i$5`
  :host {
    display: inline-flex;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    padding: var(--wui-spacing-3xs);
    position: relative;
    height: 36px;
    min-height: 36px;
    overflow: hidden;
  }

  :host::before {
    content: '';
    position: absolute;
    pointer-events: none;
    top: 4px;
    left: 4px;
    display: block;
    width: var(--local-tab-width);
    height: 28px;
    border-radius: var(--wui-border-radius-3xl);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    transform: translateX(calc(var(--local-tab) * var(--local-tab-width)));
    transition: transform var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color, opacity;
  }

  :host([data-type='flex'])::before {
    left: 3px;
    transform: translateX(calc((var(--local-tab) * 34px) + (var(--local-tab) * 4px)));
  }

  :host([data-type='flex']) {
    display: flex;
    padding: 0px 0px 0px 12px;
    gap: 4px;
  }

  :host([data-type='flex']) > button > wui-text {
    position: absolute;
    left: 18px;
    opacity: 0;
  }

  button[data-active='true'] > wui-icon,
  button[data-active='true'] > wui-text {
    color: var(--wui-color-fg-100);
  }

  button[data-active='false'] > wui-icon,
  button[data-active='false'] > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='true']:disabled,
  button[data-active='false']:disabled {
    background-color: transparent;
    opacity: 0.5;
    cursor: not-allowed;
  }

  button[data-active='true']:disabled > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='false']:disabled > wui-text {
    color: var(--wui-color-fg-300);
  }

  button > wui-icon,
  button > wui-text {
    pointer-events: none;
    transition: color var(--wui-e ase-out-power-1) var(--wui-duration-md);
    will-change: color;
  }

  button {
    width: var(--local-tab-width);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  :host([data-type='flex']) > button {
    width: 34px;
    position: relative;
    display: flex;
    justify-content: flex-start;
  }

  button:hover:enabled,
  button:active:enabled {
    background-color: transparent !important;
  }

  button:hover:enabled > wui-icon,
  button:active:enabled > wui-icon {
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    color: var(--wui-color-fg-125);
  }

  button:hover:enabled > wui-text,
  button:active:enabled > wui-text {
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    color: var(--wui-color-fg-125);
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
  }
`;
var __decorate$26 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTabs = class WuiTabs2 extends i$2 {
  constructor() {
    super(...arguments);
    this.tabs = [];
    this.onTabChange = () => null;
    this.buttons = [];
    this.disabled = false;
    this.localTabWidth = "100px";
    this.activeTab = 0;
    this.isDense = false;
  }
  render() {
    this.isDense = this.tabs.length > 3;
    this.style.cssText = `
      --local-tab: ${this.activeTab};
      --local-tab-width: ${this.localTabWidth};
    `;
    this.dataset["type"] = this.isDense ? "flex" : "block";
    return this.tabs.map((tab, index2) => {
      const isActive = index2 === this.activeTab;
      return x`
        <button
          ?disabled=${this.disabled}
          @click=${() => this.onTabClick(index2)}
          data-active=${isActive}
          data-testid="tab-${tab.label?.toLowerCase()}"
        >
          ${this.iconTemplate(tab)}
          <wui-text variant="small-600" color="inherit"> ${tab.label} </wui-text>
        </button>
      `;
    });
  }
  firstUpdated() {
    if (this.shadowRoot && this.isDense) {
      this.buttons = [...this.shadowRoot.querySelectorAll("button")];
      setTimeout(() => {
        this.animateTabs(0, true);
      }, 0);
    }
  }
  iconTemplate(tab) {
    if (tab.icon) {
      return x`<wui-icon size="xs" color="inherit" name=${tab.icon}></wui-icon>`;
    }
    return null;
  }
  onTabClick(index2) {
    if (this.buttons) {
      this.animateTabs(index2, false);
    }
    this.activeTab = index2;
    this.onTabChange(index2);
  }
  animateTabs(index2, initialAnimation) {
    const passiveBtn = this.buttons[this.activeTab];
    const activeBtn = this.buttons[index2];
    const passiveBtnText = passiveBtn?.querySelector("wui-text");
    const activeBtnText = activeBtn?.querySelector("wui-text");
    const activeBtnBounds = activeBtn?.getBoundingClientRect();
    const activeBtnTextBounds = activeBtnText?.getBoundingClientRect();
    if (passiveBtn && passiveBtnText && !initialAnimation && index2 !== this.activeTab) {
      passiveBtnText.animate([{ opacity: 0 }], {
        duration: 50,
        easing: "ease",
        fill: "forwards"
      });
      passiveBtn.animate([{ width: `34px` }], {
        duration: 500,
        easing: "ease",
        fill: "forwards"
      });
    }
    if (activeBtn && activeBtnBounds && activeBtnTextBounds && activeBtnText) {
      if (index2 !== this.activeTab || initialAnimation) {
        this.localTabWidth = `${Math.round(activeBtnBounds.width + activeBtnTextBounds.width) + 6}px`;
        activeBtn.animate([{ width: `${activeBtnBounds.width + activeBtnTextBounds.width}px` }], {
          duration: initialAnimation ? 0 : 500,
          fill: "forwards",
          easing: "ease"
        });
        activeBtnText.animate([{ opacity: 1 }], {
          duration: initialAnimation ? 0 : 125,
          delay: initialAnimation ? 0 : 200,
          fill: "forwards",
          easing: "ease"
        });
      }
    }
  }
};
WuiTabs.styles = [resetStyles, elementStyles, styles$1w];
__decorate$26([
  n$2({ type: Array })
], WuiTabs.prototype, "tabs", void 0);
__decorate$26([
  n$2()
], WuiTabs.prototype, "onTabChange", void 0);
__decorate$26([
  n$2({ type: Array })
], WuiTabs.prototype, "buttons", void 0);
__decorate$26([
  n$2({ type: Boolean })
], WuiTabs.prototype, "disabled", void 0);
__decorate$26([
  n$2()
], WuiTabs.prototype, "localTabWidth", void 0);
__decorate$26([
  r$1()
], WuiTabs.prototype, "activeTab", void 0);
__decorate$26([
  r$1()
], WuiTabs.prototype, "isDense", void 0);
WuiTabs = __decorate$26([
  customElement("wui-tabs")
], WuiTabs);
const styles$1v = i$5`
  :host {
    display: block;
  }

  :host > button {
    gap: var(--wui-spacing-xxs);
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-1xs);
    height: 40px;
    border-radius: var(--wui-border-radius-l);
    background: var(--wui-color-gray-glass-002);
    border-width: 0px;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
  }

  :host > button wui-image {
    width: 24px;
    height: 24px;
    border-radius: var(--wui-border-radius-s);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }
`;
var __decorate$25 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTokenButton = class WuiTokenButton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.text = "";
  }
  render() {
    return x`
      <button ontouchstart>
        ${this.tokenTemplate()}
        <wui-text variant="paragraph-600" color="fg-100">${this.text}</wui-text>
      </button>
    `;
  }
  tokenTemplate() {
    if (this.imageSrc) {
      return x`<wui-image src=${this.imageSrc}></wui-image>`;
    }
    return x`
      <wui-icon-box
        size="sm"
        iconColor="fg-200"
        backgroundColor="fg-300"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `;
  }
};
WuiTokenButton.styles = [resetStyles, elementStyles, styles$1v];
__decorate$25([
  n$2()
], WuiTokenButton.prototype, "imageSrc", void 0);
__decorate$25([
  n$2()
], WuiTokenButton.prototype, "text", void 0);
WuiTokenButton = __decorate$25([
  customElement("wui-token-button")
], WuiTokenButton);
const styles$1u = i$5`
  :host {
    display: block;
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);

    color: var(--wui-color-bg-100);
    position: relative;
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-color-bg-150);
    border: 1px solid var(--wui-color-gray-glass-005);
  }

  :host([data-variant='shade']) > wui-text {
    color: var(--wui-color-fg-150);
  }

  :host([data-variant='fill']) {
    background-color: var(--wui-color-fg-100);
    border: none;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
  }

  wui-icon[data-placement='top'] {
    bottom: 0px;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
var __decorate$24 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTooltip = class WuiTooltip2 extends i$2 {
  constructor() {
    super(...arguments);
    this.placement = "top";
    this.variant = "fill";
    this.message = "";
  }
  render() {
    this.dataset["variant"] = this.variant;
    return x`<wui-icon
        data-placement=${this.placement}
        color="fg-100"
        size="inherit"
        name=${this.variant === "fill" ? "cursor" : "cursorTransparent"}
      ></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>`;
  }
};
WuiTooltip.styles = [resetStyles, elementStyles, styles$1u];
__decorate$24([
  n$2()
], WuiTooltip.prototype, "placement", void 0);
__decorate$24([
  n$2()
], WuiTooltip.prototype, "variant", void 0);
__decorate$24([
  n$2()
], WuiTooltip.prototype, "message", void 0);
WuiTooltip = __decorate$24([
  customElement("wui-tooltip")
], WuiTooltip);
const styles$1t = i$5`
  :host {
    height: 60px;
    min-height: 60px;
  }

  :host > wui-flex {
    cursor: pointer;
    height: 100%;
    display: flex;
    column-gap: var(--wui-spacing-s);
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-l);
    width: 100%;
    background-color: transparent;
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
    transition:
      background-color var(--wui-ease-out-power-1) var(--wui-duration-lg),
      opacity var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color, opacity;
  }

  @media (hover: hover) and (pointer: fine) {
    :host > wui-flex:hover {
      background-color: var(--wui-color-gray-glass-002);
    }

    :host > wui-flex:active {
      background-color: var(--wui-color-gray-glass-005);
    }
  }

  :host([disabled]) > wui-flex {
    opacity: 0.6;
  }

  :host([disabled]) > wui-flex:hover {
    background-color: transparent;
  }

  :host > wui-flex > wui-flex {
    flex: 1;
  }

  :host > wui-flex > wui-image,
  :host > wui-flex > .token-item-image-placeholder {
    width: 40px;
    max-width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    position: relative;
  }

  :host > wui-flex > .token-item-image-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  :host > wui-flex > wui-image::after,
  :host > wui-flex > .token-item-image-placeholder::after {
    position: absolute;
    content: '';
    inset: 0;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
    border-radius: var(--wui-border-radius-l);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }
`;
var __decorate$23 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTokenListItem = class WuiTokenListItem2 extends i$2 {
  constructor() {
    super();
    this.observer = new IntersectionObserver(() => void 0);
    this.imageSrc = void 0;
    this.name = void 0;
    this.symbol = void 0;
    this.price = void 0;
    this.amount = void 0;
    this.visible = false;
    this.imageError = false;
    this.observer = new IntersectionObserver((entries2) => {
      entries2.forEach((entry) => {
        if (entry.isIntersecting) {
          this.visible = true;
        } else {
          this.visible = false;
        }
      });
    }, { threshold: 0.1 });
  }
  firstUpdated() {
    this.observer.observe(this);
  }
  disconnectedCallback() {
    this.observer.disconnect();
  }
  render() {
    if (!this.visible) {
      return null;
    }
    const value = this.amount && this.price ? NumberUtil.multiply(this.price, this.amount)?.toFixed(3) : null;
    return x`
      <wui-flex alignItems="center">
        ${this.visualTemplate()}
        <wui-flex flexDirection="column" gap="3xs">
          <wui-flex justifyContent="space-between">
            <wui-text variant="paragraph-500" color="fg-100" lineClamp="1">${this.name}</wui-text>
            ${value ? x`
                  <wui-text variant="paragraph-500" color="fg-100">
                    $${UiHelperUtil.formatNumberToLocalString(value, 3)}
                  </wui-text>
                ` : null}
          </wui-flex>
          <wui-flex justifyContent="space-between">
            <wui-text variant="small-400" color="fg-200" lineClamp="1">${this.symbol}</wui-text>
            ${this.amount ? x`<wui-text variant="small-400" color="fg-200">
                  ${UiHelperUtil.formatNumberToLocalString(this.amount, 4)}
                </wui-text>` : null}
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  visualTemplate() {
    if (this.imageError) {
      return x`<wui-flex class="token-item-image-placeholder">
        <wui-icon name="image" color="inherit"></wui-icon>
      </wui-flex>`;
    }
    if (this.imageSrc) {
      return x`<wui-image
        width="40"
        height="40"
        src=${this.imageSrc}
        @onLoadError=${this.imageLoadError}
      ></wui-image>`;
    }
    return null;
  }
  imageLoadError() {
    this.imageError = true;
  }
};
WuiTokenListItem.styles = [resetStyles, elementStyles, styles$1t];
__decorate$23([
  n$2()
], WuiTokenListItem.prototype, "imageSrc", void 0);
__decorate$23([
  n$2()
], WuiTokenListItem.prototype, "name", void 0);
__decorate$23([
  n$2()
], WuiTokenListItem.prototype, "symbol", void 0);
__decorate$23([
  n$2()
], WuiTokenListItem.prototype, "price", void 0);
__decorate$23([
  n$2()
], WuiTokenListItem.prototype, "amount", void 0);
__decorate$23([
  r$1()
], WuiTokenListItem.prototype, "visible", void 0);
__decorate$23([
  r$1()
], WuiTokenListItem.prototype, "imageError", void 0);
WuiTokenListItem = __decorate$23([
  customElement("wui-token-list-item")
], WuiTokenListItem);
const styles$1s = i$5`
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    box-shadow: 0 0 0 8px var(--wui-thumbnail-border);
    border-radius: var(--local-border-radius);
    overflow: hidden;
  }

  wui-icon {
    width: 32px;
    height: 32px;
  }
`;
var __decorate$22 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiVisualThumbnail = class WuiVisualThumbnail2 extends i$2 {
  render() {
    this.style.cssText = `--local-border-radius: ${this.borderRadiusFull ? "1000px" : "20px"}; background-color: var(--wui-color-modal-bg);`;
    return x`${this.templateVisual()}`;
  }
  templateVisual() {
    if (this.imageSrc) {
      return x`<wui-image src=${this.imageSrc} alt=${this.alt ?? ""}></wui-image>`;
    }
    return x`<wui-icon
      data-parent-size="md"
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
  }
};
WuiVisualThumbnail.styles = [resetStyles, styles$1s];
__decorate$22([
  n$2()
], WuiVisualThumbnail.prototype, "imageSrc", void 0);
__decorate$22([
  n$2()
], WuiVisualThumbnail.prototype, "alt", void 0);
__decorate$22([
  n$2({ type: Boolean })
], WuiVisualThumbnail.prototype, "borderRadiusFull", void 0);
WuiVisualThumbnail = __decorate$22([
  customElement("wui-visual-thumbnail")
], WuiVisualThumbnail);
const styles$1r = i$5`
  :host {
    display: block;
  }

  button {
    width: 100%;
    display: block;
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-2l);
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-color-accent-glass-010);
  }

  button:hover {
    background-color: var(--wui-color-accent-glass-015) !important;
  }

  button:active {
    background-color: var(--wui-color-accent-glass-020) !important;
  }
`;
var __decorate$21 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiNoticeCard = class WuiNoticeCard2 extends i$2 {
  constructor() {
    super(...arguments);
    this.label = "";
    this.description = "";
    this.icon = "wallet";
  }
  render() {
    return x`
      <button>
        <wui-flex gap="m" alignItems="center" justifyContent="space-between">
          <wui-icon-box
            size="lg"
            iconcolor="accent-100"
            backgroundcolor="accent-100"
            icon=${this.icon}
            background="transparent"
          ></wui-icon-box>

          <wui-flex flexDirection="column" gap="3xs">
            <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
            <wui-text variant="small-400" color="fg-200">${this.description}</wui-text>
          </wui-flex>

          <wui-icon size="md" color="fg-200" name="chevronRight"></wui-icon>
        </wui-flex>
      </button>
    `;
  }
};
WuiNoticeCard.styles = [resetStyles, elementStyles, styles$1r];
__decorate$21([
  n$2()
], WuiNoticeCard.prototype, "label", void 0);
__decorate$21([
  n$2()
], WuiNoticeCard.prototype, "description", void 0);
__decorate$21([
  n$2()
], WuiNoticeCard.prototype, "icon", void 0);
WuiNoticeCard = __decorate$21([
  customElement("wui-notice-card")
], WuiNoticeCard);
const styles$1q = i$5`
  button {
    height: auto;
    position: relative;
    flex-direction: column;
    gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  .overflowedContent {
    width: 100%;
    overflow: hidden;
  }

  .overflowedContent[data-active='false']:after {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, var(--wui-color-bg-150), transparent);
    border-bottom-left-radius: var(--wui-border-radius-xs);
    border-bottom-right-radius: var(--wui-border-radius-xs);
  }

  .heightContent {
    max-height: 100px;
  }

  pre {
    text-align: left;
    white-space: pre-wrap;
    height: auto;
    overflow-x: auto;
    overflow-wrap: anywhere;
  }
`;
var __decorate$20 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const MAX_HEIGHT = 100;
let WuiListAccordion = class WuiListAccordion2 extends i$2 {
  constructor() {
    super(...arguments);
    this.textTitle = "";
    this.overflowedContent = "";
    this.toggled = false;
    this.enableAccordion = false;
    this.scrollElement = void 0;
    this.scrollHeightElement = 0;
  }
  updated(changedProperties) {
    super.updated(changedProperties);
    if (changedProperties.has("textTitle") || changedProperties.has("overflowedContent")) {
      setTimeout(() => {
        this.checkHeight();
      }, 1);
    }
  }
  checkHeight() {
    this.updateComplete.then(() => {
      const heightElement = this.shadowRoot?.querySelector(".heightContent");
      const textElement = this.shadowRoot?.querySelector(".textContent");
      if (heightElement && textElement) {
        this.scrollElement = heightElement;
        const scrollHeight = textElement?.scrollHeight;
        if (scrollHeight && scrollHeight > MAX_HEIGHT) {
          this.enableAccordion = true;
          this.scrollHeightElement = scrollHeight;
          this.requestUpdate();
        }
      }
    });
  }
  render() {
    return x`
      <button ontouchstart @click=${() => this.onClick()}>
        <wui-flex justifyContent="space-between" alignItems="center">
          <wui-text variant="paragraph-500" color="fg-100">${this.textTitle}</wui-text>
          ${this.chevronTemplate()}
        </wui-flex>
        <div
          data-active=${this.enableAccordion ? Boolean(this.toggled) : true}
          class="overflowedContent"
        >
          <div class="heightContent">
            <wui-text class="textContent" variant="paragraph-400" color="fg-200">
              <pre>${this.overflowedContent}</pre>
            </wui-text>
          </div>
        </div>
      </button>
    `;
  }
  onClick() {
    const icon = this.shadowRoot?.querySelector("wui-icon");
    if (this.enableAccordion) {
      this.toggled = !this.toggled;
      this.requestUpdate();
      if (this.scrollElement) {
        this.scrollElement.animate([
          { maxHeight: this.toggled ? `${MAX_HEIGHT}px` : `${this.scrollHeightElement}px` },
          { maxHeight: this.toggled ? `${this.scrollHeightElement}px` : `${MAX_HEIGHT}px` }
        ], {
          duration: 300,
          fill: "forwards",
          easing: "ease"
        });
      }
      if (icon) {
        icon.animate([
          { transform: this.toggled ? `rotate(0deg)` : `rotate(180deg)` },
          { transform: this.toggled ? `rotate(180deg)` : `rotate(0deg)` }
        ], {
          duration: 300,
          fill: "forwards",
          easing: "ease"
        });
      }
    }
  }
  chevronTemplate() {
    if (this.enableAccordion) {
      return x` <wui-icon color="fg-100" size="sm" name="chevronBottom"></wui-icon>`;
    }
    return null;
  }
};
WuiListAccordion.styles = [resetStyles, elementStyles, styles$1q];
__decorate$20([
  n$2()
], WuiListAccordion.prototype, "textTitle", void 0);
__decorate$20([
  n$2()
], WuiListAccordion.prototype, "overflowedContent", void 0);
WuiListAccordion = __decorate$20([
  customElement("wui-list-accordion")
], WuiListAccordion);
const styles$1p = i$5`
  :host {
    display: flex;
    column-gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var __decorate$1$ = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListContent = class WuiListContent2 extends i$2 {
  constructor() {
    super(...arguments);
    this.imageSrc = void 0;
    this.textTitle = "";
    this.textValue = void 0;
  }
  render() {
    return x`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color=${this.textValue ? "fg-200" : "fg-100"}>
          ${this.textTitle}
        </wui-text>
        ${this.templateContent()}
      </wui-flex>
    `;
  }
  templateContent() {
    if (this.imageSrc) {
      return x`<wui-image src=${this.imageSrc} alt=${this.textTitle}></wui-image>`;
    } else if (this.textValue) {
      return x` <wui-text variant="paragraph-400" color="fg-100"> ${this.textValue} </wui-text>`;
    }
    return x`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiListContent.styles = [resetStyles, elementStyles, styles$1p];
__decorate$1$([
  n$2()
], WuiListContent.prototype, "imageSrc", void 0);
__decorate$1$([
  n$2()
], WuiListContent.prototype, "textTitle", void 0);
__decorate$1$([
  n$2()
], WuiListContent.prototype, "textValue", void 0);
WuiListContent = __decorate$1$([
  customElement("wui-list-content")
], WuiListContent);
const styles$1o = i$5`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-md);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  button[data-transparent='true'] {
    pointer-events: none;
    background-color: transparent;
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  button:active {
    background-color: var(--wui-color-gray-glass-005);
  }

  wui-image {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    border-radius: 100%;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-002);
    opacity: 0.5;
    cursor: not-allowed;
  }

  button:disabled > wui-tag {
    background-color: var(--wui-color-gray-glass-010);
    color: var(--wui-color-fg-300);
  }
`;
var __decorate$1_ = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListNetwork = class WuiListNetwork2 extends i$2 {
  constructor() {
    super(...arguments);
    this.imageSrc = "";
    this.name = "";
    this.disabled = false;
    this.selected = false;
    this.transparent = false;
  }
  render() {
    return x`
      <button data-transparent=${this.transparent} ?disabled=${this.disabled} ontouchstart>
        <wui-flex gap="s" alignItems="center">
          ${this.templateNetworkImage()}
          <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text></wui-flex
        >
        ${this.checkmarkTemplate()}
      </button>
    `;
  }
  checkmarkTemplate() {
    if (this.selected) {
      return x`<wui-icon size="sm" color="accent-100" name="checkmarkBold"></wui-icon>`;
    }
    return null;
  }
  templateNetworkImage() {
    if (this.imageSrc) {
      return x`<wui-image size="sm" src=${this.imageSrc} name=${this.name}></wui-image>`;
    }
    if (!this.imageSrc) {
      return x`<wui-network-image
        ?round=${true}
        size="md"
        name=${this.name}
      ></wui-network-image>`;
    }
    return null;
  }
};
WuiListNetwork.styles = [resetStyles, elementStyles, styles$1o];
__decorate$1_([
  n$2()
], WuiListNetwork.prototype, "imageSrc", void 0);
__decorate$1_([
  n$2()
], WuiListNetwork.prototype, "name", void 0);
__decorate$1_([
  n$2({ type: Boolean })
], WuiListNetwork.prototype, "disabled", void 0);
__decorate$1_([
  n$2({ type: Boolean })
], WuiListNetwork.prototype, "selected", void 0);
__decorate$1_([
  n$2({ type: Boolean })
], WuiListNetwork.prototype, "transparent", void 0);
WuiListNetwork = __decorate$1_([
  customElement("wui-list-network")
], WuiListNetwork);
const styles$1n = i$5`
  :host {
    display: flex;
    flex-direction: column;
    gap: var(--wui-spacing-l);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;
var __decorate$1Z = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListWalletTransaction = class WuiListWalletTransaction2 extends i$2 {
  constructor() {
    super(...arguments);
    this.amount = "";
    this.networkCurreny = "";
    this.networkImageUrl = "";
    this.receiverAddress = "";
    this.addressExplorerUrl = "";
  }
  render() {
    return x`
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">Sending</wui-text>
        <wui-flex gap="xs" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100">
            ${this.amount} ${this.networkCurreny}
          </wui-text>
          ${this.templateNetworkVisual()}
        </wui-flex>
      </wui-flex>
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">To</wui-text>
        <wui-chip
          icon="externalLink"
          variant="shadeSmall"
          href=${this.addressExplorerUrl}
          title=${this.receiverAddress}
        ></wui-chip>
      </wui-flex>
    `;
  }
  templateNetworkVisual() {
    if (this.networkImageUrl) {
      return x`<wui-image src=${this.networkImageUrl} alt="Network Image"></wui-image>`;
    }
    return x`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiListWalletTransaction.styles = [resetStyles, elementStyles, styles$1n];
__decorate$1Z([
  n$2()
], WuiListWalletTransaction.prototype, "amount", void 0);
__decorate$1Z([
  n$2()
], WuiListWalletTransaction.prototype, "networkCurreny", void 0);
__decorate$1Z([
  n$2()
], WuiListWalletTransaction.prototype, "networkImageUrl", void 0);
__decorate$1Z([
  n$2()
], WuiListWalletTransaction.prototype, "receiverAddress", void 0);
__decorate$1Z([
  n$2()
], WuiListWalletTransaction.prototype, "addressExplorerUrl", void 0);
WuiListWalletTransaction = __decorate$1Z([
  customElement("wui-list-wallet-transaction")
], WuiListWalletTransaction);
const styles$1m = i$5`
  button {
    display: flex;
    gap: var(--wui-spacing-3xs);
    align-items: center;
    padding: 6.25px var(--wui-spacing-xs) 7.25px var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-090);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-060);
    transition: background-color var(--wui-duration-md) var(--wui-ease-inout-power-1);
    will-change: background-color;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-gray-glass-080);
    }

    button:active:enabled {
      background-color: var(--wui-color-gray-glass-060);
    }
  }
`;
var __decorate$1Y = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiPromo = class WuiPromo2 extends i$2 {
  constructor() {
    super(...arguments);
    this.text = "";
  }
  render() {
    return x`<button ontouchstart>
      <wui-text variant="small-600" color="bg-100">${this.text}</wui-text>
      <wui-icon color="bg-100" size="xs" name="arrowRight"></wui-icon>
    </button>`;
  }
};
WuiPromo.styles = [resetStyles, elementStyles, styles$1m];
__decorate$1Y([
  n$2()
], WuiPromo.prototype, "text", void 0);
WuiPromo = __decorate$1Y([
  customElement("wui-promo")
], WuiPromo);
const styles$1l = i$5`
  span {
    font-weight: 500;
    font-size: 40px;
    color: var(--wui-color-fg-100);
    line-height: 130%; /* 52px */
    letter-spacing: -1.6px;
    text-align: center;
  }

  .pennies {
    color: var(--wui-color-fg-200);
  }
`;
var __decorate$1X = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiBalance = class WuiBalance2 extends i$2 {
  constructor() {
    super(...arguments);
    this.dollars = "0";
    this.pennies = "00";
  }
  render() {
    return x`<span>$${this.dollars}<span class="pennies">.${this.pennies}</span></span>`;
  }
};
WuiBalance.styles = [resetStyles, styles$1l];
__decorate$1X([
  n$2()
], WuiBalance.prototype, "dollars", void 0);
__decorate$1X([
  n$2()
], WuiBalance.prototype, "pennies", void 0);
WuiBalance = __decorate$1X([
  customElement("wui-balance")
], WuiBalance);
const styles$1k = i$5`
  button {
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-xs) var(--wui-spacing-s) var(--wui-spacing-xs) var(--wui-spacing-xs);
    position: relative;
  }

  wui-avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 0;
    outline: 3px solid var(--wui-color-gray-glass-005);
  }

  wui-icon-box,
  wui-image {
    width: 16px;
    height: 16px;
    border-radius: var(--wui-border-radius-3xl);
    position: absolute;
    left: 26px;
    top: 24px;
  }

  wui-image {
    outline: 2px solid var(--wui-color-bg-125);
  }

  wui-icon-box {
    outline: 2px solid var(--wui-color-bg-200);
    background-color: var(--wui-color-bg-250);
  }
`;
var __decorate$1W = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiProfileButton = class WuiProfileButton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.networkSrc = void 0;
    this.avatarSrc = void 0;
    this.profileName = "";
    this.address = "";
    this.icon = "chevronBottom";
  }
  render() {
    return x`<button ontouchstart data-testid="wui-profile-button">
      <wui-flex gap="xs" alignItems="center">
        <wui-avatar
          .imageSrc=${this.avatarSrc}
          alt=${this.address}
          address=${this.address}
        ></wui-avatar>
        ${this.networkImageTemplate()}
        <wui-flex gap="xs" alignItems="center">
          <wui-text variant="large-600" color="fg-100">
            ${UiHelperUtil.getTruncateString({
      string: this.profileName || this.address,
      charsStart: this.profileName ? 18 : 4,
      charsEnd: this.profileName ? 0 : 4,
      truncate: this.profileName ? "end" : "middle"
    })}
          </wui-text>
          <wui-icon size="sm" color="fg-200" name=${this.icon}></wui-icon>
        </wui-flex>
      </wui-flex>
    </button>`;
  }
  networkImageTemplate() {
    if (this.networkSrc) {
      return x`<wui-image src=${this.networkSrc}></wui-image>`;
    }
    return x`
      <wui-icon-box
        size="xxs"
        iconColor="fg-200"
        backgroundColor="bg-100"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `;
  }
};
WuiProfileButton.styles = [resetStyles, elementStyles, styles$1k];
__decorate$1W([
  n$2()
], WuiProfileButton.prototype, "networkSrc", void 0);
__decorate$1W([
  n$2()
], WuiProfileButton.prototype, "avatarSrc", void 0);
__decorate$1W([
  n$2()
], WuiProfileButton.prototype, "profileName", void 0);
__decorate$1W([
  n$2()
], WuiProfileButton.prototype, "address", void 0);
__decorate$1W([
  n$2()
], WuiProfileButton.prototype, "icon", void 0);
WuiProfileButton = __decorate$1W([
  customElement("wui-profile-button")
], WuiProfileButton);
const styles$1j = i$5`
  button {
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-xs) var(--wui-spacing-s) var(--wui-spacing-xs) var(--wui-spacing-xs);
    position: relative;
  }

  wui-avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 0;
    outline: 3px solid var(--wui-color-gray-glass-005);
  }

  wui-icon-box,
  wui-image {
    width: 16px;
    height: 16px;
    border-radius: var(--wui-border-radius-3xl);
    position: absolute;
    left: 26px;
    top: 24px;
  }

  wui-image {
    outline: 2px solid var(--wui-color-bg-125);
  }

  wui-icon-box {
    outline: 2px solid var(--wui-color-bg-200);
    background-color: var(--wui-color-bg-250);
  }
`;
var __decorate$1V = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiProfileButtonV2 = class WuiProfileButtonV22 extends i$2 {
  constructor() {
    super(...arguments);
    this.avatarSrc = void 0;
    this.profileName = "";
    this.address = "";
    this.icon = "mail";
    this.connectedConnector = StorageUtil.getConnectedConnector();
    this.shouldShowIcon = this.connectedConnector === "AUTH";
  }
  render() {
    return x`<button ontouchstart data-testid="wui-profile-button" @click=${this.handleClick}>
      <wui-flex gap="xs" alignItems="center">
        <wui-avatar
          .imageSrc=${this.avatarSrc}
          alt=${this.address}
          address=${this.address}
        ></wui-avatar>
        ${this.shouldShowIcon ? this.getIconTemplate(this.icon) : ""}
        <wui-flex gap="xs" alignItems="center">
          <wui-text variant="large-600" color="fg-100">
            ${UiHelperUtil.getTruncateString({
      string: this.profileName || this.address,
      charsStart: this.profileName ? 18 : 4,
      charsEnd: this.profileName ? 0 : 4,
      truncate: this.profileName ? "end" : "middle"
    })}
          </wui-text>
          <wui-icon size="sm" color="fg-200" name="copy" id="copy-address"></wui-icon>
        </wui-flex>
      </wui-flex>
    </button>`;
  }
  handleClick(event) {
    if (event.target instanceof HTMLElement && event.target.id === "copy-address") {
      this.onCopyClick?.(event);
      return;
    }
    this.onProfileClick?.(event);
  }
  getIconTemplate(icon) {
    return x`
      <wui-icon-box
        size="xxs"
        iconColor="fg-200"
        backgroundColor="bg-100"
        icon="${icon || "networkPlaceholder"}"
      ></wui-icon-box>
    `;
  }
};
WuiProfileButtonV2.styles = [resetStyles, elementStyles, styles$1j];
__decorate$1V([
  n$2()
], WuiProfileButtonV2.prototype, "avatarSrc", void 0);
__decorate$1V([
  n$2()
], WuiProfileButtonV2.prototype, "profileName", void 0);
__decorate$1V([
  n$2()
], WuiProfileButtonV2.prototype, "address", void 0);
__decorate$1V([
  n$2()
], WuiProfileButtonV2.prototype, "icon", void 0);
__decorate$1V([
  n$2()
], WuiProfileButtonV2.prototype, "onProfileClick", void 0);
__decorate$1V([
  n$2()
], WuiProfileButtonV2.prototype, "onCopyClick", void 0);
WuiProfileButtonV2 = __decorate$1V([
  customElement("wui-profile-button-v2")
], WuiProfileButtonV2);
const styles$1i = i$5`
  button {
    border: none;
    border-radius: var(--wui-border-radius-3xl);
  }

  button[data-variant='main'] {
    background-color: var(--wui-color-accent-100);
    color: var(--wui-color-inverse-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='accent'] {
    background-color: var(--wui-color-accent-glass-010);
    color: var(--wui-color-accent-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  button[data-variant='gray'] {
    background-color: transparent;
    color: var(--wui-color-fg-200);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-variant='shade'] {
    background-color: transparent;
    color: var(--wui-color-accent-100);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  button[data-size='sm'] {
    height: 32px;
    padding: 0 var(--wui-spacing-s);
  }

  button[data-size='md'] {
    height: 40px;
    padding: 0 var(--wui-spacing-l);
  }

  button[data-size='sm'] > wui-image {
    width: 16px;
    height: 16px;
  }

  button[data-size='md'] > wui-image {
    width: 24px;
    height: 24px;
  }

  button[data-size='sm'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  button[data-size='md'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  button.disabled > wui-icon,
  button.disabled > wui-image {
    filter: grayscale(1);
  }

  button[data-variant='main'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  button[data-variant='shade'] > wui-image,
  button[data-variant='gray'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  @media (hover: hover) and (pointer: fine) {
    button[data-variant='main']:focus-visible {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='main']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='main']:active:enabled {
      background-color: var(--wui-color-accent-080);
    }

    button[data-variant='accent']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }

    button[data-variant='accent']:active:enabled {
      background-color: var(--wui-color-accent-glass-020);
    }

    button[data-variant='shade']:focus-visible,
    button[data-variant='gray']:focus-visible,
    button[data-variant='shade']:hover,
    button[data-variant='gray']:hover {
      background-color: var(--wui-color-gray-glass-002);
    }

    button[data-variant='gray']:active,
    button[data-variant='shade']:active {
      background-color: var(--wui-color-gray-glass-005);
    }
  }

  button.disabled {
    color: var(--wui-color-gray-glass-020);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    pointer-events: none;
  }
`;
var __decorate$1U = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiChipButton = class WuiChipButton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.variant = "accent";
    this.imageSrc = "";
    this.disabled = false;
    this.icon = "externalLink";
    this.size = "md";
    this.text = "";
  }
  render() {
    const textVariant = this.size === "sm" ? "small-600" : "paragraph-600";
    return x`
      <button
        class=${this.disabled ? "disabled" : ""}
        data-variant=${this.variant}
        data-size=${this.size}
      >
        ${this.imageSrc ? x`<wui-image src=${this.imageSrc}></wui-image>` : null}
        <wui-text variant=${textVariant} color="inherit"> ${this.text} </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </button>
    `;
  }
};
WuiChipButton.styles = [resetStyles, elementStyles, styles$1i];
__decorate$1U([
  n$2()
], WuiChipButton.prototype, "variant", void 0);
__decorate$1U([
  n$2()
], WuiChipButton.prototype, "imageSrc", void 0);
__decorate$1U([
  n$2({ type: Boolean })
], WuiChipButton.prototype, "disabled", void 0);
__decorate$1U([
  n$2()
], WuiChipButton.prototype, "icon", void 0);
__decorate$1U([
  n$2()
], WuiChipButton.prototype, "size", void 0);
__decorate$1U([
  n$2()
], WuiChipButton.prototype, "text", void 0);
WuiChipButton = __decorate$1U([
  customElement("wui-chip-button")
], WuiChipButton);
const styles$1h = i$5`
  button {
    display: flex;
    gap: var(--wui-spacing-xl);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    padding: var(--wui-spacing-m) var(--wui-spacing-s);
  }

  wui-text {
    width: 100%;
  }

  wui-flex {
    width: auto;
  }

  .network-icon {
    width: var(--wui-spacing-2l);
    height: var(--wui-spacing-2l);
    border-radius: calc(var(--wui-spacing-2l) / 2);
    overflow: hidden;
    box-shadow:
      0 0 0 3px var(--wui-color-gray-glass-002),
      0 0 0 3px var(--wui-color-modal-bg);
  }
`;
var __decorate$1T = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiCompatibleNetwork = class WuiCompatibleNetwork2 extends i$2 {
  constructor() {
    super(...arguments);
    this.networkImages = [""];
    this.text = "";
  }
  render() {
    return x`
      <button ontouchstart>
        <wui-text variant="small-400" color="fg-200">${this.text}</wui-text>
        <wui-flex gap="3xs" alignItems="center">
          ${this.networksTemplate()}
          <wui-icon name="chevronRight" size="sm" color="fg-200"></wui-icon>
        </wui-flex>
      </button>
    `;
  }
  networksTemplate() {
    const slicedNetworks = this.networkImages.slice(0, 5);
    return x` <wui-flex class="networks">
      ${slicedNetworks?.map((network) => x` <wui-flex class="network-icon"> <wui-image src=${network}></wui-image> </wui-flex>`)}
    </wui-flex>`;
  }
};
WuiCompatibleNetwork.styles = [resetStyles, elementStyles, styles$1h];
__decorate$1T([
  n$2({ type: Array })
], WuiCompatibleNetwork.prototype, "networkImages", void 0);
__decorate$1T([
  n$2()
], WuiCompatibleNetwork.prototype, "text", void 0);
WuiCompatibleNetwork = __decorate$1T([
  customElement("wui-compatible-network")
], WuiCompatibleNetwork);
const styles$1g = i$5`
  wui-flex {
    width: 100%;
    background-color: var(--wui-color-gray-glass-005);
    border-radius: var(--wui-border-radius-s);
    padding: var(--wui-spacing-1xs) var(--wui-spacing-s) var(--wui-spacing-1xs)
      var(--wui-spacing-1xs);
  }
`;
var __decorate$1S = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiBanner = class WuiBanner2 extends i$2 {
  constructor() {
    super(...arguments);
    this.icon = "externalLink";
    this.text = "";
  }
  render() {
    return x`
      <wui-flex gap="1xs" alignItems="center">
        <wui-icon-box
          size="sm"
          iconcolor="fg-200"
          backgroundcolor="fg-200"
          icon=${this.icon}
          background="transparent"
        ></wui-icon-box>
        <wui-text variant="small-400" color="fg-200">${this.text}</wui-text>
      </wui-flex>
    `;
  }
};
WuiBanner.styles = [resetStyles, elementStyles, styles$1g];
__decorate$1S([
  n$2()
], WuiBanner.prototype, "icon", void 0);
__decorate$1S([
  n$2()
], WuiBanner.prototype, "text", void 0);
WuiBanner = __decorate$1S([
  customElement("wui-banner")
], WuiBanner);
const styles$1f = i$5`
  wui-flex {
    width: 100%;
    background-color: var(--wui-color-gray-glass-005);
    border-radius: var(--wui-border-radius-m);
    padding: var(--wui-spacing-1xs) var(--wui-spacing-s) var(--wui-spacing-1xs)
      var(--wui-spacing-1xs);
  }
`;
var __decorate$1R = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiBannerImg = class WuiBannerImg2 extends i$2 {
  constructor() {
    super(...arguments);
    this.imageSrc = "";
    this.text = "";
    this.size = "";
  }
  render() {
    return x`
      <wui-flex gap="1xs" alignItems="center">
        <wui-avatar size=${this.size} imageSrc=${this.imageSrc}></wui-avatar>
        <wui-text variant="small-400" color="fg-200">${this.text}</wui-text>
      </wui-flex>
    `;
  }
};
WuiBannerImg.styles = [resetStyles, elementStyles, styles$1f];
__decorate$1R([
  n$2()
], WuiBannerImg.prototype, "imageSrc", void 0);
__decorate$1R([
  n$2()
], WuiBannerImg.prototype, "text", void 0);
__decorate$1R([
  n$2()
], WuiBannerImg.prototype, "size", void 0);
WuiBannerImg = __decorate$1R([
  customElement("wui-banner-img")
], WuiBannerImg);
const styles$1e = i$5`
  button {
    padding: 6.5px var(--wui-spacing-l) 6.5px var(--wui-spacing-xs);
    display: flex;
    justify-content: space-between;
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-color-gray-glass-002);
  }

  button[data-clickable='false'] {
    pointer-events: none;
    background-color: transparent;
  }

  wui-image,
  wui-icon {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
  }
`;
var __decorate$1Q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListToken = class WuiListToken2 extends i$2 {
  constructor() {
    super(...arguments);
    this.tokenName = "";
    this.tokenImageUrl = "";
    this.tokenValue = 0;
    this.tokenAmount = "0.0";
    this.tokenCurrency = "";
    this.clickable = false;
  }
  render() {
    return x`
      <button data-clickable=${String(this.clickable)} ontouchstart>
        <wui-flex gap="s" alignItems="center">
          ${this.visualTemplate()}
          <wui-flex flexDirection="column" justifyContent="spaceBetween">
            <wui-text variant="paragraph-500" color="fg-100">${this.tokenName}</wui-text>
            <wui-text variant="small-400" color="fg-200">
              ${UiHelperUtil.formatNumberToLocalString(this.tokenAmount, 4)} ${this.tokenCurrency}
            </wui-text>
          </wui-flex>
        </wui-flex>
        <wui-text variant="paragraph-500" color="fg-100">$${this.tokenValue.toFixed(2)}</wui-text>
      </button>
    `;
  }
  visualTemplate() {
    if (this.tokenName && this.tokenImageUrl) {
      return x`<wui-image alt=${this.tokenName} src=${this.tokenImageUrl}></wui-image>`;
    }
    return x`<wui-icon name="coinPlaceholder" color="fg-100"></wui-icon>`;
  }
};
WuiListToken.styles = [resetStyles, elementStyles, styles$1e];
__decorate$1Q([
  n$2()
], WuiListToken.prototype, "tokenName", void 0);
__decorate$1Q([
  n$2()
], WuiListToken.prototype, "tokenImageUrl", void 0);
__decorate$1Q([
  n$2({ type: Number })
], WuiListToken.prototype, "tokenValue", void 0);
__decorate$1Q([
  n$2()
], WuiListToken.prototype, "tokenAmount", void 0);
__decorate$1Q([
  n$2()
], WuiListToken.prototype, "tokenCurrency", void 0);
__decorate$1Q([
  n$2({ type: Boolean })
], WuiListToken.prototype, "clickable", void 0);
WuiListToken = __decorate$1Q([
  customElement("wui-list-token")
], WuiListToken);
const styles$1d = i$5`
  button {
    width: 100%;
    display: flex;
    gap: var(--wui-spacing-s);
    align-items: center;
    justify-content: flex-start;
    padding: var(--wui-spacing-s) var(--wui-spacing-m) var(--wui-spacing-s) var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon-box {
    width: var(--wui-spacing-2xl);
    height: var(--wui-spacing-2xl);
  }

  wui-flex {
    width: auto;
  }
`;
var __decorate$1P = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListDescription = class WuiListDescription2 extends i$2 {
  constructor() {
    super(...arguments);
    this.icon = "card";
    this.text = "";
    this.description = "";
    this.tag = void 0;
    this.iconBackgroundColor = "accent-100";
    this.iconColor = "accent-100";
    this.disabled = false;
  }
  render() {
    return x`
      <button ontouchstart ?disabled=${this.disabled}>
        <wui-icon-box
          iconColor=${this.iconColor}
          backgroundColor=${this.iconBackgroundColor}
          size="inherit"
          icon=${this.icon}
          iconSize="md"
        ></wui-icon-box>
        <wui-flex flexDirection="column" justifyContent="spaceBetween">
          ${this.titleTemplate()}
          <wui-text variant="small-400" color="fg-200"> ${this.description}</wui-text></wui-flex
        >
      </button>
    `;
  }
  titleTemplate() {
    if (this.tag) {
      return x` <wui-flex alignItems="center" gap="xxs"
        ><wui-text variant="paragraph-500" color="fg-100">${this.text}</wui-text
        ><wui-tag tagType="main" size="md">${this.tag}</wui-tag>
      </wui-flex>`;
    }
    return x`<wui-text variant="paragraph-500" color="fg-100">${this.text}</wui-text>`;
  }
};
WuiListDescription.styles = [resetStyles, elementStyles, styles$1d];
__decorate$1P([
  n$2()
], WuiListDescription.prototype, "icon", void 0);
__decorate$1P([
  n$2()
], WuiListDescription.prototype, "text", void 0);
__decorate$1P([
  n$2()
], WuiListDescription.prototype, "description", void 0);
__decorate$1P([
  n$2()
], WuiListDescription.prototype, "tag", void 0);
__decorate$1P([
  n$2()
], WuiListDescription.prototype, "iconBackgroundColor", void 0);
__decorate$1P([
  n$2()
], WuiListDescription.prototype, "iconColor", void 0);
__decorate$1P([
  n$2({ type: Boolean })
], WuiListDescription.prototype, "disabled", void 0);
WuiListDescription = __decorate$1P([
  customElement("wui-list-description")
], WuiListDescription);
const styles$1c = i$5`
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    background: transparent;
    width: 100%;
    height: auto;
    font-family: var(--wui-font-family);
    color: var(--wui-color-fg-100);

    font-feature-settings: 'case' on;
    font-size: 32px;
    font-weight: var(--wui-font-weight-light);
    caret-color: var(--wui-color-accent-100);
    line-height: 130%;
    letter-spacing: -1.28px;
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }
`;
const specialCharactersRegex = /[.*+?^${}()|[\]\\]/gu;
const numbersRegex = /[0-9,.]/u;
var __decorate$1O = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiInputAmount = class WuiInputAmount2 extends i$2 {
  constructor() {
    super(...arguments);
    this.inputElementRef = e();
    this.disabled = false;
    this.value = "";
    this.placeholder = "0";
  }
  render() {
    if (this.inputElementRef?.value && this.value) {
      this.inputElementRef.value.value = this.value;
    }
    return x`<input
      ${n2(this.inputElementRef)}
      type="text"
      inputmode="decimal"
      pattern="[0-9,.]*"
      placeholder=${this.placeholder}
      ?disabled=${this.disabled}
      autofocus
      value=${this.value ?? ""}
      @input=${this.dispatchInputChangeEvent.bind(this)}
    /> `;
  }
  dispatchInputChangeEvent(e2) {
    const inputChar = e2.data;
    if (inputChar && this.inputElementRef?.value) {
      if (inputChar === ",") {
        const inputValue = this.inputElementRef.value.value.replace(",", ".");
        this.inputElementRef.value.value = inputValue;
        this.value = `${this.value}${inputValue}`;
      } else if (!numbersRegex.test(inputChar)) {
        this.inputElementRef.value.value = this.value.replace(new RegExp(inputChar.replace(specialCharactersRegex, "\\$&"), "gu"), "");
      }
    }
    this.dispatchEvent(new CustomEvent("inputChange", {
      detail: this.inputElementRef.value?.value,
      bubbles: true,
      composed: true
    }));
  }
};
WuiInputAmount.styles = [resetStyles, elementStyles, styles$1c];
__decorate$1O([
  n$2({ type: Boolean })
], WuiInputAmount.prototype, "disabled", void 0);
__decorate$1O([
  n$2({ type: String })
], WuiInputAmount.prototype, "value", void 0);
__decorate$1O([
  n$2({ type: String })
], WuiInputAmount.prototype, "placeholder", void 0);
WuiInputAmount = __decorate$1O([
  customElement("wui-input-amount")
], WuiInputAmount);
const styles$1b = i$5`
  :host {
    display: flex;
    gap: var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-xs) var(--wui-spacing-2xs)
      var(--wui-spacing-s);
    align-items: center;
  }

  wui-avatar,
  wui-icon,
  wui-image {
    width: 32px;
    height: 32px;
    border: 1px solid var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-002);
  }
`;
var __decorate$1N = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiPreviewItem = class WuiPreviewItem2 extends i$2 {
  constructor() {
    super(...arguments);
    this.text = "";
    this.address = "";
    this.isAddress = false;
  }
  render() {
    return x`<wui-text variant="large-500" color="fg-100">${this.text}</wui-text>
      ${this.imageTemplate()}`;
  }
  imageTemplate() {
    if (this.isAddress) {
      return x`<wui-avatar address=${this.address} .imageSrc=${this.imageSrc}></wui-avatar>`;
    } else if (this.imageSrc) {
      return x`<wui-image src=${this.imageSrc}></wui-image>`;
    }
    return x`<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
  }
};
WuiPreviewItem.styles = [resetStyles, elementStyles, styles$1b];
__decorate$1N([
  n$2()
], WuiPreviewItem.prototype, "text", void 0);
__decorate$1N([
  n$2()
], WuiPreviewItem.prototype, "address", void 0);
__decorate$1N([
  n$2()
], WuiPreviewItem.prototype, "imageSrc", void 0);
__decorate$1N([
  n$2({ type: Boolean })
], WuiPreviewItem.prototype, "isAddress", void 0);
WuiPreviewItem = __decorate$1N([
  customElement("wui-preview-item")
], WuiPreviewItem);
const styles$1a = i$5`
  button {
    padding: 6.5px var(--wui-spacing-l) 6.5px var(--wui-spacing-xs);
    display: flex;
    justify-content: space-between;
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-color-gray-glass-002);
  }

  button[data-clickable='false'] {
    pointer-events: none;
    background-color: transparent;
  }

  wui-image {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-avatar {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    box-shadow: 0 0 0 0;
  }
  .address {
    color: var(--wui-color-fg-base-100);
  }
  .address-description {
    text-transform: capitalize;
    color: var(--wui-color-fg-base-200);
  }

  wui-icon-box {
    position: relative;
    right: 15px;
    top: 15px;
    border: 2px solid var(--wui-color-bg-150);
    background-color: var(--wui-color-bg-125);
  }
`;
var __decorate$1M = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListAccount = class WuiListAccount2 extends i$2 {
  constructor() {
    super(...arguments);
    this.accountAddress = "";
    this.accountType = "";
    this.connectedConnector = StorageUtil.getConnectedConnector();
    this.labels = AccountController.state.addressLabels;
    this.caipNetwork = NetworkController.state.caipNetwork;
    this.socialProvider = StorageUtil.getConnectedSocialProvider();
    this.balance = 0;
    this.fetchingBalance = true;
    this.shouldShowIcon = false;
    this.selected = false;
  }
  connectedCallback() {
    super.connectedCallback();
    BlockchainApiController.getBalance(this.accountAddress, this.caipNetwork?.id).then((response) => {
      let total = this.balance;
      if (response.balances.length > 0) {
        total = response.balances.reduce((acc, balance) => acc + (balance?.value || 0), 0);
      }
      this.balance = total;
      this.fetchingBalance = false;
      this.requestUpdate();
    });
  }
  render() {
    const label = this.getLabel();
    this.shouldShowIcon = this.connectedConnector === "AUTH";
    return x`
      <wui-flex
        flexDirection="row"
        justifyContent="space-between"
        .padding=${["0", "0", "s", "1xs"]}
      >
        <wui-flex gap="md" alignItems="center">
          <wui-avatar address=${this.accountAddress}></wui-avatar>
          ${this.shouldShowIcon ? x`<wui-icon-box
                size="sm"
                iconcolor="fg-200"
                backgroundcolor="fg-300"
                icon=${this.accountType === W3mFrameRpcConstants.ACCOUNT_TYPES.EOA ? this.socialProvider ?? "mail" : "lightbulb"}
                background="fg-300"
              ></wui-icon-box>` : x`<wui-flex .padding="${["0", "0", "0", "s"]}"></wui-flex>`}
          <wui-flex flexDirection="column">
            <wui-text class="address" variant="paragraph-500" color="fg-100"
              >${UiHelperUtil.getTruncateString({
      string: this.accountAddress,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}</wui-text
            >
            <wui-text class="address-description" variant="small-400">${label}</wui-text></wui-flex
          >
        </wui-flex>
        <wui-flex gap="s" alignItems="center">
          ${this.fetchingBalance ? x`<wui-loading-spinner size="sm" color="accent-100"></wui-loading-spinner>` : x` <wui-text variant="small-400">$${this.balance.toFixed(2)}</wui-text>`}
          <slot name="action"></slot>
        </wui-flex>
      </wui-flex>
    `;
  }
  getLabel() {
    let label = this.labels?.get(this.accountAddress);
    if (!label && this.connectedConnector === "AUTH") {
      label = `${this.accountType === "eoa" ? this.socialProvider ?? "Email" : "Smart"} Account`;
    } else if (!label && this.connectedConnector === "INJECTED" || this.connectedConnector === "ANNOUNCED") {
      label = `Injected Account`;
    } else if (!label) {
      label = "EOA";
    }
    return label;
  }
};
WuiListAccount.styles = [resetStyles, elementStyles, styles$1a];
__decorate$1M([
  n$2()
], WuiListAccount.prototype, "accountAddress", void 0);
__decorate$1M([
  n$2()
], WuiListAccount.prototype, "accountType", void 0);
__decorate$1M([
  n$2({ type: Boolean })
], WuiListAccount.prototype, "selected", void 0);
__decorate$1M([
  n$2({ type: Function })
], WuiListAccount.prototype, "onSelect", void 0);
WuiListAccount = __decorate$1M([
  customElement("wui-list-account")
], WuiListAccount);
const styles$19 = i$5`
  :host {
    position: relative;
  }

  button {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 48px;
    width: 100%;
    background-color: var(--wui-color-accent-glass-010);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-color-accent-glass-010);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  wui-tooltip {
    padding: 7px var(--wui-spacing-s) 8px var(--wui-spacing-s);
    position: absolute;
    top: -8px;
    left: 50%;
    transform: translate(-50%, -100%);
    opacity: 0;
    display: none;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }

    button:active:enabled {
      background-color: var(--wui-color-accent-glass-020);
    }
  }
`;
var __decorate$1L = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiIconButton = class WuiIconButton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.text = "";
    this.icon = "card";
  }
  render() {
    return x`<button>
      <wui-icon color="accent-100" name=${this.icon} size="lg"></wui-icon>
    </button>`;
  }
};
WuiIconButton.styles = [resetStyles, elementStyles, styles$19];
__decorate$1L([
  n$2()
], WuiIconButton.prototype, "text", void 0);
__decorate$1L([
  n$2()
], WuiIconButton.prototype, "icon", void 0);
WuiIconButton = __decorate$1L([
  customElement("wui-icon-button")
], WuiIconButton);
const styles$18 = i$5`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 16.5px var(--wui-spacing-l) 16.5px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
    justify-content: center;
    align-items: center;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }
`;
var __decorate$1K = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListButton = class WuiListButton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.text = "";
    this.disabled = false;
  }
  render() {
    return x`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-text align="center" variant="paragraph-500" color="inherit">${this.text}</wui-text>
      </button>
    `;
  }
};
WuiListButton.styles = [resetStyles, elementStyles, styles$18];
__decorate$1K([
  n$2()
], WuiListButton.prototype, "text", void 0);
__decorate$1K([
  n$2({ type: Boolean })
], WuiListButton.prototype, "disabled", void 0);
WuiListButton = __decorate$1K([
  customElement("wui-list-button")
], WuiListButton);
const styles$17 = i$5`
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    justify-content: flex-start;
    background-color: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  wui-text {
    text-transform: capitalize;
  }

  wui-text[data-align='left'] {
    display: flex;
    flex: 1;
  }

  wui-text[data-align='center'] {
    display: flex;
    flex: 1;
    justify-content: center;
  }

  .invisible {
    opacity: 0;
    pointer-events: none;
  }

  button:disabled {
    background-color: var(--wui-color-gray-glass-015);
    color: var(--wui-color-gray-glass-015);
  }
`;
var __decorate$1J = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiListSocial = class WuiListSocial2 extends i$2 {
  constructor() {
    super(...arguments);
    this.logo = "google";
    this.name = "Continue with google";
    this.align = "left";
    this.disabled = false;
  }
  render() {
    return x`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-logo logo=${this.logo}></wui-logo>
        <wui-text
          data-align=${this.align}
          variant="paragraph-500"
          color="inherit"
          align=${this.align}
          >${this.name}</wui-text
        >
        ${this.templatePlacement()}
      </button>
    `;
  }
  templatePlacement() {
    if (this.align === "center") {
      return x` <wui-logo class="invisible" logo=${this.logo}></wui-logo>`;
    }
    return null;
  }
};
WuiListSocial.styles = [resetStyles, elementStyles, styles$17];
__decorate$1J([
  n$2()
], WuiListSocial.prototype, "logo", void 0);
__decorate$1J([
  n$2()
], WuiListSocial.prototype, "name", void 0);
__decorate$1J([
  n$2()
], WuiListSocial.prototype, "align", void 0);
__decorate$1J([
  n$2({ type: Boolean })
], WuiListSocial.prototype, "disabled", void 0);
WuiListSocial = __decorate$1J([
  customElement("wui-list-social")
], WuiListSocial);
const styles$16 = i$5`
  button {
    display: block;
    display: flex;
    align-items: center;
    padding: var(--wui-spacing-xxs);
    gap: var(--wui-spacing-xxs);
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-md);
    border-radius: var(--wui-border-radius-xxs);
  }

  wui-image {
    border-radius: 100%;
    width: var(--wui-spacing-xl);
    height: var(--wui-spacing-xl);
  }

  wui-icon-box {
    width: var(--wui-spacing-xl);
    height: var(--wui-spacing-xl);
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  button:active {
    background-color: var(--wui-color-gray-glass-005);
  }
`;
var __decorate$1I = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiSelect = class WuiSelect2 extends i$2 {
  constructor() {
    super(...arguments);
    this.imageSrc = "";
  }
  render() {
    return x`<button>
      ${this.imageTemplate()}
      <wui-icon size="xs" color="fg-200" name="chevronBottom"></wui-icon>
    </button>`;
  }
  imageTemplate() {
    if (this.imageSrc) {
      return x`<wui-image src=${this.imageSrc} alt="select visual"></wui-image>`;
    }
    return x`<wui-icon-box
      size="xxs"
      iconColor="fg-200"
      backgroundColor="fg-100"
      background="opaque"
      icon="networkPlaceholder"
    ></wui-icon-box>`;
  }
};
WuiSelect.styles = [resetStyles, elementStyles, colorStyles, styles$16];
__decorate$1I([
  n$2()
], WuiSelect.prototype, "imageSrc", void 0);
WuiSelect = __decorate$1I([
  customElement("wui-select")
], WuiSelect);
const styles$15 = i$5`
  :host {
    display: grid;
    width: inherit;
    height: inherit;
  }
`;
var __decorate$1H = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiGrid = class WuiGrid2 extends i$2 {
  render() {
    this.style.cssText = `
      grid-template-rows: ${this.gridTemplateRows};
      grid-template-columns: ${this.gridTemplateColumns};
      justify-items: ${this.justifyItems};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      align-content: ${this.alignContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
    return x`<slot></slot>`;
  }
};
WuiGrid.styles = [resetStyles, styles$15];
__decorate$1H([
  n$2()
], WuiGrid.prototype, "gridTemplateRows", void 0);
__decorate$1H([
  n$2()
], WuiGrid.prototype, "gridTemplateColumns", void 0);
__decorate$1H([
  n$2()
], WuiGrid.prototype, "justifyItems", void 0);
__decorate$1H([
  n$2()
], WuiGrid.prototype, "alignItems", void 0);
__decorate$1H([
  n$2()
], WuiGrid.prototype, "justifyContent", void 0);
__decorate$1H([
  n$2()
], WuiGrid.prototype, "alignContent", void 0);
__decorate$1H([
  n$2()
], WuiGrid.prototype, "columnGap", void 0);
__decorate$1H([
  n$2()
], WuiGrid.prototype, "rowGap", void 0);
__decorate$1H([
  n$2()
], WuiGrid.prototype, "gap", void 0);
__decorate$1H([
  n$2()
], WuiGrid.prototype, "padding", void 0);
__decorate$1H([
  n$2()
], WuiGrid.prototype, "margin", void 0);
WuiGrid = __decorate$1H([
  customElement("wui-grid")
], WuiGrid);
const styles$14 = i$5`
  :host {
    position: relative;
    display: flex;
    width: 100%;
    height: 1px;
    background-color: var(--wui-color-gray-glass-005);
    justify-content: center;
    align-items: center;
  }

  :host > wui-text {
    position: absolute;
    padding: 0px 10px;
    background-color: var(--wui-color-modal-bg);
  }
`;
var __decorate$1G = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiSeparator = class WuiSeparator2 extends i$2 {
  constructor() {
    super(...arguments);
    this.text = "";
  }
  render() {
    return x`${this.template()}`;
  }
  template() {
    if (this.text) {
      return x`<wui-text variant="small-500" color="fg-200">${this.text}</wui-text>`;
    }
    return null;
  }
};
WuiSeparator.styles = [resetStyles, styles$14];
__decorate$1G([
  n$2()
], WuiSeparator.prototype, "text", void 0);
WuiSeparator = __decorate$1G([
  customElement("wui-separator")
], WuiSeparator);
const MathUtil = {
  interpolate(inputRange, outputRange, value) {
    if (inputRange.length !== 2 || outputRange.length !== 2) {
      throw new Error("inputRange and outputRange must be an array of length 2");
    }
    const originalRangeMin = inputRange[0] || 0;
    const originalRangeMax = inputRange[1] || 0;
    const newRangeMin = outputRange[0] || 0;
    const newRangeMax = outputRange[1] || 0;
    if (value < originalRangeMin) {
      return newRangeMin;
    }
    if (value > originalRangeMax) {
      return newRangeMax;
    }
    return (newRangeMax - newRangeMin) / (originalRangeMax - originalRangeMin) * (value - originalRangeMin) + newRangeMin;
  }
};
const FLOAT_FIXED_VALUE = 3;
const plusTypes = ["receive", "deposit", "borrow", "claim"];
const minusTypes = ["withdraw", "repay", "burn"];
const TransactionUtil = {
  getMonthName(monthNumber) {
    const date = /* @__PURE__ */ new Date();
    date.setMonth(monthNumber);
    return date.toLocaleString("en-US", {
      month: "long"
    });
  },
  getTransactionGroupTitle(year, month) {
    const currentYear = DateUtil.getYear();
    const monthName = this.getMonthName(month);
    const isCurrentYear = year === currentYear;
    const groupTitle = isCurrentYear ? monthName : `${monthName} ${year}`;
    return groupTitle;
  },
  getTransactionImages(transfers) {
    const [transfer, secondTransfer] = transfers;
    const isAllNFT = Boolean(transfer) && transfers?.every((item) => Boolean(item.nft_info));
    const haveMultipleTransfers = transfers?.length > 1;
    const haveTwoTransfers = transfers?.length === 2;
    if (haveTwoTransfers && !isAllNFT) {
      return [this.getTransactionImage(transfer), this.getTransactionImage(secondTransfer)];
    }
    if (haveMultipleTransfers) {
      return transfers.map((item) => this.getTransactionImage(item));
    }
    return [this.getTransactionImage(transfer)];
  },
  getTransactionImage(transfer) {
    return {
      type: TransactionUtil.getTransactionTransferTokenType(transfer),
      url: TransactionUtil.getTransactionImageURL(transfer)
    };
  },
  getTransactionImageURL(transfer) {
    let imageURL = void 0;
    const isNFT = Boolean(transfer?.nft_info);
    const isFungible = Boolean(transfer?.fungible_info);
    if (transfer && isNFT) {
      imageURL = transfer?.nft_info?.content?.preview?.url;
    } else if (transfer && isFungible) {
      imageURL = transfer?.fungible_info?.icon?.url;
    }
    return imageURL;
  },
  getTransactionTransferTokenType(transfer) {
    if (transfer?.fungible_info) {
      return "FUNGIBLE";
    } else if (transfer?.nft_info) {
      return "NFT";
    }
    return void 0;
  },
  getTransactionDescriptions(transaction) {
    const type = transaction?.metadata?.operationType;
    const transfers = transaction?.transfers;
    const haveTransfer = transaction?.transfers?.length > 0;
    const haveMultipleTransfers = transaction?.transfers?.length > 1;
    const isFungible = haveTransfer && transfers?.every((transfer) => Boolean(transfer?.fungible_info));
    const [firstTransfer, secondTransfer] = transfers;
    let firstDescription = this.getTransferDescription(firstTransfer);
    let secondDescription = this.getTransferDescription(secondTransfer);
    if (!haveTransfer) {
      const isSendOrReceive = type === "send" || type === "receive";
      if (isSendOrReceive && isFungible) {
        firstDescription = UiHelperUtil.getTruncateString({
          string: transaction?.metadata.sentFrom,
          charsStart: 4,
          charsEnd: 6,
          truncate: "middle"
        });
        secondDescription = UiHelperUtil.getTruncateString({
          string: transaction?.metadata.sentTo,
          charsStart: 4,
          charsEnd: 6,
          truncate: "middle"
        });
        return [firstDescription, secondDescription];
      }
      return [transaction.metadata.status];
    }
    if (haveMultipleTransfers) {
      return transfers.map((item) => this.getTransferDescription(item));
    }
    let prefix2 = "";
    if (plusTypes.includes(type)) {
      prefix2 = "+";
    } else if (minusTypes.includes(type)) {
      prefix2 = "-";
    }
    firstDescription = prefix2.concat(firstDescription);
    return [firstDescription];
  },
  getTransferDescription(transfer) {
    let description = "";
    if (!transfer) {
      return description;
    }
    if (transfer?.nft_info) {
      description = transfer?.nft_info?.name || "-";
    } else if (transfer?.fungible_info) {
      description = this.getFungibleTransferDescription(transfer) || "-";
    }
    return description;
  },
  getFungibleTransferDescription(transfer) {
    if (!transfer) {
      return null;
    }
    const quantity = this.getQuantityFixedValue(transfer?.quantity.numeric);
    const description = [quantity, transfer?.fungible_info?.symbol].join(" ").trim();
    return description;
  },
  getQuantityFixedValue(value) {
    if (!value) {
      return null;
    }
    const parsedValue = parseFloat(value);
    return parsedValue.toFixed(FLOAT_FIXED_VALUE);
  }
};
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MathUtil,
  TransactionUtil,
  UiHelperUtil,
  get WuiAccountButton() {
    return WuiAccountButton;
  },
  get WuiAllWalletsImage() {
    return WuiAllWalletsImage;
  },
  get WuiAvatar() {
    return WuiAvatar;
  },
  get WuiBalance() {
    return WuiBalance;
  },
  get WuiBanner() {
    return WuiBanner;
  },
  get WuiBannerImg() {
    return WuiBannerImg;
  },
  get WuiButton() {
    return WuiButton;
  },
  get WuiCard() {
    return WuiCard;
  },
  get WuiCardSelect() {
    return WuiCardSelect;
  },
  get WuiCardSelectLoader() {
    return WuiCardSelectLoader;
  },
  get WuiChip() {
    return WuiChip;
  },
  get WuiChipButton() {
    return WuiChipButton;
  },
  get WuiCompatibleNetwork() {
    return WuiCompatibleNetwork;
  },
  get WuiConnectButton() {
    return WuiConnectButton;
  },
  get WuiCtaButton() {
    return WuiCtaButton;
  },
  get WuiDetailsGroup() {
    return WuiDetailsGroup;
  },
  get WuiDetailsGroupItem() {
    return WuiDetailsGroupItem;
  },
  get WuiDropdownMenu() {
    return WuiDropdownMenu;
  },
  get WuiEmailInput() {
    return WuiEmailInput;
  },
  get WuiEnsInput() {
    return WuiEnsInput;
  },
  get WuiFlex() {
    return WuiFlex;
  },
  get WuiGrid() {
    return WuiGrid;
  },
  get WuiIcon() {
    return WuiIcon;
  },
  get WuiIconBox() {
    return WuiIconBox;
  },
  get WuiIconButton() {
    return WuiIconButton;
  },
  get WuiIconLink() {
    return WuiIconLink;
  },
  get WuiImage() {
    return WuiImage;
  },
  get WuiInputAmount() {
    return WuiInputAmount;
  },
  get WuiInputElement() {
    return WuiInputElement;
  },
  get WuiInputNumeric() {
    return WuiInputNumeric;
  },
  get WuiInputText() {
    return WuiInputText;
  },
  get WuiLink() {
    return WuiLink;
  },
  get WuiListAccordion() {
    return WuiListAccordion;
  },
  get WuiListAccount() {
    return WuiListAccount;
  },
  get WuiListButton() {
    return WuiListButton;
  },
  get WuiListContent() {
    return WuiListContent;
  },
  get WuiListDescription() {
    return WuiListDescription;
  },
  get WuiListItem() {
    return WuiListItem;
  },
  get WuiListNetwork() {
    return WuiListNetwork;
  },
  get WuiListSocial() {
    return WuiListSocial;
  },
  get WuiListToken() {
    return WuiListToken;
  },
  get WuiListWallet() {
    return WuiListWallet;
  },
  get WuiListWalletTransaction() {
    return WuiListWalletTransaction;
  },
  get WuiLoadingHexagon() {
    return WuiLoadingHexagon;
  },
  get WuiLoadingSpinner() {
    return WuiLoadingSpinner;
  },
  get WuiLoadingThumbnail() {
    return WuiLoadingThumbnail;
  },
  get WuiLogo() {
    return WuiLogo;
  },
  get WuiLogoSelect() {
    return WuiLogoSelect;
  },
  get WuiNetworkButton() {
    return WuiNetworkButton;
  },
  get WuiNetworkImage() {
    return WuiNetworkImage;
  },
  get WuiNoticeCard() {
    return WuiNoticeCard;
  },
  get WuiOtp() {
    return WuiOtp;
  },
  get WuiPreviewItem() {
    return WuiPreviewItem;
  },
  get WuiProfileButton() {
    return WuiProfileButton;
  },
  get WuiProfileButtonV2() {
    return WuiProfileButtonV2;
  },
  get WuiPromo() {
    return WuiPromo;
  },
  get WuiQrCode() {
    return WuiQrCode;
  },
  get WuiSearchBar() {
    return WuiSearchBar;
  },
  get WuiSelect() {
    return WuiSelect;
  },
  get WuiSeparator() {
    return WuiSeparator;
  },
  get WuiShimmer() {
    return WuiShimmer;
  },
  get WuiSnackbar() {
    return WuiSnackbar;
  },
  get WuiTabs() {
    return WuiTabs;
  },
  get WuiTag() {
    return WuiTag;
  },
  get WuiText() {
    return WuiText;
  },
  get WuiTokenButton() {
    return WuiTokenButton;
  },
  get WuiTokenListItem() {
    return WuiTokenListItem;
  },
  get WuiTooltip() {
    return WuiTooltip;
  },
  get WuiTransactionListItem() {
    return WuiTransactionListItem;
  },
  get WuiTransactionListItemLoader() {
    return WuiTransactionListItemLoader;
  },
  get WuiTransactionVisual() {
    return WuiTransactionVisual;
  },
  get WuiVisual() {
    return WuiVisual;
  },
  get WuiVisualThumbnail() {
    return WuiVisualThumbnail;
  },
  get WuiWalletImage() {
    return WuiWalletImage;
  },
  customElement,
  initializeTheming,
  setColorTheme,
  setThemeVariables,
  swapInputMaskBottomSvg,
  swapInputMaskTopSvg
}, Symbol.toStringTag, { value: "Module" }));
let isInitialized = false;
class AppKit {
  constructor(options) {
    this.initPromise = void 0;
    this.setIsConnected = (isConnected, chain) => {
      AccountController.setIsConnected(isConnected, chain);
    };
    this.getIsConnectedState = () => AccountController.state.isConnected;
    this.setAllAccounts = (addresses, chain) => {
      AccountController.setAllAccounts(addresses, chain);
      OptionsController.setHasMultipleAddresses(addresses?.length > 1);
    };
    this.addAddressLabel = (address, label, chain) => {
      AccountController.addAddressLabel(address, label, chain);
    };
    this.removeAddressLabel = (address, chain) => {
      AccountController.removeAddressLabel(address, chain);
    };
    this.getCaipAddress = () => AccountController.state.caipAddress;
    this.setCaipAddress = (caipAddress, chain) => {
      AccountController.setCaipAddress(caipAddress, chain);
    };
    this.setBalance = (balance, balanceSymbol, chain) => {
      AccountController.setBalance(balance, balanceSymbol, chain);
    };
    this.setProfileName = (profileName, chain) => {
      AccountController.setProfileName(profileName, chain);
    };
    this.setProfileImage = (profileImage, chain) => {
      AccountController.setProfileImage(profileImage, chain);
    };
    this.resetAccount = (chain) => {
      AccountController.resetAccount(chain);
    };
    this.setCaipNetwork = (caipNetwork) => {
      NetworkController.setCaipNetwork(caipNetwork);
    };
    this.getCaipNetwork = () => NetworkController.state.caipNetwork;
    this.setRequestedCaipNetworks = (requestedCaipNetworks, chain) => {
      NetworkController.setRequestedCaipNetworks(requestedCaipNetworks, chain);
    };
    this.getApprovedCaipNetworkIds = () => NetworkController.getApprovedCaipNetworkIds();
    this.setApprovedCaipNetworksData = (chain) => NetworkController.setApprovedCaipNetworksData(chain);
    this.resetNetwork = () => {
      NetworkController.resetNetwork();
    };
    this.setConnectors = (connectors) => {
      ConnectorController.setConnectors(connectors);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.getConnectors = () => ConnectorController.getConnectors();
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
    this.setAddressExplorerUrl = (addressExplorerUrl, chain) => {
      AccountController.setAddressExplorerUrl(addressExplorerUrl, chain);
    };
    this.setSmartAccountDeployed = (isDeployed, chain) => {
      AccountController.setSmartAccountDeployed(isDeployed, chain);
    };
    this.setConnectedWalletInfo = (connectedWalletInfo, chain) => {
      AccountController.setConnectedWalletInfo(connectedWalletInfo, chain);
    };
    this.setSmartAccountEnabledNetworks = (smartAccountEnabledNetworks, chain) => {
      NetworkController.setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain);
    };
    this.setPreferredAccountType = (preferredAccountType, chain) => {
      AccountController.setPreferredAccountType(preferredAccountType, chain);
    };
    this.getWalletConnectName = (address) => EnsController.getNamesForAddress(address);
    this.resolveWalletConnectName = async (name) => {
      const trimmedName = name.replace(ConstantsUtil$2.WC_NAME_SUFFIX, "");
      const wcNameAddress = await EnsController.resolveName(trimmedName);
      const networkNameAddresses = Object.values(wcNameAddress?.addresses) || [];
      return networkNameAddresses[0]?.address || false;
    };
    this.setEIP6963Enabled = (enabled) => {
      OptionsController.setEIP6963Enabled(enabled);
    };
    this.setClientId = (clientId) => {
      BlockchainApiController.setClientId(clientId);
    };
    this.getConnectorImage = (connector) => AssetUtil.getConnectorImage(connector);
    this.handleUnsafeRPCRequest = () => {
      if (this.isOpen()) {
        if (this.isTransactionStackEmpty()) {
          return;
        }
        if (this.isTransactionShouldReplaceView()) {
          this.replace("ApproveTransaction");
        } else {
          this.redirect("ApproveTransaction");
        }
      } else {
        this.open({ view: "ApproveTransaction" });
      }
    };
    this.adapter = options.adapters?.[0];
    this.initControllers(options);
    this.initOrContinue();
  }
  static getInstance() {
    return this.instance;
  }
  async open(options) {
    await this.initOrContinue();
    ModalController.open(options);
  }
  async close() {
    await this.initOrContinue();
    ModalController.close();
  }
  setLoading(loading) {
    ModalController.setLoading(loading);
  }
  getError() {
    return this.adapter?.getError?.();
  }
  getChainId() {
    return this.adapter?.getChainId?.();
  }
  getAddress() {
    return this.adapter?.getAddress?.();
  }
  switchNetwork(chainId) {
    return this.adapter?.switchNetwork?.(chainId);
  }
  getIsConnected() {
    return this.adapter?.getIsConnected?.();
  }
  getWalletProvider() {
    return this.adapter?.getWalletProvider?.();
  }
  getWalletProviderType() {
    return this.adapter?.getWalletProviderType?.();
  }
  subscribeProvider(callback) {
    return this.adapter?.subscribeProvider?.(callback);
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  getWalletInfo() {
    return AccountController.state.connectedWalletInfo;
  }
  subscribeWalletInfo(callback) {
    return AccountController.subscribeKey("connectedWalletInfo", callback);
  }
  subscribeShouldUpdateToAddress(callback) {
    AccountController.subscribeKey("shouldUpdateToAddress", callback);
  }
  subscribeCaipNetworkChange(callback) {
    NetworkController.subscribeKey("caipNetwork", callback);
  }
  getState() {
    return PublicStateController.state;
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  showErrorMessage(message) {
    SnackController.showError(message);
  }
  showSuccessMessage(message) {
    SnackController.showSuccess(message);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  replace(route) {
    RouterController.replace(route);
  }
  redirect(route) {
    RouterController.push(route);
  }
  popTransactionStack(cancel) {
    RouterController.popTransactionStack(cancel);
  }
  isOpen() {
    return ModalController.state.open;
  }
  isTransactionStackEmpty() {
    return RouterController.state.transactionStack.length === 0;
  }
  isTransactionShouldReplaceView() {
    return RouterController.state.transactionStack[RouterController.state.transactionStack.length - 1]?.replace;
  }
  async initControllers(options) {
    OptionsController.setProjectId(options.projectId);
    OptionsController.setSdkVersion(options.sdkVersion);
    ChainController.initialize(options.adapters || []);
    options.adapters?.forEach((adapter) => {
      adapter.construct?.(this, options);
      NetworkController.setAllowUnsupportedChain(options.allowUnsupportedChain, adapter.chain);
      NetworkController.setDefaultCaipNetwork(options.defaultChain);
    });
    OptionsController.setAllWallets(options.allWallets);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setEnableAnalytics(options.enableAnalytics);
    OptionsController.setOnrampEnabled(options.enableOnramp);
    OptionsController.setEnableSwaps(options.enableSwaps);
    if (options.metadata) {
      OptionsController.setMetadata(options.metadata);
    }
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
    if (options.disableAppend) {
      OptionsController.setDisableAppend(Boolean(options.disableAppend));
    }
    const evmAdapter = options.adapters?.find((adapter) => adapter.chain === ConstantsUtil$2.CHAIN.EVM);
    if (evmAdapter) {
      if (options.siweConfig) {
        const { SIWEController } = await __vitePreload(async () => {
          const { SIWEController: SIWEController2 } = await import("./index-BPfKs9-b.js");
          return { SIWEController: SIWEController2 };
        }, true ? [] : void 0);
        SIWEController.setSIWEClient(options.siweConfig);
      }
    }
  }
  async initOrContinue() {
    if (!this.initPromise && !isInitialized && CoreHelperUtil.isClient()) {
      isInitialized = true;
      this.initPromise = new Promise(async (resolve) => {
        await Promise.all([__vitePreload(() => Promise.resolve().then(() => index), true ? void 0 : void 0), __vitePreload(() => import("./w3m-modal-BOUgta1k.js"), true ? [] : void 0)]);
        const modal2 = document.createElement("w3m-modal");
        if (!OptionsController.state.disableAppend) {
          document.body.insertAdjacentElement("beforeend", modal2);
        }
        resolve();
      });
    }
    return this.initPromise;
  }
}
var __decorate$1F = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAccountButton = class W3mAccountButton2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = "show";
    this.charsStart = 4;
    this.charsEnd = 6;
    this.address = AccountController.state.address;
    this.balanceVal = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.profileName = AccountController.state.profileName;
    this.profileImage = AccountController.state.profileImage;
    this.network = NetworkController.state.caipNetwork;
    this.networkImage = this.network ? AssetUtil.getNetworkImage(this.network) : void 0;
    this.isUnsupportedChain = NetworkController.state.isUnsupportedChain;
    this.unsubscribe.push(...[
      AssetController.subscribeNetworkImages(() => {
        this.networkImage = this.network?.imageId ? AssetUtil.getNetworkImage(this.network) : void 0;
      }),
      AccountController.subscribe((val) => {
        if (val.isConnected) {
          this.address = val.address;
          this.balanceVal = val.balance;
          this.profileName = val.profileName;
          this.profileImage = val.profileImage;
          this.balanceSymbol = val.balanceSymbol;
        } else {
          this.address = "";
          this.balanceVal = "";
          this.profileName = "";
          this.profileImage = "";
          this.balanceSymbol = "";
        }
      }),
      NetworkController.subscribeKey("caipNetwork", (val) => {
        this.network = val;
        this.networkImage = val?.imageId ? AssetUtil.getNetworkImage(val) : void 0;
      }),
      NetworkController.subscribeKey("isUnsupportedChain", (val) => {
        this.isUnsupportedChain = val;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const showBalance = this.balance === "show";
    return x`
      <wui-account-button
        .disabled=${Boolean(this.disabled)}
        .isUnsupportedChain=${this.isUnsupportedChain}
        address=${o$3(this.address)}
        profileName=${o$3(this.profileName)}
        networkSrc=${o$3(this.networkImage)}
        avatarSrc=${o$3(this.profileImage)}
        balance=${showBalance ? CoreHelperUtil.formatBalance(this.balanceVal, this.balanceSymbol) : ""}
        @click=${this.onClick.bind(this)}
        data-testid="account-button"
        .charsStart=${this.charsStart}
        .charsEnd=${this.charsEnd}
      >
      </wui-account-button>
    `;
  }
  onClick() {
    if (this.isUnsupportedChain) {
      ModalController.open({ view: "UnsupportedChain" });
    } else {
      ModalController.open();
    }
  }
};
__decorate$1F([
  n$2({ type: Boolean })
], W3mAccountButton.prototype, "disabled", void 0);
__decorate$1F([
  n$2()
], W3mAccountButton.prototype, "balance", void 0);
__decorate$1F([
  n$2()
], W3mAccountButton.prototype, "charsStart", void 0);
__decorate$1F([
  n$2()
], W3mAccountButton.prototype, "charsEnd", void 0);
__decorate$1F([
  r$1()
], W3mAccountButton.prototype, "address", void 0);
__decorate$1F([
  r$1()
], W3mAccountButton.prototype, "balanceVal", void 0);
__decorate$1F([
  r$1()
], W3mAccountButton.prototype, "balanceSymbol", void 0);
__decorate$1F([
  r$1()
], W3mAccountButton.prototype, "profileName", void 0);
__decorate$1F([
  r$1()
], W3mAccountButton.prototype, "profileImage", void 0);
__decorate$1F([
  r$1()
], W3mAccountButton.prototype, "network", void 0);
__decorate$1F([
  r$1()
], W3mAccountButton.prototype, "networkImage", void 0);
__decorate$1F([
  r$1()
], W3mAccountButton.prototype, "isUnsupportedChain", void 0);
W3mAccountButton = __decorate$1F([
  customElement("w3m-account-button")
], W3mAccountButton);
const styles$13 = i$5`
  :host {
    display: block;
    width: max-content;
  }
`;
var __decorate$1E = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mButton = class W3mButton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = void 0;
    this.size = void 0;
    this.label = void 0;
    this.loadingLabel = void 0;
    this.charsStart = 4;
    this.charsEnd = 6;
    this.isAccount = AccountController.state.isConnected;
    this.isLoading = ModalController.state.loading;
  }
  firstUpdated() {
    this.unsubscribe.push(AccountController.subscribe((val) => {
      this.isAccount = val.isConnected;
    }), ModalController.subscribeKey("loading", (val) => {
      this.isLoading = val;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return this.isAccount && !this.isLoading ? x`
          <w3m-account-button
            .disabled=${Boolean(this.disabled)}
            balance=${o$3(this.balance)}
            .charsStart=${o$3(this.charsStart)}
            .charsEnd=${o$3(this.charsEnd)}
          >
          </w3m-account-button>
        ` : x`
          <w3m-connect-button
            size=${o$3(this.size)}
            label=${o$3(this.label)}
            loadingLabel=${o$3(this.loadingLabel)}
          ></w3m-connect-button>
        `;
  }
};
W3mButton.styles = styles$13;
__decorate$1E([
  n$2({ type: Boolean })
], W3mButton.prototype, "disabled", void 0);
__decorate$1E([
  n$2()
], W3mButton.prototype, "balance", void 0);
__decorate$1E([
  n$2()
], W3mButton.prototype, "size", void 0);
__decorate$1E([
  n$2()
], W3mButton.prototype, "label", void 0);
__decorate$1E([
  n$2()
], W3mButton.prototype, "loadingLabel", void 0);
__decorate$1E([
  n$2()
], W3mButton.prototype, "charsStart", void 0);
__decorate$1E([
  n$2()
], W3mButton.prototype, "charsEnd", void 0);
__decorate$1E([
  r$1()
], W3mButton.prototype, "isAccount", void 0);
__decorate$1E([
  r$1()
], W3mButton.prototype, "isLoading", void 0);
W3mButton = __decorate$1E([
  customElement("w3m-button")
], W3mButton);
var __decorate$1D = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectButton = class W3mConnectButton2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.size = "md";
    this.label = "Connect Wallet";
    this.loadingLabel = "Connecting...";
    this.open = ModalController.state.open;
    this.loading = ModalController.state.loading;
    this.unsubscribe.push(ModalController.subscribe((val) => {
      this.open = val.open;
      this.loading = val.loading;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const isLoading = this.loading || this.open;
    return x`
      <wui-connect-button
        size=${o$3(this.size)}
        .loading=${isLoading}
        @click=${this.onClick.bind(this)}
        data-testid="connect-button"
      >
        ${isLoading ? this.loadingLabel : this.label}
      </wui-connect-button>
    `;
  }
  onClick() {
    if (this.open) {
      ModalController.close();
    } else if (!this.loading) {
      ModalController.open();
    }
  }
};
__decorate$1D([
  n$2()
], W3mConnectButton.prototype, "size", void 0);
__decorate$1D([
  n$2()
], W3mConnectButton.prototype, "label", void 0);
__decorate$1D([
  n$2()
], W3mConnectButton.prototype, "loadingLabel", void 0);
__decorate$1D([
  r$1()
], W3mConnectButton.prototype, "open", void 0);
__decorate$1D([
  r$1()
], W3mConnectButton.prototype, "loading", void 0);
W3mConnectButton = __decorate$1D([
  customElement("w3m-connect-button")
], W3mConnectButton);
const styles$12 = i$5`
  :host {
    display: block;
    width: max-content;
  }
`;
var __decorate$1C = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mNetworkButton = class W3mNetworkButton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.unsubscribe = [];
    this.disabled = false;
    this.network = NetworkController.state.caipNetwork;
    this.networkImage = this.network ? AssetUtil.getNetworkImage(this.network) : void 0;
    this.connected = AccountController.state.isConnected;
    this.loading = ModalController.state.loading;
    this.isUnsupportedChain = NetworkController.state.isUnsupportedChain;
  }
  firstUpdated() {
    this.unsubscribe.push(...[
      AssetController.subscribeNetworkImages(() => {
        this.networkImage = this.network?.imageId ? AssetUtil.getNetworkImage(this.network) : void 0;
      }),
      NetworkController.subscribeKey("caipNetwork", (val) => {
        this.network = val;
        this.networkImage = val?.imageId ? AssetUtil.getNetworkImage(val) : void 0;
      }),
      AccountController.subscribeKey("isConnected", (val) => this.connected = val),
      ModalController.subscribeKey("loading", (val) => this.loading = val),
      NetworkController.subscribeKey("isUnsupportedChain", (val) => this.isUnsupportedChain = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      <wui-network-button
        data-testid="wui-network-button"
        .disabled=${Boolean(this.disabled || this.loading)}
        .isUnsupportedChain=${this.isUnsupportedChain}
        imageSrc=${o$3(this.networkImage)}
        @click=${this.onClick.bind(this)}
      >
        ${this.getLabel()}
        <slot></slot>
      </wui-network-button>
    `;
  }
  getLabel() {
    if (this.label) {
      return this.label;
    }
    if (this.isUnsupportedChain) {
      return "Switch Network";
    }
    if (this.network) {
      return this.network.name;
    }
    if (this.connected) {
      return "Unknown Network";
    }
    return "Select Network";
  }
  onClick() {
    if (!this.loading) {
      EventsController.sendEvent({ type: "track", event: "CLICK_NETWORKS" });
      ModalController.open({ view: "Networks" });
    }
  }
};
W3mNetworkButton.styles = styles$12;
__decorate$1C([
  n$2({ type: Boolean })
], W3mNetworkButton.prototype, "disabled", void 0);
__decorate$1C([
  n$2({ type: String })
], W3mNetworkButton.prototype, "label", void 0);
__decorate$1C([
  r$1()
], W3mNetworkButton.prototype, "network", void 0);
__decorate$1C([
  r$1()
], W3mNetworkButton.prototype, "networkImage", void 0);
__decorate$1C([
  r$1()
], W3mNetworkButton.prototype, "connected", void 0);
__decorate$1C([
  r$1()
], W3mNetworkButton.prototype, "loading", void 0);
__decorate$1C([
  r$1()
], W3mNetworkButton.prototype, "isUnsupportedChain", void 0);
W3mNetworkButton = __decorate$1C([
  customElement("w3m-network-button")
], W3mNetworkButton);
const styles$11 = i$5`
  :host {
    --prev-height: 0px;
    --new-height: 0px;
    display: block;
  }

  div.w3m-router-container {
    transform: translateY(0);
    opacity: 1;
  }

  div.w3m-router-container[view-direction='prev'] {
    animation:
      slide-left-out 150ms forwards ease,
      slide-left-in 150ms forwards ease;
    animation-delay: 0ms, 200ms;
  }

  div.w3m-router-container[view-direction='next'] {
    animation:
      slide-right-out 150ms forwards ease,
      slide-right-in 150ms forwards ease;
    animation-delay: 0ms, 200ms;
  }

  @keyframes slide-left-out {
    from {
      transform: translateX(0px);
      opacity: 1;
    }
    to {
      transform: translateX(10px);
      opacity: 0;
    }
  }

  @keyframes slide-left-in {
    from {
      transform: translateX(-10px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes slide-right-out {
    from {
      transform: translateX(0px);
      opacity: 1;
    }
    to {
      transform: translateX(-10px);
      opacity: 0;
    }
  }

  @keyframes slide-right-in {
    from {
      transform: translateX(10px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
`;
var define_process_env_default = {};
const ConstantsUtil = {
  ACCOUNT_TABS: [{ label: "Tokens" }, { label: "NFTs" }, { label: "Activity" }],
  SECURE_SITE_ORIGIN: define_process_env_default["NEXT_PUBLIC_SECURE_SITE_ORIGIN"] || "https://secure.walletconnect.org",
  VIEW_DIRECTION: {
    Next: "next",
    Prev: "prev"
  },
  ANIMATION_DURATIONS: {
    HeaderText: 120,
    ModalHeight: 150,
    ViewTransition: 150
  }
};
var __decorate$1B = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mRouter = class W3mRouter2 extends i$2 {
  constructor() {
    super();
    this.resizeObserver = void 0;
    this.prevHeight = "0px";
    this.prevHistoryLength = 1;
    this.unsubscribe = [];
    this.view = RouterController.state.view;
    this.viewDirection = "";
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => this.onViewChange(val)));
  }
  firstUpdated() {
    this.resizeObserver = new ResizeObserver(([content]) => {
      const height2 = `${content?.contentRect.height}px`;
      if (this.prevHeight !== "0px") {
        this.style.setProperty("--prev-height", this.prevHeight);
        this.style.setProperty("--new-height", height2);
        this.style.animation = "w3m-view-height 150ms forwards ease";
        this.style.height = "auto";
      }
      setTimeout(() => {
        this.prevHeight = height2;
        this.style.animation = "unset";
      }, ConstantsUtil.ANIMATION_DURATIONS.ModalHeight);
    });
    this.resizeObserver.observe(this.getWrapper());
  }
  disconnectedCallback() {
    this.resizeObserver?.unobserve(this.getWrapper());
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`<div class="w3m-router-container" view-direction="${this.viewDirection}">
      ${this.viewTemplate()}
    </div>`;
  }
  viewTemplate() {
    switch (this.view) {
      case "AccountSettings":
        return x`<w3m-account-settings-view></w3m-account-settings-view>`;
      case "Account":
        return x`<w3m-account-view></w3m-account-view>`;
      case "AllWallets":
        return x`<w3m-all-wallets-view></w3m-all-wallets-view>`;
      case "ApproveTransaction":
        return x`<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
      case "BuyInProgress":
        return x`<w3m-buy-in-progress-view></w3m-buy-in-progress-view>`;
      case "ChooseAccountName":
        return x`<w3m-choose-account-name-view></w3m-choose-account-name-view>`;
      case "Connect":
        return x`<w3m-connect-view></w3m-connect-view>`;
      case "ConnectingWalletConnect":
        return x`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
      case "ConnectingExternal":
        return x`<w3m-connecting-external-view></w3m-connecting-external-view>`;
      case "ConnectingSiwe":
        return x`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
      case "ConnectWallets":
        return x`<w3m-connect-wallets-view></w3m-connect-wallets-view>`;
      case "ConnectSocials":
        return x`<w3m-connect-socials-view></w3m-connect-socials-view>`;
      case "ConnectingSocial":
        return x`<w3m-connecting-social-view></w3m-connecting-social-view>`;
      case "Downloads":
        return x`<w3m-downloads-view></w3m-downloads-view>`;
      case "EmailVerifyOtp":
        return x`<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
      case "EmailVerifyDevice":
        return x`<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
      case "GetWallet":
        return x`<w3m-get-wallet-view></w3m-get-wallet-view>`;
      case "Networks":
        return x`<w3m-networks-view></w3m-networks-view>`;
      case "SwitchNetwork":
        return x`<w3m-network-switch-view></w3m-network-switch-view>`;
      case "Profile":
        return x`<w3m-profile-view></w3m-profile-view>`;
      case "SelectAddresses":
        return x`<w3m-select-addresses-view></w3m-select-addresses-view>`;
      case "SwitchAddress":
        return x`<w3m-switch-address-view></w3m-switch-address-view>`;
      case "Transactions":
        return x`<w3m-transactions-view></w3m-transactions-view>`;
      case "OnRampProviders":
        return x`<w3m-onramp-providers-view></w3m-onramp-providers-view>`;
      case "OnRampActivity":
        return x`<w3m-onramp-activity-view></w3m-onramp-activity-view>`;
      case "OnRampTokenSelect":
        return x`<w3m-onramp-token-select-view></w3m-onramp-token-select-view>`;
      case "OnRampFiatSelect":
        return x`<w3m-onramp-fiat-select-view></w3m-onramp-fiat-select-view>`;
      case "UpgradeEmailWallet":
        return x`<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
      case "UpgradeToSmartAccount":
        return x`<w3m-upgrade-to-smart-account-view></w3m-upgrade-to-smart-account-view>`;
      case "UpdateEmailWallet":
        return x`<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
      case "UpdateEmailPrimaryOtp":
        return x`<w3m-update-email-primary-otp-view></w3m-update-email-primary-otp-view>`;
      case "UpdateEmailSecondaryOtp":
        return x`<w3m-update-email-secondary-otp-view></w3m-update-email-secondary-otp-view>`;
      case "UnsupportedChain":
        return x`<w3m-unsupported-chain-view></w3m-unsupported-chain-view>`;
      case "Swap":
        return x`<w3m-swap-view></w3m-swap-view>`;
      case "SwapSelectToken":
        return x`<w3m-swap-select-token-view></w3m-swap-select-token-view>`;
      case "SwapPreview":
        return x`<w3m-swap-preview-view></w3m-swap-preview-view>`;
      case "WalletSend":
        return x`<w3m-wallet-send-view></w3m-wallet-send-view>`;
      case "WalletSendSelectToken":
        return x`<w3m-wallet-send-select-token-view></w3m-wallet-send-select-token-view>`;
      case "WalletSendPreview":
        return x`<w3m-wallet-send-preview-view></w3m-wallet-send-preview-view>`;
      case "WhatIsABuy":
        return x`<w3m-what-is-a-buy-view></w3m-what-is-a-buy-view>`;
      case "WalletReceive":
        return x`<w3m-wallet-receive-view></w3m-wallet-receive-view>`;
      case "WalletCompatibleNetworks":
        return x`<w3m-wallet-compatible-networks-view></w3m-wallet-compatible-networks-view>`;
      case "WhatIsAWallet":
        return x`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
      case "ConnectingMultiChain":
        return x`<w3m-connecting-multi-chain-view></w3m-connecting-multi-chain-view>`;
      case "WhatIsANetwork":
        return x`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
      case "ConnectingFarcaster":
        return x`<w3m-connecting-farcaster-view></w3m-connecting-farcaster-view>`;
      case "SwitchActiveChain":
        return x`<w3m-switch-active-chain-view></w3m-switch-active-chain-view>`;
      case "RegisterAccountName":
        return x`<w3m-register-account-name-view></w3m-register-account-name-view>`;
      case "RegisterAccountNameSuccess":
        return x`<w3m-register-account-name-success-view></w3m-register-account-name-success-view>`;
      default:
        return x`<w3m-connect-view></w3m-connect-view>`;
    }
  }
  onViewChange(newView) {
    TooltipController.hide();
    let direction = ConstantsUtil.VIEW_DIRECTION.Next;
    const { history } = RouterController.state;
    if (history.length < this.prevHistoryLength) {
      direction = ConstantsUtil.VIEW_DIRECTION.Prev;
    }
    this.prevHistoryLength = history.length;
    this.viewDirection = direction;
    setTimeout(() => {
      this.view = newView;
    }, ConstantsUtil.ANIMATION_DURATIONS.ViewTransition);
  }
  getWrapper() {
    return this.shadowRoot?.querySelector("div");
  }
};
W3mRouter.styles = styles$11;
__decorate$1B([
  r$1()
], W3mRouter.prototype, "view", void 0);
__decorate$1B([
  r$1()
], W3mRouter.prototype, "viewDirection", void 0);
W3mRouter = __decorate$1B([
  customElement("w3m-router")
], W3mRouter);
const styles$10 = i$5`
  :host > wui-flex {
    width: 100%;
    max-width: 360px;
  }

  :host > wui-flex > wui-flex {
    border-radius: var(--wui-border-radius-l);
    width: 100%;
  }

  .amounts-container {
    width: 100%;
  }
`;
var __decorate$1A = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const PAYMENT_CURRENCY_SYMBOLS = {
  USD: "$",
  EUR: "",
  GBP: ""
};
const BUY_PRESET_AMOUNTS = [100, 250, 500, 1e3];
let W3mOnrampWidget = class W3mOnrampWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.connected = AccountController.state.isConnected;
    this.loading = ModalController.state.loading;
    this.paymentCurrency = OnRampController.state.paymentCurrency;
    this.paymentAmount = OnRampController.state.paymentAmount;
    this.purchaseAmount = OnRampController.state.purchaseAmount;
    this.quoteLoading = OnRampController.state.quotesLoading;
    this.unsubscribe.push(...[
      AccountController.subscribeKey("isConnected", (val) => {
        this.connected = val;
      }),
      ModalController.subscribeKey("loading", (val) => {
        this.loading = val;
      }),
      OnRampController.subscribe((val) => {
        this.paymentCurrency = val.paymentCurrency;
        this.paymentAmount = val.paymentAmount;
        this.purchaseAmount = val.purchaseAmount;
        this.quoteLoading = val.quotesLoading;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      <wui-flex flexDirection="column" justifyContent="center" alignItems="center">
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <w3m-onramp-input
            type="Fiat"
            @inputChange=${this.onPaymentAmountChange.bind(this)}
            .value=${this.paymentAmount || 0}
          ></w3m-onramp-input>
          <w3m-onramp-input
            type="Token"
            .value=${this.purchaseAmount || 0}
            .loading=${this.quoteLoading}
          ></w3m-onramp-input>
          <wui-flex justifyContent="space-evenly" class="amounts-container" gap="xs">
            ${BUY_PRESET_AMOUNTS.map((amount) => x`<wui-button
                  variant=${this.paymentAmount === amount ? "accent" : "neutral"}
                  size="md"
                  textVariant="paragraph-600"
                  fullWidth
                  @click=${() => this.selectPresetAmount(amount)}
                  >${`${PAYMENT_CURRENCY_SYMBOLS[this.paymentCurrency?.id || "USD"]} ${amount}`}</wui-button
                >`)}
          </wui-flex>
          ${this.templateButton()}
        </wui-flex>
      </wui-flex>
    `;
  }
  templateButton() {
    return this.connected ? x`<wui-button
          @click=${this.getQuotes.bind(this)}
          variant="main"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Get quotes
        </wui-button>` : x`<wui-button
          @click=${this.openModal.bind(this)}
          variant="accent"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Connect wallet
        </wui-button>`;
  }
  getQuotes() {
    if (!this.loading) {
      ModalController.open({ view: "OnRampProviders" });
    }
  }
  openModal() {
    ModalController.open({ view: "Connect" });
  }
  async onPaymentAmountChange(event) {
    OnRampController.setPaymentAmount(Number(event.detail));
    await OnRampController.getQuote();
  }
  async selectPresetAmount(amount) {
    OnRampController.setPaymentAmount(amount);
    await OnRampController.getQuote();
  }
};
W3mOnrampWidget.styles = styles$10;
__decorate$1A([
  n$2({ type: Boolean })
], W3mOnrampWidget.prototype, "disabled", void 0);
__decorate$1A([
  r$1()
], W3mOnrampWidget.prototype, "connected", void 0);
__decorate$1A([
  r$1()
], W3mOnrampWidget.prototype, "loading", void 0);
__decorate$1A([
  r$1()
], W3mOnrampWidget.prototype, "paymentCurrency", void 0);
__decorate$1A([
  r$1()
], W3mOnrampWidget.prototype, "paymentAmount", void 0);
__decorate$1A([
  r$1()
], W3mOnrampWidget.prototype, "purchaseAmount", void 0);
__decorate$1A([
  r$1()
], W3mOnrampWidget.prototype, "quoteLoading", void 0);
W3mOnrampWidget = __decorate$1A([
  customElement("w3m-onramp-widget")
], W3mOnrampWidget);
var __decorate$1z = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAccountSettingsView = class W3mAccountSettingsView2 extends i$2 {
  constructor() {
    super();
    this.usubscribe = [];
    this.networkImages = AssetController.state.networkImages;
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.network = NetworkController.state.caipNetwork;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.disconnecting = false;
    this.loading = false;
    this.switched = false;
    this.text = "";
    this.usubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          ModalController.close();
        }
      }),
      AccountController.subscribeKey("preferredAccountType", (val) => this.preferredAccountType = val),
      NetworkController.subscribeKey("caipNetwork", (val) => {
        if (val?.id) {
          this.network = val;
        }
      })
    ]);
  }
  disconnectedCallback() {
    this.usubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-account-settings-view: No account provided");
    }
    const networkImage = this.networkImages[this.network?.imageId ?? ""];
    const name = this.profileName?.split(".")[0];
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="l"
        .padding=${["0", "xl", "m", "xl"]}
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${o$3(this.profileImage)}
          size="2lg"
        ></wui-avatar>
        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="title-6-600" color="fg-100" data-testid="account-settings-address">
              ${name ? UiHelperUtil.getTruncateString({
      string: name,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
      <wui-flex flexDirection="column" gap="m">
        <wui-flex flexDirection="column" gap="xs" .padding=${["0", "l", "m", "l"]}>
          ${this.authCardTemplate()}
          <w3m-account-auth-button></w3m-account-auth-button>
          <wui-list-item
            .variant=${networkImage ? "image" : "icon"}
            iconVariant="overlay"
            icon="networkPlaceholder"
            imageSrc=${o$3(networkImage)}
            ?chevron=${this.isAllowedNetworkSwitch()}
            @click=${this.onNetworks.bind(this)}
            data-testid="account-switch-network-button"
          >
            <wui-text variant="paragraph-500" color="fg-100">
              ${this.network?.name ?? "Unknown"}
            </wui-text>
          </wui-list-item>
          ${this.togglePreferredAccountBtnTemplate()} ${this.chooseNameButtonTemplate()}
          <wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${false}
            .loading=${this.disconnecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `;
  }
  chooseNameButtonTemplate() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector2 = ConnectorController.getAuthConnector();
    const hasNetworkSupport = NetworkController.checkIfNamesSupported();
    if (!hasNetworkSupport || !authConnector2 || type !== "AUTH" || this.profileName) {
      return null;
    }
    return x`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="id"
        iconSize="sm"
        ?chevron=${true}
        @click=${this.onChooseName.bind(this)}
        data-testid="account-choose-name-button"
      >
        <wui-text variant="paragraph-500" color="fg-100">Choose account name </wui-text>
      </wui-list-item>
    `;
  }
  authCardTemplate() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector2 = ConnectorController.getAuthConnector();
    const { origin } = location;
    if (!authConnector2 || type !== "AUTH" || origin.includes(ConstantsUtil$1.SECURE_SITE)) {
      return null;
    }
    return x`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
        data-testid="w3m-wallet-upgrade-card"
      ></wui-notice-card>
    `;
  }
  isAllowedNetworkSwitch() {
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
    const isValidNetwork = requestedCaipNetworks?.find(({ id }) => id === this.network?.id);
    return isMultiNetwork || !isValidNetwork;
  }
  onCopyAddress() {
    try {
      if (this.profileName) {
        CoreHelperUtil.copyToClopboard(this.profileName);
        SnackController.showSuccess("Name copied");
      } else if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
  togglePreferredAccountBtnTemplate() {
    const networkEnabled = NetworkController.checkIfSmartAccountEnabled();
    const type = StorageUtil.getConnectedConnector();
    const authConnector2 = ConnectorController.getAuthConnector();
    if (!authConnector2 || type !== "AUTH" || !networkEnabled) {
      return null;
    }
    if (!this.switched) {
      this.text = this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT ? "Switch to your EOA" : "Switch to your smart account";
    }
    return x`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="swapHorizontalBold"
        iconSize="sm"
        ?chevron=${true}
        ?loading=${this.loading}
        @click=${this.changePreferredAccountType.bind(this)}
        data-testid="account-toggle-preferred-account-type"
      >
        <wui-text variant="paragraph-500" color="fg-100">${this.text}</wui-text>
      </wui-list-item>
    `;
  }
  onChooseName() {
    RouterController.push("ChooseAccountName");
  }
  async changePreferredAccountType() {
    const smartAccountEnabled = NetworkController.checkIfSmartAccountEnabled();
    const accountTypeTarget = this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT || !smartAccountEnabled ? W3mFrameRpcConstants.ACCOUNT_TYPES.EOA : W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT;
    const authConnector2 = ConnectorController.getAuthConnector();
    if (!authConnector2) {
      return;
    }
    this.loading = true;
    await ConnectionController.setPreferredAccountType(accountTypeTarget);
    this.text = accountTypeTarget === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT ? "Switch to your EOA" : "Switch to your smart account";
    this.switched = true;
    SendController.resetSend();
    this.loading = false;
    this.requestUpdate();
  }
  onNetworks() {
    if (this.isAllowedNetworkSwitch()) {
      RouterController.push("Networks");
    }
  }
  async onDisconnect() {
    try {
      this.disconnecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconnecting = false;
    }
  }
  onGoToUpgradeView() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" });
    RouterController.push("UpgradeEmailWallet");
  }
};
__decorate$1z([
  r$1()
], W3mAccountSettingsView.prototype, "address", void 0);
__decorate$1z([
  r$1()
], W3mAccountSettingsView.prototype, "profileImage", void 0);
__decorate$1z([
  r$1()
], W3mAccountSettingsView.prototype, "profileName", void 0);
__decorate$1z([
  r$1()
], W3mAccountSettingsView.prototype, "network", void 0);
__decorate$1z([
  r$1()
], W3mAccountSettingsView.prototype, "preferredAccountType", void 0);
__decorate$1z([
  r$1()
], W3mAccountSettingsView.prototype, "disconnecting", void 0);
__decorate$1z([
  r$1()
], W3mAccountSettingsView.prototype, "loading", void 0);
__decorate$1z([
  r$1()
], W3mAccountSettingsView.prototype, "switched", void 0);
__decorate$1z([
  r$1()
], W3mAccountSettingsView.prototype, "text", void 0);
W3mAccountSettingsView = __decorate$1z([
  customElement("w3m-account-settings-view")
], W3mAccountSettingsView);
var __decorate$1y = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAccountView = class W3mAccountView2 extends i$2 {
  render() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector2 = ConnectorController.getAuthConnector();
    return x`
      ${authConnector2?.walletFeatures && type === "AUTH" ? this.walletFeaturesTemplate() : this.defaultTemplate()}
    `;
  }
  walletFeaturesTemplate() {
    return x`<w3m-account-wallet-features-widget></w3m-account-wallet-features-widget>`;
  }
  defaultTemplate() {
    return x`<w3m-account-default-widget></w3m-account-default-widget>`;
  }
};
W3mAccountView = __decorate$1y([
  customElement("w3m-account-view")
], W3mAccountView);
var __decorate$1x = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAllWalletsView = class W3mAllWalletsView2 extends i$2 {
  constructor() {
    super(...arguments);
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    });
  }
  render() {
    const isSearch = this.search.length >= 2;
    return x`
      <wui-flex .padding=${["0", "s", "s", "s"]} gap="s">
        <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${isSearch ? x`<w3m-all-wallets-search query=${this.search}></w3m-all-wallets-search>` : x`<w3m-all-wallets-list></w3m-all-wallets-list>`}
    `;
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  qrButtonTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return x`
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      `;
    }
    return null;
  }
  onWalletConnectQr() {
    RouterController.push("ConnectingWalletConnect");
  }
};
__decorate$1x([
  r$1()
], W3mAllWalletsView.prototype, "search", void 0);
W3mAllWalletsView = __decorate$1x([
  customElement("w3m-all-wallets-view")
], W3mAllWalletsView);
const styles$$ = i$5`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-visual {
    width: var(--wui-wallet-image-size-lg);
    height: var(--wui-wallet-image-size-lg);
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    position: relative;
    overflow: hidden;
  }

  wui-visual::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition:
      opacity var(--wui-ease-out-power-2) var(--wui-duration-lg),
      transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }

  wui-link {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
  }
`;
var __decorate$1w = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mBuyInProgressView = class W3mBuyInProgressView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedOnRampProvider = OnRampController.state.selectedProvider;
    this.uri = ConnectionController.state.wcUri;
    this.ready = false;
    this.showRetry = false;
    this.buffering = false;
    this.error = false;
    this.startTime = null;
    this.isMobile = false;
    this.onRetry = void 0;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("selectedProvider", (val) => {
        this.selectedOnRampProvider = val;
      })
    ]);
    this.watchTransactions();
  }
  disconnectedCallback() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }
  render() {
    let label = "Continue in external window";
    if (this.error) {
      label = "Buy failed";
    } else if (this.selectedOnRampProvider) {
      label = `Buy in ${this.selectedOnRampProvider?.label}`;
    }
    const subLabel = this.error ? "Buy can be declined from your side or due to and error on the provider app" : `Well notify you once your Buy is processed`;
    return x`
      <wui-flex
        data-error=${o$3(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-visual
            name=${o$3(this.selectedOnRampProvider?.name)}
            size="lg"
            class="provider-image"
          >
          </wui-visual>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        ${this.error ? this.tryAgainTemplate() : null}
      </wui-flex>

      <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
        <wui-link @click=${this.onCopyUri} color="fg-200">
          <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
          Copy link
        </wui-link>
      </wui-flex>
    `;
  }
  watchTransactions() {
    if (!this.selectedOnRampProvider) {
      return;
    }
    switch (this.selectedOnRampProvider.name) {
      case "coinbase":
        this.startTime = Date.now();
        this.initializeCoinbaseTransactions();
        break;
    }
  }
  async initializeCoinbaseTransactions() {
    await this.watchCoinbaseTransactions();
    this.intervalId = setInterval(() => this.watchCoinbaseTransactions(), 4e3);
  }
  async watchCoinbaseTransactions() {
    try {
      const address = AccountController.state.address;
      const projectId2 = OptionsController.state.projectId;
      if (!address) {
        throw new Error("No address found");
      }
      const coinbaseResponse = await BlockchainApiController.fetchTransactions({
        account: address,
        onramp: "coinbase",
        projectId: projectId2
      });
      const newTransactions = coinbaseResponse.data.filter((tx) => new Date(tx.metadata.minedAt) > new Date(this.startTime) || tx.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS");
      if (newTransactions.length) {
        clearInterval(this.intervalId);
        RouterController.replace("OnRampActivity");
      } else if (this.startTime && Date.now() - this.startTime >= 18e4) {
        clearInterval(this.intervalId);
        this.error = true;
      }
    } catch (error) {
      SnackController.showError(error);
    }
  }
  onTryAgain() {
    if (!this.selectedOnRampProvider) {
      return;
    }
    this.error = false;
    CoreHelperUtil.openHref(this.selectedOnRampProvider.url, "popupWindow", "width=600,height=800,scrollbars=yes");
  }
  tryAgainTemplate() {
    if (!this.selectedOnRampProvider?.url) {
      return null;
    }
    return x`<wui-button size="md" variant="accent" @click=${this.onTryAgain.bind(this)}>
      <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
      Try again
    </wui-button>`;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return x`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  onCopyUri() {
    if (!this.selectedOnRampProvider?.url) {
      SnackController.showError("No link found");
      RouterController.goBack();
      return;
    }
    try {
      CoreHelperUtil.copyToClopboard(this.selectedOnRampProvider.url);
      SnackController.showSuccess("Link copied");
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mBuyInProgressView.styles = styles$$;
__decorate$1w([
  r$1()
], W3mBuyInProgressView.prototype, "intervalId", void 0);
__decorate$1w([
  r$1()
], W3mBuyInProgressView.prototype, "selectedOnRampProvider", void 0);
__decorate$1w([
  r$1()
], W3mBuyInProgressView.prototype, "uri", void 0);
__decorate$1w([
  r$1()
], W3mBuyInProgressView.prototype, "ready", void 0);
__decorate$1w([
  r$1()
], W3mBuyInProgressView.prototype, "showRetry", void 0);
__decorate$1w([
  r$1()
], W3mBuyInProgressView.prototype, "buffering", void 0);
__decorate$1w([
  r$1()
], W3mBuyInProgressView.prototype, "error", void 0);
__decorate$1w([
  r$1()
], W3mBuyInProgressView.prototype, "startTime", void 0);
__decorate$1w([
  n$2({ type: Boolean })
], W3mBuyInProgressView.prototype, "isMobile", void 0);
__decorate$1w([
  n$2()
], W3mBuyInProgressView.prototype, "onRetry", void 0);
W3mBuyInProgressView = __decorate$1w([
  customElement("w3m-buy-in-progress-view")
], W3mBuyInProgressView);
const styles$_ = i$5`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    scrollbar-width: none;
    overflow-y: scroll;
    overflow-x: hidden;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }

  .all-wallets {
    flex-flow: column;
  }
`;
var __decorate$1v = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectView = class W3mConnectView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      <wui-flex flexDirection="column" .padding=${["3xs", "s", "s", "s"]}>
        <w3m-email-login-widget></w3m-email-login-widget>
        <w3m-social-login-widget></w3m-social-login-widget>
        ${this.walletListTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  walletListTemplate() {
    const authConnector2 = this.connectors.find((c2) => c2.type === "AUTH");
    if (authConnector2?.socials) {
      if (authConnector2?.showWallets) {
        return x`
          <wui-flex flexDirection="column" gap="xs" .margin=${["xs", "0", "0", "0"]}>
            <w3m-connector-list></w3m-connector-list>
            <wui-flex class="all-wallets">
              <w3m-all-wallets-widget></w3m-all-wallets-widget>
            </wui-flex>
          </wui-flex>
        `;
      }
      return x`<wui-list-button
        @click=${this.onContinueWalletClick.bind(this)}
        text="Continue with a wallet"
      ></wui-list-button>`;
    }
    return x`<w3m-wallet-login-list></w3m-wallet-login-list>`;
  }
  onContinueWalletClick() {
    RouterController.push("ConnectWallets");
  }
};
W3mConnectView.styles = styles$_;
__decorate$1v([
  r$1()
], W3mConnectView.prototype, "connectors", void 0);
W3mConnectView = __decorate$1v([
  customElement("w3m-connect-view")
], W3mConnectView);
const styles$Z = i$5`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition-property: opacity, transform;
    transition-duration: var(--wui-duration-lg);
    transition-timing-function: var(--wui-ease-out-power-2);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`;
var __decorate$1u = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
class W3mConnectingWidget extends i$2 {
  constructor() {
    super();
    this.wallet = RouterController.state.data?.wallet;
    this.connector = RouterController.state.data?.connector;
    this.timeout = void 0;
    this.secondaryBtnLabel = "Try again";
    this.secondaryBtnIcon = "refresh";
    this.secondaryLabel = "Accept connection request in the wallet";
    this.onConnect = void 0;
    this.onRender = void 0;
    this.onAutoConnect = void 0;
    this.isWalletConnect = true;
    this.unsubscribe = [];
    this.imageSrc = AssetUtil.getWalletImage(this.wallet) ?? AssetUtil.getConnectorImage(this.connector);
    this.name = this.wallet?.name ?? this.connector?.name ?? "Wallet";
    this.isRetrying = false;
    this.uri = ConnectionController.state.wcUri;
    this.error = ConnectionController.state.wcError;
    this.ready = false;
    this.showRetry = false;
    this.buffering = false;
    this.isMobile = false;
    this.onRetry = void 0;
    this.unsubscribe.push(...[
      ConnectionController.subscribeKey("wcUri", (val) => {
        this.uri = val;
        if (this.isRetrying && this.onRetry) {
          this.isRetrying = false;
          this.onConnect?.();
        }
      }),
      ConnectionController.subscribeKey("wcError", (val) => this.error = val),
      ConnectionController.subscribeKey("buffering", (val) => this.buffering = val)
    ]);
  }
  firstUpdated() {
    this.onAutoConnect?.();
    this.showRetry = !this.onAutoConnect;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    clearTimeout(this.timeout);
  }
  render() {
    this.onRender?.();
    this.onShowRetry();
    const subLabel = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel;
    let label = `Continue in ${this.name}`;
    if (this.buffering) {
      label = "Connecting...";
    }
    if (this.error) {
      label = "Connection declined";
    }
    return x`
      <wui-flex
        data-error=${o$3(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${o$3(this.imageSrc)}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          variant="accent"
          size="md"
          ?disabled=${!this.error && this.buffering}
          @click=${this.onTryAgain.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
          ${this.secondaryBtnLabel}
        </wui-button>
      </wui-flex>

      ${this.isWalletConnect ? x`
            <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
              <wui-link @click=${this.onCopyUri} color="fg-200">
                <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy link
              </wui-link>
            </wui-flex>
          ` : null}

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onShowRetry() {
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = this.shadowRoot?.querySelector("wui-button");
      retryButton?.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onTryAgain() {
    if (!this.buffering) {
      ConnectionController.setWcError(false);
      if (this.onRetry) {
        this.isRetrying = true;
        this.onRetry?.();
      } else {
        this.onConnect?.();
      }
    }
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return x`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  onCopyUri() {
    try {
      if (this.uri) {
        CoreHelperUtil.copyToClopboard(this.uri);
        SnackController.showSuccess("Link copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
}
W3mConnectingWidget.styles = styles$Z;
__decorate$1u([
  r$1()
], W3mConnectingWidget.prototype, "uri", void 0);
__decorate$1u([
  r$1()
], W3mConnectingWidget.prototype, "error", void 0);
__decorate$1u([
  r$1()
], W3mConnectingWidget.prototype, "ready", void 0);
__decorate$1u([
  r$1()
], W3mConnectingWidget.prototype, "showRetry", void 0);
__decorate$1u([
  r$1()
], W3mConnectingWidget.prototype, "buffering", void 0);
__decorate$1u([
  n$2({ type: Boolean })
], W3mConnectingWidget.prototype, "isMobile", void 0);
__decorate$1u([
  n$2()
], W3mConnectingWidget.prototype, "onRetry", void 0);
var __decorate$1t = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingExternalView = class W3mConnectingExternalView2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.connector) {
      throw new Error("w3m-connecting-view: No connector provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: {
        name: this.connector.name ?? "Unknown",
        platform: "browser"
      }
    });
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    this.isWalletConnect = false;
  }
  async onConnectProxy() {
    try {
      this.error = false;
      if (this.connector) {
        if (this.connector.id !== ConstantsUtil$3.COINBASE_SDK_CONNECTOR_ID || !this.error) {
          await ConnectionController.connectExternal(this.connector, this.connector.chain);
          if (OptionsController.state.isSiweEnabled) {
            RouterController.push("ConnectingSiwe");
          } else {
            ModalController.close();
          }
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: { method: "browser", name: this.connector.name || "Unknown" }
          });
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: error?.message ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingExternalView = __decorate$1t([
  customElement("w3m-connecting-external-view")
], W3mConnectingExternalView);
const styles$Y = i$5`
  wui-flex,
  wui-list-wallet {
    width: 100%;
  }
`;
var __decorate$1s = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingMultiChainView = class W3mConnectingMultiChainView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.activeConnector = ChainController.state.activeConnector;
    this.unsubscribe.push(...[ChainController.subscribeKey("activeConnector", (val) => this.activeConnector = val)]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["m", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image
            size="lg"
            imageSrc=${o$3(AssetUtil.getConnectorImage(this.activeConnector))}
          ></wui-wallet-image>
        </wui-flex>
        <wui-flex
          flexDirection="column"
          alignItems="center"
          gap="xs"
          .padding=${["0", "s", "0", "s"]}
        >
          <wui-text variant="paragraph-500" color="fg-100">
            Select Chain for ${this.activeConnector?.name}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200"
            >Select which chain to connect to your multi chain wallet</wui-text
          >
        </wui-flex>
        <wui-flex
          flexGrow="1"
          flexDirection="column"
          alignItems="center"
          gap="xs"
          .padding=${["xs", "0", "xs", "0"]}
        >
          ${this.networksTemplate()}
        </wui-flex>
      </wui-flex>
    `;
  }
  networksTemplate() {
    return this.activeConnector?.providers?.map((provider) => x`
        <wui-list-wallet
          imageSrc=${o$3(AssetUtil.getChainImage(provider.chain))}
          name=${provider.name}
          @click=${() => this.onConnector(provider)}
        ></wui-list-wallet>
      `);
  }
  onConnector(provider) {
    ChainController.setActiveChain(provider.chain);
    const connector = this.activeConnector?.providers?.find((p2) => p2.chain === provider.chain);
    if (!connector) {
      SnackController.showError("Failed to find connector");
      return;
    }
    if (connector.type === "WALLET_CONNECT") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", { connector });
    }
  }
};
W3mConnectingMultiChainView.styles = styles$Y;
__decorate$1s([
  r$1()
], W3mConnectingMultiChainView.prototype, "activeConnector", void 0);
W3mConnectingMultiChainView = __decorate$1s([
  customElement("w3m-connecting-multi-chain-view")
], W3mConnectingMultiChainView);
var __decorate$1r = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcView = class W3mConnectingWcView2 extends i$2 {
  constructor() {
    super();
    this.interval = void 0;
    this.lastRetry = Date.now();
    this.wallet = RouterController.state.data?.wallet;
    this.platform = void 0;
    this.platforms = [];
    this.determinePlatforms();
    this.initializeConnection();
    this.interval = setInterval(this.initializeConnection.bind(this), ConstantsUtil$1.TEN_SEC_MS);
  }
  disconnectedCallback() {
    clearTimeout(this.interval);
  }
  render() {
    if (!this.wallet) {
      return x`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
    }
    return x`
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
    `;
  }
  async initializeConnection(retry = false) {
    try {
      if (this.platform === "browser") {
        return;
      }
      const { wcPairingExpiry } = ConnectionController.state;
      if (retry || CoreHelperUtil.isPairingExpired(wcPairingExpiry)) {
        await ConnectionController.connectWalletConnect();
        this.finalizeConnection();
        if (StorageUtil.getConnectedConnector() === "AUTH" && OptionsController.state.hasMultipleAddresses) {
          RouterController.push("SelectAddresses");
        } else if (OptionsController.state.isSiweEnabled) {
          const { SIWEController } = await __vitePreload(async () => {
            const { SIWEController: SIWEController2 } = await import("./index-BPfKs9-b.js");
            return { SIWEController: SIWEController2 };
          }, true ? [] : void 0);
          if (SIWEController.state.status === "success") {
            ModalController.close();
          } else {
            RouterController.push("ConnectingSiwe");
          }
        } else {
          ModalController.close();
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: error?.message ?? "Unknown" }
      });
      ConnectionController.setWcError(true);
      if (CoreHelperUtil.isAllowedRetry(this.lastRetry)) {
        SnackController.showError("Declined");
        this.lastRetry = Date.now();
        this.initializeConnection(true);
      }
    }
  }
  finalizeConnection() {
    const { wcLinking, recentWallet } = ConnectionController.state;
    if (wcLinking) {
      StorageUtil.setWalletConnectDeepLink(wcLinking);
    }
    if (recentWallet) {
      StorageUtil.setWeb3ModalRecent(recentWallet);
    }
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      properties: {
        method: wcLinking ? "mobile" : "qrcode",
        name: this.wallet?.name || "Unknown"
      }
    });
  }
  determinePlatforms() {
    if (!this.wallet) {
      this.platforms.push("qrcode");
      this.platform = "qrcode";
      return;
    }
    if (this.platform) {
      return;
    }
    const { mobile_link, desktop_link, webapp_link, injected: injected2, rdns, name } = this.wallet;
    const injectedIds = injected2?.map(({ injected_id }) => injected_id).filter(Boolean);
    const browserIds = [...rdns ? [rdns] : injectedIds ?? [], name];
    const isBrowser2 = OptionsController.state.isUniversalProvider ? false : browserIds.length;
    const isMobileWc = mobile_link;
    const isWebWc = webapp_link;
    const isBrowserInstalled = ConnectionController.checkInstalled(browserIds);
    const isBrowserWc = isBrowser2 && isBrowserInstalled;
    const isDesktopWc = desktop_link && !CoreHelperUtil.isMobile();
    if (isBrowserWc) {
      this.platforms.push("browser");
    }
    if (isMobileWc) {
      this.platforms.push(CoreHelperUtil.isMobile() ? "mobile" : "qrcode");
    }
    if (isWebWc) {
      this.platforms.push("web");
    }
    if (isDesktopWc) {
      this.platforms.push("desktop");
    }
    if (!isBrowserWc && isBrowser2) {
      this.platforms.push("unsupported");
    }
    this.platform = this.platforms[0];
  }
  platformTemplate() {
    switch (this.platform) {
      case "browser":
        return x`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
      case "desktop":
        return x`
          <w3m-connecting-wc-desktop .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-desktop>
        `;
      case "web":
        return x`
          <w3m-connecting-wc-web .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-web>
        `;
      case "mobile":
        return x`
          <w3m-connecting-wc-mobile isMobile .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-mobile>
        `;
      case "qrcode":
        return x`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
      default:
        return x`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`;
    }
  }
  headerTemplate() {
    const multiPlatform = this.platforms.length > 1;
    if (!multiPlatform) {
      return null;
    }
    return x`
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    `;
  }
  async onSelectPlatform(platform) {
    const container = this.shadowRoot?.querySelector("div");
    if (container) {
      await container.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.platform = platform;
      container.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
__decorate$1r([
  r$1()
], W3mConnectingWcView.prototype, "platform", void 0);
__decorate$1r([
  r$1()
], W3mConnectingWcView.prototype, "platforms", void 0);
W3mConnectingWcView = __decorate$1r([
  customElement("w3m-connecting-wc-view")
], W3mConnectingWcView);
const styles$X = i$5`
  .continue-button-container {
    width: 100%;
  }
`;
var __decorate$1q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mChooseAccountNameView = class W3mChooseAccountNameView2 extends i$2 {
  constructor() {
    super(...arguments);
    this.loading = false;
  }
  render() {
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more about names
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
  }
  onboardingTemplate() {
    return x` <wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <wui-flex gap="s" alignItems="center" justifyContent="center">
        <wui-icon-box
          icon="id"
          size="xl"
          iconSize="xxl"
          iconColor="fg-200"
          backgroundColor="fg-200"
        ></wui-icon-box>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-text align="center" variant="medium-600" color="fg-100">
          Choose your account name
        </wui-text>
        <wui-text align="center" variant="paragraph-400" color="fg-100">
          Finally say goodbye to 0x addresses, name your account to make it easier to exchange
          assets
        </wui-text>
      </wui-flex>
    </wui-flex>`;
  }
  buttonsTemplate() {
    return x`<wui-flex
      .padding=${["0", "2l", "0", "2l"]}
      gap="s"
      class="continue-button-container"
    >
      <wui-button
        fullWidth
        .loading=${this.loading}
        size="lg"
        borderRadius="xs"
        @click=${this.handleContinue.bind(this)}
        >Choose name
      </wui-button>
    </wui-flex>`;
  }
  handleContinue() {
    RouterController.push("RegisterAccountName");
    EventsController.sendEvent({
      type: "track",
      event: "OPEN_ENS_FLOW",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
  }
};
W3mChooseAccountNameView.styles = styles$X;
__decorate$1q([
  r$1()
], W3mChooseAccountNameView.prototype, "loading", void 0);
W3mChooseAccountNameView = __decorate$1q([
  customElement("w3m-choose-account-name-view")
], W3mChooseAccountNameView);
var __decorate$1p = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mDownloadsView = class W3mDownloadsView2 extends i$2 {
  constructor() {
    super(...arguments);
    this.wallet = RouterController.state.data?.wallet;
  }
  render() {
    if (!this.wallet) {
      throw new Error("w3m-downloads-view");
    }
    return x`
      <wui-flex gap="xs" flexDirection="column" .padding=${["s", "s", "l", "s"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `;
  }
  chromeTemplate() {
    if (!this.wallet?.chrome_store) {
      return null;
    }
    return x`<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>`;
  }
  iosTemplate() {
    if (!this.wallet?.app_store) {
      return null;
    }
    return x`<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>`;
  }
  androidTemplate() {
    if (!this.wallet?.play_store) {
      return null;
    }
    return x`<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>`;
  }
  homepageTemplate() {
    if (!this.wallet?.homepage) {
      return null;
    }
    return x`
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    `;
  }
  onChromeStore() {
    if (this.wallet?.chrome_store) {
      CoreHelperUtil.openHref(this.wallet.chrome_store, "_blank");
    }
  }
  onAppStore() {
    if (this.wallet?.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    if (this.wallet?.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    if (this.wallet?.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mDownloadsView = __decorate$1p([
  customElement("w3m-downloads-view")
], W3mDownloadsView);
var __decorate$1o = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const EXPLORER = "https://walletconnect.com/explorer";
let W3mGetWalletView = class W3mGetWalletView2 extends i$2 {
  render() {
    return x`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.recommendedWalletsTemplate()}
        <wui-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          @click=${() => {
      CoreHelperUtil.openHref("https://walletconnect.com/explorer?type=wallet", "_blank");
    }}
        ></wui-list-wallet>
      </wui-flex>
    `;
  }
  recommendedWalletsTemplate() {
    const { recommended, featured } = ApiController.state;
    const { customWallets } = OptionsController.state;
    const wallets = [...featured, ...customWallets ?? [], ...recommended].slice(0, 4);
    return wallets.map((wallet) => x`
        <wui-list-wallet
          name=${wallet.name ?? "Unknown"}
          tagVariant="main"
          imageSrc=${o$3(AssetUtil.getWalletImage(wallet))}
          @click=${() => {
      CoreHelperUtil.openHref(wallet.homepage ?? EXPLORER, "_blank");
    }}
        ></wui-list-wallet>
      `);
  }
};
W3mGetWalletView = __decorate$1o([
  customElement("w3m-get-wallet-view")
], W3mGetWalletView);
const styles$W = i$5`
  wui-flex {
    width: 100%;
  }

  .suggestion {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }

  .suggestion:hover {
    background-color: var(--wui-color-gray-glass-005);
    cursor: pointer;
  }

  .suggested-name {
    max-width: 75%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  form {
    width: 100%;
  }

  wui-icon-link {
    position: absolute;
    right: 20px;
    transform: translateY(11px);
  }
`;
var __decorate$1n = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mRegisterAccountNameView = class W3mRegisterAccountNameView2 extends i$2 {
  constructor() {
    super();
    this.formRef = e();
    this.usubscribe = [];
    this.name = "";
    this.error = "";
    this.loading = EnsController.state.loading;
    this.suggestions = EnsController.state.suggestions;
    this.registered = false;
    this.profileName = AccountController.state.profileName;
    this.onDebouncedNameInputChange = CoreHelperUtil.debounce((value) => {
      if (EnsController.validateName(value)) {
        this.error = "";
        this.name = value;
        EnsController.getSuggestions(value);
        EnsController.isNameRegistered(value).then((registered) => {
          this.registered = registered;
        });
      } else if (value.length < 4) {
        this.error = "Name must be at least 4 characters long";
      } else {
        this.error = "Can only contain letters, numbers and - characters";
      }
    });
    this.usubscribe.push(...[
      EnsController.subscribe((val) => {
        this.suggestions = val.suggestions;
        this.loading = val.loading;
      }),
      AccountController.subscribeKey("profileName", (val) => {
        this.profileName = val;
        if (val) {
          this.error = "You already own a name";
        }
      })
    ]);
  }
  firstUpdated() {
    this.formRef.value?.addEventListener("keydown", this.onEnterKey.bind(this));
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.usubscribe.forEach((unsub) => unsub());
    this.formRef.value?.removeEventListener("keydown", this.onEnterKey.bind(this));
  }
  render() {
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="m"
        .padding=${["0", "s", "m", "s"]}
      >
        <form ${n2(this.formRef)} @submit=${this.onSubmitName.bind(this)}>
          <wui-ens-input
            @inputChange=${this.onNameInputChange.bind(this)}
            .errorMessage=${this.error}
            .value=${this.name}
          >
          </wui-ens-input>
          ${this.submitButtonTemplate()}
          <input type="submit" hidden />
        </form>
        ${this.templateSuggestions()}
      </wui-flex>
    `;
  }
  submitButtonTemplate() {
    const showSubmit = this.isAllowedToSubmit();
    return showSubmit ? x`
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitName.bind(this)}
          >
          </wui-icon-link>
        ` : null;
  }
  onSelectSuggestion(name) {
    return () => {
      this.name = name;
      this.registered = false;
      this.requestUpdate();
    };
  }
  onNameInputChange(event) {
    this.onDebouncedNameInputChange(event.detail);
  }
  nameSuggestionTagTemplate() {
    if (this.loading) {
      return x`<wui-loading-spinner size="lg" color="fg-100"></wui-loading-spinner>`;
    }
    return this.registered ? x`<wui-tag variant="shade" size="lg">Registered</wui-tag>` : x`<wui-tag variant="success" size="lg">Available</wui-tag>`;
  }
  templateSuggestions() {
    if (!this.name || this.name.length < 4 || this.error) {
      return null;
    }
    const suggestions = this.registered ? this.suggestions.filter((s2) => s2.name !== this.name) : [];
    return x`<wui-flex flexDirection="column" gap="xxs" alignItems="center">
      <wui-flex
        data-testid="account-name-suggestion"
        .padding=${["m", "m", "m", "m"]}
        justifyContent="space-between"
        class="suggestion"
      >
        <wui-text color="fg-100" variant="paragraph-400" class="suggested-name">
          ${this.name}</wui-text
        >${this.nameSuggestionTagTemplate()}
      </wui-flex>
      ${suggestions.map((suggestion) => this.availableNameTemplate(suggestion.name))}
    </wui-flex>`;
  }
  availableNameTemplate(suggestion) {
    return x` <wui-flex
      data-testid="account-name-suggestion"
      .padding=${["m", "m", "m", "m"]}
      justifyContent="space-between"
      class="suggestion"
      @click=${this.onSelectSuggestion(suggestion)}
    >
      <wui-text color="fg-100" variant="paragraph-400" class="suggested-name">
        ${suggestion}
      </wui-text>
      <wui-tag variant="success" size="lg">Available</wui-tag>
    </wui-flex>`;
  }
  isAllowedToSubmit() {
    return !this.loading && !this.registered && !this.error && !this.profileName && EnsController.validateName(this.name);
  }
  async onSubmitName() {
    try {
      if (!this.isAllowedToSubmit()) {
        return;
      }
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName: this.name
        }
      });
      await EnsController.registerName(this.name);
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_SUCCESS",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName: this.name
        }
      });
    } catch (error) {
      SnackController.showError(error.message);
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_ERROR",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName: this.name,
          error: error?.message || "Unknown error"
        }
      });
    }
  }
  onEnterKey(event) {
    if (event.key === "Enter" && this.isAllowedToSubmit()) {
      this.onSubmitName();
    }
  }
};
W3mRegisterAccountNameView.styles = styles$W;
__decorate$1n([
  n$2()
], W3mRegisterAccountNameView.prototype, "errorMessage", void 0);
__decorate$1n([
  r$1()
], W3mRegisterAccountNameView.prototype, "name", void 0);
__decorate$1n([
  r$1()
], W3mRegisterAccountNameView.prototype, "error", void 0);
__decorate$1n([
  r$1()
], W3mRegisterAccountNameView.prototype, "loading", void 0);
__decorate$1n([
  r$1()
], W3mRegisterAccountNameView.prototype, "suggestions", void 0);
__decorate$1n([
  r$1()
], W3mRegisterAccountNameView.prototype, "registered", void 0);
__decorate$1n([
  r$1()
], W3mRegisterAccountNameView.prototype, "profileName", void 0);
W3mRegisterAccountNameView = __decorate$1n([
  customElement("w3m-register-account-name-view")
], W3mRegisterAccountNameView);
const styles$V = i$5`
  .continue-button-container {
    width: 100%;
  }
`;
var __decorate$1m = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mRegisterAccountNameSuccess = class W3mRegisterAccountNameSuccess2 extends i$2 {
  render() {
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
  }
  onboardingTemplate() {
    return x` <wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <wui-flex gap="s" alignItems="center" justifyContent="center">
        <wui-icon-box
          size="xl"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-text align="center" variant="medium-600" color="fg-100">
          Account name chosen successfully
        </wui-text>
        <wui-text align="center" variant="paragraph-400" color="fg-100">
          You can now fund your account and trade crypto
        </wui-text>
      </wui-flex>
    </wui-flex>`;
  }
  buttonsTemplate() {
    return x`<wui-flex
      .padding=${["0", "2l", "0", "2l"]}
      gap="s"
      class="continue-button-container"
    >
      <wui-button fullWidth size="lg" borderRadius="xs" @click=${this.redirectToAccount.bind(this)}
        >Let's Go!
      </wui-button>
    </wui-flex>`;
  }
  redirectToAccount() {
    RouterController.replace("Account");
  }
};
W3mRegisterAccountNameSuccess.styles = styles$V;
W3mRegisterAccountNameSuccess = __decorate$1m([
  customElement("w3m-register-account-name-success-view")
], W3mRegisterAccountNameSuccess);
const styles$U = i$5`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
  }

  wui-button {
    display: none;
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;
const NetworkUtil = {
  onNetworkChange: async () => {
    if (OptionsController.state.isSiweEnabled) {
      const { SIWEController } = await __vitePreload(async () => {
        const { SIWEController: SIWEController2 } = await import("./index-BPfKs9-b.js");
        return { SIWEController: SIWEController2 };
      }, true ? [] : void 0);
      if (SIWEController.state._client?.options?.signOutOnNetworkChange) {
        await SIWEController.signOut();
      } else {
        RouterUtil.navigateAfterNetworkSwitch();
      }
    } else {
      RouterUtil.navigateAfterNetworkSwitch();
    }
  }
};
var __decorate$1l = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mNetworkSwitchView = class W3mNetworkSwitchView2 extends i$2 {
  constructor() {
    super();
    this.network = RouterController.state.data?.network;
    this.unsubscribe = [];
    this.showRetry = false;
    this.error = false;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    this.onSwitchNetwork();
  }
  render() {
    if (!this.network) {
      throw new Error("w3m-network-switch-view: No network provided");
    }
    this.onShowRetry();
    const label = this.getLabel();
    const subLabel = this.getSubLabel();
    return x`
      <wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-network-image
            size="lg"
            imageSrc=${o$3(AssetUtil.getNetworkImage(this.network))}
          ></wui-network-image>

          ${this.error ? null : x`<wui-loading-hexagon></wui-loading-hexagon>`}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            ?border=${true}
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">${label}</wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          data-retry=${this.showRetry}
          variant="accent"
          size="md"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
          Try again
        </wui-button>
      </wui-flex>
    `;
  }
  getSubLabel() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector2 = ConnectorController.getAuthConnector();
    if (authConnector2 && type === "AUTH") {
      return "";
    }
    return this.error ? "Switch can be declined if chain is not supported by a wallet or previous request is still active" : "Accept connection request in your wallet";
  }
  getLabel() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector2 = ConnectorController.getAuthConnector();
    if (authConnector2 && type === "AUTH") {
      return `Switching to ${this.network?.name ?? "Unknown"} network...`;
    }
    return this.error ? "Switch declined" : "Approve in wallet";
  }
  onShowRetry() {
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = this.shadowRoot?.querySelector("wui-button");
      retryButton?.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onSwitchNetwork() {
    try {
      this.error = false;
      if (this.network) {
        await NetworkController.switchActiveNetwork(this.network);
        await NetworkUtil.onNetworkChange();
      }
    } catch {
      this.error = true;
    }
  }
};
W3mNetworkSwitchView.styles = styles$U;
__decorate$1l([
  r$1()
], W3mNetworkSwitchView.prototype, "showRetry", void 0);
__decorate$1l([
  r$1()
], W3mNetworkSwitchView.prototype, "error", void 0);
W3mNetworkSwitchView = __decorate$1l([
  customElement("w3m-network-switch-view")
], W3mNetworkSwitchView);
const styles$T = i$5`
  .container {
    max-height: 360px;
    overflow: auto;
  }

  .container::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$1k = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mNetworksView = class W3mNetworksView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.network = NetworkController.state.caipNetwork;
    this.requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    }, 100);
    this.unsubscribe.push(NetworkController.subscribeKey("caipNetwork", (val) => this.network = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      ${this.templateSearchInput()}
      <wui-flex
        class="container"
        .padding=${["0", "s", "s", "s"]}
        flexDirection="column"
        gap="xs"
      >
        ${this.networksTemplate()}
      </wui-flex>

      <wui-separator></wui-separator>

      <wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
        <wui-text variant="small-400" color="fg-300" align="center">
          Your connected wallet may not support some of the networks available for this dApp
        </wui-text>
        <wui-link @click=${this.onNetworkHelp.bind(this)}>
          <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
          What is a network
        </wui-link>
      </wui-flex>
    `;
  }
  templateSearchInput() {
    return x`
      <wui-flex gap="xs" .padding=${["0", "s", "s", "s"]}>
        <wui-input-text
          @inputChange=${this.onInputChange.bind(this)}
          class="network-search-input"
          size="md"
          placeholder="Search network"
          icon="search"
        ></wui-input-text>
      </wui-flex>
    `;
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  onNetworkHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_NETWORK_HELP" });
    RouterController.push("WhatIsANetwork");
  }
  networksTemplate() {
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const approvedCaipNetworkIds = NetworkController.state.approvedCaipNetworkIds;
    const supportsAllNetworks = NetworkController.state.supportsAllNetworks;
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    if (this.search) {
      this.filteredNetworks = sortedNetworks?.filter((network) => network?.name?.toLowerCase().includes(this.search.toLowerCase()));
    } else {
      this.filteredNetworks = sortedNetworks;
    }
    return this.filteredNetworks?.map((network) => x`
        <wui-list-network
          .selected=${this.network?.id === network.id}
          imageSrc=${o$3(AssetUtil.getNetworkImage(network))}
          type="network"
          name=${network.name ?? network.id}
          @click=${() => this.onSwitchNetwork(network)}
          .disabled=${!supportsAllNetworks && !approvedCaipNetworkIds?.includes(network.id) && network.chain === ChainController.state.activeChain}
          data-testid=${`w3m-network-switch-${network.name ?? network.id}`}
        ></wui-list-network>
      `);
  }
  async onSwitchNetwork(network) {
    const isConnected = AccountController.state.isConnected;
    const isNetworkChainConnected = AccountController.getChainIsConnected(network.chain);
    const approvedCaipNetworkIds = NetworkController.state.approvedCaipNetworkIds;
    const supportsAllNetworks = NetworkController.state.supportsAllNetworks;
    const caipNetwork = NetworkController.state.caipNetwork;
    const routerData = RouterController.state.data;
    if (isConnected && caipNetwork?.id !== network.id) {
      if (!isNetworkChainConnected) {
        RouterController.push("SwitchActiveChain", {
          switchToChain: network.chain,
          navigateTo: "Connect",
          navigateWithReplace: true
        });
        return;
      }
      if (approvedCaipNetworkIds?.includes(network.id)) {
        await NetworkController.switchActiveNetwork(network);
        await NetworkUtil.onNetworkChange();
      } else if (supportsAllNetworks) {
        RouterController.push("SwitchNetwork", { ...routerData, network });
      }
    } else if (!isConnected) {
      NetworkController.setActiveCaipNetwork(network);
      if (!isNetworkChainConnected) {
        RouterController.push("Connect");
      }
    }
  }
};
W3mNetworksView.styles = styles$T;
__decorate$1k([
  r$1()
], W3mNetworksView.prototype, "network", void 0);
__decorate$1k([
  r$1()
], W3mNetworksView.prototype, "requestedCaipNetworks", void 0);
__decorate$1k([
  r$1()
], W3mNetworksView.prototype, "filteredNetworks", void 0);
__decorate$1k([
  r$1()
], W3mNetworksView.prototype, "search", void 0);
W3mNetworksView = __decorate$1k([
  customElement("w3m-networks-view")
], W3mNetworksView);
const styles$S = i$5`
  :host > wui-flex {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
    padding: var(--wui-spacing-m);
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: flex-start;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }

  :host > wui-flex > wui-flex {
    width: 100%;
  }

  wui-transaction-list-item-loader {
    width: 100%;
  }
`;
var __decorate$1j = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const LOADING_ITEM_COUNT$1 = 7;
let W3mOnRampActivityView = class W3mOnRampActivityView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedOnRampProvider = OnRampController.state.selectedProvider;
    this.loading = false;
    this.coinbaseTransactions = TransactionsController.state.coinbaseTransactions;
    this.tokenImages = AssetController.state.tokenImages;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("selectedProvider", (val) => {
        this.selectedOnRampProvider = val;
      }),
      AssetController.subscribeKey("tokenImages", (val) => this.tokenImages = val),
      () => {
        clearTimeout(this.refetchTimeout);
      },
      TransactionsController.subscribe((val) => {
        this.coinbaseTransactions = { ...val.coinbaseTransactions };
      })
    ]);
    TransactionsController.clearCursor();
    this.fetchTransactions();
  }
  render() {
    return x`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.loading ? this.templateLoading() : this.templateTransactionsByYear()}
      </wui-flex>
    `;
  }
  templateTransactions(transactions) {
    return transactions?.map((transaction) => {
      const date = DateUtil.formatDate(transaction?.metadata?.minedAt);
      const transfer = transaction.transfers[0];
      const fungibleInfo = transfer?.fungible_info;
      if (!fungibleInfo) {
        return null;
      }
      const icon = fungibleInfo?.icon?.url || this.tokenImages?.[fungibleInfo.symbol || ""];
      return x`
        <w3m-onramp-activity-item
          label="Bought"
          .completed=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_SUCCESS"}
          .inProgress=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS"}
          .failed=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_FAILED"}
          purchaseCurrency=${o$3(fungibleInfo.symbol)}
          purchaseValue=${transfer.quantity.numeric}
          date=${date}
          icon=${o$3(icon)}
          symbol=${o$3(fungibleInfo.symbol)}
        ></w3m-onramp-activity-item>
      `;
    });
  }
  templateTransactionsByYear() {
    const sortedYearKeys = Object.keys(this.coinbaseTransactions).sort().reverse();
    return sortedYearKeys.map((year) => {
      const yearInt = parseInt(year, 10);
      const sortedMonthIndexes = new Array(12).fill(null).map((_2, idx) => idx).reverse();
      return sortedMonthIndexes.map((month) => {
        const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt, month);
        const transactions = this.coinbaseTransactions[yearInt]?.[month];
        if (!transactions) {
          return null;
        }
        return x`
          <wui-flex flexDirection="column">
            <wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${["xs", "s", "s", "s"]}
            >
              <wui-text variant="paragraph-500" color="fg-200">${groupTitle}</wui-text>
            </wui-flex>
            <wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(transactions)}
            </wui-flex>
          </wui-flex>
        `;
      });
    });
  }
  async fetchTransactions() {
    {
      await this.fetchCoinbaseTransactions();
    }
  }
  async fetchCoinbaseTransactions() {
    const address = AccountController.state.address;
    const projectId2 = OptionsController.state.projectId;
    if (!address) {
      throw new Error("No address found");
    }
    if (!projectId2) {
      throw new Error("No projectId found");
    }
    this.loading = true;
    await TransactionsController.fetchTransactions(address, "coinbase");
    this.loading = false;
    this.refetchLoadingTransactions();
  }
  refetchLoadingTransactions() {
    const today = /* @__PURE__ */ new Date();
    const currentMonthTxs = this.coinbaseTransactions[today.getFullYear()]?.[today.getMonth()] || [];
    const loadingTransactions = currentMonthTxs.filter((transaction) => transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS");
    if (loadingTransactions.length === 0) {
      clearTimeout(this.refetchTimeout);
      return;
    }
    this.refetchTimeout = setTimeout(async () => {
      const address = AccountController.state.address;
      await TransactionsController.fetchTransactions(address, "coinbase");
      this.refetchLoadingTransactions();
    }, 3e3);
  }
  templateLoading() {
    return Array(LOADING_ITEM_COUNT$1).fill(x` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map((item) => item);
  }
};
W3mOnRampActivityView.styles = styles$S;
__decorate$1j([
  r$1()
], W3mOnRampActivityView.prototype, "selectedOnRampProvider", void 0);
__decorate$1j([
  r$1()
], W3mOnRampActivityView.prototype, "loading", void 0);
__decorate$1j([
  r$1()
], W3mOnRampActivityView.prototype, "coinbaseTransactions", void 0);
__decorate$1j([
  r$1()
], W3mOnRampActivityView.prototype, "tokenImages", void 0);
W3mOnRampActivityView = __decorate$1j([
  customElement("w3m-onramp-activity-view")
], W3mOnRampActivityView);
const styles$R = i$5`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$1i = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mOnrampFiatSelectView = class W3mOnrampFiatSelectView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedCurrency = OnRampController.state.paymentCurrency;
    this.currencies = OnRampController.state.paymentCurrencies;
    this.currencyImages = AssetController.state.currencyImages;
    this.unsubscribe.push(...[
      OnRampController.subscribe((val) => {
        this.selectedCurrency = val.paymentCurrency;
        this.currencies = val.paymentCurrencies;
      }),
      AssetController.subscribeKey("currencyImages", (val) => this.currencyImages = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.currenciesTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  currenciesTemplate() {
    return this.currencies.map((currency) => x`
        <wui-list-item
          imageSrc=${o$3(this.currencyImages?.[currency.id])}
          @click=${() => this.selectCurrency(currency)}
          variant="image"
        >
          <wui-text variant="paragraph-500" color="fg-100">${currency.id}</wui-text>
        </wui-list-item>
      `);
  }
  selectCurrency(currency) {
    if (!currency) {
      return;
    }
    OnRampController.setPaymentCurrency(currency);
    ModalController.close();
  }
};
W3mOnrampFiatSelectView.styles = styles$R;
__decorate$1i([
  r$1()
], W3mOnrampFiatSelectView.prototype, "selectedCurrency", void 0);
__decorate$1i([
  r$1()
], W3mOnrampFiatSelectView.prototype, "currencies", void 0);
__decorate$1i([
  r$1()
], W3mOnrampFiatSelectView.prototype, "currencyImages", void 0);
W3mOnrampFiatSelectView = __decorate$1i([
  customElement("w3m-onramp-fiat-select-view")
], W3mOnrampFiatSelectView);
var __decorate$1h = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mOnRampProvidersView = class W3mOnRampProvidersView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.providers = OnRampController.state.providers;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("providers", (val) => {
        this.providers = val;
      })
    ]);
  }
  firstUpdated() {
    const urlPromises = this.providers.map(async (provider) => {
      if (provider.name === "coinbase") {
        return await this.getCoinbaseOnRampURL();
      }
      return Promise.resolve(provider?.url);
    });
    Promise.all(urlPromises).then((urls) => {
      this.providers = this.providers.map((provider, index2) => ({
        ...provider,
        url: urls[index2] || ""
      }));
    });
  }
  render() {
    return x`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.onRampProvidersTemplate()}
      </wui-flex>
      <w3m-onramp-providers-footer></w3m-onramp-providers-footer>
    `;
  }
  onRampProvidersTemplate() {
    return this.providers.filter((provider) => provider.supportedChains.includes(ChainController.state.activeChain ?? "evm")).map((provider) => x`
          <w3m-onramp-provider-item
            label=${provider.label}
            name=${provider.name}
            feeRange=${provider.feeRange}
            @click=${() => {
      this.onClickProvider(provider);
    }}
            ?disabled=${!provider.url}
          ></w3m-onramp-provider-item>
        `);
  }
  onClickProvider(provider) {
    OnRampController.setSelectedProvider(provider);
    RouterController.push("BuyInProgress");
    CoreHelperUtil.openHref(provider.url, "popupWindow", "width=600,height=800,scrollbars=yes");
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_BUY_PROVIDER",
      properties: {
        provider: provider.name,
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
  }
  async getCoinbaseOnRampURL() {
    const address = AccountController.state.address;
    const network = NetworkController.state.caipNetwork;
    if (!address) {
      throw new Error("No address found");
    }
    if (!network?.name) {
      throw new Error("No network found");
    }
    const defaultNetwork = ConstantsUtil$1.WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP[network.name] ?? ConstantsUtil$1.WC_COINBASE_PAY_SDK_FALLBACK_CHAIN;
    const purchaseCurrency = OnRampController.state.purchaseCurrency;
    const assets = purchaseCurrency ? [purchaseCurrency.symbol] : OnRampController.state.purchaseCurrencies.map((currency) => currency.symbol);
    return await BlockchainApiController.generateOnRampURL({
      defaultNetwork,
      destinationWallets: [
        { address, blockchains: ConstantsUtil$1.WC_COINBASE_PAY_SDK_CHAINS, assets }
      ],
      partnerUserId: address,
      purchaseAmount: OnRampController.state.purchaseAmount
    });
  }
};
__decorate$1h([
  r$1()
], W3mOnRampProvidersView.prototype, "providers", void 0);
W3mOnRampProvidersView = __decorate$1h([
  customElement("w3m-onramp-providers-view")
], W3mOnRampProvidersView);
const styles$Q = i$5`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$1g = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mOnrampTokensView = class W3mOnrampTokensView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedCurrency = OnRampController.state.purchaseCurrencies;
    this.tokens = OnRampController.state.purchaseCurrencies;
    this.tokenImages = AssetController.state.tokenImages;
    this.unsubscribe.push(...[
      OnRampController.subscribe((val) => {
        this.selectedCurrency = val.purchaseCurrencies;
        this.tokens = val.purchaseCurrencies;
      }),
      AssetController.subscribeKey("tokenImages", (val) => this.tokenImages = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.currenciesTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  currenciesTemplate() {
    return this.tokens.map((token2) => x`
        <wui-list-item
          imageSrc=${o$3(this.tokenImages?.[token2.symbol])}
          @click=${() => this.selectToken(token2)}
          variant="image"
        >
          <wui-flex gap="3xs" alignItems="center">
            <wui-text variant="paragraph-500" color="fg-100">${token2.name}</wui-text>
            <wui-text variant="small-400" color="fg-200">${token2.symbol}</wui-text>
          </wui-flex>
        </wui-list-item>
      `);
  }
  selectToken(currency) {
    if (!currency) {
      return;
    }
    OnRampController.setPurchaseCurrency(currency);
    ModalController.close();
  }
};
W3mOnrampTokensView.styles = styles$Q;
__decorate$1g([
  r$1()
], W3mOnrampTokensView.prototype, "selectedCurrency", void 0);
__decorate$1g([
  r$1()
], W3mOnrampTokensView.prototype, "tokens", void 0);
__decorate$1g([
  r$1()
], W3mOnrampTokensView.prototype, "tokenImages", void 0);
W3mOnrampTokensView = __decorate$1g([
  customElement("w3m-onramp-token-select-view")
], W3mOnrampTokensView);
const styles$P = i$5`
  :host > wui-flex:first-child {
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  .action-button {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
  }

  .action-button:disabled {
    border-color: 1px solid var(--wui-color-gray-glass-005);
  }

  .swap-inputs-container {
    position: relative;
  }

  .replace-tokens-button-container {
    display: flex;
    justify-content: center;
    align-items: center;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    gap: var(--wui-spacing-1xs);
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-color-modal-bg-base);
    padding: var(--wui-spacing-xxs);
  }

  .replace-tokens-button-container > button {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 40px;
    width: 40px;
    padding: var(--wui-spacing-xs);
    border: none;
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-duration-md) var(--wui-ease-out-power-1);
    will-change: background-color;
    z-index: 20;
  }

  .replace-tokens-button-container > button:hover {
    background: var(--wui-color-gray-glass-005);
  }

  .details-container > wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    transition: background 0.2s linear;
  }

  .details-container > wui-flex > button:hover {
    background: var(--wui-color-gray-glass-002);
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }
`;
var __decorate$1f = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mSwapView = class W3mSwapView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.detailsOpen = false;
    this.caipNetworkId = NetworkController.state.caipNetwork?.id;
    this.initialized = SwapController.state.initialized;
    this.loadingQuote = SwapController.state.loadingQuote;
    this.loadingPrices = SwapController.state.loadingPrices;
    this.loadingTransaction = SwapController.state.loadingTransaction;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount;
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount;
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.inputError = SwapController.state.inputError;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.fetchError = SwapController.state.fetchError;
    this.onDebouncedGetSwapCalldata = CoreHelperUtil.debounce(async () => {
      await SwapController.swapTokens();
    }, 200);
    NetworkController.subscribeKey("caipNetwork", (newCaipNetwork) => {
      if (this.caipNetworkId !== newCaipNetwork?.id) {
        this.caipNetworkId = newCaipNetwork?.id;
        SwapController.resetState();
        SwapController.initializeState();
      }
    });
    this.unsubscribe.push(...[
      ModalController.subscribeKey("open", (isOpen) => {
        if (!isOpen) {
          SwapController.resetState();
        }
      }),
      RouterController.subscribeKey("view", (newRoute) => {
        if (!newRoute.includes("Swap")) {
          SwapController.resetValues();
        }
      }),
      SwapController.subscribe((newState) => {
        this.initialized = newState.initialized;
        this.loadingQuote = newState.loadingQuote;
        this.loadingPrices = newState.loadingPrices;
        this.loadingTransaction = newState.loadingTransaction;
        this.sourceToken = newState.sourceToken;
        this.sourceTokenAmount = newState.sourceTokenAmount;
        this.sourceTokenPriceInUSD = newState.sourceTokenPriceInUSD;
        this.toToken = newState.toToken;
        this.toTokenAmount = newState.toTokenAmount;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.inputError = newState.inputError;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.fetchError = newState.fetchError;
      })
    ]);
  }
  firstUpdated() {
    SwapController.initializeState();
    this.watchTokensAndValues();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe?.());
    clearInterval(this.interval);
  }
  render() {
    return x`
      <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]} gap="s">
        ${this.initialized ? this.templateSwap() : this.templateLoading()}
      </wui-flex>
    `;
  }
  watchTokensAndValues() {
    this.interval = setInterval(() => {
      SwapController.getNetworkTokenPrice();
      SwapController.getMyTokensWithBalance();
      SwapController.swapTokens();
    }, 1e4);
  }
  templateSwap() {
    return x`
      <wui-flex flexDirection="column" gap="s">
        <wui-flex flexDirection="column" alignItems="center" gap="xs" class="swap-inputs-container">
          ${this.templateTokenInput("sourceToken", this.sourceToken)}
          ${this.templateTokenInput("toToken", this.toToken)} ${this.templateReplaceTokensButton()}
        </wui-flex>
        ${this.templateDetails()} ${this.templateActionButton()}
      </wui-flex>
    `;
  }
  actionButtonLabel() {
    if (this.fetchError) {
      return "Swap";
    }
    if (!this.sourceToken || !this.toToken) {
      return "Select token";
    }
    if (!this.sourceTokenAmount) {
      return "Enter amount";
    }
    if (this.inputError) {
      return this.inputError;
    }
    return "Review swap";
  }
  templateReplaceTokensButton() {
    return x`
      <wui-flex class="replace-tokens-button-container">
        <button @click=${this.onSwitchTokens.bind(this)}>
          <wui-icon name="recycleHorizontal" color="fg-250" size="lg"></wui-icon>
        </button>
      </wui-flex>
    `;
  }
  templateLoading() {
    return x`
      <wui-flex flexDirection="column" gap="l">
        <wui-flex flexDirection="column" alignItems="center" gap="xs" class="swap-inputs-container">
          <w3m-swap-input-skeleton target="sourceToken"></w3m-swap-input-skeleton>
          <w3m-swap-input-skeleton target="toToken"></w3m-swap-input-skeleton>
          ${this.templateReplaceTokensButton()}
        </wui-flex>
        ${this.templateActionButton()}
      </wui-flex>
    `;
  }
  templateTokenInput(target, token2) {
    const myToken = SwapController.state.myTokensWithBalance?.find((ct) => ct?.address === token2?.address);
    const amount = target === "toToken" ? this.toTokenAmount : this.sourceTokenAmount;
    const price = target === "toToken" ? this.toTokenPriceInUSD : this.sourceTokenPriceInUSD;
    let value = parseFloat(amount) * price;
    if (target === "toToken") {
      value -= this.gasPriceInUSD || 0;
    }
    return x`<w3m-swap-input
      .value=${target === "toToken" ? this.toTokenAmount : this.sourceTokenAmount}
      ?disabled=${this.loadingQuote && target === "toToken"}
      .onSetAmount=${this.handleChangeAmount.bind(this)}
      target=${target}
      .token=${token2}
      .balance=${myToken?.quantity?.numeric}
      .price=${myToken?.price}
      .marketValue=${value}
      .onSetMaxValue=${this.onSetMaxValue.bind(this)}
    ></w3m-swap-input>`;
  }
  onSetMaxValue(target, balance) {
    const token2 = target === "sourceToken" ? this.sourceToken : this.toToken;
    const isNetworkToken = token2?.address === NetworkController.getActiveNetworkTokenAddress();
    let value = "0";
    if (!balance) {
      value = "0";
      this.handleChangeAmount(target, value);
      return;
    }
    if (!this.gasPriceInUSD) {
      value = balance;
      this.handleChangeAmount(target, value);
      return;
    }
    const amountOfTokenGasRequires = NumberUtil.bigNumber(this.gasPriceInUSD.toFixed(5)).dividedBy(this.sourceTokenPriceInUSD);
    const maxValue = isNetworkToken ? NumberUtil.bigNumber(balance).minus(amountOfTokenGasRequires) : NumberUtil.bigNumber(balance);
    this.handleChangeAmount(target, maxValue.isGreaterThan(0) ? maxValue.toFixed(20) : "0");
  }
  templateDetails() {
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    return x`<w3m-swap-details .detailsOpen=${this.detailsOpen}></w3m-swap-details>`;
  }
  handleChangeAmount(target, value) {
    SwapController.clearError();
    if (target === "sourceToken") {
      SwapController.setSourceTokenAmount(value);
    } else {
      SwapController.setToTokenAmount(value);
    }
    this.onDebouncedGetSwapCalldata();
  }
  templateActionButton() {
    const haveNoTokenSelected = !this.toToken || !this.sourceToken;
    const haveNoAmount = !this.sourceTokenAmount;
    const loading = this.loadingQuote || this.loadingPrices || this.loadingTransaction;
    const disabled = loading || haveNoTokenSelected || haveNoAmount || this.inputError;
    return x` <wui-flex gap="xs">
      <wui-button
        data-testid="swap-action-button"
        class="action-button"
        fullWidth
        size="lg"
        borderRadius="xs"
        variant=${haveNoTokenSelected ? "neutral" : "main"}
        .loading=${loading}
        .disabled=${disabled}
        @click=${this.onSwapPreview.bind(this)}
      >
        ${this.actionButtonLabel()}
      </wui-button>
    </wui-flex>`;
  }
  onSwitchTokens() {
    SwapController.switchTokens();
  }
  onSwapPreview() {
    if (this.fetchError) {
      SwapController.swapTokens();
      return;
    }
    EventsController.sendEvent({
      type: "track",
      event: "INITIATE_SWAP",
      properties: {
        network: this.caipNetworkId || "",
        swapFromToken: this.sourceToken?.symbol || "",
        swapToToken: this.toToken?.symbol || "",
        swapFromAmount: this.sourceTokenAmount || "",
        swapToAmount: this.toTokenAmount || "",
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("SwapPreview");
  }
};
W3mSwapView.styles = styles$P;
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "interval", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "detailsOpen", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "caipNetworkId", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "initialized", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "loadingQuote", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "loadingPrices", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "loadingTransaction", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "sourceToken", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "sourceTokenAmount", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "sourceTokenPriceInUSD", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "toToken", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "toTokenAmount", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "toTokenPriceInUSD", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "inputError", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "gasPriceInUSD", void 0);
__decorate$1f([
  r$1()
], W3mSwapView.prototype, "fetchError", void 0);
W3mSwapView = __decorate$1f([
  customElement("w3m-swap-view")
], W3mSwapView);
const styles$O = i$5`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-visual {
    width: var(--wui-wallet-image-size-lg);
    height: var(--wui-wallet-image-size-lg);
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    position: relative;
    overflow: hidden;
  }

  wui-visual::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition:
      opacity var(--wui-ease-out-power-2) var(--wui-duration-lg),
      transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }

  wui-link {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
  }
`;
var __decorate$1e = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mSwitchActiveChainView = class W3mSwitchActiveChainView2 extends i$2 {
  constructor() {
    super(...arguments);
    this.unsubscribe = [];
    this.switchToChain = RouterController.state.data?.switchToChain;
    this.navigateTo = RouterController.state.data?.navigateTo;
    this.navigateWithReplace = RouterController.state.data?.navigateWithReplace;
    this.activeChain = ChainController.state.activeChain;
  }
  firstUpdated() {
    this.unsubscribe.push(ChainController.subscribeKey("activeChain", (val) => this.activeChain = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const chainNameString = this.activeChain ? ConstantsUtil$2.CHAIN_NAME_MAP[this.activeChain] : "current";
    const switchedChainNameString = this.switchToChain ? ConstantsUtil$2.CHAIN_NAME_MAP[this.switchToChain] : "supported";
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" flexDirection="column" alignItems="center" gap="xl">
          <wui-visual name="eth"></wui-visual>
          <wui-text variant="paragraph-500" color="fg-100" align="center">Switch to EVM</wui-text>
          <wui-text variant="small-400" color="fg-200" align="center">
            This feature is not supported on the ${chainNameString} chain. Switch to
            ${switchedChainNameString} chain to proceed using it.
          </wui-text>
          <wui-button size="md" @click=${this.switchActiveChain.bind(this)}>Switch</wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  switchActiveChain() {
    if (!this.switchToChain) {
      return;
    }
    ChainController.setActiveChain(this.switchToChain);
    if (this.navigateTo) {
      if (this.navigateWithReplace) {
        RouterController.replace(this.navigateTo);
      } else {
        RouterController.push(this.navigateTo);
      }
    } else {
      RouterController.goBack();
    }
  }
};
W3mSwitchActiveChainView.styles = styles$O;
__decorate$1e([
  n$2()
], W3mSwitchActiveChainView.prototype, "activeChain", void 0);
W3mSwitchActiveChainView = __decorate$1e([
  customElement("w3m-switch-active-chain-view")
], W3mSwitchActiveChainView);
const styles$N = i$5`
  :host > wui-flex:first-child {
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  .preview-container,
  .details-container {
    width: 100%;
  }

  .token-image {
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
    border-radius: 12px;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  .token-item {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-xxs);
    padding: var(--wui-spacing-xs);
    height: 40px;
    border: none;
    border-radius: 80px;
    background: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    cursor: pointer;
    transition: background 0.2s linear;
  }

  .token-item:hover {
    background: var(--wui-color-gray-glass-005);
  }

  .preview-token-details-container {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }

  .action-buttons-container {
    width: 100%;
    gap: var(--wui-spacing-xs);
  }

  .action-buttons-container > button {
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    height: 48px;
    border-radius: var(--wui-border-radius-xs);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  .action-buttons-container > button:disabled {
    opacity: 0.8;
    cursor: not-allowed;
  }

  .action-button > wui-loading-spinner {
    display: inline-block;
  }

  .cancel-button:hover,
  .action-button:hover {
    cursor: pointer;
  }

  .action-buttons-container > wui-button.cancel-button {
    flex: 2;
  }

  .action-buttons-container > wui-button.action-button {
    flex: 4;
  }

  .action-buttons-container > button.action-button > wui-text {
    color: white;
  }

  .details-container > wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    transition: background 0.2s linear;
  }

  .details-container > wui-flex > button:hover {
    background: var(--wui-color-gray-glass-002);
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }
`;
var __decorate$1d = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mSwapPreviewView = class W3mSwapPreviewView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.detailsOpen = true;
    this.approvalTransaction = SwapController.state.approvalTransaction;
    this.swapTransaction = SwapController.state.swapTransaction;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount ?? "";
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount ?? "";
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.caipNetwork = NetworkController.state.caipNetwork;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.inputError = SwapController.state.inputError;
    this.loadingQuote = SwapController.state.loadingQuote;
    this.loadingApprovalTransaction = SwapController.state.loadingApprovalTransaction;
    this.loadingBuildTransaction = SwapController.state.loadingBuildTransaction;
    this.loadingTransaction = SwapController.state.loadingTransaction;
    this.unsubscribe.push(...[
      AccountController.subscribeKey("balanceSymbol", (newBalanceSymbol) => {
        if (this.balanceSymbol !== newBalanceSymbol) {
          RouterController.goBack();
        }
      }),
      NetworkController.subscribeKey("caipNetwork", (newCaipNetwork) => {
        if (this.caipNetwork !== newCaipNetwork) {
          this.caipNetwork = newCaipNetwork;
        }
      }),
      SwapController.subscribe((newState) => {
        this.approvalTransaction = newState.approvalTransaction;
        this.swapTransaction = newState.swapTransaction;
        this.sourceToken = newState.sourceToken;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.toToken = newState.toToken;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.sourceTokenAmount = newState.sourceTokenAmount ?? "";
        this.toTokenAmount = newState.toTokenAmount ?? "";
        this.inputError = newState.inputError;
        if (newState.inputError) {
          RouterController.goBack();
        }
        this.loadingQuote = newState.loadingQuote;
        this.loadingApprovalTransaction = newState.loadingApprovalTransaction;
        this.loadingBuildTransaction = newState.loadingBuildTransaction;
        this.loadingTransaction = newState.loadingTransaction;
      })
    ]);
  }
  firstUpdated() {
    SwapController.getTransaction();
    this.refreshTransaction();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe?.());
    clearInterval(this.interval);
  }
  render() {
    return x`
      <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]} gap="s">
        ${this.templateSwap()}
      </wui-flex>
    `;
  }
  refreshTransaction() {
    this.interval = setInterval(() => {
      if (!SwapController.getApprovalLoadingState()) {
        SwapController.getTransaction();
      }
    }, 1e4);
  }
  templateSwap() {
    const sourceTokenText = `${UiHelperUtil.formatNumberToLocalString(parseFloat(this.sourceTokenAmount))} ${this.sourceToken?.symbol}`;
    const toTokenText = `${UiHelperUtil.formatNumberToLocalString(parseFloat(this.toTokenAmount))} ${this.toToken?.symbol}`;
    const sourceTokenValue = parseFloat(this.sourceTokenAmount) * this.sourceTokenPriceInUSD;
    const toTokenValue = parseFloat(this.toTokenAmount) * this.toTokenPriceInUSD - (this.gasPriceInUSD || 0);
    const sentPrice = UiHelperUtil.formatNumberToLocalString(sourceTokenValue);
    const receivePrice = UiHelperUtil.formatNumberToLocalString(toTokenValue);
    const loading = this.loadingQuote || this.loadingBuildTransaction || this.loadingTransaction || this.loadingApprovalTransaction;
    return x`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        <wui-flex class="preview-container" flexDirection="column" alignItems="flex-start" gap="l">
          <wui-flex
            class="preview-token-details-container"
            alignItems="center"
            justifyContent="space-between"
            gap="l"
          >
            <wui-flex flexDirection="column" alignItems="flex-start" gap="4xs">
              <wui-text variant="small-400" color="fg-150">Send</wui-text>
              <wui-text variant="paragraph-400" color="fg-100">$${sentPrice}</wui-text>
            </wui-flex>
            <wui-token-button
              flexDirection="row-reverse"
              text=${sourceTokenText}
              imageSrc=${this.sourceToken?.logoUri}
            >
            </wui-token-button>
          </wui-flex>
          <wui-icon name="recycleHorizontal" color="fg-200" size="md"></wui-icon>
          <wui-flex
            class="preview-token-details-container"
            alignItems="center"
            justifyContent="space-between"
            gap="l"
          >
            <wui-flex flexDirection="column" alignItems="flex-start" gap="4xs">
              <wui-text variant="small-400" color="fg-150">Receive</wui-text>
              <wui-text variant="paragraph-400" color="fg-100">$${receivePrice}</wui-text>
            </wui-flex>
            <wui-token-button
              flexDirection="row-reverse"
              text=${toTokenText}
              imageSrc=${this.toToken?.logoUri}
            >
            </wui-token-button>
          </wui-flex>
        </wui-flex>

        ${this.templateDetails()}

        <wui-flex flexDirection="row" alignItems="center" justifyContent="center" gap="xs">
          <wui-icon size="sm" color="fg-200" name="infoCircle"></wui-icon>
          <wui-text variant="small-400" color="fg-200">Review transaction carefully</wui-text>
        </wui-flex>

        <wui-flex
          class="action-buttons-container"
          flexDirection="row"
          alignItems="center"
          justifyContent="space-between"
          gap="xs"
        >
          <wui-button
            class="cancel-button"
            fullWidth
            size="lg"
            borderRadius="xs"
            variant="neutral"
            @click=${this.onCancelTransaction.bind(this)}
          >
            <wui-text variant="paragraph-600" color="fg-200">Cancel</wui-text>
          </wui-button>
          <wui-button
            class="action-button"
            fullWidth
            size="lg"
            borderRadius="xs"
            variant="main"
            ?loading=${loading}
            ?disabled=${loading}
            @click=${this.onSendTransaction.bind(this)}
          >
            <wui-text variant="paragraph-600" color="inverse-100">
              ${this.actionButtonLabel()}
            </wui-text>
          </wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  templateDetails() {
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    return x`<w3m-swap-details .detailsOpen=${this.detailsOpen}></w3m-swap-details>`;
  }
  actionButtonLabel() {
    if (this.loadingApprovalTransaction) {
      return "Approving...";
    }
    if (this.approvalTransaction) {
      return "Approve";
    }
    return "Swap";
  }
  onCancelTransaction() {
    RouterController.goBack();
  }
  onSendTransaction() {
    if (this.approvalTransaction) {
      SwapController.sendTransactionForApproval(this.approvalTransaction);
    } else {
      SwapController.sendTransactionForSwap(this.swapTransaction);
    }
  }
};
W3mSwapPreviewView.styles = styles$N;
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "interval", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "detailsOpen", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "approvalTransaction", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "swapTransaction", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "sourceToken", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "sourceTokenAmount", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "sourceTokenPriceInUSD", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "toToken", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "toTokenAmount", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "toTokenPriceInUSD", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "caipNetwork", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "balanceSymbol", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "gasPriceInUSD", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "inputError", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "loadingQuote", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "loadingApprovalTransaction", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "loadingBuildTransaction", void 0);
__decorate$1d([
  r$1()
], W3mSwapPreviewView.prototype, "loadingTransaction", void 0);
W3mSwapPreviewView = __decorate$1d([
  customElement("w3m-swap-preview-view")
], W3mSwapPreviewView);
const styles$M = i$5`
  :host {
    --tokens-scroll--top-opacity: 0;
    --tokens-scroll--bottom-opacity: 1;
    --suggested-tokens-scroll--left-opacity: 0;
    --suggested-tokens-scroll--right-opacity: 1;
  }

  :host > wui-flex:first-child {
    overflow-y: hidden;
    overflow-x: hidden;
    scrollbar-width: none;
    scrollbar-height: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  .suggested-tokens-container {
    overflow-x: auto;
    mask-image: linear-gradient(
      to right,
      rgba(0, 0, 0, calc(1 - var(--suggested-tokens-scroll--left-opacity))) 0px,
      rgba(200, 200, 200, calc(1 - var(--suggested-tokens-scroll--left-opacity))) 1px,
      black 50px,
      black 90px,
      black calc(100% - 90px),
      black calc(100% - 50px),
      rgba(155, 155, 155, calc(1 - var(--suggested-tokens-scroll--right-opacity))) calc(100% - 1px),
      rgba(0, 0, 0, calc(1 - var(--suggested-tokens-scroll--right-opacity))) 100%
    );
  }

  .suggested-tokens-container::-webkit-scrollbar {
    display: none;
  }

  .tokens-container {
    border-top: 1px solid var(--wui-color-gray-glass-005);
    height: 100%;
    max-height: 390px;
  }

  .tokens {
    width: 100%;
    overflow-y: auto;
    mask-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, calc(1 - var(--tokens-scroll--top-opacity))) 0px,
      rgba(200, 200, 200, calc(1 - var(--tokens-scroll--top-opacity))) 1px,
      black 50px,
      black 90px,
      black calc(100% - 90px),
      black calc(100% - 50px),
      rgba(155, 155, 155, calc(1 - var(--tokens-scroll--bottom-opacity))) calc(100% - 1px),
      rgba(0, 0, 0, calc(1 - var(--tokens-scroll--bottom-opacity))) 100%
    );
  }

  .network-search-input,
  .select-network-button {
    height: 40px;
  }

  .select-network-button {
    border: none;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
    background-color: transparent;
    border-radius: var(--wui-border-radius-xxs);
    padding: var(--wui-spacing-xs);
    align-items: center;
    transition: background-color 0.2s linear;
  }

  .select-network-button:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  .select-network-button > wui-image {
    width: 26px;
    height: 26px;
    border-radius: var(--wui-border-radius-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }
`;
var __decorate$1c = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mSwapSelectTokenView = class W3mSwapSelectTokenView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.targetToken = RouterController.state.data?.target;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount;
    this.toToken = SwapController.state.toToken;
    this.myTokensWithBalance = SwapController.state.myTokensWithBalance;
    this.popularTokens = SwapController.state.popularTokens;
    this.searchValue = "";
    this.unsubscribe.push(...[
      SwapController.subscribe((newState) => {
        this.sourceToken = newState.sourceToken;
        this.toToken = newState.toToken;
        this.myTokensWithBalance = newState.myTokensWithBalance;
      })
    ]);
  }
  updated() {
    const suggestedTokensContainer = this.renderRoot?.querySelector(".suggested-tokens-container");
    suggestedTokensContainer?.addEventListener("scroll", this.handleSuggestedTokensScroll.bind(this));
    const tokensList = this.renderRoot?.querySelector(".tokens");
    tokensList?.addEventListener("scroll", this.handleTokenListScroll.bind(this));
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    const suggestedTokensContainer = this.renderRoot?.querySelector(".suggested-tokens-container");
    const tokensList = this.renderRoot?.querySelector(".tokens");
    suggestedTokensContainer?.removeEventListener("scroll", this.handleSuggestedTokensScroll.bind(this));
    tokensList?.removeEventListener("scroll", this.handleTokenListScroll.bind(this));
    clearInterval(this.interval);
  }
  render() {
    return x`
      <wui-flex flexDirection="column" gap="s">
        ${this.templateSearchInput()} ${this.templateSuggestedTokens()} ${this.templateTokens()}
      </wui-flex>
    `;
  }
  onSelectToken(token2) {
    if (this.targetToken === "sourceToken") {
      SwapController.setSourceToken(token2);
    } else {
      SwapController.setToToken(token2);
      if (this.sourceToken && this.sourceTokenAmount) {
        SwapController.swapTokens();
      }
    }
    RouterController.goBack();
  }
  templateSearchInput() {
    return x`
      <wui-flex .padding=${["3xs", "s", "0", "s"]} gap="xs">
        <wui-input-text
          data-testid="swap-select-token-search-input"
          class="network-search-input"
          size="sm"
          placeholder="Search token"
          icon="search"
          .value=${this.searchValue}
          @inputChange=${this.onSearchInputChange.bind(this)}
        ></wui-input-text>
      </wui-flex>
    `;
  }
  templateTokens() {
    const yourTokens = this.myTokensWithBalance ? Object.values(this.myTokensWithBalance) : [];
    const tokens = this.popularTokens ? this.popularTokens : [];
    const filteredYourTokens = this.filterTokensWithText(yourTokens, this.searchValue);
    const filteredTokens = this.filterTokensWithText(tokens, this.searchValue);
    return x`
      <wui-flex class="tokens-container">
        <wui-flex class="tokens" .padding=${["0", "s", "s", "s"]} flexDirection="column">
          ${filteredYourTokens?.length > 0 ? x`
                <wui-flex justifyContent="flex-start" padding="s">
                  <wui-text variant="paragraph-500" color="fg-200">Your tokens</wui-text>
                </wui-flex>
                ${filteredYourTokens.map((token2) => {
      const selected = token2.symbol === this.sourceToken?.symbol || token2.symbol === this.toToken?.symbol;
      return x`
                    <wui-token-list-item
                      data-testid="swap-select-token-item-${token2.symbol}"
                      name=${token2.name}
                      ?disabled=${selected}
                      symbol=${token2.symbol}
                      price=${token2?.price}
                      amount=${token2?.quantity?.numeric}
                      imageSrc=${token2.logoUri}
                      @click=${() => {
        if (!selected) {
          this.onSelectToken(token2);
        }
      }}
                    >
                    </wui-token-list-item>
                  `;
    })}
              ` : null}

          <wui-flex justifyContent="flex-start" padding="s">
            <wui-text variant="paragraph-500" color="fg-200">Tokens</wui-text>
          </wui-flex>
          ${filteredTokens?.length > 0 ? filteredTokens.map((token2) => x`
                  <wui-token-list-item
                    data-testid="swap-select-token-item-${token2.symbol}"
                    name=${token2.name}
                    symbol=${token2.symbol}
                    imageSrc=${token2.logoUri}
                    @click=${() => this.onSelectToken(token2)}
                  >
                  </wui-token-list-item>
                `) : null}
        </wui-flex>
      </wui-flex>
    `;
  }
  templateSuggestedTokens() {
    const tokens = SwapController.state.suggestedTokens ? SwapController.state.suggestedTokens.slice(0, 8) : null;
    if (!tokens) {
      return null;
    }
    return x`
      <wui-flex class="suggested-tokens-container" .padding=${["0", "s", "0", "s"]} gap="xs">
        ${tokens.map((token2) => x`
            <wui-token-button
              text=${token2.symbol}
              imageSrc=${token2.logoUri}
              @click=${() => this.onSelectToken(token2)}
            >
            </wui-token-button>
          `)}
      </wui-flex>
    `;
  }
  onSearchInputChange(event) {
    this.searchValue = event.detail;
  }
  handleSuggestedTokensScroll() {
    const container = this.renderRoot?.querySelector(".suggested-tokens-container");
    if (!container) {
      return;
    }
    container.style.setProperty("--suggested-tokens-scroll--left-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollLeft).toString());
    container.style.setProperty("--suggested-tokens-scroll--right-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollWidth - container.scrollLeft - container.offsetWidth).toString());
  }
  handleTokenListScroll() {
    const container = this.renderRoot?.querySelector(".tokens");
    if (!container) {
      return;
    }
    container.style.setProperty("--tokens-scroll--top-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollTop).toString());
    container.style.setProperty("--tokens-scroll--bottom-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollHeight - container.scrollTop - container.offsetHeight).toString());
  }
  filterTokensWithText(tokens, text) {
    return tokens.filter((token2) => `${token2.symbol} ${token2.name} ${token2.address}`.toLowerCase().includes(text.toLowerCase()));
  }
};
W3mSwapSelectTokenView.styles = styles$M;
__decorate$1c([
  r$1()
], W3mSwapSelectTokenView.prototype, "interval", void 0);
__decorate$1c([
  r$1()
], W3mSwapSelectTokenView.prototype, "targetToken", void 0);
__decorate$1c([
  r$1()
], W3mSwapSelectTokenView.prototype, "sourceToken", void 0);
__decorate$1c([
  r$1()
], W3mSwapSelectTokenView.prototype, "sourceTokenAmount", void 0);
__decorate$1c([
  r$1()
], W3mSwapSelectTokenView.prototype, "toToken", void 0);
__decorate$1c([
  r$1()
], W3mSwapSelectTokenView.prototype, "myTokensWithBalance", void 0);
__decorate$1c([
  r$1()
], W3mSwapSelectTokenView.prototype, "popularTokens", void 0);
__decorate$1c([
  r$1()
], W3mSwapSelectTokenView.prototype, "searchValue", void 0);
W3mSwapSelectTokenView = __decorate$1c([
  customElement("w3m-swap-select-token-view")
], W3mSwapSelectTokenView);
const styles$L = i$5`
  :host > wui-flex:first-child {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$1b = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mTransactionsView = class W3mTransactionsView2 extends i$2 {
  render() {
    return x`
      <wui-flex flexDirection="column" .padding=${["0", "m", "m", "m"]} gap="s">
        <w3m-activity-list page="activity"></w3m-activity-list>
      </wui-flex>
    `;
  }
};
W3mTransactionsView.styles = styles$L;
W3mTransactionsView = __decorate$1b([
  customElement("w3m-transactions-view")
], W3mTransactionsView);
var __decorate$1a = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const data$1 = [
  {
    images: ["network", "layers", "system"],
    title: "The systems nuts and bolts",
    text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services."
  },
  {
    images: ["noun", "defiAlt", "dao"],
    title: "Designed for different uses",
    text: "Each network is designed differently, and may therefore suit certain apps and experiences."
  }
];
let W3mWhatIsANetworkView = class W3mWhatIsANetworkView2 extends i$2 {
  render() {
    return x`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data$1}></w3m-help-widget>
        <wui-button
          variant="main"
          size="md"
          @click=${() => {
      CoreHelperUtil.openHref("https://ethereum.org/en/developers/docs/networks/", "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
  }
};
W3mWhatIsANetworkView = __decorate$1a([
  customElement("w3m-what-is-a-network-view")
], W3mWhatIsANetworkView);
var __decorate$19 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const data = [
  {
    images: ["login", "profile", "lock"],
    title: "One login for all of web3",
    text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!"
  },
  {
    images: ["defi", "nft", "eth"],
    title: "A home for your digital assets",
    text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs."
  },
  {
    images: ["browser", "noun", "dao"],
    title: "Your gateway to a new web",
    text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more."
  }
];
let W3mWhatIsAWalletView = class W3mWhatIsAWalletView2 extends i$2 {
  render() {
    return x`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data}></w3m-help-widget>
        <wui-button variant="main" size="md" @click=${this.onGetWallet.bind(this)}>
          <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
          Get a wallet
        </wui-button>
      </wui-flex>
    `;
  }
  onGetWallet() {
    EventsController.sendEvent({ type: "track", event: "CLICK_GET_WALLET" });
    RouterController.push("GetWallet");
  }
};
W3mWhatIsAWalletView = __decorate$19([
  customElement("w3m-what-is-a-wallet-view")
], W3mWhatIsAWalletView);
var __decorate$18 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mWhatIsABuyView = class W3mWhatIsABuyView2 extends i$2 {
  render() {
    return x`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "3xl", "xl", "3xl"]}
        alignItems="center"
        gap="xl"
      >
        <wui-visual name="onrampCard"></wui-visual>
        <wui-flex flexDirection="column" gap="xs" alignItems="center">
          <wui-text align="center" variant="paragraph-500" color="fg-100">
            Quickly and easily buy digital assets!
          </wui-text>
          <wui-text align="center" variant="small-400" color="fg-200">
            Simply select your preferred onramp provider and add digital assets to your account
            using your credit card or bank transfer
          </wui-text>
        </wui-flex>
        <wui-button @click=${RouterController.goBack}>
          <wui-icon size="sm" color="inherit" name="add" slot="iconLeft"></wui-icon>
          Buy
        </wui-button>
      </wui-flex>
    `;
  }
};
W3mWhatIsABuyView = __decorate$18([
  customElement("w3m-what-is-a-buy-view")
], W3mWhatIsABuyView);
const styles$K = i$5`
  wui-loading-spinner {
    margin: 9px auto;
  }

  .email-display,
  .email-display wui-text {
    max-width: 100%;
  }
`;
var __decorate$17 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const OTP_LENGTH = 6;
let W3mEmailOtpWidget = class W3mEmailOtpWidget2 extends i$2 {
  firstUpdated() {
    this.startOTPTimeout();
  }
  disconnectedCallback() {
    clearTimeout(this.OTPTimeout);
  }
  constructor() {
    super();
    this.loading = false;
    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
    this.error = "";
    this.otp = "";
    this.email = RouterController.state.data?.email;
    this.authConnector = ConnectorController.getAuthConnector();
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-email-otp-widget: No email provided");
    }
    const isResendDisabled = Boolean(this.timeoutTimeLeft);
    const footerLabels = this.getFooterLabels(isResendDisabled);
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["l", "0", "l", "0"]}
        gap="l"
      >
        <wui-flex
          class="email-display"
          flexDirection="column"
          alignItems="center"
          .padding=${["0", "xl", "0", "xl"]}
        >
          <wui-text variant="paragraph-400" color="fg-100" align="center">
            Enter the code we sent to
          </wui-text>
          <wui-text variant="paragraph-500" color="fg-100" lineClamp="1" align="center">
            ${this.email}
          </wui-text>
        </wui-flex>

        <wui-text variant="small-400" color="fg-200">The code expires in 20 minutes</wui-text>

        ${this.loading ? x`<wui-loading-spinner size="xl" color="accent-100"></wui-loading-spinner>` : x` <wui-flex flexDirection="column" alignItems="center" gap="xs">
              <wui-otp
                dissabled
                length="6"
                @inputChange=${this.onOtpInputChange.bind(this)}
                .otp=${this.otp}
              ></wui-otp>
              ${this.error ? x`
                    <wui-text variant="small-400" align="center" color="error-100">
                      ${this.error}. Try Again
                    </wui-text>
                  ` : null}
            </wui-flex>`}

        <wui-flex alignItems="center" gap="xs">
          <wui-text variant="small-400" color="fg-200">${footerLabels.title}</wui-text>
          <wui-link @click=${this.onResendCode.bind(this)} .disabled=${isResendDisabled}>
            ${footerLabels.action}
          </wui-link>
        </wui-flex>
      </wui-flex>
    `;
  }
  startOTPTimeout() {
    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
    this.OTPTimeout = setInterval(() => {
      if (this.timeoutTimeLeft > 0) {
        this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
      } else {
        clearInterval(this.OTPTimeout);
      }
    }, 1e3);
  }
  async onOtpInputChange(event) {
    try {
      if (!this.loading) {
        this.otp = event.detail;
        if (this.authConnector && this.otp.length === OTP_LENGTH) {
          this.loading = true;
          await this.onOtpSubmit?.(this.otp);
        }
      }
    } catch (error) {
      this.error = CoreHelperUtil.parseError(error);
      this.loading = false;
    }
  }
  async onResendCode() {
    try {
      if (this.onOtpResend) {
        if (!this.loading && !this.timeoutTimeLeft) {
          this.error = "";
          this.otp = "";
          const authConnector2 = ConnectorController.getAuthConnector();
          if (!authConnector2 || !this.email) {
            throw new Error("w3m-email-otp-widget: Unable to resend email");
          }
          this.loading = true;
          await this.onOtpResend(this.email);
          this.startOTPTimeout();
          SnackController.showSuccess("Code email resent");
        }
      } else if (this.onStartOver) {
        this.onStartOver();
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
  getFooterLabels(isResendDisabled) {
    if (this.onStartOver) {
      return {
        title: "Something wrong?",
        action: `Try again ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : ""}`
      };
    }
    return {
      title: `Didn't receive it?`,
      action: `Resend ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : "Code"}`
    };
  }
};
W3mEmailOtpWidget.styles = styles$K;
__decorate$17([
  r$1()
], W3mEmailOtpWidget.prototype, "loading", void 0);
__decorate$17([
  r$1()
], W3mEmailOtpWidget.prototype, "timeoutTimeLeft", void 0);
__decorate$17([
  r$1()
], W3mEmailOtpWidget.prototype, "error", void 0);
W3mEmailOtpWidget = __decorate$17([
  customElement("w3m-email-otp-widget")
], W3mEmailOtpWidget);
var __decorate$16 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mEmailVerifyOtpView = class W3mEmailVerifyOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    super();
    this.unsubscribe = [];
    this.smartAccountDeployed = AccountController.state.smartAccountDeployed;
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          const smartAccountEnabled = NetworkController.checkIfSmartAccountEnabled();
          await this.authConnector.provider.connectOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          await ConnectionController.connectExternal(this.authConnector, this.authConnector.chain);
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: { method: "email", name: this.authConnector.name || "Unknown" }
          });
          if (AccountController.state.allAccounts.length > 1) {
            RouterController.push("SelectAddresses");
          } else if (smartAccountEnabled && !this.smartAccountDeployed) {
            RouterController.push("UpgradeToSmartAccount");
          } else {
            ModalController.close();
          }
        }
      } catch (error) {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
        throw error;
      }
    };
    this.onOtpResend = async (email) => {
      if (this.authConnector) {
        await this.authConnector.provider.connectEmail({ email });
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
      }
    };
    this.unsubscribe.push(AccountController.subscribeKey("smartAccountDeployed", (val) => {
      this.smartAccountDeployed = val;
    }));
  }
};
__decorate$16([
  r$1()
], W3mEmailVerifyOtpView.prototype, "smartAccountDeployed", void 0);
W3mEmailVerifyOtpView = __decorate$16([
  customElement("w3m-email-verify-otp-view")
], W3mEmailVerifyOtpView);
const styles$J = i$5`
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;
var __decorate$15 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mEmailVerifyDeviceView = class W3mEmailVerifyDeviceView2 extends i$2 {
  constructor() {
    super();
    this.email = RouterController.state.data?.email;
    this.authConnector = ConnectorController.getAuthConnector();
    this.loading = false;
    this.listenForDeviceApproval();
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-email-verify-device-view: No email provided");
    }
    if (!this.authConnector) {
      throw new Error("w3m-email-verify-device-view: No auth connector provided");
    }
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl", "s", "xxl", "s"]}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="verify"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve the login link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100"><b>${this.email}</b></wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            The code expires in 20 minutes
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section" gap="xs">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  async listenForDeviceApproval() {
    if (this.authConnector) {
      try {
        await this.authConnector.provider.connectDevice();
        EventsController.sendEvent({ type: "track", event: "DEVICE_REGISTERED_FOR_EMAIL" });
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        RouterController.replace("EmailVerifyOtp", { email: this.email });
      } catch (error) {
        RouterController.goBack();
      }
    }
  }
  async onResendCode() {
    try {
      if (!this.loading) {
        if (!this.authConnector || !this.email) {
          throw new Error("w3m-email-login-widget: Unable to resend email");
        }
        this.loading = true;
        await this.authConnector.provider.connectEmail({ email: this.email });
        this.listenForDeviceApproval();
        SnackController.showSuccess("Code email resent");
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
};
W3mEmailVerifyDeviceView.styles = styles$J;
__decorate$15([
  r$1()
], W3mEmailVerifyDeviceView.prototype, "loading", void 0);
W3mEmailVerifyDeviceView = __decorate$15([
  customElement("w3m-email-verify-device-view")
], W3mEmailVerifyDeviceView);
const styles$I = i$5`
  div {
    width: 100%;
    height: 400px;
  }

  [data-ready='false'] {
    transform: scale(1.05);
  }

  @media (max-width: 430px) {
    [data-ready='false'] {
      transform: translateY(-50px);
    }
  }
`;
var __decorate$14 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const PAGE_HEIGHT = 400;
const PAGE_WIDTH = 360;
const HEADER_HEIGHT = 64;
let W3mApproveTransactionView = class W3mApproveTransactionView2 extends i$2 {
  constructor() {
    super();
    this.bodyObserver = void 0;
    this.unsubscribe = [];
    this.iframe = document.getElementById("w3m-iframe");
    this.ready = false;
    this.unsubscribe.push(...[
      ModalController.subscribeKey("open", (isOpen) => {
        if (!isOpen) {
          this.onHideIframe();
          RouterController.popTransactionStack();
        }
      }),
      ModalController.subscribeKey("shake", (val) => {
        if (val) {
          this.iframe.style.animation = `w3m-shake 500ms var(--wui-ease-out-power-2)`;
        } else {
          this.iframe.style.animation = "none";
        }
      })
    ]);
  }
  disconnectedCallback() {
    this.onHideIframe();
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    this.bodyObserver?.unobserve(window.document.body);
  }
  async firstUpdated() {
    await this.syncTheme();
    this.iframe.style.display = "block";
    this.bodyObserver = new ResizeObserver((entries2) => {
      const contentBoxSize = entries2?.[0]?.contentBoxSize;
      const width2 = contentBoxSize?.[0]?.inlineSize;
      this.iframe.style.height = `${PAGE_HEIGHT}px`;
      if (width2 && width2 <= 430) {
        this.iframe.style.width = "100%";
        this.iframe.style.left = "0px";
        this.iframe.style.bottom = "0px";
        this.iframe.style.top = "unset";
      } else {
        this.iframe.style.width = `${PAGE_WIDTH}px`;
        this.iframe.style.left = `calc(50% - ${PAGE_WIDTH / 2}px)`;
        this.iframe.style.top = `calc(50% - ${PAGE_HEIGHT / 2}px + ${HEADER_HEIGHT / 2}px)`;
        this.iframe.style.bottom = "unset";
      }
      this.ready = true;
      this.onShowIframe();
    });
    this.bodyObserver.observe(window.document.body);
  }
  render() {
    return x`<div data-ready=${this.ready}></div>`;
  }
  onShowIframe() {
    const isMobile = window.innerWidth <= 430;
    this.iframe.style.animation = isMobile ? "w3m-iframe-zoom-in-mobile 200ms var(--wui-ease-out-power-2)" : "w3m-iframe-zoom-in 200ms var(--wui-ease-out-power-2)";
  }
  onHideIframe() {
    this.iframe.style.display = "none";
    this.iframe.style.animation = "w3m-iframe-fade-out 200ms var(--wui-ease-out-power-2)";
  }
  async syncTheme() {
    const authConnector2 = ConnectorController.getAuthConnector();
    if (authConnector2) {
      const themeMode = ThemeController.getSnapshot().themeMode;
      const themeVariables = ThemeController.getSnapshot().themeVariables;
      await authConnector2.provider.syncTheme({
        themeVariables,
        w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
      });
    }
  }
};
W3mApproveTransactionView.styles = styles$I;
__decorate$14([
  r$1()
], W3mApproveTransactionView.prototype, "ready", void 0);
W3mApproveTransactionView = __decorate$14([
  customElement("w3m-approve-transaction-view")
], W3mApproveTransactionView);
var __decorate$13 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mUpgradeWalletView = class W3mUpgradeWalletView2 extends i$2 {
  render() {
    return x`
      <wui-flex flexDirection="column" alignItems="center" gap="xl" padding="xl">
        <wui-text variant="paragraph-400" color="fg-100">Follow the instructions on</wui-text>
        <wui-chip
          icon="externalLink"
          variant="fill"
          href=${ConstantsUtil$1.SECURE_SITE_DASHBOARD}
          imageSrc=${ConstantsUtil$1.SECURE_SITE_FAVICON}
          data-testid="w3m-secure-website-button"
        >
        </wui-chip>
        <wui-text variant="small-400" color="fg-200">
          You will have to reconnect for security reasons
        </wui-text>
      </wui-flex>
    `;
  }
};
W3mUpgradeWalletView = __decorate$13([
  customElement("w3m-upgrade-wallet-view")
], W3mUpgradeWalletView);
var __decorate$12 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mUpgradeToSmartAccountView = class W3mUpgradeToSmartAccountView2 extends i$2 {
  constructor() {
    super(...arguments);
    this.authConnector = ConnectorController.getAuthConnector();
    this.loading = false;
    this.setPreferSmartAccount = async () => {
      if (this.authConnector) {
        try {
          this.loading = true;
          await ConnectionController.setPreferredAccountType(W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT);
          this.loading = false;
          RouterUtil.navigateAfterPreferredAccountTypeSelect();
        } catch (e2) {
          SnackController.showError("Error upgrading to smart account");
        }
      }
    };
  }
  render() {
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
  }
  onboardingTemplate() {
    return x` <wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <wui-flex gap="s" alignItems="center" justifyContent="center">
        <wui-visual name="google"></wui-visual>
        <wui-visual name="pencil"></wui-visual>
        <wui-visual name="lightbulb"></wui-visual>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-text align="center" variant="medium-600" color="fg-100">
          Discover Smart Accounts
        </wui-text>
        <wui-text align="center" variant="paragraph-400" color="fg-100">
          Access advanced features such as username, social login, improved security and a smoother
          user experience!
        </wui-text>
      </wui-flex>
    </wui-flex>`;
  }
  buttonsTemplate() {
    return x`<wui-flex .padding=${["0", "2l", "0", "2l"]} gap="s">
      <wui-button
        variant="accent"
        @click=${this.redirectToAccount.bind(this)}
        size="lg"
        borderRadius="xs"
      >
        Do it later
      </wui-button>
      <wui-button
        .loading=${this.loading}
        size="lg"
        borderRadius="xs"
        @click=${this.setPreferSmartAccount.bind(this)}
        >Continue
      </wui-button>
    </wui-flex>`;
  }
  redirectToAccount() {
    RouterController.push("Account");
  }
};
__decorate$12([
  r$1()
], W3mUpgradeToSmartAccountView.prototype, "authConnector", void 0);
__decorate$12([
  r$1()
], W3mUpgradeToSmartAccountView.prototype, "loading", void 0);
W3mUpgradeToSmartAccountView = __decorate$12([
  customElement("w3m-upgrade-to-smart-account-view")
], W3mUpgradeToSmartAccountView);
const styles$H = i$5`
  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }
`;
var __decorate$11 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mUpdateEmailWalletView = class W3mUpdateEmailWalletView2 extends i$2 {
  constructor() {
    super(...arguments);
    this.formRef = e();
    this.initialEmail = RouterController.state.data?.email ?? "";
    this.email = "";
    this.loading = false;
  }
  firstUpdated() {
    this.formRef.value?.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    const showSubmit = !this.loading && this.email.length > 3 && this.email !== this.initialEmail;
    return x`
      <wui-flex flexDirection="column" padding="m" gap="m">
        <form ${n2(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
          <wui-email-input
            value=${this.initialEmail}
            .disabled=${this.loading}
            @inputChange=${this.onEmailInputChange.bind(this)}
          >
          </wui-email-input>
          <input type="submit" hidden />
        </form>

        <wui-flex gap="s">
          <wui-button size="md" variant="neutral" fullWidth @click=${RouterController.goBack}>
            Cancel
          </wui-button>

          <wui-button
            size="md"
            variant="main"
            fullWidth
            @click=${this.onSubmitEmail.bind(this)}
            .disabled=${!showSubmit}
            .loading=${this.loading}
          >
            Save
          </wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  onEmailInputChange(event) {
    this.email = event.detail;
  }
  async onSubmitEmail(event) {
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const authConnector2 = ConnectorController.getAuthConnector();
      if (!authConnector2) {
        throw new Error("w3m-update-email-wallet: Auth connector not found");
      }
      const response = await authConnector2.provider.updateEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_EDIT" });
      if (response.action === "VERIFY_SECONDARY_OTP") {
        RouterController.push("UpdateEmailSecondaryOtp", {
          email: this.initialEmail,
          newEmail: this.email
        });
      } else {
        RouterController.push("UpdateEmailPrimaryOtp", {
          email: this.initialEmail,
          newEmail: this.email
        });
      }
    } catch (error) {
      SnackController.showError(error);
      this.loading = false;
    }
  }
};
W3mUpdateEmailWalletView.styles = styles$H;
__decorate$11([
  r$1()
], W3mUpdateEmailWalletView.prototype, "email", void 0);
__decorate$11([
  r$1()
], W3mUpdateEmailWalletView.prototype, "loading", void 0);
W3mUpdateEmailWalletView = __decorate$11([
  customElement("w3m-update-email-wallet-view")
], W3mUpdateEmailWalletView);
var __decorate$10 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mUpdateEmailPrimaryOtpView = class W3mUpdateEmailPrimaryOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    super();
    this.email = RouterController.state.data?.email;
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          await this.authConnector.provider.updateEmailPrimaryOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          RouterController.replace("UpdateEmailSecondaryOtp", RouterController.state.data);
        }
      } catch (error) {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
        throw error;
      }
    };
    this.onStartOver = () => {
      RouterController.replace("UpdateEmailWallet", RouterController.state.data);
    };
  }
};
W3mUpdateEmailPrimaryOtpView = __decorate$10([
  customElement("w3m-update-email-primary-otp-view")
], W3mUpdateEmailPrimaryOtpView);
var __decorate$$ = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mUpdateEmailSecondaryOtpView = class W3mUpdateEmailSecondaryOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    super();
    this.email = RouterController.state.data?.newEmail;
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          await this.authConnector.provider.updateEmailSecondaryOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          RouterController.reset("Account");
        }
      } catch (error) {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
        throw error;
      }
    };
    this.onStartOver = () => {
      RouterController.replace("UpdateEmailWallet", RouterController.state.data);
    };
  }
};
W3mUpdateEmailSecondaryOtpView = __decorate$$([
  customElement("w3m-update-email-secondary-otp-view")
], W3mUpdateEmailSecondaryOtpView);
const styles$G = i$5`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$_ = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mUnsupportedChainView = class W3mUnsupportedChainView2 extends i$2 {
  constructor() {
    super(...arguments);
    this.swapUnsupportedChain = RouterController.state.data?.swapUnsupportedChain;
    this.disconecting = false;
  }
  render() {
    return x`
      <wui-flex class="container" flexDirection="column" gap="0">
        <wui-flex
          class="container"
          flexDirection="column"
          .padding=${["m", "xl", "xs", "xl"]}
          alignItems="center"
          gap="xl"
        >
          ${this.descriptionTemplate()}
        </wui-flex>

        <wui-flex flexDirection="column" padding="s" gap="xs">
          ${this.networksTemplate()}
        </wui-flex>

        <wui-separator text="or"></wui-separator>
        <wui-flex flexDirection="column" padding="s" gap="xs">
          <wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${false}
            .loading=${this.disconecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `;
  }
  descriptionTemplate() {
    if (this.swapUnsupportedChain) {
      return x`
        <wui-text variant="small-400" color="fg-200" align="center">
          The swap feature doesnt support your current network. Switch to an available option to
          continue.
        </wui-text>
      `;
    }
    return x`
      <wui-text variant="small-400" color="fg-200" align="center">
        This app doesnt support your current network. Switch to an available option to continue.
      </wui-text>
    `;
  }
  networksTemplate() {
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const approvedCaipNetworkIds = NetworkController.state.approvedCaipNetworkIds;
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    const filteredNetworks = this.swapUnsupportedChain ? sortedNetworks.filter((network) => ConstantsUtil$1.SWAP_SUPPORTED_NETWORKS.includes(network.id)) : sortedNetworks;
    return filteredNetworks.map((network) => x`
        <wui-list-network
          imageSrc=${o$3(AssetUtil.getNetworkImage(network))}
          name=${network.name ?? "Unknown"}
          @click=${() => this.onSwitchNetwork(network)}
        >
        </wui-list-network>
      `);
  }
  async onDisconnect() {
    try {
      this.disconecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({
        type: "track",
        event: "DISCONNECT_SUCCESS"
      });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconecting = false;
    }
  }
  async onSwitchNetwork(network) {
    const isConnected = AccountController.state.isConnected;
    const approvedCaipNetworkIds = NetworkController.state.approvedCaipNetworkIds;
    const supportsAllNetworks = NetworkController.state.supportsAllNetworks;
    const caipNetwork = NetworkController.state.caipNetwork;
    const routerData = RouterController.state.data;
    if (isConnected && caipNetwork?.id !== network.id) {
      if (approvedCaipNetworkIds?.includes(network.id)) {
        await NetworkController.switchActiveNetwork(network);
        await NetworkUtil.onNetworkChange();
      } else if (supportsAllNetworks) {
        RouterController.push("SwitchNetwork", { ...routerData, network });
      }
    } else if (!isConnected) {
      NetworkController.setActiveCaipNetwork(network);
      RouterController.push("Connect");
    }
  }
};
W3mUnsupportedChainView.styles = styles$G;
__decorate$_([
  r$1()
], W3mUnsupportedChainView.prototype, "disconecting", void 0);
W3mUnsupportedChainView = __decorate$_([
  customElement("w3m-unsupported-chain-view")
], W3mUnsupportedChainView);
const styles$F = i$5`
  wui-compatible-network {
    margin-top: var(--wui-spacing-l);
  }
`;
var __decorate$Z = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mWalletReceiveView = class W3mWalletReceiveView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.address = AccountController.state.address;
    this.profileName = AccountController.state.profileName;
    this.network = NetworkController.state.caipNetwork;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileName = val.profileName;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          SnackController.showError("Account not found");
        }
      })
    ], NetworkController.subscribeKey("caipNetwork", (val) => {
      if (val?.id) {
        this.network = val;
      }
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-wallet-receive-view: No account provided");
    }
    const networkImage = AssetUtil.getNetworkImage(this.network);
    return x` <wui-flex
      flexDirection="column"
      .padding=${["0", "l", "l", "l"]}
      alignItems="center"
    >
      <wui-chip-button
        data-testid="receive-address-copy-button"
        @click=${this.onCopyClick.bind(this)}
        text=${UiHelperUtil.getTruncateString({
      string: this.profileName || this.address || "",
      charsStart: this.profileName ? 18 : 4,
      charsEnd: this.profileName ? 0 : 4,
      truncate: this.profileName ? "end" : "middle"
    })}
        icon="copy"
        size="sm"
        imageSrc=${networkImage ? networkImage : ""}
        variant="gray"
      ></wui-chip-button>
      <wui-flex
        flexDirection="column"
        .padding=${["l", "0", "0", "0"]}
        alignItems="center"
        gap="s"
      >
        <wui-qr-code
          size=${232}
          theme=${ThemeController.state.themeMode}
          uri=${this.address}
          ?arenaClear=${true}
          data-testid="wui-qr-code"
        ></wui-qr-code>
        <wui-text variant="paragraph-500" color="fg-100" align="center">
          Copy your address or scan this QR code
        </wui-text>
      </wui-flex>
      ${this.networkTemplate()}
    </wui-flex>`;
  }
  networkTemplate() {
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const isNetworkEnabledForSmartAccounts = NetworkController.checkIfSmartAccountEnabled();
    const caipNetwork = NetworkController.state.caipNetwork;
    if (this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT && isNetworkEnabledForSmartAccounts) {
      if (!caipNetwork) {
        return null;
      }
      return x`<wui-compatible-network
        @click=${this.onReceiveClick.bind(this)}
        text="Only receive assets on this network"
        .networkImages=${[AssetUtil.getNetworkImage(caipNetwork) ?? ""]}
      ></wui-compatible-network>`;
    }
    const slicedNetworks = requestedCaipNetworks?.filter((network) => network?.imageId)?.slice(0, 5);
    const imagesArray = slicedNetworks.map(AssetUtil.getNetworkImage).filter(Boolean);
    return x`<wui-compatible-network
      @click=${this.onReceiveClick.bind(this)}
      text="Only receive assets on these networks"
      .networkImages=${imagesArray}
    ></wui-compatible-network>`;
  }
  onReceiveClick() {
    RouterController.push("WalletCompatibleNetworks");
  }
  onCopyClick() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mWalletReceiveView.styles = styles$F;
__decorate$Z([
  r$1()
], W3mWalletReceiveView.prototype, "address", void 0);
__decorate$Z([
  r$1()
], W3mWalletReceiveView.prototype, "profileName", void 0);
__decorate$Z([
  r$1()
], W3mWalletReceiveView.prototype, "network", void 0);
__decorate$Z([
  r$1()
], W3mWalletReceiveView.prototype, "preferredAccountType", void 0);
W3mWalletReceiveView = __decorate$Z([
  customElement("w3m-wallet-receive-view")
], W3mWalletReceiveView);
const styles$E = i$5`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$Y = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mWalletCompatibleNetworksView = class W3mWalletCompatibleNetworksView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.unsubscribe.push(AccountController.subscribeKey("preferredAccountType", (val) => {
      this.preferredAccountType = val;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x` <wui-flex
      flexDirection="column"
      .padding=${["xs", "s", "m", "s"]}
      gap="xs"
    >
      <wui-banner
        icon="warningCircle"
        text="You can only receive assets on these networks"
      ></wui-banner>
      ${this.networkTemplate()}
    </wui-flex>`;
  }
  networkTemplate() {
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const approvedCaipNetworkIds = NetworkController.state.approvedCaipNetworkIds;
    const caipNetwork = NetworkController.state.caipNetwork;
    const isNetworkEnabledForSmartAccounts = NetworkController.checkIfSmartAccountEnabled();
    let sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    if (isNetworkEnabledForSmartAccounts && this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT) {
      if (!caipNetwork) {
        return null;
      }
      sortedNetworks = [caipNetwork];
    }
    return sortedNetworks.map((network) => x`
        <wui-list-network
          imageSrc=${o$3(AssetUtil.getNetworkImage(network))}
          name=${network.name ?? "Unknown"}
          ?transparent=${true}
        >
        </wui-list-network>
      `);
  }
};
W3mWalletCompatibleNetworksView.styles = styles$E;
__decorate$Y([
  r$1()
], W3mWalletCompatibleNetworksView.prototype, "preferredAccountType", void 0);
W3mWalletCompatibleNetworksView = __decorate$Y([
  customElement("w3m-wallet-compatible-networks-view")
], W3mWalletCompatibleNetworksView);
const styles$D = i$5`
  :host {
    display: block;
  }

  wui-flex {
    position: relative;
  }

  wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xs) !important;
    border: 5px solid var(--wui-color-bg-125);
    background: var(--wui-color-bg-175);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 3;
  }

  wui-button {
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }

  .inputContainer {
    height: fit-content;
  }
`;
var __decorate$X = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mWalletSendView = class W3mWalletSendView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.token = SendController.state.token;
    this.sendTokenAmount = SendController.state.sendTokenAmount;
    this.receiverAddress = SendController.state.receiverAddress;
    this.receiverProfileName = SendController.state.receiverProfileName;
    this.loading = SendController.state.loading;
    this.gasPriceInUSD = SendController.state.gasPriceInUSD;
    this.gasPrice = SendController.state.gasPrice;
    this.message = "Preview Send";
    this.fetchNetworkPrice();
    this.unsubscribe.push(...[
      SendController.subscribe((val) => {
        this.token = val.token;
        this.sendTokenAmount = val.sendTokenAmount;
        this.receiverAddress = val.receiverAddress;
        this.gasPriceInUSD = val.gasPriceInUSD;
        this.receiverProfileName = val.receiverProfileName;
        this.loading = val.loading;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    this.getMessage();
    return x` <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]}>
      <wui-flex class="inputContainer" gap="xs" flexDirection="column">
        <w3m-input-token
          .token=${this.token}
          .sendTokenAmount=${this.sendTokenAmount}
          .gasPriceInUSD=${this.gasPriceInUSD}
          .gasPrice=${this.gasPrice}
        ></w3m-input-token>
        <wui-icon-box
          size="inherit"
          backgroundColor="fg-300"
          iconSize="lg"
          iconColor="fg-250"
          background="opaque"
          icon="arrowBottom"
        ></wui-icon-box>
        <w3m-input-address
          .value=${this.receiverProfileName ? this.receiverProfileName : this.receiverAddress}
        ></w3m-input-address>
      </wui-flex>
      <wui-flex .margin=${["l", "0", "0", "0"]}>
        <wui-button
          @click=${this.onButtonClick.bind(this)}
          ?disabled=${!this.message.startsWith("Preview Send")}
          size="lg"
          variant="main"
          ?loading=${this.loading}
          fullWidth
        >
          ${this.message}
        </wui-button>
      </wui-flex>
    </wui-flex>`;
  }
  async fetchNetworkPrice() {
    await SwapController.getNetworkTokenPrice();
    const gas = await SwapController.getInitialGasPrice();
    if (gas?.gasPrice && gas?.gasPriceInUSD) {
      SendController.setGasPrice(gas.gasPrice);
      SendController.setGasPriceInUsd(gas.gasPriceInUSD);
    }
  }
  onButtonClick() {
    RouterController.push("WalletSendPreview");
  }
  getMessage() {
    this.message = "Preview Send";
    if (this.receiverAddress && !CoreHelperUtil.isAddress(this.receiverAddress, ChainController.state.activeChain)) {
      this.message = "Invalid Address";
    }
    if (!this.receiverAddress) {
      this.message = "Add Address";
    }
    if (this.sendTokenAmount && this.token && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
      this.message = "Insufficient Funds";
    }
    if (!this.sendTokenAmount) {
      this.message = "Add Amount";
    }
    if (this.sendTokenAmount && this.token?.price) {
      const value = this.sendTokenAmount * this.token.price;
      if (!value) {
        this.message = "Incorrect Value";
      }
    }
    if (!this.token) {
      this.message = "Select Token";
    }
  }
};
W3mWalletSendView.styles = styles$D;
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "token", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "sendTokenAmount", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "receiverAddress", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "receiverProfileName", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "loading", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "gasPriceInUSD", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "gasPrice", void 0);
__decorate$X([
  r$1()
], W3mWalletSendView.prototype, "message", void 0);
W3mWalletSendView = __decorate$X([
  customElement("w3m-wallet-send-view")
], W3mWalletSendView);
const styles$C = i$5`
  .contentContainer {
    height: 440px;
    overflow: scroll;
    scrollbar-width: none;
  }

  .contentContainer::-webkit-scrollbar {
    display: none;
  }

  wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }
`;
var __decorate$W = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mSendSelectTokenView = class W3mSendSelectTokenView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tokenBalance = AccountController.state.tokenBalance;
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    });
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        this.tokenBalance = val.tokenBalance;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      <wui-flex flexDirection="column">
        ${this.templateSearchInput()} <wui-separator></wui-separator> ${this.templateTokens()}
      </wui-flex>
    `;
  }
  templateSearchInput() {
    return x`
      <wui-flex gap="xs" padding="s">
        <wui-input-text
          @inputChange=${this.onInputChange.bind(this)}
          class="network-search-input"
          size="sm"
          placeholder="Search token"
          icon="search"
        ></wui-input-text>
      </wui-flex>
    `;
  }
  templateTokens() {
    this.tokens = this.tokenBalance?.filter((token2) => token2.chainId === NetworkController.state.caipNetwork?.id);
    if (this.search) {
      this.filteredTokens = this.tokenBalance?.filter((token2) => token2.name.toLowerCase().includes(this.search.toLowerCase()));
    } else {
      this.filteredTokens = this.tokens;
    }
    return x`
      <wui-flex
        class="contentContainer"
        flexDirection="column"
        .padding=${["0", "s", "0", "s"]}
      >
        <wui-flex justifyContent="flex-start" .padding=${["m", "s", "s", "s"]}>
          <wui-text variant="paragraph-500" color="fg-200">Your tokens</wui-text>
        </wui-flex>
        <wui-flex flexDirection="column" gap="xs">
          ${this.filteredTokens && this.filteredTokens.length > 0 ? this.filteredTokens.map((token2) => x`<wui-list-token
                    @click=${this.handleTokenClick.bind(this, token2)}
                    ?clickable=${true}
                    tokenName=${token2.name}
                    tokenImageUrl=${token2.iconUrl}
                    tokenAmount=${token2.quantity.numeric}
                    tokenValue=${token2.value}
                    tokenCurrency=${token2.symbol}
                  ></wui-list-token>`) : x`<wui-flex
                .padding=${["4xl", "0", "0", "0"]}
                alignItems="center"
                flexDirection="column"
                gap="l"
              >
                <wui-icon-box
                  icon="coinPlaceholder"
                  size="inherit"
                  iconColor="fg-200"
                  backgroundColor="fg-200"
                  iconSize="lg"
                ></wui-icon-box>
                <wui-flex
                  class="textContent"
                  gap="xs"
                  flexDirection="column"
                  justifyContent="center"
                  flexDirection="column"
                >
                  <wui-text variant="paragraph-500" align="center" color="fg-100"
                    >No tokens found</wui-text
                  >
                  <wui-text variant="small-400" align="center" color="fg-200"
                    >Your tokens will appear here</wui-text
                  >
                </wui-flex>
                <wui-link @click=${this.onBuyClick.bind(this)}>Buy</wui-link>
              </wui-flex>`}
        </wui-flex>
      </wui-flex>
    `;
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  handleTokenClick(token2) {
    SendController.setToken(token2);
    SendController.setTokenAmount(void 0);
    RouterController.goBack();
  }
};
W3mSendSelectTokenView.styles = styles$C;
__decorate$W([
  r$1()
], W3mSendSelectTokenView.prototype, "tokenBalance", void 0);
__decorate$W([
  r$1()
], W3mSendSelectTokenView.prototype, "tokens", void 0);
__decorate$W([
  r$1()
], W3mSendSelectTokenView.prototype, "filteredTokens", void 0);
__decorate$W([
  r$1()
], W3mSendSelectTokenView.prototype, "search", void 0);
W3mSendSelectTokenView = __decorate$W([
  customElement("w3m-wallet-send-select-token-view")
], W3mSendSelectTokenView);
const styles$B = i$5`
  wui-avatar,
  wui-image {
    display: ruby;
    width: 32px;
    height: 32px;
    border-radius: var(--wui-border-radius-3xl);
  }

  .sendButton {
    width: 70%;
    --local-width: 100% !important;
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }

  .cancelButton {
    width: 30%;
    --local-width: 100% !important;
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }
`;
var __decorate$V = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mWalletSendPreviewView = class W3mWalletSendPreviewView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.token = SendController.state.token;
    this.sendTokenAmount = SendController.state.sendTokenAmount;
    this.receiverAddress = SendController.state.receiverAddress;
    this.receiverProfileName = SendController.state.receiverProfileName;
    this.receiverProfileImageUrl = SendController.state.receiverProfileImageUrl;
    this.gasPriceInUSD = SendController.state.gasPriceInUSD;
    this.caipNetwork = NetworkController.state.caipNetwork;
    this.unsubscribe.push(...[
      SendController.subscribe((val) => {
        this.token = val.token;
        this.sendTokenAmount = val.sendTokenAmount;
        this.receiverAddress = val.receiverAddress;
        this.gasPriceInUSD = val.gasPriceInUSD;
        this.receiverProfileName = val.receiverProfileName;
        this.receiverProfileImageUrl = val.receiverProfileImageUrl;
      }),
      NetworkController.subscribeKey("caipNetwork", (val) => this.caipNetwork = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x` <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]}>
      <wui-flex gap="xs" flexDirection="column" .padding=${["0", "xs", "0", "xs"]}>
        <wui-flex alignItems="center" justifyContent="space-between">
          <wui-flex flexDirection="column" gap="4xs">
            <wui-text variant="small-400" color="fg-150">Send</wui-text>
            ${this.sendValueTemplate()}
          </wui-flex>
          <wui-preview-item
            text="${this.sendTokenAmount ? UiHelperUtil.roundNumber(this.sendTokenAmount, 6, 5) : "unknown"} ${this.token?.symbol}"
            .imageSrc=${this.token?.iconUrl}
          ></wui-preview-item>
        </wui-flex>
        <wui-flex>
          <wui-icon color="fg-200" size="md" name="arrowBottom"></wui-icon>
        </wui-flex>
        <wui-flex alignItems="center" justifyContent="space-between">
          <wui-text variant="small-400" color="fg-150">To</wui-text>
          <wui-preview-item
            text="${this.receiverProfileName ? UiHelperUtil.getTruncateString({
      string: this.receiverProfileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.receiverAddress ? this.receiverAddress : "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}"
            address=${this.receiverAddress ?? ""}
            .imageSrc=${this.receiverProfileImageUrl ?? void 0}
            .isAddress=${true}
          ></wui-preview-item>
        </wui-flex>
      </wui-flex>
      <wui-flex flexDirection="column" .padding=${["xxl", "0", "0", "0"]}>
        <w3m-wallet-send-details
          .caipNetwork=${this.caipNetwork}
          .receiverAddress=${this.receiverAddress}
          .networkFee=${this.gasPriceInUSD}
        ></w3m-wallet-send-details>
        <wui-flex justifyContent="center" gap="xxs" .padding=${["s", "0", "0", "0"]}>
          <wui-icon size="sm" color="fg-200" name="warningCircle"></wui-icon>
          <wui-text variant="small-400" color="fg-200">Review transaction carefully</wui-text>
        </wui-flex>
        <wui-flex justifyContent="center" gap="s" .padding=${["l", "0", "0", "0"]}>
          <wui-button
            class="cancelButton"
            @click=${this.onCancelClick.bind(this)}
            size="lg"
            variant="neutral"
          >
            Cancel
          </wui-button>
          <wui-button
            class="sendButton"
            @click=${this.onSendClick.bind(this)}
            size="lg"
            variant="main"
          >
            Send
          </wui-button>
        </wui-flex>
      </wui-flex></wui-flex
    >`;
  }
  sendValueTemplate() {
    if (this.token && this.sendTokenAmount) {
      const price = this.token.price;
      const totalValue = price * this.sendTokenAmount;
      return x`<wui-text variant="paragraph-400" color="fg-100"
        >$${totalValue.toFixed(2)}</wui-text
      >`;
    }
    return null;
  }
  onSendClick() {
    SendController.sendToken();
  }
  onCancelClick() {
    RouterController.goBack();
  }
};
W3mWalletSendPreviewView.styles = styles$B;
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "token", void 0);
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "sendTokenAmount", void 0);
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "receiverAddress", void 0);
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "receiverProfileName", void 0);
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "receiverProfileImageUrl", void 0);
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "gasPriceInUSD", void 0);
__decorate$V([
  r$1()
], W3mWalletSendPreviewView.prototype, "caipNetwork", void 0);
W3mWalletSendPreviewView = __decorate$V([
  customElement("w3m-wallet-send-preview-view")
], W3mWalletSendPreviewView);
const styles$A = i$5`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }
  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$U = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectWalletsView = class W3mConnectWalletsView2 extends i$2 {
  render() {
    return x`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        <w3m-wallet-login-list></w3m-wallet-login-list>
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
};
W3mConnectWalletsView.styles = styles$A;
W3mConnectWalletsView = __decorate$U([
  customElement("w3m-connect-wallets-view")
], W3mConnectWalletsView);
const styles$z = i$5`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }
  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$T = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectSocialsView = class W3mConnectSocialsView2 extends i$2 {
  render() {
    return x`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        <w3m-social-login-list></w3m-social-login-list>
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
};
W3mConnectSocialsView.styles = styles$z;
W3mConnectSocialsView = __decorate$T([
  customElement("w3m-connect-socials-view")
], W3mConnectSocialsView);
const styles$y = i$5`
  wui-logo {
    width: 80px;
    height: 80px;
    border-radius: var(--wui-border-radius-m);
  }
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }
  wui-flex:first-child:not(:only-child) {
    position: relative;
  }
  wui-loading-thumbnail {
    position: absolute;
  }
  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }
  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }
  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }
  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }
  .capitalize {
    text-transform: capitalize;
  }
`;
var __decorate$S = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingSocialView = class W3mConnectingSocialView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.socialProvider = AccountController.state.socialProvider;
    this.socialWindow = AccountController.state.socialWindow;
    this.error = false;
    this.connecting = false;
    this.message = "Connect in the provider window";
    this.authConnector = ConnectorController.getAuthConnector();
    this.handleSocialConnection = async (event) => {
      if (event.data?.resultUri) {
        if (event.origin === ConstantsUtil.SECURE_SITE_ORIGIN) {
          window.removeEventListener("message", this.handleSocialConnection, false);
          try {
            if (this.authConnector && !this.connecting) {
              if (this.socialWindow) {
                this.socialWindow.close();
                AccountController.setSocialWindow(void 0, ChainController.state.activeChain);
              }
              this.connecting = true;
              this.updateMessage();
              const uri = event.data.resultUri;
              await this.authConnector.provider.connectSocial(uri);
              if (this.socialProvider) {
                StorageUtil.setConnectedSocialProvider(this.socialProvider);
                await ConnectionController.connectExternal(this.authConnector, this.authConnector.chain);
                EventsController.sendEvent({
                  type: "track",
                  event: "SOCIAL_LOGIN_SUCCESS",
                  properties: { provider: this.socialProvider }
                });
              }
            }
          } catch (error) {
            this.error = true;
            this.updateMessage();
            if (this.socialProvider) {
              EventsController.sendEvent({
                type: "track",
                event: "SOCIAL_LOGIN_ERROR",
                properties: { provider: this.socialProvider }
              });
            }
          }
        } else {
          RouterController.goBack();
          SnackController.showError("Untrusted Origin");
          if (this.socialProvider) {
            EventsController.sendEvent({
              type: "track",
              event: "SOCIAL_LOGIN_ERROR",
              properties: { provider: this.socialProvider }
            });
          }
        }
      }
    };
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.socialProvider) {
          this.socialProvider = val.socialProvider;
        }
        if (val.socialWindow) {
          this.socialWindow = val.socialWindow;
        }
        if (val.address) {
          if (ModalController.state.open) {
            ModalController.close();
          }
        }
      })
    ]);
    if (this.authConnector) {
      this.connectSocial();
    }
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    window.removeEventListener("message", this.handleSocialConnection, false);
  }
  render() {
    return x`
      <wui-flex
        data-error=${o$3(this.error)}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-logo logo=${o$3(this.socialProvider)}></wui-logo>
          ${this.error ? null : this.loaderTemplate()}
          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100"
            >Log in with
            <span class="capitalize">${this.socialProvider ?? "Social"}</span></wui-text
          >
          <wui-text align="center" variant="small-400" color=${this.error ? "error-100" : "fg-200"}
            >${this.message}</wui-text
          ></wui-flex
        >
      </wui-flex>
    `;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return x`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  connectSocial() {
    const interval = setInterval(() => {
      if (this.socialWindow?.closed) {
        if (!this.connecting && RouterController.state.view === "ConnectingSocial") {
          RouterController.goBack();
        }
        clearInterval(interval);
      }
    }, 1e3);
    window.addEventListener("message", this.handleSocialConnection, false);
  }
  updateMessage() {
    if (this.error) {
      this.message = "Something went wrong";
    } else if (this.connecting) {
      this.message = "Retrieving user data";
    } else {
      this.message = "Connect in the provider window";
    }
  }
};
W3mConnectingSocialView.styles = styles$y;
__decorate$S([
  r$1()
], W3mConnectingSocialView.prototype, "socialProvider", void 0);
__decorate$S([
  r$1()
], W3mConnectingSocialView.prototype, "socialWindow", void 0);
__decorate$S([
  r$1()
], W3mConnectingSocialView.prototype, "error", void 0);
__decorate$S([
  r$1()
], W3mConnectingSocialView.prototype, "connecting", void 0);
__decorate$S([
  r$1()
], W3mConnectingSocialView.prototype, "message", void 0);
W3mConnectingSocialView = __decorate$S([
  customElement("w3m-connecting-social-view")
], W3mConnectingSocialView);
const styles$x = i$5`
  wui-flex {
    width: 100%;
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;

    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #47a1ff;
  }

  .account-settings-button {
    padding: calc(var(--wui-spacing-m) - 1px) var(--wui-spacing-2l);
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    cursor: pointer;
  }

  .account-settings-button:hover {
    background: var(--wui-color-gray-glass-005);
  }
`;
var __decorate$R = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mProfileView = class W3mProfileView2 extends i$2 {
  constructor() {
    super();
    this.usubscribe = [];
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.accounts = AccountController.state.allAccounts;
    this.usubscribe.push(AccountController.subscribeKey("address", (address) => {
      if (address) {
        this.address = address;
      } else {
        ModalController.close();
      }
    }));
    this.usubscribe.push(AccountController.subscribeKey("profileImage", (profileImage) => {
      this.profileImage = profileImage;
    }));
    this.usubscribe.push(AccountController.subscribeKey("profileName", (profileName) => {
      this.profileName = profileName;
    }));
  }
  disconnectedCallback() {
    this.usubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-profile-view: No account provided");
    }
    const name = this.profileName?.split(".")[0];
    return x`
      <wui-flex flexDirection="column" gap="l" .padding=${["0", "xl", "m", "xl"]}>
        <wui-flex flexDirection="column" alignItems="center" gap="l">
          <wui-avatar
            alt=${this.address}
            address=${this.address}
            imageSrc=${o$3(this.profileImage)}
            size="2lg"
          ></wui-avatar>
          <wui-flex flexDirection="column" alignItems="center">
            <wui-flex gap="3xs" alignItems="center" justifyContent="center">
              <wui-text variant="title-6-600" color="fg-100" data-testid="account-settings-address">
                ${name ? UiHelperUtil.getTruncateString({
      string: name,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}
              </wui-text>
              <wui-icon-link
                size="md"
                icon="copy"
                iconColor="fg-200"
                @click=${this.onCopyAddress}
              ></wui-icon-link>
            </wui-flex>
          </wui-flex>
        </wui-flex>
        <wui-flex
          data-testid="account-settings-button"
          justifyContent="center"
          alignItems="center"
          class="account-settings-button"
          @click=${() => RouterController.push("AccountSettings")}
        >
          <wui-text variant="paragraph-500" color="fg-100">Account Settings</wui-text>
        </wui-flex>
        ${this.accountsTemplate()}
      </wui-flex>
    `;
  }
  accountsTemplate() {
    return x`<wui-flex flexDirection="column">
      <wui-flex .padding=${["3xs", "m", "s", "s"]}>
        <wui-text color="fg-200" variant="paragraph-400">Your accounts</wui-text>
      </wui-flex>
      <wui-flex flexDirection="column" gap="xxs">
        ${this.accounts.map((account) => this.accountTemplate(account))}
      </wui-flex>
    </wui-flex>`;
  }
  async onSwitchAccount(account) {
    AccountController.setShouldUpdateToAddress(account.address, ChainController.state.activeChain);
    const emailConnector = ConnectorController.getAuthConnector();
    if (!emailConnector) {
      return;
    }
    await emailConnector.provider.setPreferredAccount(account.type);
    await emailConnector.provider.connect();
  }
  accountTemplate(account) {
    return x`<wui-list-account accountAddress=${account.address} accountType=${account.type}>
      ${account.address === this.address ? "" : x`<wui-button
            slot="action"
            textVariant="small-600"
            size="sm"
            variant="accent"
            @click=${() => this.onSwitchAccount(account)}
            >Switch</wui-button
          >`}
    </wui-list-account>`;
  }
  onCopyAddress() {
    try {
      if (this.profileName) {
        CoreHelperUtil.copyToClopboard(this.profileName);
        SnackController.showSuccess("Name copied");
      } else if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mProfileView.styles = styles$x;
__decorate$R([
  r$1()
], W3mProfileView.prototype, "address", void 0);
__decorate$R([
  r$1()
], W3mProfileView.prototype, "profileImage", void 0);
__decorate$R([
  r$1()
], W3mProfileView.prototype, "profileName", void 0);
__decorate$R([
  r$1()
], W3mProfileView.prototype, "accounts", void 0);
W3mProfileView = __decorate$R([
  customElement("w3m-profile-view")
], W3mProfileView);
const styles$w = i$5`
  input[type='checkbox'] {
    all: revert;
    width: var(--wui-spacing-xl);
    height: var(--wui-spacing-xl);
    accent-color: var(--wui-color-accent-100);
  }
`;
var __decorate$Q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mSelectAddressesView = class W3mSelectAddressesView2 extends i$2 {
  constructor() {
    super();
    this.metadata = OptionsController.state.metadata;
    this.allAccounts = AccountController.state.allAccounts;
    this.selectedAccounts = AccountController.state.allAccounts;
    this.selectAll = true;
    this.approved = false;
    this.isApproving = false;
    this.getAddressTemplate = (account) => {
      const checked = this.selectedAccounts.some((_account) => _account.address === account.address);
      return x`<wui-list-account accountAddress="${account.address}" accountType="${account.type}">
      <input
        id="${account.address}"
        slot="action"
        type="checkbox"
        .checked="${checked}"
        @change="${this.handleClick(account)}"
      />
    </wui-list-account>`;
    };
    this.onSelectAll = (event) => {
      const checked = event.target.checked;
      this.selectAll = this.selectedAccounts.length === this.allAccounts.length;
      this.allAccounts.forEach((account) => {
        this.onSelect(account, checked);
      });
    };
    this.onSelect = (account, add2) => {
      if (add2) {
        this.selectedAccounts.push(account);
      } else {
        this.selectedAccounts = this.selectedAccounts.filter((a2) => a2.address !== account.address);
      }
      if (this.selectedAccounts.length > 0) {
        this.selectAll = this.selectedAccounts.length === this.allAccounts.length;
      }
    };
    AccountController.subscribeKey("allAccounts", (allAccounts) => {
      this.allAccounts = allAccounts;
    });
  }
  render() {
    return x`
    <wui-flex justifyContent="center" .padding=${["xl", "0", "xl", "0"]}>
      <wui-banner-img imageSrc="${o$3(this.metadata?.icons[0])}" text="${o$3(this.metadata?.url)}" size="sm"></wui-banner>
    </wui-flex>
    <wui-flex .padding=${["0", "xl", "0", "xl"]} flexDirection="row" justifyContent="space-between">
        <wui-text variant="paragraph-400" color="fg-200">Select all</wui-text>
        <input type="checkbox" .checked=${this.selectAll}  @click=${this.onSelectAll.bind(this)} />
    </wui-flex>
      <wui-flex flexDirection="column" .padding=${["l", "xl", "xl", "xl"]}>
        ${this.allAccounts.map((account) => this.getAddressTemplate(account))}
      </wui-flex>
      <wui-flex .padding=${["l", "xl", "xl", "xl"]} gap="s" justifyContent="space-between">
        <wui-button
          size="md"
          ?fullwidth=${true}
          variant="neutral"
          @click=${this.onCancel.bind(this)}
          data-testid="w3m-connecting-siwe-cancel"
        >
          Cancel
        </wui-button>
        <wui-button
          size="md"
          ?fullwidth=${true}
          variant="main"
          .disabled=${this.selectedAccounts.length === 0}
          @click=${this.onContinue.bind(this)}
          ?loading=${this.isApproving}
        >
          ${this.isApproving ? "Signing..." : "Continue"}
        </wui-button>
      </wui-flex>
    `;
  }
  handleClick(account) {
    return (event) => {
      const target = event.target;
      this.onSelect?.({ ...account }, target?.checked);
    };
  }
  onContinue() {
    if (this.selectedAccounts.length > 0) {
      this.isApproving = true;
      AccountController.setAllAccounts(this.selectedAccounts, ChainController.state.activeChain);
      AccountController.setShouldUpdateToAddress(this.selectedAccounts[0]?.address ?? "", ChainController.state.activeChain);
      this.approved = true;
      this.isApproving = false;
      ModalController.close();
    } else {
      this.onCancel();
    }
  }
  async onCancel() {
    const { isConnected } = AccountController.state;
    if (isConnected) {
      await ConnectionController.disconnect();
      ModalController.close();
    } else {
      RouterController.push("Connect");
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (!this.approved) {
      this.onCancel();
    }
  }
};
W3mSelectAddressesView.styles = styles$w;
__decorate$Q([
  r$1()
], W3mSelectAddressesView.prototype, "allAccounts", void 0);
__decorate$Q([
  r$1()
], W3mSelectAddressesView.prototype, "selectedAccounts", void 0);
__decorate$Q([
  r$1()
], W3mSelectAddressesView.prototype, "selectAll", void 0);
__decorate$Q([
  r$1()
], W3mSelectAddressesView.prototype, "approved", void 0);
__decorate$Q([
  r$1()
], W3mSelectAddressesView.prototype, "isApproving", void 0);
W3mSelectAddressesView = __decorate$Q([
  customElement("w3m-select-addresses-view")
], W3mSelectAddressesView);
const styles$v = i$5`
  wui-avatar {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    box-shadow: 0 0 0 0;
  }

  wui-icon-box {
    position: relative;
    right: 15px;
    top: 15px;
    border: 2px solid var(--wui-color-bg-150);
    background-color: var(--wui-color-bg-125);
  }
`;
var __decorate$P = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mSwitchAddressView = class W3mSwitchAddressView2 extends i$2 {
  constructor() {
    super();
    this.metadata = OptionsController.state.metadata;
    this.allAccounts = AccountController.state.allAccounts || [];
    this.balances = {};
    this.labels = AccountController.state.addressLabels;
    this.currentAddress = AccountController.state.address || "";
    this.connectedConnector = StorageUtil.getConnectedConnector();
    this.shouldShowIcon = this.connectedConnector === "AUTH";
    this.caipNetwork = NetworkController.state.caipNetwork;
    AccountController.subscribeKey("allAccounts", (allAccounts) => {
      this.allAccounts = allAccounts;
    });
  }
  connectedCallback() {
    super.connectedCallback();
    this.allAccounts.forEach((account) => {
      BlockchainApiController.getBalance(account.address, this.caipNetwork?.id).then((response) => {
        let total = this.balances[account.address] || 0;
        if (response.balances.length > 0) {
          total = response.balances.reduce((acc, balance) => acc + (balance?.value || 0), 0);
        }
        this.balances[account.address] = total;
        this.requestUpdate();
      });
    });
  }
  getAddressIcon(type) {
    if (type === "smartAccount") {
      return "lightbulb";
    }
    return "mail";
  }
  render() {
    return x`
      <wui-flex justifyContent="center" .padding=${["xl", "0", "xl", "0"]}>
        <wui-banner-img
          imageSrc=${o$3(this.metadata?.icons[0])}
          text=${o$3(this.metadata?.url)}
          size="sm"
        ></wui-banner-img>
      </wui-flex>
      <wui-flex flexDirection="column" gap="xxl" .padding=${["l", "xl", "xl", "xl"]}>
        ${this.allAccounts.map((account, index2) => this.getAddressTemplate(account, index2))}
      </wui-flex>
    `;
  }
  getAddressTemplate(account, index2) {
    const label = this.labels?.get(account.address);
    return x`
      <wui-flex
        flexDirection="row"
        justifyContent="space-between"
        data-testid="switch-address-item"
      >
        <wui-flex alignItems="center">
          <wui-avatar address=${account.address}></wui-avatar>
          ${this.shouldShowIcon ? x`<wui-icon-box
                size="sm"
                iconcolor="fg-200"
                backgroundcolor="glass-002"
                background="gray"
                icon="${this.getAddressIcon(account.type)}"
                ?border=${true}
              ></wui-icon-box>` : x`<wui-flex .padding="${["0", "0", "0", "s"]}"></wui-flex>`}
          <wui-flex flexDirection="column">
            <wui-text class="address" variant="paragraph-500" color="fg-100"
              >${label ? label : UiHelperUtil.getTruncateString({
      string: account.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}</wui-text
            >
            <wui-text class="address-description" variant="small-400">
              ${typeof this.balances[account.address] === "number" ? `$${this.balances[account.address]?.toFixed(2)}` : x`<wui-loading-spinner size="sm" color="accent-100"></wui-loading-spinner>`}
            </wui-text>
          </wui-flex>
        </wui-flex>
        <wui-flex gap="s" alignItems="center">
          ${account.address?.toLowerCase() === this.currentAddress?.toLowerCase() ? "" : x`
                <wui-button
                  data-testid=${`w3m-switch-address-button-${index2}`}
                  textVariant="small-600"
                  size="md"
                  variant="accent"
                  @click=${() => this.onSwitchAddress(account.address)}
                  >Switch to</wui-button
                >
              `}
        </wui-flex>
      </wui-flex>
    `;
  }
  onSwitchAddress(address) {
    AccountController.setShouldUpdateToAddress(address, ChainController.state.activeChain);
    ModalController.close();
  }
};
W3mSwitchAddressView.styles = styles$v;
__decorate$P([
  r$1()
], W3mSwitchAddressView.prototype, "allAccounts", void 0);
__decorate$P([
  r$1()
], W3mSwitchAddressView.prototype, "balances", void 0);
W3mSwitchAddressView = __decorate$P([
  customElement("w3m-switch-address-view")
], W3mSwitchAddressView);
const styles$u = i$5`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }

  wui-logo {
    width: 80px;
    height: 80px;
    border-radius: var(--wui-border-radius-m);
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }
  wui-loading-thumbnail {
    position: absolute;
  }
  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }
`;
var __decorate$O = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingFarcasterView = class W3mConnectingFarcasterView2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.timeout = void 0;
    this.socialProvider = AccountController.state.socialProvider;
    this.uri = AccountController.state.farcasterUrl;
    this.ready = false;
    this.loading = false;
    this.authConnector = ConnectorController.getAuthConnector();
    this.forceUpdate = () => {
      this.requestUpdate();
    };
    this.unsubscribe.push(...[
      AccountController.subscribeKey("farcasterUrl", (val) => {
        if (val) {
          this.uri = val;
          this.connectFarcaster();
        }
      }),
      AccountController.subscribeKey("socialProvider", (val) => {
        if (val) {
          this.socialProvider = val;
        }
      })
    ]);
    window.addEventListener("resize", this.forceUpdate);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    clearTimeout(this.timeout);
    window.removeEventListener("resize", this.forceUpdate);
  }
  render() {
    this.onRenderProxy();
    return x`${this.platformTemplate()}`;
  }
  platformTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return x`${this.mobileTemplate()}`;
    }
    return x`${this.desktopTemplate()}`;
  }
  desktopTemplate() {
    if (this.loading) {
      return x`${this.loadingTemplate()}`;
    }
    return x`${this.qrTemplate()}`;
  }
  qrTemplate() {
    return x` <wui-flex
      flexDirection="column"
      alignItems="center"
      .padding=${["0", "xl", "xl", "xl"]}
      gap="xl"
    >
      <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

      <wui-text variant="paragraph-500" color="fg-100">
        Scan this QR Code with your phone
      </wui-text>
      ${this.copyTemplate()}
    </wui-flex>`;
  }
  loadingTemplate() {
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-logo logo="farcaster"></wui-logo>
          ${this.loaderTemplate()}
          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">
            Loading user data
          </wui-text>
          <wui-text align="center" variant="small-400" color="fg-200">
            Please wait a moment while we load your data.
          </wui-text>
        </wui-flex>
      </wui-flex>
    `;
  }
  mobileTemplate() {
    return x` <wui-flex
      flexDirection="column"
      alignItems="center"
      .padding=${["3xl", "xl", "xl", "xl"]}
      gap="xl"
    >
      <wui-flex justifyContent="center" alignItems="center">
        <wui-logo logo="farcaster"></wui-logo>
        ${this.loaderTemplate()}
        <wui-icon-box
          backgroundColor="error-100"
          background="opaque"
          iconColor="error-100"
          icon="close"
          size="sm"
          border
          borderColor="wui-color-bg-125"
        ></wui-icon-box>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="xs">
        <wui-text align="center" variant="paragraph-500" color="fg-100"
          >Continue in Farcaster</span></wui-text
        >
        <wui-text align="center" variant="small-400" color="fg-200"
          >Accept connection request in the app</wui-text
        ></wui-flex
      >
      ${this.mobileLinkTemplate()}
    </wui-flex>`;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return x`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  async connectFarcaster() {
    if (this.authConnector) {
      try {
        await this.authConnector?.provider.connectFarcaster();
        if (this.socialProvider) {
          StorageUtil.setConnectedSocialProvider(this.socialProvider);
        }
        this.loading = true;
        await ConnectionController.connectExternal(this.authConnector, this.authConnector.chain);
        this.loading = false;
        ModalController.close();
      } catch (error) {
        RouterController.goBack();
        SnackController.showError(error);
      }
    }
  }
  mobileLinkTemplate() {
    return x`<wui-button
      size="md"
      ?loading=${this.loading}
      ?disabled=${!this.uri || this.loading}
      @click=${() => {
      if (this.uri) {
        CoreHelperUtil.openHref(this.uri, "_blank");
      }
    }}
    >
      Open farcaster</wui-button
    >`;
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.timeout = setTimeout(() => {
        this.ready = true;
      }, 0);
    }
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready) {
      return null;
    }
    const size2 = this.getBoundingClientRect().width - 40;
    return x` <wui-qr-code
      size=${size2}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      ?farcaster=${true}
      data-testid="wui-qr-code"
    ></wui-qr-code>`;
  }
  copyTemplate() {
    const inactive = !this.uri || !this.ready;
    return x`<wui-link
      .disabled=${inactive}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`;
  }
  onCopyUri() {
    try {
      if (this.uri) {
        CoreHelperUtil.copyToClopboard(this.uri);
        SnackController.showSuccess("Link copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mConnectingFarcasterView.styles = styles$u;
__decorate$O([
  r$1()
], W3mConnectingFarcasterView.prototype, "socialProvider", void 0);
__decorate$O([
  r$1()
], W3mConnectingFarcasterView.prototype, "uri", void 0);
__decorate$O([
  r$1()
], W3mConnectingFarcasterView.prototype, "ready", void 0);
__decorate$O([
  r$1()
], W3mConnectingFarcasterView.prototype, "loading", void 0);
W3mConnectingFarcasterView = __decorate$O([
  customElement("w3m-connecting-farcaster-view")
], W3mConnectingFarcasterView);
const styles$t = i$5`
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 76px);
  }

  @media (max-width: 435px) {
    wui-grid {
      grid-template-columns: repeat(auto-fill, 77px);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;
function markWalletsAsInstalled(wallets) {
  const { connectors } = ConnectorController.state;
  const installedConnectors = connectors.filter((c2) => c2.type === "ANNOUNCED").reduce((acum, val) => {
    if (!val.info?.rdns) {
      return acum;
    }
    acum[val.info.rdns] = true;
    return acum;
  }, {});
  const walletsWithInstalled = wallets.map((wallet) => ({
    ...wallet,
    installed: Boolean(wallet.rdns) && Boolean(installedConnectors[wallet.rdns ?? ""])
  }));
  const sortedWallets = walletsWithInstalled.sort((a2, b2) => Number(b2.installed) - Number(a2.installed));
  return sortedWallets;
}
var __decorate$N = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const PAGINATOR_ID$1 = "local-paginator";
let W3mAllWalletsList = class W3mAllWalletsList2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.initial = !ApiController.state.wallets.length;
    this.wallets = ApiController.state.wallets;
    this.recommended = ApiController.state.recommended;
    this.featured = ApiController.state.featured;
    this.unsubscribe.push(...[
      ApiController.subscribeKey("wallets", (val) => this.wallets = val),
      ApiController.subscribeKey("recommended", (val) => this.recommended = val),
      ApiController.subscribeKey("featured", (val) => this.featured = val)
    ]);
  }
  firstUpdated() {
    this.initialFetch();
    this.createPaginationObserver();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    this.paginationObserver?.disconnect();
  }
  render() {
    return x`
      <wui-grid
        data-scroll=${!this.initial}
        .padding=${["0", "s", "s", "s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.initial ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `;
  }
  async initialFetch() {
    const gridEl = this.shadowRoot?.querySelector("wui-grid");
    if (this.initial && gridEl) {
      await ApiController.fetchWallets({ page: 1 });
      await gridEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.initial = false;
      gridEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  shimmerTemplate(items, id) {
    return [...Array(items)].map(() => x`
        <wui-card-select-loader type="wallet" id=${o$3(id)}></wui-card-select-loader>
      `);
  }
  walletsTemplate() {
    const wallets = [...this.featured, ...this.recommended, ...this.wallets];
    const walletsWithInstalled = markWalletsAsInstalled(wallets);
    return walletsWithInstalled.map((wallet) => x`
        <w3m-all-wallets-list-item
          @click=${() => this.onConnectWallet(wallet)}
          .wallet=${wallet}
        ></w3m-all-wallets-list-item>
      `);
  }
  paginationLoaderTemplate() {
    const { wallets, recommended, featured, count } = ApiController.state;
    const columns = window.innerWidth < 352 ? 3 : 4;
    const currentWallets = wallets.length + recommended.length;
    const minimumRows = Math.ceil(currentWallets / columns);
    let shimmerCount = minimumRows * columns - currentWallets + columns;
    shimmerCount -= wallets.length ? featured.length % columns : 0;
    if (count === 0 && featured.length > 0) {
      return null;
    }
    if (count === 0 || [...featured, ...wallets, ...recommended].length < count) {
      return this.shimmerTemplate(shimmerCount, PAGINATOR_ID$1);
    }
    return null;
  }
  createPaginationObserver() {
    const loaderEl = this.shadowRoot?.querySelector(`#${PAGINATOR_ID$1}`);
    if (loaderEl) {
      this.paginationObserver = new IntersectionObserver(([element]) => {
        if (element?.isIntersecting && !this.initial) {
          const { page, count, wallets } = ApiController.state;
          if (wallets.length < count) {
            ApiController.fetchWallets({ page: page + 1 });
          }
        }
      });
      this.paginationObserver.observe(loaderEl);
    }
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsList.styles = styles$t;
__decorate$N([
  r$1()
], W3mAllWalletsList.prototype, "initial", void 0);
__decorate$N([
  r$1()
], W3mAllWalletsList.prototype, "wallets", void 0);
__decorate$N([
  r$1()
], W3mAllWalletsList.prototype, "recommended", void 0);
__decorate$N([
  r$1()
], W3mAllWalletsList.prototype, "featured", void 0);
W3mAllWalletsList = __decorate$N([
  customElement("w3m-all-wallets-list")
], W3mAllWalletsList);
const styles$s = i$5`
  button {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-0);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    will-change: background-color, color;
    outline: none;
    border: none;
  }

  button > wui-text {
    color: var(--wui-color-fg-100);
    max-width: var(--wui-icon-box-size-xl);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  button:disabled > wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-color-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-color-accent-glass-010);
  }
`;
var __decorate$M = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAllWalletsListItem = class W3mAllWalletsListItem2 extends i$2 {
  constructor() {
    super();
    this.observer = new IntersectionObserver(() => void 0);
    this.visible = false;
    this.imageSrc = void 0;
    this.imageLoading = false;
    this.wallet = void 0;
    this.observer = new IntersectionObserver((entries2) => {
      entries2.forEach((entry) => {
        if (entry.isIntersecting) {
          this.visible = true;
          this.fetchImageSrc();
        } else {
          this.visible = false;
        }
      });
    }, { threshold: 0.01 });
  }
  firstUpdated() {
    this.observer.observe(this);
  }
  disconnectedCallback() {
    this.observer.disconnect();
  }
  render() {
    return x`
      <button ontouchstart>
        ${this.imageTemplate()}
        <wui-text variant="tiny-500" color="inherit">${this.wallet?.name}</wui-text>
      </button>
    `;
  }
  imageTemplate() {
    if (!this.visible && !this.imageSrc || this.imageLoading) {
      return this.shimmerTemplate();
    }
    return x`
      <wui-wallet-image
        size="md"
        imageSrc=${o$3(this.imageSrc)}
        name=${this.wallet?.name}
        .installed=${this.wallet?.installed}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `;
  }
  shimmerTemplate() {
    return x`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`;
  }
  async fetchImageSrc() {
    if (!this.wallet) {
      return;
    }
    this.imageSrc = AssetUtil.getWalletImage(this.wallet);
    if (this.imageSrc) {
      return;
    }
    this.imageLoading = true;
    this.imageSrc = await AssetUtil.fetchWalletImage(this.wallet.image_id);
    this.imageLoading = false;
  }
};
W3mAllWalletsListItem.styles = styles$s;
__decorate$M([
  r$1()
], W3mAllWalletsListItem.prototype, "visible", void 0);
__decorate$M([
  r$1()
], W3mAllWalletsListItem.prototype, "imageSrc", void 0);
__decorate$M([
  r$1()
], W3mAllWalletsListItem.prototype, "imageLoading", void 0);
__decorate$M([
  n$2()
], W3mAllWalletsListItem.prototype, "wallet", void 0);
W3mAllWalletsListItem = __decorate$M([
  customElement("w3m-all-wallets-list-item")
], W3mAllWalletsListItem);
const styles$r = i$5`
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }
`;
var __decorate$L = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAllWalletsSearch = class W3mAllWalletsSearch2 extends i$2 {
  constructor() {
    super(...arguments);
    this.prevQuery = "";
    this.loading = true;
    this.query = "";
  }
  render() {
    this.onSearch();
    return this.loading ? x`<wui-loading-spinner color="accent-100"></wui-loading-spinner>` : this.walletsTemplate();
  }
  async onSearch() {
    if (this.query.trim() !== this.prevQuery.trim()) {
      this.prevQuery = this.query;
      this.loading = true;
      await ApiController.searchWallet({ search: this.query });
      this.loading = false;
    }
  }
  walletsTemplate() {
    const { search } = ApiController.state;
    const wallets = markWalletsAsInstalled(search);
    if (!search.length) {
      return x`
        <wui-flex justifyContent="center" alignItems="center" gap="s" flexDirection="column">
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text color="fg-200" variant="paragraph-500">No Wallet found</wui-text>
        </wui-flex>
      `;
    }
    return x`
      <wui-grid
        .padding=${["0", "s", "s", "s"]}
        gridTemplateColumns="repeat(4, 1fr)"
        rowGap="l"
        columnGap="xs"
      >
        ${wallets.map((wallet) => x`
            <w3m-all-wallets-list-item
              @click=${() => this.onConnectWallet(wallet)}
              .wallet=${wallet}
            ></w3m-all-wallets-list-item>
          `)}
      </wui-grid>
    `;
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsSearch.styles = styles$r;
__decorate$L([
  r$1()
], W3mAllWalletsSearch.prototype, "loading", void 0);
__decorate$L([
  n$2()
], W3mAllWalletsSearch.prototype, "query", void 0);
W3mAllWalletsSearch = __decorate$L([
  customElement("w3m-all-wallets-search")
], W3mAllWalletsSearch);
var __decorate$K = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingHeader = class W3mConnectingHeader2 extends i$2 {
  constructor() {
    super();
    this.platformTabs = [];
    this.unsubscribe = [];
    this.platforms = [];
    this.onSelectPlatfrom = void 0;
    this.buffering = false;
    this.unsubscribe.push(ConnectionController.subscribeKey("buffering", (val) => this.buffering = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const tabs = this.generateTabs();
    return x`
      <wui-flex justifyContent="center" .padding=${["0", "0", "l", "0"]}>
        <wui-tabs
          ?disabled=${this.buffering}
          .tabs=${tabs}
          .onTabChange=${this.onTabChange.bind(this)}
        ></wui-tabs>
      </wui-flex>
    `;
  }
  generateTabs() {
    const tabs = this.platforms.map((platform) => {
      if (platform === "browser") {
        return { label: "Browser", icon: "extension", platform: "browser" };
      } else if (platform === "mobile") {
        return { label: "Mobile", icon: "mobile", platform: "mobile" };
      } else if (platform === "qrcode") {
        return { label: "Mobile", icon: "mobile", platform: "qrcode" };
      } else if (platform === "web") {
        return { label: "Webapp", icon: "browser", platform: "web" };
      } else if (platform === "desktop") {
        return { label: "Desktop", icon: "desktop", platform: "desktop" };
      }
      return { label: "Browser", icon: "extension", platform: "unsupported" };
    });
    this.platformTabs = tabs.map(({ platform }) => platform);
    return tabs;
  }
  onTabChange(index2) {
    const tab = this.platformTabs[index2];
    if (tab) {
      this.onSelectPlatfrom?.(tab);
    }
  }
};
__decorate$K([
  n$2({ type: Array })
], W3mConnectingHeader.prototype, "platforms", void 0);
__decorate$K([
  n$2()
], W3mConnectingHeader.prototype, "onSelectPlatfrom", void 0);
__decorate$K([
  r$1()
], W3mConnectingHeader.prototype, "buffering", void 0);
W3mConnectingHeader = __decorate$K([
  customElement("w3m-connecting-header")
], W3mConnectingHeader);
var __decorate$J = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcBrowser = class W3mConnectingWcBrowser2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-browser: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  async onConnectProxy() {
    try {
      this.error = false;
      const { connectors } = ConnectorController.state;
      const connector = connectors.find((c2) => c2.type === "ANNOUNCED" && c2.info?.rdns === this.wallet?.rdns || c2.type === "INJECTED" || c2.name === this.wallet?.name);
      if (connector) {
        await ConnectionController.connectExternal(connector, connector.chain);
      } else {
        throw new Error("w3m-connecting-wc-browser: No connector found");
      }
      ModalController.close();
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_SUCCESS",
        properties: { method: "browser", name: this.wallet?.name || "Unknown" }
      });
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: error?.message ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingWcBrowser = __decorate$J([
  customElement("w3m-connecting-wc-browser")
], W3mConnectingWcBrowser);
var __decorate$I = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcDesktop = class W3mConnectingWcDesktop2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-desktop: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "desktop" }
    });
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.ready = true;
      this.onConnect?.();
    }
  }
  onConnectProxy() {
    if (this.wallet?.desktop_link && this.uri) {
      try {
        this.error = false;
        const { desktop_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(desktop_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcDesktop = __decorate$I([
  customElement("w3m-connecting-wc-desktop")
], W3mConnectingWcDesktop);
var __decorate$H = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcMobile = class W3mConnectingWcMobile2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-mobile: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    document.addEventListener("visibilitychange", this.onBuffering.bind(this));
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "mobile" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("visibilitychange", this.onBuffering.bind(this));
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.ready = true;
      this.onConnect?.();
    }
  }
  onConnectProxy() {
    if (this.wallet?.mobile_link && this.uri) {
      try {
        this.error = false;
        const { mobile_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(mobile_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_self");
      } catch {
        this.error = true;
      }
    }
  }
  onBuffering() {
    const isIos = CoreHelperUtil.isIos();
    if (document?.visibilityState === "visible" && !this.error && isIos) {
      ConnectionController.setBuffering(true);
      setTimeout(() => {
        ConnectionController.setBuffering(false);
      }, 5e3);
    }
  }
};
W3mConnectingWcMobile = __decorate$H([
  customElement("w3m-connecting-wc-mobile")
], W3mConnectingWcMobile);
const styles$q = i$5`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;
var __decorate$G = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcQrcode = class W3mConnectingWcQrcode2 extends W3mConnectingWidget {
  constructor() {
    super();
    this.forceUpdate = () => {
      this.requestUpdate();
    };
    window.addEventListener("resize", this.forceUpdate);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet?.name ?? "WalletConnect", platform: "qrcode" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("resize", this.forceUpdate);
  }
  render() {
    this.onRenderProxy();
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["0", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>
        ${this.copyTemplate()}
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.timeout = setTimeout(() => {
        this.ready = true;
      }, 0);
    }
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready) {
      return null;
    }
    const size2 = this.getBoundingClientRect().width - 40;
    const alt = this.wallet ? this.wallet.name : void 0;
    ConnectionController.setWcLinking(void 0);
    ConnectionController.setRecentWallet(this.wallet);
    return x` <wui-qr-code
      size=${size2}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      imageSrc=${o$3(AssetUtil.getWalletImage(this.wallet))}
      alt=${o$3(alt)}
      data-testid="wui-qr-code"
    ></wui-qr-code>`;
  }
  copyTemplate() {
    const inactive = !this.uri || !this.ready;
    return x`<wui-link
      .disabled=${inactive}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`;
  }
};
W3mConnectingWcQrcode.styles = styles$q;
W3mConnectingWcQrcode = __decorate$G([
  customElement("w3m-connecting-wc-qrcode")
], W3mConnectingWcQrcode);
var __decorate$F = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcUnsupported = class W3mConnectingWcUnsupported2 extends i$2 {
  constructor() {
    super();
    this.wallet = RouterController.state.data?.wallet;
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-unsupported: No wallet provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  render() {
    return x`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${o$3(AssetUtil.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
};
W3mConnectingWcUnsupported = __decorate$F([
  customElement("w3m-connecting-wc-unsupported")
], W3mConnectingWcUnsupported);
var __decorate$E = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectingWcWeb = class W3mConnectingWcWeb2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-web: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.secondaryBtnLabel = "Open";
    this.secondaryLabel = "Open and continue in a new browser tab";
    this.secondaryBtnIcon = "externalLink";
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "web" }
    });
  }
  onConnectProxy() {
    if (this.wallet?.webapp_link && this.uri) {
      try {
        this.error = false;
        const { webapp_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatUniversalUrl(webapp_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcWeb = __decorate$E([
  customElement("w3m-connecting-wc-web")
], W3mConnectingWcWeb);
const styles$p = i$5`
  :host {
    width: 100%;
  }

  .details-container > wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    cursor: pointer;
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    padding-top: 0px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-1xs);
    border-radius: calc(var(--wui-border-radius-5xs) + var(--wui-border-radius-4xs));
    background: var(--wui-color-gray-glass-002);
  }

  .details-row-title {
    white-space: nowrap;
  }

  .details-row.provider-free-row {
    padding-right: var(--wui-spacing-xs);
  }
`;
var __decorate$D = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const slippageRate = ConstantsUtil$1.CONVERT_SLIPPAGE_TOLERANCE;
let WuiSwapDetails = class WuiSwapDetails2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.networkName = NetworkController.state.caipNetwork?.name;
    this.detailsOpen = false;
    this.sourceToken = SwapController.state.sourceToken;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount;
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.priceImpact = SwapController.state.priceImpact;
    this.maxSlippage = SwapController.state.maxSlippage;
    this.networkTokenSymbol = SwapController.state.networkTokenSymbol;
    this.inputError = SwapController.state.inputError;
    this.unsubscribe.push(...[
      SwapController.subscribe((newState) => {
        this.sourceToken = newState.sourceToken;
        this.toToken = newState.toToken;
        this.toTokenAmount = newState.toTokenAmount;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.priceImpact = newState.priceImpact;
        this.maxSlippage = newState.maxSlippage;
        this.sourceTokenPriceInUSD = newState.sourceTokenPriceInUSD;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.inputError = newState.inputError;
      })
    ]);
  }
  render() {
    const minReceivedAmount = this.toTokenAmount && this.maxSlippage ? NumberUtil.bigNumber(this.toTokenAmount).minus(this.maxSlippage).toString() : null;
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    const toTokenSwappedAmount = this.sourceTokenPriceInUSD && this.toTokenPriceInUSD ? 1 / this.toTokenPriceInUSD * this.sourceTokenPriceInUSD : 0;
    return x`
      <wui-flex flexDirection="column" alignItems="center" gap="1xs" class="details-container">
        <wui-flex flexDirection="column">
          <button @click=${this.toggleDetails.bind(this)}>
            <wui-flex justifyContent="space-between" .padding=${["0", "xs", "0", "xs"]}>
              <wui-flex justifyContent="flex-start" flexGrow="1" gap="xs">
                <wui-text variant="small-400" color="fg-100">
                  1 ${this.sourceToken.symbol} =
                  ${UiHelperUtil.formatNumberToLocalString(toTokenSwappedAmount, 3)}
                  ${this.toToken.symbol}
                </wui-text>
                <wui-text variant="small-400" color="fg-200">
                  $${UiHelperUtil.formatNumberToLocalString(this.sourceTokenPriceInUSD)}
                </wui-text>
              </wui-flex>
              <wui-icon name="chevronBottom"></wui-icon>
            </wui-flex>
          </button>
          ${this.detailsOpen ? x`
                <wui-flex flexDirection="column" gap="xs" class="details-content-container">
                  <wui-flex flexDirection="column" gap="xs">
                    <wui-flex
                      justifyContent="space-between"
                      alignItems="center"
                      class="details-row"
                    >
                      <wui-flex alignItems="center" gap="xs">
                        <wui-text class="details-row-title" variant="small-400" color="fg-150">
                          Network cost
                        </wui-text>
                        <w3m-tooltip-trigger
                          text=${`Network cost is paid in ${this.networkTokenSymbol} on the ${this.networkName} network in order to execute transaction.`}
                        >
                          <wui-icon size="xs" color="fg-250" name="infoCircle"></wui-icon>
                        </w3m-tooltip-trigger>
                      </wui-flex>
                      <wui-text variant="small-400" color="fg-100">
                        $${UiHelperUtil.formatNumberToLocalString(this.gasPriceInUSD, 3)}
                      </wui-text>
                    </wui-flex>
                  </wui-flex>
                  ${this.priceImpact ? x` <wui-flex flexDirection="column" gap="xs">
                        <wui-flex
                          justifyContent="space-between"
                          alignItems="center"
                          class="details-row"
                        >
                          <wui-flex alignItems="center" gap="xs">
                            <wui-text class="details-row-title" variant="small-400" color="fg-150">
                              Price impact
                            </wui-text>
                            <w3m-tooltip-trigger
                              text="Price impact reflects the change in market price due to your trade"
                            >
                              <wui-icon size="xs" color="fg-250" name="infoCircle"></wui-icon>
                            </w3m-tooltip-trigger>
                          </wui-flex>
                          <wui-flex>
                            <wui-text variant="small-400" color="fg-200">
                              ${UiHelperUtil.formatNumberToLocalString(this.priceImpact, 3)}%
                            </wui-text>
                          </wui-flex>
                        </wui-flex>
                      </wui-flex>` : null}
                  ${this.maxSlippage && this.sourceToken.symbol ? x`<wui-flex flexDirection="column" gap="xs">
                        <wui-flex
                          justifyContent="space-between"
                          alignItems="center"
                          class="details-row"
                        >
                          <wui-flex alignItems="center" gap="xs">
                            <wui-text class="details-row-title" variant="small-400" color="fg-150">
                              Max. slippage
                            </wui-text>
                            <w3m-tooltip-trigger
                              text=${`Max slippage sets the minimum amount you must receive for the transaction to proceed. ${minReceivedAmount ? `Transaction will be reversed if you receive less than ${UiHelperUtil.formatNumberToLocalString(minReceivedAmount, 6)} ${this.toToken.symbol} due to price changes.` : ""}`}
                            >
                              <wui-icon size="xs" color="fg-250" name="infoCircle"></wui-icon>
                            </w3m-tooltip-trigger>
                          </wui-flex>
                          <wui-flex>
                            <wui-text variant="small-400" color="fg-200">
                              ${UiHelperUtil.formatNumberToLocalString(this.maxSlippage, 6)}
                              ${this.toToken.symbol} ${slippageRate}%
                            </wui-text>
                          </wui-flex>
                        </wui-flex>
                      </wui-flex>` : null}
                  <wui-flex flexDirection="column" gap="xs">
                    <wui-flex
                      justifyContent="space-between"
                      alignItems="center"
                      class="details-row provider-free-row"
                    >
                      <wui-flex alignItems="center" gap="xs">
                        <wui-text class="details-row-title" variant="small-400" color="fg-150">
                          Provider fee
                        </wui-text>
                      </wui-flex>
                      <wui-flex>
                        <wui-text variant="small-400" color="fg-200">0.85%</wui-text>
                      </wui-flex>
                    </wui-flex>
                  </wui-flex>
                </wui-flex>
              ` : null}
        </wui-flex>
      </wui-flex>
    `;
  }
  toggleDetails() {
    this.detailsOpen = !this.detailsOpen;
  }
};
WuiSwapDetails.styles = [styles$p];
__decorate$D([
  r$1()
], WuiSwapDetails.prototype, "networkName", void 0);
__decorate$D([
  n$2()
], WuiSwapDetails.prototype, "detailsOpen", void 0);
__decorate$D([
  r$1()
], WuiSwapDetails.prototype, "sourceToken", void 0);
__decorate$D([
  r$1()
], WuiSwapDetails.prototype, "toToken", void 0);
__decorate$D([
  r$1()
], WuiSwapDetails.prototype, "toTokenAmount", void 0);
__decorate$D([
  r$1()
], WuiSwapDetails.prototype, "sourceTokenPriceInUSD", void 0);
__decorate$D([
  r$1()
], WuiSwapDetails.prototype, "toTokenPriceInUSD", void 0);
__decorate$D([
  r$1()
], WuiSwapDetails.prototype, "gasPriceInUSD", void 0);
__decorate$D([
  r$1()
], WuiSwapDetails.prototype, "priceImpact", void 0);
__decorate$D([
  r$1()
], WuiSwapDetails.prototype, "maxSlippage", void 0);
__decorate$D([
  r$1()
], WuiSwapDetails.prototype, "networkTokenSymbol", void 0);
__decorate$D([
  r$1()
], WuiSwapDetails.prototype, "inputError", void 0);
WuiSwapDetails = __decorate$D([
  customElement("w3m-swap-details")
], WuiSwapDetails);
const styles$o = i$5`
  :host > wui-flex {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-xl);
    padding-right: var(--wui-spacing-s);
    width: 100%;
    height: 100px;
    box-sizing: border-box;
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-002);
    position: relative;
    transition: box-shadow var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  :host wui-flex.focus {
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-005);
  }

  :host > wui-flex .swap-input,
  :host > wui-flex .swap-token-button {
    z-index: 10;
  }

  :host > wui-flex .swap-input {
    -webkit-mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
    mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
  }

  :host > wui-flex .swap-input input {
    background: none;
    border: none;
    height: 42px;
    width: 100%;
    font-size: 32px;
    font-style: normal;
    font-weight: 400;
    line-height: 130%;
    letter-spacing: -1.28px;
    outline: none;
    caret-color: var(--wui-color-accent-100);
    color: var(--wui-color-fg-100);
    padding: 0px;
  }

  :host > wui-flex .swap-input input:focus-visible {
    outline: none;
  }

  :host > wui-flex .swap-input input::-webkit-outer-spin-button,
  :host > wui-flex .swap-input input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .max-value-button {
    background-color: transparent;
    border: none;
    cursor: pointer;
    color: var(--wui-color-gray-glass-020);
    padding-left: 0px;
  }

  .market-value {
    min-height: 18px;
  }
`;
var __decorate$C = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const MINIMUM_USD_VALUE_TO_CONVERT = 5e-5;
let W3mSwapInput = class W3mSwapInput2 extends i$2 {
  constructor() {
    super(...arguments);
    this.focused = false;
    this.price = 0;
    this.target = "sourceToken";
    this.onSetAmount = null;
    this.onSetMaxValue = null;
  }
  render() {
    const marketValue = this.marketValue || "0";
    const isMarketValueGreaterThanZero = NumberUtil.bigNumber(marketValue).isGreaterThan("0");
    return x`
      <wui-flex class="${this.focused ? "focus" : ""}" justifyContent="space-between">
        <wui-flex
          flex="1"
          flexDirection="column"
          alignItems="flex-start"
          justifyContent="center"
          class="swap-input"
        >
          <input
            data-testid="swap-input-${this.target}"
            @focusin=${() => this.onFocusChange(true)}
            @focusout=${() => this.onFocusChange(false)}
            ?disabled=${this.disabled}
            .value=${this.value}
            @input=${this.dispatchInputChangeEvent}
            @keydown=${this.handleKeydown}
            placeholder="0"
            type="text"
            inputmode="decimal"
          />
          <wui-text class="market-value" variant="small-400" color="fg-200">
            ${isMarketValueGreaterThanZero ? `$${UiHelperUtil.formatNumberToLocalString(this.marketValue, 3)}` : null}
          </wui-text>
        </wui-flex>
        ${this.templateTokenSelectButton()}
      </wui-flex>
    `;
  }
  handleKeydown(event) {
    return InputUtil.numericInputKeyDown(event, this.value, (value) => this.onSetAmount?.(this.target, value));
  }
  dispatchInputChangeEvent(event) {
    if (!this.onSetAmount) {
      return;
    }
    const value = event.target.value.replace(/[^0-9.]/gu, "");
    if (value === "," || value === ".") {
      this.onSetAmount(this.target, "0.");
    } else if (value.endsWith(",")) {
      this.onSetAmount(this.target, value.replace(",", "."));
    } else {
      this.onSetAmount(this.target, value);
    }
  }
  setMaxValueToInput() {
    this.onSetMaxValue?.(this.target, this.balance);
  }
  templateTokenSelectButton() {
    if (!this.token) {
      return x` <wui-button
        data-testid="swap-select-token-button-${this.target}"
        class="swap-token-button"
        size="md"
        variant="accent"
        @click=${this.onSelectToken.bind(this)}
      >
        Select token
      </wui-button>`;
    }
    return x`
      <wui-flex
        class="swap-token-button"
        flexDirection="column"
        alignItems="flex-end"
        justifyContent="center"
        gap="xxs"
      >
        <wui-token-button
          data-testid="swap-input-token-${this.target}"
          text=${this.token.symbol}
          imageSrc=${this.token.logoUri}
          @click=${this.onSelectToken.bind(this)}
        >
        </wui-token-button>
        <wui-flex alignItems="center" gap="xxs"> ${this.tokenBalanceTemplate()} </wui-flex>
      </wui-flex>
    `;
  }
  tokenBalanceTemplate() {
    const balanceValueInUSD = NumberUtil.multiply(this.balance, this.price);
    const haveBalance = balanceValueInUSD ? balanceValueInUSD?.isGreaterThan(MINIMUM_USD_VALUE_TO_CONVERT) : false;
    return x`
      ${haveBalance ? x`<wui-text variant="small-400" color="fg-200">
            ${UiHelperUtil.formatNumberToLocalString(this.balance, 3)}
          </wui-text>` : null}
      ${this.target === "sourceToken" ? this.tokenActionButtonTemplate(haveBalance) : null}
    `;
  }
  tokenActionButtonTemplate(haveBalance) {
    if (haveBalance) {
      return x` <button class="max-value-button" @click=${this.setMaxValueToInput.bind(this)}>
        <wui-text color="accent-100" variant="small-600">Max</wui-text>
      </button>`;
    }
    return x` <button class="max-value-button" @click=${this.onBuyToken.bind(this)}>
      <wui-text color="accent-100" variant="small-600">Buy</wui-text>
    </button>`;
  }
  onFocusChange(state2) {
    this.focused = state2;
  }
  onSelectToken() {
    EventsController.sendEvent({ type: "track", event: "CLICK_SELECT_TOKEN_TO_SWAP" });
    RouterController.push("SwapSelectToken", {
      target: this.target
    });
  }
  onBuyToken() {
    RouterController.push("OnRampProviders");
  }
};
W3mSwapInput.styles = [styles$o];
__decorate$C([
  n$2()
], W3mSwapInput.prototype, "focused", void 0);
__decorate$C([
  n$2()
], W3mSwapInput.prototype, "balance", void 0);
__decorate$C([
  n$2()
], W3mSwapInput.prototype, "value", void 0);
__decorate$C([
  n$2()
], W3mSwapInput.prototype, "price", void 0);
__decorate$C([
  n$2()
], W3mSwapInput.prototype, "marketValue", void 0);
__decorate$C([
  n$2()
], W3mSwapInput.prototype, "disabled", void 0);
__decorate$C([
  n$2()
], W3mSwapInput.prototype, "target", void 0);
__decorate$C([
  n$2()
], W3mSwapInput.prototype, "token", void 0);
__decorate$C([
  n$2()
], W3mSwapInput.prototype, "onSetAmount", void 0);
__decorate$C([
  n$2()
], W3mSwapInput.prototype, "onSetMaxValue", void 0);
W3mSwapInput = __decorate$C([
  customElement("w3m-swap-input")
], W3mSwapInput);
const styles$n = i$5`
  :host {
    width: 100%;
  }

  :host > wui-flex {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    border-radius: var(--wui-border-radius-s);
    padding: var(--wui-spacing-xl);
    padding-right: var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-002);
    width: 100%;
    height: 100px;
    box-sizing: border-box;
    position: relative;
  }

  wui-shimmer.market-value {
    opacity: 0;
  }

  :host > wui-flex > svg.input_mask {
    position: absolute;
    inset: 0;
    z-index: 5;
  }

  :host wui-flex .input_mask__border,
  :host wui-flex .input_mask__background {
    transition: fill var(--wui-duration-md) var(--wui-ease-out-power-1);
    will-change: fill;
  }

  :host wui-flex .input_mask__border {
    fill: var(--wui-color-gray-glass-020);
  }

  :host wui-flex .input_mask__background {
    fill: var(--wui-color-gray-glass-002);
  }
`;
var __decorate$B = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mSwapInputSkeleton = class W3mSwapInputSkeleton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.target = "sourceToken";
  }
  render() {
    return x`
      <wui-flex class justifyContent="space-between">
        <wui-flex
          flex="1"
          flexDirection="column"
          alignItems="flex-start"
          justifyContent="center"
          class="swap-input"
          gap="xxs"
        >
          <wui-shimmer width="80px" height="40px" borderRadius="xxs" variant="light"></wui-shimmer>
        </wui-flex>
        ${this.templateTokenSelectButton()}
      </wui-flex>
    `;
  }
  templateTokenSelectButton() {
    return x`
      <wui-flex
        class="swap-token-button"
        flexDirection="column"
        alignItems="flex-end"
        justifyContent="center"
        gap="xxs"
      >
        <wui-shimmer width="80px" height="40px" borderRadius="3xl" variant="light"></wui-shimmer>
      </wui-flex>
    `;
  }
};
W3mSwapInputSkeleton.styles = [styles$n];
__decorate$B([
  n$2()
], W3mSwapInputSkeleton.prototype, "target", void 0);
W3mSwapInputSkeleton = __decorate$B([
  customElement("w3m-swap-input-skeleton")
], W3mSwapInputSkeleton);
const styles$m = i$5`
  :host {
    height: 64px;
  }

  wui-text {
    text-transform: capitalize;
  }

  wui-flex.w3m-header-title {
    transform: translateY(0);
    opacity: 1;
  }

  wui-flex.w3m-header-title[view-direction='prev'] {
    animation:
      slide-down-out 120ms forwards var(--wui-ease-out-power-2),
      slide-down-in 120ms forwards var(--wui-ease-out-power-2);
    animation-delay: 0ms, 200ms;
  }

  wui-flex.w3m-header-title[view-direction='next'] {
    animation:
      slide-up-out 120ms forwards var(--wui-ease-out-power-2),
      slide-up-in 120ms forwards var(--wui-ease-out-power-2);
    animation-delay: 0ms, 200ms;
  }

  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }

  @keyframes slide-up-out {
    from {
      transform: translateY(0px);
      opacity: 1;
    }
    to {
      transform: translateY(3px);
      opacity: 0;
    }
  }

  @keyframes slide-up-in {
    from {
      transform: translateY(-3px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  @keyframes slide-down-out {
    from {
      transform: translateY(0px);
      opacity: 1;
    }
    to {
      transform: translateY(-3px);
      opacity: 0;
    }
  }

  @keyframes slide-down-in {
    from {
      transform: translateY(3px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
`;
var __decorate$A = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const BETA_SCREENS = ["Swap", "SwapSelectToken", "SwapPreview"];
function headings() {
  const connectorName = RouterController.state.data?.connector?.name;
  const walletName = RouterController.state.data?.wallet?.name;
  const networkName = RouterController.state.data?.network?.name;
  const name = walletName ?? connectorName;
  const connectors = ConnectorController.getConnectors();
  const isEmail = connectors.length === 1 && connectors[0]?.id === "w3m-email";
  return {
    Connect: `Connect ${isEmail ? "Email" : ""} Wallet`,
    ChooseAccountName: void 0,
    Account: void 0,
    AccountSettings: void 0,
    AllWallets: "All Wallets",
    ApproveTransaction: "Approve Transaction",
    BuyInProgress: "Buy",
    ConnectingExternal: name ?? "Connect Wallet",
    ConnectingWalletConnect: name ?? "WalletConnect",
    ConnectingSiwe: "Sign In",
    Convert: "Convert",
    ConvertSelectToken: "Select token",
    ConvertPreview: "Preview convert",
    Downloads: name ? `Get ${name}` : "Downloads",
    EmailVerifyOtp: "Confirm Email",
    EmailVerifyDevice: "Register Device",
    GetWallet: "Get a wallet",
    Networks: "Choose Network",
    OnRampProviders: "Choose Provider",
    OnRampActivity: "Activity",
    OnRampTokenSelect: "Select Token",
    OnRampFiatSelect: "Select Currency",
    Profile: void 0,
    SelectAddresses: "Select accounts",
    SwitchNetwork: networkName ?? "Switch Network",
    SwitchAddress: "Switch Address",
    Transactions: "Activity",
    UnsupportedChain: "Switch Network",
    UpgradeEmailWallet: "Upgrade your Wallet",
    UpgradeToSmartAccount: void 0,
    UpdateEmailWallet: "Edit Email",
    UpdateEmailPrimaryOtp: "Confirm Current Email",
    UpdateEmailSecondaryOtp: "Confirm New Email",
    WhatIsABuy: "What is Buy?",
    RegisterAccountName: "Choose name",
    RegisterAccountNameSuccess: "",
    WalletReceive: "Receive",
    WalletCompatibleNetworks: "Compatible Networks",
    Swap: "Swap",
    SwapSelectToken: "Select token",
    SwapPreview: "Preview swap",
    WalletSend: "Send",
    WalletSendPreview: "Review send",
    WalletSendSelectToken: "Select Token",
    WhatIsANetwork: "What is a network?",
    WhatIsAWallet: "What is a wallet?",
    ConnectWallets: "Connect wallet",
    ConnectSocials: "All socials",
    ConnectingSocial: AccountController.state.socialProvider ? AccountController.state.socialProvider : "Connect Social",
    ConnectingMultiChain: "Select chain",
    ConnectingFarcaster: "Farcaster",
    SwitchActiveChain: "Switch chain"
  };
}
let W3mHeader = class W3mHeader2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.heading = headings()[RouterController.state.view];
    this.network = NetworkController.state.caipNetwork;
    this.buffering = false;
    this.showBack = false;
    this.isSiweEnabled = OptionsController.state.isSiweEnabled;
    this.prevHistoryLength = 1;
    this.view = RouterController.state.view;
    this.viewDirection = "";
    this.headerText = headings()[RouterController.state.view];
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => {
      setTimeout(() => {
        this.view = val;
        this.headerText = headings()[val];
      }, ConstantsUtil.ANIMATION_DURATIONS.HeaderText);
      this.onViewChange();
      this.onHistoryChange();
    }), ConnectionController.subscribeKey("buffering", (val) => this.buffering = val), NetworkController.subscribeKey("caipNetwork", (val) => this.network = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.dynamicButtonTemplate()} ${this.titleTemplate()} ${this.closeButtonTemplate()}
      </wui-flex>
    `;
  }
  onWalletHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_WALLET_HELP" });
    RouterController.push("WhatIsAWallet");
  }
  async onClose() {
    if (this.isSiweEnabled) {
      const { SIWEController } = await __vitePreload(async () => {
        const { SIWEController: SIWEController2 } = await import("./index-BPfKs9-b.js");
        return { SIWEController: SIWEController2 };
      }, true ? [] : void 0);
      const isApproveSignScreen = RouterController.state.view === "ApproveTransaction";
      const isUnauthenticated = SIWEController.state.status !== "success";
      if (isUnauthenticated && isApproveSignScreen) {
        RouterController.popTransactionStack(true);
      } else {
        ModalController.close();
      }
    } else {
      ModalController.close();
    }
  }
  closeButtonTemplate() {
    const isSiweSignScreen = RouterController.state.view === "ConnectingSiwe";
    if (this.isSiweEnabled && isSiweSignScreen) {
      return x`<div style="width:40px" />`;
    }
    return x`
      <wui-icon-link
        ?disabled=${this.buffering}
        icon="close"
        @click=${this.onClose.bind(this)}
        data-testid="w3m-header-close"
      ></wui-icon-link>
    `;
  }
  titleTemplate() {
    const isBeta = BETA_SCREENS.includes(this.view);
    return x`
      <wui-flex
        view-direction="${this.viewDirection}"
        class="w3m-header-title"
        alignItems="center"
        gap="xs"
      >
        <wui-text variant="paragraph-700" color="fg-100">${this.headerText}</wui-text>
        ${isBeta ? x`<wui-tag variant="main">Beta</wui-tag>` : null}
      </wui-flex>
    `;
  }
  dynamicButtonTemplate() {
    const { view } = RouterController.state;
    const isConnectHelp = view === "Connect";
    const isApproveTransaction = view === "ApproveTransaction";
    const isUpgradeToSmartAccounts = view === "UpgradeToSmartAccount";
    const isConnectingSIWEView = view === "ConnectingSiwe";
    const isAccountView = view === "Account";
    const shouldHideBack = isApproveTransaction || isUpgradeToSmartAccounts || isConnectingSIWEView;
    if (isAccountView) {
      return x`<wui-select
        id="dynamic"
        data-testid="w3m-account-select-network"
        active-network=${this.network?.name}
        @click=${this.onNetworks.bind(this)}
        imageSrc=${o$3(AssetUtil.getNetworkImage(this.network))}
      ></wui-select>`;
    }
    if (this.showBack && !shouldHideBack) {
      return x`<wui-icon-link
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${this.onGoBack.bind(this)}
      ></wui-icon-link>`;
    }
    return x`<wui-icon-link
      data-hidden=${!isConnectHelp}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`;
  }
  onNetworks() {
    if (this.isAllowedNetworkSwitch()) {
      EventsController.sendEvent({ type: "track", event: "CLICK_NETWORKS" });
      RouterController.push("Networks");
    }
  }
  isAllowedNetworkSwitch() {
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
    const isValidNetwork = requestedCaipNetworks?.find(({ id }) => id === this.network?.id);
    return isMultiNetwork || !isValidNetwork;
  }
  getPadding() {
    if (this.heading) {
      return ["l", "2l", "l", "2l"];
    }
    return ["0", "2l", "0", "2l"];
  }
  onViewChange() {
    const { history } = RouterController.state;
    let direction = ConstantsUtil.VIEW_DIRECTION.Next;
    if (history.length < this.prevHistoryLength) {
      direction = ConstantsUtil.VIEW_DIRECTION.Prev;
    }
    this.prevHistoryLength = history.length;
    this.viewDirection = direction;
  }
  async onHistoryChange() {
    const { history } = RouterController.state;
    const buttonEl = this.shadowRoot?.querySelector("#dynamic");
    if (history.length > 1 && !this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = true;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    } else if (history.length <= 1 && this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = false;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onGoBack() {
    RouterController.goBack();
  }
};
W3mHeader.styles = styles$m;
__decorate$A([
  r$1()
], W3mHeader.prototype, "heading", void 0);
__decorate$A([
  r$1()
], W3mHeader.prototype, "network", void 0);
__decorate$A([
  r$1()
], W3mHeader.prototype, "buffering", void 0);
__decorate$A([
  r$1()
], W3mHeader.prototype, "showBack", void 0);
__decorate$A([
  r$1()
], W3mHeader.prototype, "isSiweEnabled", void 0);
__decorate$A([
  r$1()
], W3mHeader.prototype, "prevHistoryLength", void 0);
__decorate$A([
  r$1()
], W3mHeader.prototype, "view", void 0);
__decorate$A([
  r$1()
], W3mHeader.prototype, "viewDirection", void 0);
__decorate$A([
  r$1()
], W3mHeader.prototype, "headerText", void 0);
W3mHeader = __decorate$A([
  customElement("w3m-header")
], W3mHeader);
var __decorate$z = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mHelpWidget = class W3mHelpWidget2 extends i$2 {
  constructor() {
    super(...arguments);
    this.data = [];
  }
  render() {
    return x`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        ${this.data.map((item) => x`
            <wui-flex flexDirection="column" alignItems="center" gap="xl">
              <wui-flex flexDirection="row" justifyContent="center" gap="1xs">
                ${item.images.map((image) => x`<wui-visual name=${image}></wui-visual>`)}
              </wui-flex>
            </wui-flex>
            <wui-flex flexDirection="column" alignItems="center" gap="xxs">
              <wui-text variant="paragraph-500" color="fg-100" align="center">
                ${item.title}
              </wui-text>
              <wui-text variant="small-500" color="fg-200" align="center">${item.text}</wui-text>
            </wui-flex>
          `)}
      </wui-flex>
    `;
  }
};
__decorate$z([
  n$2({ type: Array })
], W3mHelpWidget.prototype, "data", void 0);
W3mHelpWidget = __decorate$z([
  customElement("w3m-help-widget")
], W3mHelpWidget);
const styles$l = i$5`
  :host {
    width: 100%;
  }

  :host > wui-flex {
    width: 100%;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
  }

  :host > wui-flex:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  .purchase-image-container {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: var(--wui-icon-box-size-lg);
    height: var(--wui-icon-box-size-lg);
  }

  .purchase-image-container wui-image {
    width: 100%;
    height: 100%;
    position: relative;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
  }

  .purchase-image-container wui-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  .purchase-image-container wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }
`;
var __decorate$y = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mOnRampActivityItem = class W3mOnRampActivityItem2 extends i$2 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
    this.label = "Bought";
    this.purchaseValue = "";
    this.purchaseCurrency = "";
    this.date = "";
    this.completed = false;
    this.inProgress = false;
    this.failed = false;
    this.onClick = null;
    this.symbol = "";
  }
  firstUpdated() {
    if (!this.icon) {
      this.fetchTokenImage();
    }
  }
  render() {
    return x`
      <wui-flex>
        ${this.imageTemplate()}
        <wui-flex flexDirection="column" gap="4xs" flexGrow="1">
          <wui-flex gap="xxs" alignItems="center" justifyContent="flex-start">
            ${this.statusIconTemplate()}
            <wui-text variant="paragraph-500" color="fg-100"> ${this.label}</wui-text>
          </wui-flex>
          <wui-text variant="small-400" color="fg-200">
            + ${this.purchaseValue} ${this.purchaseCurrency}
          </wui-text>
        </wui-flex>
        ${this.inProgress ? x`<wui-loading-spinner color="fg-200" size="md"></wui-loading-spinner>` : x`<wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>`}
      </wui-flex>
    `;
  }
  async fetchTokenImage() {
    await ApiController._fetchTokenImage(this.purchaseCurrency);
  }
  statusIconTemplate() {
    if (this.inProgress) {
      return null;
    }
    return this.completed ? this.boughtIconTemplate() : this.errorIconTemplate();
  }
  errorIconTemplate() {
    return x`<wui-icon-box
      size="xxs"
      iconColor="error-100"
      backgroundColor="error-100"
      background="opaque"
      icon="close"
      borderColor="wui-color-bg-125"
    ></wui-icon-box>`;
  }
  imageTemplate() {
    const icon = this.icon || `https://avatar.vercel.sh/andrew.svg?size=50&text=${this.symbol}`;
    return x`<wui-flex class="purchase-image-container">
      <wui-image src=${icon}></wui-image>
    </wui-flex>`;
  }
  boughtIconTemplate() {
    return x`<wui-icon-box
      size="xxs"
      iconColor="success-100"
      backgroundColor="success-100"
      background="opaque"
      icon="arrowBottom"
      borderColor="wui-color-bg-125"
    ></wui-icon-box>`;
  }
};
W3mOnRampActivityItem.styles = [styles$l];
__decorate$y([
  n$2({ type: Boolean })
], W3mOnRampActivityItem.prototype, "disabled", void 0);
__decorate$y([
  n$2()
], W3mOnRampActivityItem.prototype, "color", void 0);
__decorate$y([
  n$2()
], W3mOnRampActivityItem.prototype, "label", void 0);
__decorate$y([
  n$2()
], W3mOnRampActivityItem.prototype, "purchaseValue", void 0);
__decorate$y([
  n$2()
], W3mOnRampActivityItem.prototype, "purchaseCurrency", void 0);
__decorate$y([
  n$2()
], W3mOnRampActivityItem.prototype, "date", void 0);
__decorate$y([
  n$2({ type: Boolean })
], W3mOnRampActivityItem.prototype, "completed", void 0);
__decorate$y([
  n$2({ type: Boolean })
], W3mOnRampActivityItem.prototype, "inProgress", void 0);
__decorate$y([
  n$2({ type: Boolean })
], W3mOnRampActivityItem.prototype, "failed", void 0);
__decorate$y([
  n$2()
], W3mOnRampActivityItem.prototype, "onClick", void 0);
__decorate$y([
  n$2()
], W3mOnRampActivityItem.prototype, "symbol", void 0);
__decorate$y([
  n$2()
], W3mOnRampActivityItem.prototype, "icon", void 0);
W3mOnRampActivityItem = __decorate$y([
  customElement("w3m-onramp-activity-item")
], W3mOnRampActivityItem);
const styles$k = i$5`
  :host {
    width: 100%;
  }

  wui-loading-spinner {
    position: absolute;
    top: 50%;
    right: 20px;
    transform: translateY(-50%);
  }

  .currency-container {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    right: var(--wui-spacing-1xs);
    height: 40px;
    padding: var(--wui-spacing-xs) var(--wui-spacing-1xs) var(--wui-spacing-xs)
      var(--wui-spacing-xs);
    min-width: 95px;
    border-radius: var(--FULL, 1000px);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    cursor: pointer;
  }

  .currency-container > wui-image {
    height: 24px;
    width: 24px;
    border-radius: 50%;
  }
`;
var __decorate$x = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mInputCurrency = class W3mInputCurrency2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.type = "Token";
    this.value = 0;
    this.currencies = [];
    this.selectedCurrency = this.currencies?.[0];
    this.currencyImages = AssetController.state.currencyImages;
    this.tokenImages = AssetController.state.tokenImages;
    this.unsubscribe.push(OnRampController.subscribeKey("purchaseCurrency", (val) => {
      if (!val || this.type === "Fiat") {
        return;
      }
      this.selectedCurrency = this.formatPurchaseCurrency(val);
    }), OnRampController.subscribeKey("paymentCurrency", (val) => {
      if (!val || this.type === "Token") {
        return;
      }
      this.selectedCurrency = this.formatPaymentCurrency(val);
    }), OnRampController.subscribe((val) => {
      if (this.type === "Fiat") {
        this.currencies = val.purchaseCurrencies.map(this.formatPurchaseCurrency);
      } else {
        this.currencies = val.paymentCurrencies.map(this.formatPaymentCurrency);
      }
    }), AssetController.subscribe((val) => {
      this.currencyImages = { ...val.currencyImages };
      this.tokenImages = { ...val.tokenImages };
    }));
  }
  firstUpdated() {
    OnRampController.getAvailableCurrencies();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const symbol = this.selectedCurrency?.symbol || "";
    const image = this.currencyImages[symbol] || this.tokenImages[symbol];
    return x`<wui-input-text type="number" size="lg" value=${this.value}>
      ${this.selectedCurrency ? x` <wui-flex
            class="currency-container"
            justifyContent="space-between"
            alignItems="center"
            gap="xxs"
            @click=${() => ModalController.open({ view: `OnRamp${this.type}Select` })}
          >
            <wui-image src=${o$3(image)}></wui-image>
            <wui-text color="fg-100">${this.selectedCurrency.symbol}</wui-text>
          </wui-flex>` : x`<wui-loading-spinner></wui-loading-spinner>`}
    </wui-input-text>`;
  }
  formatPaymentCurrency(currency) {
    return {
      name: currency.id,
      symbol: currency.id
    };
  }
  formatPurchaseCurrency(currency) {
    return {
      name: currency.name,
      symbol: currency.symbol
    };
  }
};
W3mInputCurrency.styles = styles$k;
__decorate$x([
  n$2({ type: String })
], W3mInputCurrency.prototype, "type", void 0);
__decorate$x([
  n$2({ type: Number })
], W3mInputCurrency.prototype, "value", void 0);
__decorate$x([
  r$1()
], W3mInputCurrency.prototype, "currencies", void 0);
__decorate$x([
  r$1()
], W3mInputCurrency.prototype, "selectedCurrency", void 0);
__decorate$x([
  r$1()
], W3mInputCurrency.prototype, "currencyImages", void 0);
__decorate$x([
  r$1()
], W3mInputCurrency.prototype, "tokenImages", void 0);
W3mInputCurrency = __decorate$x([
  customElement("w3m-onramp-input")
], W3mInputCurrency);
const styles$j = i$5`
  button {
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    border: none;
    outline: none;
    background-color: var(--wui-color-gray-glass-002);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .provider-image {
    width: var(--wui-spacing-3xl);
    min-width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    position: relative;
    overflow: hidden;
  }

  .provider-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  .network-icon {
    width: var(--wui-spacing-m);
    height: var(--wui-spacing-m);
    border-radius: calc(var(--wui-spacing-m) / 2);
    overflow: hidden;
    box-shadow:
      0 0 0 3px var(--wui-color-gray-glass-002),
      0 0 0 3px var(--wui-color-modal-bg);
    transition: box-shadow var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: box-shadow;
  }

  button:hover .network-icon {
    box-shadow:
      0 0 0 3px var(--wui-color-gray-glass-005),
      0 0 0 3px var(--wui-color-modal-bg);
  }
`;
var __decorate$w = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mOnRampProviderItem = class W3mOnRampProviderItem2 extends i$2 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
    this.label = "";
    this.feeRange = "";
    this.loading = false;
    this.onClick = null;
  }
  render() {
    return x`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-visual name=${o$3(this.name)} class="provider-image"></wui-visual>
        <wui-flex flexDirection="column" gap="4xs">
          <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
          <wui-flex alignItems="center" justifyContent="flex-start" gap="l">
            <wui-text variant="tiny-500" color="fg-100">
              <wui-text variant="tiny-400" color="fg-200">Fees</wui-text>
              ${this.feeRange}
            </wui-text>
            <wui-flex gap="xxs">
              <wui-icon name="bank" size="xs" color="fg-150"></wui-icon>
              <wui-icon name="card" size="xs" color="fg-150"></wui-icon>
            </wui-flex>
            ${this.networksTemplate()}
          </wui-flex>
        </wui-flex>
        ${this.loading ? x`<wui-loading-spinner color="fg-200" size="md"></wui-loading-spinner>` : x`<wui-icon name="chevronRight" color="fg-200" size="sm"></wui-icon>`}
      </button>
    `;
  }
  networksTemplate() {
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const slicedNetworks = requestedCaipNetworks?.filter((network) => network?.imageId)?.slice(0, 5);
    return x`
      <wui-flex class="networks">
        ${slicedNetworks?.map((network) => x`
            <wui-flex class="network-icon">
              <wui-image src=${o$3(AssetUtil.getNetworkImage(network))}></wui-image>
            </wui-flex>
          `)}
      </wui-flex>
    `;
  }
};
W3mOnRampProviderItem.styles = [styles$j];
__decorate$w([
  n$2({ type: Boolean })
], W3mOnRampProviderItem.prototype, "disabled", void 0);
__decorate$w([
  n$2()
], W3mOnRampProviderItem.prototype, "color", void 0);
__decorate$w([
  n$2()
], W3mOnRampProviderItem.prototype, "name", void 0);
__decorate$w([
  n$2()
], W3mOnRampProviderItem.prototype, "label", void 0);
__decorate$w([
  n$2()
], W3mOnRampProviderItem.prototype, "feeRange", void 0);
__decorate$w([
  n$2({ type: Boolean })
], W3mOnRampProviderItem.prototype, "loading", void 0);
__decorate$w([
  n$2()
], W3mOnRampProviderItem.prototype, "onClick", void 0);
W3mOnRampProviderItem = __decorate$w([
  customElement("w3m-onramp-provider-item")
], W3mOnRampProviderItem);
const styles$i = i$5`
  wui-flex {
    background-color: var(--wui-color-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
  }
`;
var __decorate$v = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mLegalFooter = class W3mLegalFooter2 extends i$2 {
  render() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    return x`
      <wui-flex .padding=${["m", "s", "s", "s"]} justifyContent="center">
        <wui-text color="fg-250" variant="small-400" align="center">
          By connecting your wallet, you agree to our <br />
          ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-flex>
    `;
  }
  andTemplate() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    return termsConditionsUrl && privacyPolicyUrl ? "and" : "";
  }
  termsTemplate() {
    const { termsConditionsUrl } = OptionsController.state;
    if (!termsConditionsUrl) {
      return null;
    }
    return x`<a href=${termsConditionsUrl}>Terms of Service</a>`;
  }
  privacyTemplate() {
    const { privacyPolicyUrl } = OptionsController.state;
    if (!privacyPolicyUrl) {
      return null;
    }
    return x`<a href=${privacyPolicyUrl}>Privacy Policy</a>`;
  }
};
W3mLegalFooter.styles = [styles$i];
W3mLegalFooter = __decorate$v([
  customElement("w3m-legal-footer")
], W3mLegalFooter);
const styles$h = i$5`
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;
var __decorate$u = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mMobileDownloadLinks = class W3mMobileDownloadLinks2 extends i$2 {
  constructor() {
    super(...arguments);
    this.wallet = void 0;
  }
  render() {
    if (!this.wallet) {
      this.style.display = "none";
      return null;
    }
    const { name, app_store, play_store, chrome_store, homepage } = this.wallet;
    const isMobile = CoreHelperUtil.isMobile();
    const isIos = CoreHelperUtil.isIos();
    const isAndroid = CoreHelperUtil.isAndroid();
    const isMultiple = [app_store, play_store, homepage, chrome_store].filter(Boolean).length > 1;
    const shortName = UiHelperUtil.getTruncateString({
      string: name,
      charsStart: 12,
      charsEnd: 0,
      truncate: "end"
    });
    if (isMultiple && !isMobile) {
      return x`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${() => RouterController.push("Downloads", { wallet: this.wallet })}
        ></wui-cta-button>
      `;
    }
    if (!isMultiple && homepage) {
      return x`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (app_store && isIos) {
      return x`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (play_store && isAndroid) {
      return x`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    this.style.display = "none";
    return null;
  }
  onAppStore() {
    if (this.wallet?.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    if (this.wallet?.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    if (this.wallet?.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mMobileDownloadLinks.styles = [styles$h];
__decorate$u([
  n$2({ type: Object })
], W3mMobileDownloadLinks.prototype, "wallet", void 0);
W3mMobileDownloadLinks = __decorate$u([
  customElement("w3m-mobile-download-links")
], W3mMobileDownloadLinks);
const styles$g = i$5`
  wui-flex {
    border-top: 1px solid var(--wui-color-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-3xs);
  }
`;
var __decorate$t = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mOnRampProvidersFooter = class W3mOnRampProvidersFooter2 extends i$2 {
  render() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    return x`
      <wui-flex
        .padding=${["m", "s", "s", "s"]}
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
        gap="s"
      >
        <wui-text color="fg-250" variant="small-400" align="center">
          We work with the best providers to give you the lowest fees and best support. More options
          coming soon!
        </wui-text>

        ${this.howDoesItWorkTemplate()}
      </wui-flex>
    `;
  }
  howDoesItWorkTemplate() {
    return x` <wui-link @click=${this.onWhatIsBuy.bind(this)}>
      <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
      How does it work?
    </wui-link>`;
  }
  onWhatIsBuy() {
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WHAT_IS_A_BUY",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("WhatIsABuy");
  }
};
W3mOnRampProvidersFooter.styles = [styles$g];
W3mOnRampProvidersFooter = __decorate$t([
  customElement("w3m-onramp-providers-footer")
], W3mOnRampProvidersFooter);
const styles$f = i$5`
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
    width: max-content;
  }
`;
var __decorate$s = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const presets = {
  loading: void 0,
  success: {
    backgroundColor: "success-100",
    iconColor: "success-100",
    icon: "checkmark"
  },
  error: {
    backgroundColor: "error-100",
    iconColor: "error-100",
    icon: "close"
  }
};
let W3mSnackBar = class W3mSnackBar2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.timeout = void 0;
    this.open = SnackController.state.open;
    this.unsubscribe.push(SnackController.subscribeKey("open", (val) => {
      this.open = val;
      this.onOpen();
    }));
  }
  disconnectedCallback() {
    clearTimeout(this.timeout);
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { message, variant } = SnackController.state;
    const preset = presets[variant];
    return x`
      <wui-snackbar
        message=${message}
        backgroundColor=${preset?.backgroundColor}
        iconColor=${preset?.iconColor}
        icon=${preset?.icon}
        .loading=${variant === "loading"}
      ></wui-snackbar>
    `;
  }
  onOpen() {
    clearTimeout(this.timeout);
    if (this.open) {
      this.animate([
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" },
        { opacity: 1, transform: "translateX(-50%) scale(1)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
      this.timeout = setTimeout(() => SnackController.hide(), 2500);
    } else {
      this.animate([
        { opacity: 1, transform: "translateX(-50%) scale(1)" },
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
W3mSnackBar.styles = styles$f;
__decorate$s([
  r$1()
], W3mSnackBar.prototype, "open", void 0);
W3mSnackBar = __decorate$s([
  customElement("w3m-snackbar")
], W3mSnackBar);
const styles$e = i$5`
  wui-separator {
    margin: var(--wui-spacing-s) calc(var(--wui-spacing-s) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }

  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }

  wui-icon-link,
  wui-loading-spinner {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
  }

  wui-icon-link {
    right: var(--wui-spacing-xs);
  }

  wui-loading-spinner {
    right: var(--wui-spacing-m);
  }
`;
var __decorate$r = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mEmailLoginWidget = class W3mEmailLoginWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.formRef = e();
    this.connectors = ConnectorController.state.connectors;
    this.email = "";
    this.loading = false;
    this.error = "";
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    this.formRef.value?.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    const connector = this.connectors.find((c2) => c2.type === "AUTH");
    const multipleConnectors = this.connectors.length > 1;
    if (!connector?.email) {
      return null;
    }
    return x`
      <form ${n2(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
        <wui-email-input
          @focus=${this.onFocusEvent.bind(this)}
          .disabled=${this.loading}
          @inputChange=${this.onEmailInputChange.bind(this)}
          .errorMessage=${this.error}
        >
        </wui-email-input>

        ${this.submitButtonTemplate()}${this.loadingTemplate()}
        <input type="submit" hidden />
      </form>

      ${connector.socials || !multipleConnectors ? null : x`<wui-flex .padding=${["xxs", "0", "0", "0"]}>
            <wui-separator text="or"></wui-separator>
          </wui-flex>`}
    `;
  }
  submitButtonTemplate() {
    const showSubmit = !this.loading && this.email.length > 3;
    return showSubmit ? x`
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitEmail.bind(this)}
          >
          </wui-icon-link>
        ` : null;
  }
  loadingTemplate() {
    return this.loading ? x`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : null;
  }
  onEmailInputChange(event) {
    this.email = event.detail.trim();
    this.error = "";
  }
  async onSubmitEmail(event) {
    const availableChains = [ConstantsUtil$2.CHAIN.EVM, ConstantsUtil$2.CHAIN.SOLANA];
    const isAvailableChain = availableChains.find((chain) => chain === ChainController.state.activeChain);
    if (!isAvailableChain) {
      RouterController.push("SwitchActiveChain", {
        switchToChain: ConstantsUtil$2.CHAIN.EVM
      });
      return;
    }
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const authConnector2 = ConnectorController.getAuthConnector();
      if (!authConnector2) {
        throw new Error("w3m-email-login-widget: Auth connector not found");
      }
      const { action } = await authConnector2.provider.connectEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_SUBMITTED" });
      if (action === "VERIFY_OTP") {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        RouterController.push("EmailVerifyOtp", { email: this.email });
      } else if (action === "VERIFY_DEVICE") {
        RouterController.push("EmailVerifyDevice", { email: this.email });
      }
    } catch (error) {
      const parsedError = CoreHelperUtil.parseError(error);
      if (parsedError?.includes("Invalid email")) {
        this.error = "Invalid email. Try again.";
      } else {
        SnackController.showError(error);
      }
    } finally {
      this.loading = false;
    }
  }
  onFocusEvent() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_LOGIN_SELECTED" });
  }
};
W3mEmailLoginWidget.styles = styles$e;
__decorate$r([
  r$1()
], W3mEmailLoginWidget.prototype, "connectors", void 0);
__decorate$r([
  r$1()
], W3mEmailLoginWidget.prototype, "email", void 0);
__decorate$r([
  r$1()
], W3mEmailLoginWidget.prototype, "loading", void 0);
__decorate$r([
  r$1()
], W3mEmailLoginWidget.prototype, "error", void 0);
W3mEmailLoginWidget = __decorate$r([
  customElement("w3m-email-login-widget")
], W3mEmailLoginWidget);
const styles$d = i$5`
  wui-flex {
    width: 100%;
  }

  :host > wui-flex:first-child {
    transform: translateY(calc(var(--wui-spacing-xxs) * -1));
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  wui-notice-card {
    margin-bottom: var(--wui-spacing-3xs);
  }

  wui-list-item > wui-text {
    flex: 1;
  }

  w3m-transactions-view {
    max-height: 200px;
  }

  .tab-content-container {
    height: 300px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  .tab-content-container::-webkit-scrollbar {
    display: none;
  }

  .account-button {
    width: auto;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-s);
    height: 48px;
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-s);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: 24px;
    transition: background-color 0.2s linear;
  }

  .account-button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .avatar-container {
    position: relative;
  }

  wui-avatar.avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  wui-avatar.network-avatar {
    width: 16px;
    height: 16px;
    position: absolute;
    left: 100%;
    top: 100%;
    transform: translate(-75%, -75%);
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;
    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition:
      background-color var(--wui-ease-out-power-1) var(--wui-duration-md),
      opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color, opacity;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #667dff;
  }
`;
var __decorate$q = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAccountDefaultWidget = class W3mAccountDefaultWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.disconnecting = false;
    this.balance = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.balance = val.balance;
          this.balanceSymbol = val.balanceSymbol;
        } else if (!this.disconnecting) {
          SnackController.showError("Account not found");
        }
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-account-view: No account provided");
    }
    return x`<wui-flex
        flexDirection="column"
        .padding=${["0", "xl", "m", "xl"]}
        alignItems="center"
        gap="l"
      >
        ${ChainController.state.activeChain === ConstantsUtil$2.CHAIN.EVM ? this.multiAccountTemplate() : this.singleAccountTemplate()}
        <wui-flex flexDirection="column" alignItems="center">
          <wui-text variant="paragraph-500" color="fg-200">
            ${CoreHelperUtil.formatBalance(this.balance, this.balanceSymbol)}
          </wui-text>
        </wui-flex>
        ${this.explorerBtnTemplate()}
      </wui-flex>

      <wui-flex flexDirection="column" gap="xs" .padding=${["0", "s", "s", "s"]}>
        ${this.authCardTemplate()} <w3m-account-auth-button></w3m-account-auth-button>
        ${this.onrampTemplate()} ${this.swapsTemplate()} ${this.activityTemplate()}
        <wui-list-item
          variant="icon"
          iconVariant="overlay"
          icon="disconnect"
          ?chevron=${false}
          .loading=${this.disconnecting}
          @click=${this.onDisconnect.bind(this)}
          data-testid="disconnect-button"
        >
          <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
        </wui-list-item>
      </wui-flex>`;
  }
  onrampTemplate() {
    const { enableOnramp } = OptionsController.state;
    if (!enableOnramp) {
      return null;
    }
    return x`
      <wui-list-item
        data-testid="w3m-account-default-onramp-button"
        iconVariant="blue"
        icon="card"
        ?chevron=${true}
        @click=${this.handleClickPay.bind(this)}
      >
        <wui-text variant="paragraph-500" color="fg-100">Buy crypto</wui-text>
      </wui-list-item>
    `;
  }
  activityTemplate() {
    const isSolana = ChainController.state.activeChain === ConstantsUtil$2.CHAIN.SOLANA;
    return x` <wui-list-item
      iconVariant="blue"
      icon="clock"
      iconSize="sm"
      ?chevron=${!isSolana}
      ?disabled=${isSolana}
      @click=${this.onTransactions.bind(this)}
    >
      <wui-text variant="paragraph-500" color="fg-100" ?disabled=${isSolana}> Activity </wui-text>
      ${isSolana ? x`<wui-tag variant="main">Coming soon</wui-tag>` : ""}
    </wui-list-item>`;
  }
  swapsTemplate() {
    const { enableSwaps } = OptionsController.state;
    if (!enableSwaps || ChainController.state.activeChain === ConstantsUtil$2.CHAIN.SOLANA) {
      return null;
    }
    return x`
      <wui-list-item
        iconVariant="blue"
        icon="recycleHorizontal"
        ?chevron=${true}
        @click=${this.handleClickSwap.bind(this)}
      >
        <wui-text variant="paragraph-500" color="fg-100">Swap</wui-text>
      </wui-list-item>
    `;
  }
  authCardTemplate() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector2 = ConnectorController.getAuthConnector();
    const { origin } = location;
    if (!authConnector2 || type !== "AUTH" || origin.includes(ConstantsUtil$1.SECURE_SITE)) {
      return null;
    }
    return x`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
        data-testid="w3m-wallet-upgrade-card"
      ></wui-notice-card>
    `;
  }
  handleSwitchAccountsView() {
    RouterController.push("SwitchAddress");
  }
  handleClickPay() {
    RouterController.push("OnRampProviders");
  }
  handleClickSwap() {
    RouterController.push("Swap");
  }
  explorerBtnTemplate() {
    const addressExplorerUrl = AccountController.state.addressExplorerUrl;
    if (!addressExplorerUrl) {
      return null;
    }
    return x`
      <wui-button size="md" variant="neutral" @click=${this.onExplorer.bind(this)}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    `;
  }
  singleAccountTemplate() {
    return x`
      <wui-avatar
        alt=${o$3(this.address)}
        address=${o$3(this.address)}
        imageSrc=${o$3(this.profileImage === null ? void 0 : this.profileImage)}
      ></wui-avatar>
      <wui-flex flexDirection="column" alignItems="center">
        <wui-flex gap="3xs" alignItems="center" justifyContent="center">
          <wui-text variant="large-600" color="fg-100">
            ${this.profileName ? UiHelperUtil.getTruncateString({
      string: this.profileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.address ? this.address : "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}
          </wui-text>
          <wui-icon-link
            size="md"
            icon="copy"
            iconColor="fg-200"
            @click=${this.onCopyAddress}
          ></wui-icon-link> </wui-flex
      ></wui-flex>
    `;
  }
  multiAccountTemplate() {
    if (!this.address) {
      throw new Error("w3m-account-view: No account provided");
    }
    const account = AccountController.state.allAccounts?.find((acc) => acc.address === this.address);
    const label = AccountController.state.addressLabels.get(this.address);
    return x`
      <wui-profile-button-v2
        .onProfileClick=${this.handleSwitchAccountsView.bind(this)}
        address=${o$3(this.address)}
        icon="${account?.type === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT && ChainController.state.activeChain === ConstantsUtil$2.CHAIN.EVM ? "lightbulb" : "mail"}"
        avatarSrc=${o$3(this.profileImage ? this.profileImage : void 0)}
        profileName=${o$3(label ? label : this.profileName)}
        .onCopyClick=${this.onCopyAddress.bind(this)}
      ></wui-profile-button-v2>
    `;
  }
  onCopyAddress() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
  onTransactions() {
    EventsController.sendEvent({
      type: "track",
      event: "CLICK_TRANSACTIONS",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("Transactions");
  }
  async onDisconnect() {
    try {
      this.disconnecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconnecting = false;
    }
  }
  onExplorer() {
    const addressExplorerUrl = AccountController.state.addressExplorerUrl;
    if (addressExplorerUrl) {
      CoreHelperUtil.openHref(addressExplorerUrl, "_blank");
    }
  }
  onGoToUpgradeView() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" });
    RouterController.push("UpgradeEmailWallet");
  }
};
W3mAccountDefaultWidget.styles = styles$d;
__decorate$q([
  r$1()
], W3mAccountDefaultWidget.prototype, "address", void 0);
__decorate$q([
  r$1()
], W3mAccountDefaultWidget.prototype, "profileImage", void 0);
__decorate$q([
  r$1()
], W3mAccountDefaultWidget.prototype, "profileName", void 0);
__decorate$q([
  r$1()
], W3mAccountDefaultWidget.prototype, "disconnecting", void 0);
__decorate$q([
  r$1()
], W3mAccountDefaultWidget.prototype, "balance", void 0);
__decorate$q([
  r$1()
], W3mAccountDefaultWidget.prototype, "balanceSymbol", void 0);
W3mAccountDefaultWidget = __decorate$q([
  customElement("w3m-account-default-widget")
], W3mAccountDefaultWidget);
const styles$c = i$5`
  wui-flex {
    width: 100%;
  }

  wui-promo {
    position: absolute;
    top: -32px;
  }

  wui-profile-button {
    margin-top: calc(-1 * var(--wui-spacing-2l));
  }

  wui-promo + wui-profile-button {
    margin-top: var(--wui-spacing-2l);
  }

  wui-tabs {
    width: 100%;
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;
var __decorate$p = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const TABS = 3;
const TABS_PADDING = 48;
const MODAL_MOBILE_VIEW_PX = 430;
let W3mAccountWalletFeaturesWidget = class W3mAccountWalletFeaturesWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.smartAccountDeployed = AccountController.state.smartAccountDeployed;
    this.network = NetworkController.state.caipNetwork;
    this.currentTab = AccountController.state.currentTab;
    this.tokenBalance = AccountController.state.tokenBalance;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.currentTab = val.currentTab;
          this.tokenBalance = val.tokenBalance;
          this.smartAccountDeployed = val.smartAccountDeployed;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          ModalController.close();
        }
      })
    ], NetworkController.subscribeKey("caipNetwork", (val) => {
      this.network = val;
    }));
    this.watchSwapValues();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    clearInterval(this.watchTokenBalance);
  }
  firstUpdated() {
    AccountController.fetchTokenBalance();
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-account-view: No account provided");
    }
    const networkImage = AssetUtil.getNetworkImage(this.network);
    return x`<wui-flex
      flexDirection="column"
      .padding=${["0", "xl", "m", "xl"]}
      alignItems="center"
      gap="m"
    >
      ${this.network && x`<wui-network-icon .network=${this.network}></wui-network-icon>`}
      ${this.activateAccountTemplate()}
      <wui-profile-button
        @click=${this.onProfileButtonClick.bind(this)}
        address=${o$3(this.address)}
        networkSrc=${o$3(networkImage)}
        icon="chevronBottom"
        avatarSrc=${o$3(this.profileImage ? this.profileImage : void 0)}
        profileName=${this.profileName}
        data-testid="w3m-profile-button"
      ></wui-profile-button>
      ${this.tokenBalanceTemplate()}
      <wui-flex gap="s">
        <w3m-tooltip-trigger text="Buy">
          <wui-icon-button
            data-testid="wallet-features-onramp-button"
            @click=${this.onBuyClick.bind(this)}
            icon="card"
          ></wui-icon-button>
        </w3m-tooltip-trigger>
        ${this.swapsTemplate()}
        <w3m-tooltip-trigger text="Receive">
          <wui-icon-button
            data-testid="wallet-features-receive-button"
            @click=${this.onReceiveClick.bind(this)}
            icon="arrowBottomCircle"
          >
          </wui-icon-button>
        </w3m-tooltip-trigger>
        <w3m-tooltip-trigger text="Send">
          <wui-icon-button
            data-testid="wallet-features-send-button"
            @click=${this.onSendClick.bind(this)}
            icon="send"
          ></wui-icon-button>
        </w3m-tooltip-trigger>
      </wui-flex>

      <wui-tabs
        .onTabChange=${this.onTabChange.bind(this)}
        .activeTab=${this.currentTab}
        localTabWidth=${CoreHelperUtil.isMobile() && window.innerWidth < MODAL_MOBILE_VIEW_PX ? `${(window.innerWidth - TABS_PADDING) / TABS}px` : "104px"}
        .tabs=${ConstantsUtil.ACCOUNT_TABS}
      ></wui-tabs>
      ${this.listContentTemplate()}
    </wui-flex>`;
  }
  swapsTemplate() {
    const { enableSwaps } = OptionsController.state;
    if (!enableSwaps) {
      return null;
    }
    return x`
      <w3m-tooltip-trigger text="Swap">
        <wui-icon-button
          data-testid="wallet-features-swap-button"
          @click=${this.onSwapClick.bind(this)}
          icon="recycleHorizontal"
        >
        </wui-icon-button>
      </w3m-tooltip-trigger>
    `;
  }
  watchSwapValues() {
    this.watchTokenBalance = setInterval(() => AccountController.fetchTokenBalance(), 1e4);
  }
  listContentTemplate() {
    if (this.currentTab === 0) {
      return x`<w3m-account-tokens-widget></w3m-account-tokens-widget>`;
    }
    if (this.currentTab === 1) {
      return x`<w3m-account-nfts-widget></w3m-account-nfts-widget>`;
    }
    if (this.currentTab === 2) {
      return x`<w3m-account-activity-widget></w3m-account-activity-widget>`;
    }
    return x`<w3m-account-tokens-widget></w3m-account-tokens-widget>`;
  }
  tokenBalanceTemplate() {
    if (this.tokenBalance && this.tokenBalance?.length >= 0) {
      const value = CoreHelperUtil.calculateBalance(this.tokenBalance);
      const { dollars = "0", pennies = "00" } = CoreHelperUtil.formatTokenBalance(value);
      return x`<wui-balance dollars=${dollars} pennies=${pennies}></wui-balance>`;
    }
    return x`<wui-balance dollars="0" pennies="00"></wui-balance>`;
  }
  activateAccountTemplate() {
    const smartAccountEnabled = NetworkController.checkIfSmartAccountEnabled();
    if (!smartAccountEnabled || this.preferredAccountType !== W3mFrameRpcConstants.ACCOUNT_TYPES.EOA || this.smartAccountDeployed) {
      return null;
    }
    return x` <wui-promo
      text=${"Activate your account"}
      @click=${this.onUpdateToSmartAccount.bind(this)}
      data-testid="activate-smart-account-promo"
    ></wui-promo>`;
  }
  onTabChange(index2) {
    AccountController.setCurrentTab(index2);
  }
  onProfileButtonClick() {
    RouterController.push("Profile");
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
  onSwapClick() {
    if (this.network?.id && !ConstantsUtil$1.SWAP_SUPPORTED_NETWORKS.includes(this.network?.id)) {
      RouterController.push("UnsupportedChain", {
        swapUnsupportedChain: true
      });
    } else {
      EventsController.sendEvent({
        type: "track",
        event: "OPEN_SWAP",
        properties: {
          network: this.network?.id || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      RouterController.push("Swap");
    }
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  onSendClick() {
    EventsController.sendEvent({
      type: "track",
      event: "OPEN_SEND",
      properties: {
        network: this.network?.id || "",
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("WalletSend");
  }
  onUpdateToSmartAccount() {
    RouterController.push("UpgradeToSmartAccount");
  }
};
W3mAccountWalletFeaturesWidget.styles = styles$c;
__decorate$p([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "watchTokenBalance", void 0);
__decorate$p([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "address", void 0);
__decorate$p([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "profileImage", void 0);
__decorate$p([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "profileName", void 0);
__decorate$p([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "smartAccountDeployed", void 0);
__decorate$p([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "network", void 0);
__decorate$p([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "currentTab", void 0);
__decorate$p([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "tokenBalance", void 0);
__decorate$p([
  r$1()
], W3mAccountWalletFeaturesWidget.prototype, "preferredAccountType", void 0);
W3mAccountWalletFeaturesWidget = __decorate$p([
  customElement("w3m-account-wallet-features-widget")
], W3mAccountWalletFeaturesWidget);
const styles$b = i$5`
  :host {
    width: 100%;
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }

  :host::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$o = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAccountActivityWidget = class W3mAccountActivityWidget2 extends i$2 {
  render() {
    return x`<w3m-activity-list page="account"></w3m-activity-list>`;
  }
};
W3mAccountActivityWidget.styles = styles$b;
W3mAccountActivityWidget = __decorate$o([
  customElement("w3m-account-activity-widget")
], W3mAccountActivityWidget);
const styles$a = i$5`
  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;
var __decorate$n = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAccountNftsWidget = class W3mAccountNftsWidget2 extends i$2 {
  render() {
    return x`${this.nftTemplate()}`;
  }
  nftTemplate() {
    return x` <wui-flex
      class="contentContainer"
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      gap="l"
    >
      <wui-icon-box
        icon="wallet"
        size="inherit"
        iconColor="fg-200"
        backgroundColor="fg-200"
        iconSize="lg"
      ></wui-icon-box>
      <wui-flex
        class="textContent"
        gap="xs"
        flexDirection="column"
        justifyContent="center"
        flexDirection="column"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100">Coming soon</wui-text>
        <wui-text variant="small-400" align="center" color="fg-200"
          >Stay tuned for our upcoming NFT feature</wui-text
        >
      </wui-flex>
      <wui-link @click=${this.onReceiveClick.bind(this)}>Receive funds</wui-link>
    </wui-flex>`;
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
};
W3mAccountNftsWidget.styles = styles$a;
W3mAccountNftsWidget = __decorate$n([
  customElement("w3m-account-nfts-widget")
], W3mAccountNftsWidget);
const styles$9 = i$5`
  :host {
    width: 100%;
  }

  wui-flex {
    width: 100%;
  }

  .contentContainer {
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }

  .contentContainer::-webkit-scrollbar {
    display: none;
  }
`;
var __decorate$m = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAccountTokensWidget = class W3mAccountTokensWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tokenBalance = AccountController.state.tokenBalance;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        this.tokenBalance = val.tokenBalance;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x`${this.tokenTemplate()}`;
  }
  tokenTemplate() {
    if (this.tokenBalance && this.tokenBalance?.length > 0) {
      return x`<wui-flex class="contentContainer" flexDirection="column" gap="xs">
        ${this.tokenItemTemplate()}
      </wui-flex>`;
    }
    return x` <wui-flex flexDirection="column" gap="xs"
      ><wui-list-description
        @click=${this.onBuyClick.bind(this)}
        text="Buy Crypto"
        description="Easy with card or bank account"
        icon="card"
        iconColor="success-100"
        iconBackgroundColor="success-100"
        tag="popular"
      ></wui-list-description
      ><wui-list-description
        @click=${this.onReceiveClick.bind(this)}
        text="Receive funds"
        description="Transfer tokens on your wallet"
        icon="arrowBottomCircle"
        iconColor="fg-200"
        iconBackgroundColor="fg-200"
      ></wui-list-description
    ></wui-flex>`;
  }
  tokenItemTemplate() {
    return this.tokenBalance?.map((token2) => x`<wui-list-token
          tokenName=${token2.name}
          tokenImageUrl=${token2.iconUrl}
          tokenAmount=${token2.quantity.numeric}
          tokenValue=${token2.value}
          tokenCurrency=${token2.symbol}
        ></wui-list-token>`);
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  onBuyClick() {
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_BUY_CRYPTO",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("OnRampProviders");
  }
};
W3mAccountTokensWidget.styles = styles$9;
__decorate$m([
  r$1()
], W3mAccountTokensWidget.prototype, "tokenBalance", void 0);
W3mAccountTokensWidget = __decorate$m([
  customElement("w3m-account-tokens-widget")
], W3mAccountTokensWidget);
const styles$8 = i$5`
  :host {
    min-height: 100%;
  }

  .group-container[last-group='true'] {
    padding-bottom: var(--wui-spacing-m);
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }

  .emptyContainer {
    height: 100%;
  }
`;
var __decorate$l = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const PAGINATOR_ID = "last-transaction";
const LOADING_ITEM_COUNT = 7;
let W3mActivityList = class W3mActivityList2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.page = "activity";
    this.address = AccountController.state.address;
    this.transactionsByYear = TransactionsController.state.transactionsByYear;
    this.loading = TransactionsController.state.loading;
    this.empty = TransactionsController.state.empty;
    this.next = TransactionsController.state.next;
    TransactionsController.clearCursor();
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.isConnected) {
          if (this.address !== val.address) {
            this.address = val.address;
            TransactionsController.resetTransactions();
            TransactionsController.fetchTransactions(val.address);
          }
        }
      }),
      NetworkController.subscribeKey("caipNetwork", () => {
        this.updateTransactionView();
      }),
      TransactionsController.subscribe((val) => {
        this.transactionsByYear = val.transactionsByYear;
        this.loading = val.loading;
        this.empty = val.empty;
        this.next = val.next;
      })
    ]);
  }
  firstUpdated() {
    this.updateTransactionView();
    this.createPaginationObserver();
  }
  updated() {
    this.setPaginationObserver();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return x` ${this.empty ? null : this.templateTransactionsByYear()}
    ${this.loading ? this.templateLoading() : null}
    ${!this.loading && this.empty ? this.templateEmpty() : null}`;
  }
  updateTransactionView() {
    const currentNetwork = NetworkController.state.caipNetwork?.id;
    const lastNetworkInView = TransactionsController.state.lastNetworkInView;
    if (lastNetworkInView !== currentNetwork) {
      TransactionsController.resetTransactions();
      TransactionsController.fetchTransactions(this.address);
    }
    TransactionsController.setLastNetworkInView(currentNetwork);
  }
  templateTransactionsByYear() {
    const sortedYearKeys = Object.keys(this.transactionsByYear).sort().reverse();
    return sortedYearKeys.map((year) => {
      const yearInt = parseInt(year, 10);
      const sortedMonthIndexes = new Array(12).fill(null).map((_2, idx) => {
        const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt, idx);
        const transactions = this.transactionsByYear[yearInt]?.[idx];
        return {
          groupTitle,
          transactions
        };
      }).filter(({ transactions }) => transactions).reverse();
      return sortedMonthIndexes.map(({ groupTitle, transactions }, index2) => {
        const isLastGroup = index2 === sortedMonthIndexes.length - 1;
        if (!transactions) {
          return null;
        }
        return x`
          <wui-flex
            flexDirection="column"
            class="group-container"
            last-group="${isLastGroup ? "true" : "false"}"
          >
            <wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${["xs", "s", "s", "s"]}
            >
              <wui-text variant="paragraph-500" color="fg-200">${groupTitle}</wui-text>
            </wui-flex>
            <wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(transactions, isLastGroup)}
            </wui-flex>
          </wui-flex>
        `;
      });
    });
  }
  templateRenderTransaction(transaction, isLastTransaction) {
    const { date, descriptions, direction, isAllNFT, images, status, transfers, type } = this.getTransactionListItemProps(transaction);
    const haveMultipleTransfers = transfers?.length > 1;
    const haveTwoTransfers = transfers?.length === 2;
    if (haveTwoTransfers && !isAllNFT) {
      return x`
        <wui-transaction-list-item
          date=${date}
          .direction=${direction}
          id=${isLastTransaction && this.next ? PAGINATOR_ID : ""}
          status=${status}
          type=${type}
          .images=${images}
          .descriptions=${descriptions}
        ></wui-transaction-list-item>
      `;
    }
    if (haveMultipleTransfers) {
      return transfers.map((transfer, index2) => {
        const description = TransactionUtil.getTransferDescription(transfer);
        const isLastTransfer = isLastTransaction && index2 === transfers.length - 1;
        return x` <wui-transaction-list-item
          date=${date}
          direction=${transfer.direction}
          id=${isLastTransfer && this.next ? PAGINATOR_ID : ""}
          status=${status}
          type=${type}
          .onlyDirectionIcon=${true}
          .images=${[images[index2]]}
          .descriptions=${[description]}
        ></wui-transaction-list-item>`;
      });
    }
    return x`
      <wui-transaction-list-item
        date=${date}
        .direction=${direction}
        id=${isLastTransaction && this.next ? PAGINATOR_ID : ""}
        status=${status}
        type=${type}
        .images=${images}
        .descriptions=${descriptions}
      ></wui-transaction-list-item>
    `;
  }
  templateTransactions(transactions, isLastGroup) {
    return transactions.map((transaction, index2) => {
      const isLastTransaction = isLastGroup && index2 === transactions.length - 1;
      return x`${this.templateRenderTransaction(transaction, isLastTransaction)}`;
    });
  }
  emptyStateActivity() {
    return x`<wui-flex
      class="emptyContainer"
      flexGrow="1"
      flexDirection="column"
      justifyContent="center"
      alignItems="center"
      .padding=${["3xl", "xl", "3xl", "xl"]}
      gap="xl"
    >
      <wui-icon-box
        backgroundColor="gray-glass-005"
        background="gray"
        iconColor="fg-200"
        icon="wallet"
        size="lg"
        ?border=${true}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
      <wui-flex flexDirection="column" alignItems="center" gap="xs">
        <wui-text align="center" variant="paragraph-500" color="fg-100"
          >No Transactions yet</wui-text
        >
        <wui-text align="center" variant="small-500" color="fg-200"
          >Start trading on dApps <br />
          to grow your wallet!</wui-text
        >
      </wui-flex>
    </wui-flex>`;
  }
  emptyStateAccount() {
    return x`<wui-flex
      class="contentContainer"
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      gap="l"
    >
      <wui-icon-box
        icon="swapHorizontal"
        size="inherit"
        iconColor="fg-200"
        backgroundColor="fg-200"
        iconSize="lg"
      ></wui-icon-box>
      <wui-flex
        class="textContent"
        gap="xs"
        flexDirection="column"
        justifyContent="center"
        flexDirection="column"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100">No activity yet</wui-text>
        <wui-text variant="small-400" align="center" color="fg-200"
          >Your next transactions will appear here</wui-text
        >
      </wui-flex>
      <wui-link @click=${this.onReceiveClick.bind(this)}>Trade</wui-link>
    </wui-flex>`;
  }
  templateEmpty() {
    if (this.page === "account") {
      return x`${this.emptyStateAccount()}`;
    }
    return x`${this.emptyStateActivity()}`;
  }
  templateLoading() {
    if (this.page === "activity") {
      return Array(LOADING_ITEM_COUNT).fill(x` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map((item) => item);
    }
    return null;
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  createPaginationObserver() {
    const { projectId: projectId2 } = OptionsController.state;
    this.paginationObserver = new IntersectionObserver(([element]) => {
      if (element?.isIntersecting && !this.loading) {
        TransactionsController.fetchTransactions(this.address);
        EventsController.sendEvent({
          type: "track",
          event: "LOAD_MORE_TRANSACTIONS",
          properties: {
            address: this.address,
            projectId: projectId2,
            cursor: this.next,
            isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
          }
        });
      }
    }, {});
    this.setPaginationObserver();
  }
  setPaginationObserver() {
    this.paginationObserver?.disconnect();
    const lastItem = this.shadowRoot?.querySelector(`#${PAGINATOR_ID}`);
    if (lastItem) {
      this.paginationObserver?.observe(lastItem);
    }
  }
  getTransactionListItemProps(transaction) {
    const date = DateUtil.formatDate(transaction?.metadata?.minedAt);
    const descriptions = TransactionUtil.getTransactionDescriptions(transaction);
    const transfers = transaction?.transfers;
    const transfer = transaction?.transfers?.[0];
    const isAllNFT = Boolean(transfer) && transaction?.transfers?.every((item) => Boolean(item.nft_info));
    const images = TransactionUtil.getTransactionImages(transfers);
    return {
      date,
      direction: transfer?.direction,
      descriptions,
      isAllNFT,
      images,
      status: transaction.metadata?.status,
      transfers,
      type: transaction.metadata?.operationType
    };
  }
};
W3mActivityList.styles = styles$8;
__decorate$l([
  n$2()
], W3mActivityList.prototype, "page", void 0);
__decorate$l([
  r$1()
], W3mActivityList.prototype, "address", void 0);
__decorate$l([
  r$1()
], W3mActivityList.prototype, "transactionsByYear", void 0);
__decorate$l([
  r$1()
], W3mActivityList.prototype, "loading", void 0);
__decorate$l([
  r$1()
], W3mActivityList.prototype, "empty", void 0);
__decorate$l([
  r$1()
], W3mActivityList.prototype, "next", void 0);
W3mActivityList = __decorate$l([
  customElement("w3m-activity-list")
], W3mActivityList);
const styles$7 = i$5`
  :host {
    width: 100%;
    height: 100px;
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  :host(:hover) {
    background-color: var(--wui-color-gray-glass-005);
  }

  wui-flex {
    width: 100%;
    height: fit-content;
  }

  wui-button {
    width: 100%;
    display: flex;
    justify-content: flex-end;
  }

  wui-input-amount {
    mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
  }

  .totalValue {
    width: 100%;
  }
`;
var __decorate$k = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mInputToken = class W3mInputToken2 extends i$2 {
  render() {
    return x` <wui-flex
      flexDirection="column"
      gap="4xs"
      .padding=${["xl", "s", "l", "l"]}
    >
      <wui-flex alignItems="center">
        <wui-input-amount
          @inputChange=${this.onInputChange.bind(this)}
          ?disabled=${!this.token && true}
          .value=${this.sendTokenAmount ? String(this.sendTokenAmount) : ""}
        ></wui-input-amount>
        ${this.buttonTemplate()}
      </wui-flex>
      <wui-flex alignItems="center" justifyContent="space-between">
        ${this.sendValueTemplate()}
        <wui-flex alignItems="center" gap="4xs" justifyContent="flex-end">
          ${this.maxAmountTemplate()} ${this.actionTemplate()}
        </wui-flex>
      </wui-flex>
    </wui-flex>`;
  }
  buttonTemplate() {
    if (this.token) {
      return x`<wui-token-button
        text=${this.token.symbol}
        imageSrc=${this.token.iconUrl}
        @click=${this.handleSelectButtonClick.bind(this)}
      >
      </wui-token-button>`;
    }
    return x`<wui-button
      size="md"
      variant="accent"
      @click=${this.handleSelectButtonClick.bind(this)}
      >Select token</wui-button
    >`;
  }
  handleSelectButtonClick() {
    RouterController.push("WalletSendSelectToken");
  }
  sendValueTemplate() {
    if (this.token && this.sendTokenAmount) {
      const price = this.token.price;
      const totalValue = price * this.sendTokenAmount;
      return x`<wui-text class="totalValue" variant="small-400" color="fg-200"
        >${totalValue ? `$${UiHelperUtil.formatNumberToLocalString(totalValue, 2)}` : "Incorrect value"}</wui-text
      >`;
    }
    return null;
  }
  maxAmountTemplate() {
    if (this.token) {
      if (this.sendTokenAmount && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
        return x` <wui-text variant="small-400" color="error-100">
          ${UiHelperUtil.roundNumber(Number(this.token.quantity.numeric), 6, 5)}
        </wui-text>`;
      }
      return x` <wui-text variant="small-400" color="fg-200">
        ${UiHelperUtil.roundNumber(Number(this.token.quantity.numeric), 6, 5)}
      </wui-text>`;
    }
    return null;
  }
  actionTemplate() {
    if (this.token) {
      if (this.sendTokenAmount && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
        return x`<wui-link @click=${this.onBuyClick.bind(this)}>Buy</wui-link>`;
      }
      return x`<wui-link @click=${this.onMaxClick.bind(this)}>Max</wui-link>`;
    }
    return null;
  }
  onInputChange(event) {
    SendController.setTokenAmount(event.detail);
  }
  onMaxClick() {
    if (this.token && typeof this.gasPrice !== "undefined") {
      const isNetworkToken = this.token.address === void 0 || Object.values(ConstantsUtil$1.NATIVE_TOKEN_ADDRESS).some((nativeAddress) => this.token?.address === nativeAddress);
      const numericGas = NumberUtil.bigNumber(this.gasPrice).shiftedBy(-this.token.quantity.decimals);
      const maxValue = isNetworkToken ? NumberUtil.bigNumber(this.token.quantity.numeric).minus(numericGas) : NumberUtil.bigNumber(this.token.quantity.numeric);
      SendController.setTokenAmount(Number(maxValue.toFixed(20)));
    }
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
};
W3mInputToken.styles = styles$7;
__decorate$k([
  n$2({ type: Object })
], W3mInputToken.prototype, "token", void 0);
__decorate$k([
  n$2({ type: Number })
], W3mInputToken.prototype, "sendTokenAmount", void 0);
__decorate$k([
  n$2({ type: Number })
], W3mInputToken.prototype, "gasPriceInUSD", void 0);
__decorate$k([
  n$2({ type: Number })
], W3mInputToken.prototype, "gasPrice", void 0);
W3mInputToken = __decorate$k([
  customElement("w3m-input-token")
], W3mInputToken);
const styles$6 = i$5`
  :host {
    width: 100%;
    height: 100px;
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
    position: relative;
  }

  :host(:hover) {
    background-color: var(--wui-color-gray-glass-005);
  }

  wui-flex {
    width: 100%;
    height: fit-content;
  }

  wui-button {
    display: ruby;
    color: var(--wui-color-fg-100);
    margin: 0 var(--wui-spacing-xs);
  }

  .instruction {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    z-index: 2;
  }

  .paste {
    display: inline-flex;
  }

  textarea {
    background: transparent;
    width: 100%;
    font-family: var(--w3m-font-family);
    font-size: var(--wui-font-size-medium);
    font-style: normal;
    font-weight: var(--wui-font-weight-light);
    line-height: 130%;
    letter-spacing: var(--wui-letter-spacing-medium);
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
    border: none;
    outline: none;
    appearance: none;
    resize: none;
    overflow: hidden;
  }
`;
var __decorate$j = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mInputAddress = class W3mInputAddress2 extends i$2 {
  constructor() {
    super(...arguments);
    this.inputElementRef = e();
    this.instructionElementRef = e();
    this.instructionHidden = Boolean(this.value);
    this.pasting = false;
    this.onDebouncedSearch = CoreHelperUtil.debounce(async (value) => {
      const address = await ConnectionController.getEnsAddress(value);
      SendController.setLoading(false);
      if (address) {
        SendController.setReceiverProfileName(value);
        SendController.setReceiverAddress(address);
        const avatar = await ConnectionController.getEnsAvatar(value);
        if (avatar) {
          SendController.setReceiverProfileImageUrl(avatar);
        }
      } else {
        SendController.setReceiverAddress(value);
        SendController.setReceiverProfileName(void 0);
        SendController.setReceiverProfileImageUrl(void 0);
      }
    });
  }
  firstUpdated() {
    if (this.value) {
      this.instructionHidden = true;
    }
    this.checkHidden();
  }
  render() {
    return x` <wui-flex
      @click=${this.onBoxClick.bind(this)}
      flexDirection="column"
      justifyContent="center"
      gap="4xs"
      .padding=${["2xl", "l", "xl", "l"]}
    >
      <wui-text
        ${n2(this.instructionElementRef)}
        class="instruction"
        color="fg-300"
        variant="medium-400"
      >
        Type or
        <wui-button
          class="paste"
          size="md"
          variant="neutral"
          iconLeft="copy"
          @click=${this.onPasteClick.bind(this)}
        >
          <wui-icon size="sm" color="inherit" slot="iconLeft" name="copy"></wui-icon>
          Paste
        </wui-button>
        address
      </wui-text>
      <textarea
        spellcheck="false"
        ?disabled=${!this.instructionHidden}
        ${n2(this.inputElementRef)}
        @input=${this.onInputChange.bind(this)}
        @blur=${this.onBlur.bind(this)}
        .value=${this.value ?? ""}
        autocomplete="off"
      >
${this.value ?? ""}</textarea
      >
    </wui-flex>`;
  }
  async focusInput() {
    if (this.instructionElementRef.value) {
      this.instructionHidden = true;
      await this.toggleInstructionFocus(false);
      this.instructionElementRef.value.style.pointerEvents = "none";
      this.inputElementRef.value?.focus();
      if (this.inputElementRef.value) {
        this.inputElementRef.value.selectionStart = this.inputElementRef.value.selectionEnd = this.inputElementRef.value.value.length;
      }
    }
  }
  async focusInstruction() {
    if (this.instructionElementRef.value) {
      this.instructionHidden = false;
      await this.toggleInstructionFocus(true);
      this.instructionElementRef.value.style.pointerEvents = "auto";
      this.inputElementRef.value?.blur();
    }
  }
  async toggleInstructionFocus(focus) {
    if (this.instructionElementRef.value) {
      await this.instructionElementRef.value.animate([{ opacity: focus ? 0 : 1 }, { opacity: focus ? 1 : 0 }], {
        duration: 100,
        easing: "ease",
        fill: "forwards"
      }).finished;
    }
  }
  onBoxClick() {
    if (!this.value && !this.instructionHidden) {
      this.focusInput();
    }
  }
  onBlur() {
    if (!this.value && this.instructionHidden && !this.pasting) {
      this.focusInstruction();
    }
  }
  checkHidden() {
    if (this.instructionHidden) {
      this.focusInput();
    }
  }
  async onPasteClick() {
    this.pasting = true;
    const text = await navigator.clipboard.readText();
    SendController.setReceiverAddress(text);
    this.focusInput();
  }
  onInputChange(e2) {
    this.pasting = false;
    const element = e2.target;
    if (element.value && !this.instructionHidden) {
      this.focusInput();
    }
    SendController.setLoading(true);
    this.onDebouncedSearch(element.value);
  }
};
W3mInputAddress.styles = styles$6;
__decorate$j([
  n$2()
], W3mInputAddress.prototype, "value", void 0);
__decorate$j([
  r$1()
], W3mInputAddress.prototype, "instructionHidden", void 0);
__decorate$j([
  r$1()
], W3mInputAddress.prototype, "pasting", void 0);
W3mInputAddress = __decorate$j([
  customElement("w3m-input-address")
], W3mInputAddress);
const styles$5 = i$5`
  :host {
    display: flex;
    width: auto;
    flex-direction: column;
    gap: var(--wui-border-radius-1xs);
    border-radius: var(--wui-border-radius-s);
    background: var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-s) var(--wui-spacing-1xs) var(--wui-spacing-1xs)
      var(--wui-spacing-1xs);
  }

  wui-text {
    padding: 0 var(--wui-spacing-1xs);
  }

  wui-flex {
    margin-top: var(--wui-spacing-1xs);
  }

  .network {
    cursor: pointer;
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  .network:focus-visible {
    border: 1px solid var(--wui-color-accent-100);
    background-color: var(--wui-color-gray-glass-005);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  .network:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .network:active {
    background-color: var(--wui-color-gray-glass-010);
  }
`;
var __decorate$i = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mWalletSendDetails = class W3mWalletSendDetails2 extends i$2 {
  render() {
    return x` <wui-text variant="small-400" color="fg-200">Details</wui-text>
      <wui-flex flexDirection="column" gap="xxs">
        <wui-list-content textTitle="Network cost" textValue="$${o$3(UiHelperUtil.formatNumberToLocalString(this.networkFee, 2))}"></wui-list-content></wui-list-content>
        <wui-list-content
          textTitle="Address"
          textValue=${UiHelperUtil.getTruncateString({
      string: this.receiverAddress ?? "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}
        >
        </wui-list-content>
        ${this.networkTemplate()}
      </wui-flex>`;
  }
  networkTemplate() {
    if (this.caipNetwork?.name) {
      return x` <wui-list-content
        @click=${() => this.onNetworkClick(this.caipNetwork)}
        class="network"
        textTitle="Network"
        imageSrc=${o$3(AssetUtil.getNetworkImage(this.caipNetwork))}
      ></wui-list-content>`;
    }
    return null;
  }
  onNetworkClick(network) {
    if (network) {
      RouterController.push("Networks", { network });
    }
  }
};
W3mWalletSendDetails.styles = styles$5;
__decorate$i([
  n$2()
], W3mWalletSendDetails.prototype, "receiverAddress", void 0);
__decorate$i([
  n$2({ type: Object })
], W3mWalletSendDetails.prototype, "caipNetwork", void 0);
__decorate$i([
  n$2({ type: Number })
], W3mWalletSendDetails.prototype, "networkFee", void 0);
W3mWalletSendDetails = __decorate$i([
  customElement("w3m-wallet-send-details")
], W3mWalletSendDetails);
const styles$4 = i$5`
  :host {
    pointer-events: none;
  }

  :host > wui-flex {
    display: var(--w3m-tooltip-display);
    opacity: var(--w3m-tooltip-opacity);
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    color: var(--wui-color-bg-100);
    position: fixed;
    top: var(--w3m-tooltip-top);
    left: var(--w3m-tooltip-left);
    transform: translate(calc(-50% + var(--w3m-tooltip-parent-width)), calc(-100% - 8px));
    max-width: calc(var(--w3m-modal-width) - var(--wui-spacing-xl));
    transition: opacity 0.2s var(--wui-ease-out-power-2);
    will-change: opacity;
  }

  :host([data-variant='shade']) > wui-flex {
    background-color: var(--wui-color-bg-150);
    border: 1px solid var(--wui-color-gray-glass-005);
  }

  :host([data-variant='shade']) > wui-flex > wui-text {
    color: var(--wui-color-fg-150);
  }

  :host([data-variant='fill']) > wui-flex {
    background-color: var(--wui-color-fg-100);
    border: none;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
    color: var(--wui-color-bg-150);
  }

  wui-icon[data-placement='top'] {
    bottom: 0px;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;
var __decorate$h = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mTooltip = class W3mTooltip2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.open = TooltipController.state.open;
    this.message = TooltipController.state.message;
    this.triggerRect = TooltipController.state.triggerRect;
    this.variant = TooltipController.state.variant;
    this.unsubscribe.push(...[
      TooltipController.subscribe((newState) => {
        this.open = newState.open;
        this.message = newState.message;
        this.triggerRect = newState.triggerRect;
        this.variant = newState.variant;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    this.dataset["variant"] = this.variant;
    const topValue = this.triggerRect.top;
    const leftValue = this.triggerRect.left;
    this.style.cssText = `
    --w3m-tooltip-top: ${topValue}px;
    --w3m-tooltip-left: ${leftValue}px;
    --w3m-tooltip-parent-width: ${this.triggerRect.width / 2}px;
    --w3m-tooltip-display: ${this.open ? "flex" : "none"};
    --w3m-tooltip-opacity: ${this.open ? 1 : 0};
    `;
    return x`<wui-flex>
      <wui-icon data-placement="top" color="fg-100" size="inherit" name="cursor"></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>
    </wui-flex>`;
  }
};
W3mTooltip.styles = [styles$4];
__decorate$h([
  r$1()
], W3mTooltip.prototype, "open", void 0);
__decorate$h([
  r$1()
], W3mTooltip.prototype, "message", void 0);
__decorate$h([
  r$1()
], W3mTooltip.prototype, "triggerRect", void 0);
__decorate$h([
  r$1()
], W3mTooltip.prototype, "variant", void 0);
W3mTooltip = __decorate$h([
  customElement("w3m-tooltip")
], W3mTooltip);
const styles$3 = i$5`
  :host {
    width: 100%;
    display: block;
  }
`;
var __decorate$g = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let WuiTooltipTrigger = class WuiTooltipTrigger2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.text = "";
    this.open = TooltipController.state.open;
    this.unsubscribe.push(RouterController.subscribeKey("view", () => {
      TooltipController.hide();
    }), ModalController.subscribeKey("open", (modalOpen) => {
      if (!modalOpen) {
        TooltipController.hide();
      }
    }), TooltipController.subscribeKey("open", (tooltipOpen) => {
      this.open = tooltipOpen;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    TooltipController.hide();
  }
  render() {
    return x`
      <div
        @pointermove=${this.onMouseEnter.bind(this)}
        @pointerleave=${this.onMouseLeave.bind(this)}
      >
        ${this.renderChildren()}
      </div>
    `;
  }
  renderChildren() {
    return x`<slot></slot> `;
  }
  onMouseEnter() {
    const rect = this.getBoundingClientRect();
    if (!this.open) {
      TooltipController.showTooltip({
        message: this.text,
        triggerRect: {
          width: rect.width,
          height: rect.height,
          left: rect.left,
          top: rect.top
        },
        variant: "shade"
      });
    }
  }
  onMouseLeave(event) {
    if (!this.contains(event.relatedTarget)) {
      TooltipController.hide();
    }
  }
};
WuiTooltipTrigger.styles = [styles$3];
__decorate$g([
  n$2()
], WuiTooltipTrigger.prototype, "text", void 0);
__decorate$g([
  r$1()
], WuiTooltipTrigger.prototype, "open", void 0);
WuiTooltipTrigger = __decorate$g([
  customElement("w3m-tooltip-trigger")
], WuiTooltipTrigger);
const styles$2 = i$5`
  :host > wui-flex:first-child {
    margin-top: var(--wui-spacing-s);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-m)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;
var __decorate$f = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
const MAX_TOP_VIEW = 2;
const MAXIMUM_LENGTH = 6;
let W3mSocialLoginWidget = class W3mSocialLoginWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.connector = this.connectors.find((c2) => c2.type === "AUTH");
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.connector = this.connectors.find((c2) => c2.type === "AUTH");
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.connector) {
      return null;
    }
    return x`
      <wui-flex
        class="container"
        flexDirection="column"
        gap="xs"
        .padding=${["0", "0", "xs", "0"]}
        data-testid="w3m-social-login-widget"
      >
        ${this.topViewTemplate()}${this.bottomViewTemplate()}
      </wui-flex>
      ${this.separatorTemplate()}
    `;
  }
  topViewTemplate() {
    if (!this.connector?.socials?.length) {
      return null;
    }
    if (this.connector.socials.length === 2) {
      return x` <wui-flex gap="xs">
        ${this.connector.socials.slice(0, MAX_TOP_VIEW).map((social) => x`<wui-logo-select
              data-testid=${`social-selector-${social}`}
              @click=${() => {
        this.onSocialClick(social);
      }}
              logo=${social}
            ></wui-logo-select>`)}
      </wui-flex>`;
    }
    return x` <wui-list-social
      data-testid=${`social-selector-${this.connector?.socials?.[0]}`}
      @click=${() => {
      this.onSocialClick(this.connector?.socials?.[0]);
    }}
      logo=${o$3(this.connector.socials[0])}
      align="center"
      name=${`Continue with ${this.connector.socials[0]}`}
    ></wui-list-social>`;
  }
  bottomViewTemplate() {
    if (!this.connector?.socials?.length) {
      return null;
    }
    if (this.connector?.socials.length <= MAX_TOP_VIEW) {
      return null;
    }
    if (this.connector?.socials.length > MAXIMUM_LENGTH) {
      return x`<wui-flex gap="xs">
        ${this.connector.socials.slice(1, MAXIMUM_LENGTH - 1).map((social) => x`<wui-logo-select
              data-testid=${`social-selector-${social}`}
              @click=${() => {
        this.onSocialClick(social);
      }}
              logo=${social}
            ></wui-logo-select>`)}
        <wui-logo-select logo="more" @click=${this.onMoreSocialsClick.bind(this)}></wui-logo-select>
      </wui-flex>`;
    }
    return x`<wui-flex gap="xs">
      ${this.connector.socials.slice(1, this.connector.socials.length).map((social) => x`<wui-logo-select
            data-testid=${`social-selector-${social}`}
            @click=${() => {
      this.onSocialClick(social);
    }}
            logo=${social}
          ></wui-logo-select>`)}
    </wui-flex>`;
  }
  separatorTemplate() {
    const walletConnectConnector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (walletConnectConnector) {
      return x`<wui-separator text="or"></wui-separator>`;
    }
    return null;
  }
  onMoreSocialsClick() {
    RouterController.push("ConnectSocials");
  }
  async onSocialClick(socialProvider) {
    if (socialProvider) {
      AccountController.setSocialProvider(socialProvider, ChainController.state.activeChain);
      EventsController.sendEvent({
        type: "track",
        event: "SOCIAL_LOGIN_STARTED",
        properties: { provider: socialProvider }
      });
    }
    if (socialProvider === SocialProviderEnum.Farcaster) {
      RouterController.push("ConnectingFarcaster");
      const authConnector2 = ConnectorController.getAuthConnector();
      if (authConnector2) {
        if (!AccountController.state.farcasterUrl) {
          try {
            const { url } = await authConnector2.provider.getFarcasterUri();
            AccountController.setFarcasterUrl(url, ChainController.state.activeChain);
          } catch (error) {
            RouterController.goBack();
            SnackController.showError(error);
          }
        }
      }
    } else {
      RouterController.push("ConnectingSocial");
      const authConnector2 = ConnectorController.getAuthConnector();
      this.popupWindow = CoreHelperUtil.returnOpenHref("", "popupWindow", "width=600,height=800,scrollbars=yes");
      try {
        if (authConnector2 && socialProvider) {
          const { uri } = await authConnector2.provider.getSocialRedirectUri({
            provider: socialProvider
          });
          if (this.popupWindow && uri) {
            AccountController.setSocialWindow(this.popupWindow, ChainController.state.activeChain);
            this.popupWindow.location.href = uri;
          } else {
            this.popupWindow?.close();
            throw new Error("Something went wrong");
          }
        }
      } catch (error) {
        this.popupWindow?.close();
        SnackController.showError("Something went wrong");
      }
    }
  }
};
W3mSocialLoginWidget.styles = styles$2;
__decorate$f([
  r$1()
], W3mSocialLoginWidget.prototype, "connectors", void 0);
W3mSocialLoginWidget = __decorate$f([
  customElement("w3m-social-login-widget")
], W3mSocialLoginWidget);
var __decorate$e = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mWalletLoginList = class W3mWalletLoginList2 extends i$2 {
  render() {
    return x`
      <wui-flex flexDirection="column" gap="xs">
        <w3m-connector-list></w3m-connector-list>
        <w3m-all-wallets-widget></w3m-all-wallets-widget>
      </wui-flex>
    `;
  }
};
W3mWalletLoginList = __decorate$e([
  customElement("w3m-wallet-login-list")
], W3mWalletLoginList);
const styles$1 = i$5`
  :host {
    margin-top: var(--wui-spacing-3xs);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-xs)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;
var __decorate$d = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mSocialLoginList = class W3mSocialLoginList2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.connector = this.connectors.find((c2) => c2.type === "AUTH");
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.connector = this.connectors.find((c2) => c2.type === "AUTH");
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.connector?.socials) {
      return null;
    }
    return x` <wui-flex flexDirection="column" gap="xs">
      ${this.connector.socials.map((social) => x`<wui-list-social
            @click=${() => {
      this.onSocialClick(social);
    }}
            name=${social}
            logo=${social}
          ></wui-list-social>`)}
    </wui-flex>`;
  }
  async onSocialClick(socialProvider) {
    if (socialProvider) {
      AccountController.setSocialProvider(socialProvider, ChainController.state.activeChain);
      EventsController.sendEvent({
        type: "track",
        event: "SOCIAL_LOGIN_STARTED",
        properties: { provider: socialProvider }
      });
    }
    if (socialProvider === SocialProviderEnum.Farcaster) {
      RouterController.push("ConnectingFarcaster");
      const authConnector2 = ConnectorController.getAuthConnector();
      if (authConnector2) {
        if (!AccountController.state.farcasterUrl) {
          try {
            const { url } = await authConnector2.provider.getFarcasterUri();
            AccountController.setFarcasterUrl(url, ChainController.state.activeChain);
          } catch (error) {
            RouterController.goBack();
            SnackController.showError(error);
          }
        }
      }
    } else {
      RouterController.push("ConnectingSocial");
      const authConnector2 = ConnectorController.getAuthConnector();
      this.popupWindow = CoreHelperUtil.returnOpenHref("", "popupWindow", "width=600,height=800,scrollbars=yes");
      try {
        if (authConnector2 && socialProvider) {
          const { uri } = await authConnector2.provider.getSocialRedirectUri({
            provider: socialProvider
          });
          if (this.popupWindow && uri) {
            AccountController.setSocialWindow(this.popupWindow, ChainController.state.activeChain);
            this.popupWindow.location.href = uri;
          } else {
            this.popupWindow?.close();
            throw new Error("Something went wrong");
          }
        }
      } catch (error) {
        this.popupWindow?.close();
        SnackController.showError("Something went wrong");
      }
    }
  }
};
W3mSocialLoginList.styles = styles$1;
__decorate$d([
  r$1()
], W3mSocialLoginList.prototype, "connectors", void 0);
W3mSocialLoginList = __decorate$d([
  customElement("w3m-social-login-list")
], W3mSocialLoginList);
var __decorate$c = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectAnnouncedWidget = class W3mConnectAnnouncedWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const announcedConnectors = this.connectors.filter((connector) => connector.type === "ANNOUNCED");
    if (!announcedConnectors?.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    return x`
      <wui-flex flexDirection="column" gap="xs">
        ${announcedConnectors.map((connector) => {
      if (connector.info?.rdns && ApiController.state.excludedRDNS) {
        if (ApiController.state.excludedRDNS.includes(connector?.info?.rdns)) {
          return null;
        }
      }
      return x`
            <wui-list-wallet
              imageSrc=${o$3(AssetUtil.getConnectorImage(connector))}
              name=${connector.name ?? "Unknown"}
              @click=${() => this.onConnector(connector)}
              tagVariant="success"
              tagLabel="installed"
              data-testid=${`wallet-selector-${connector.id}`}
              .installed=${true}
            >
            </wui-list-wallet>
          `;
    })}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    if (connector.type === "WALLET_CONNECT") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", { connector });
    }
  }
};
__decorate$c([
  r$1()
], W3mConnectAnnouncedWidget.prototype, "connectors", void 0);
W3mConnectAnnouncedWidget = __decorate$c([
  customElement("w3m-connect-announced-widget")
], W3mConnectAnnouncedWidget);
var __decorate$b = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectCustomWidget = class W3mConnectCustomWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { customWallets } = OptionsController.state;
    if (!customWallets?.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    const wallets = this.filterOutDuplicateWallets(customWallets);
    return x`<wui-flex flexDirection="column" gap="xs">
      ${wallets.map((wallet) => x`
          <wui-list-wallet
            imageSrc=${o$3(AssetUtil.getWalletImage(wallet))}
            name=${wallet.name ?? "Unknown"}
            @click=${() => this.onConnectWallet(wallet)}
            data-testid=${`wallet-selector-${wallet.id}`}
          >
          </wui-list-wallet>
        `)}
    </wui-flex>`;
  }
  filterOutDuplicateWallets(wallets) {
    const recent = StorageUtil.getRecentWallets();
    const connectorRDNSs = this.connectors.map((connector) => connector.info?.rdns).filter(Boolean);
    const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
    const allRDNSs = connectorRDNSs.concat(recentRDNSs);
    if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
      const index2 = allRDNSs.indexOf("io.metamask.mobile");
      allRDNSs[index2] = "io.metamask";
    }
    const filtered = wallets.filter((wallet) => !allRDNSs.includes(String(wallet?.rdns)));
    return filtered;
  }
  onConnectWallet(wallet) {
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
__decorate$b([
  r$1()
], W3mConnectCustomWidget.prototype, "connectors", void 0);
W3mConnectCustomWidget = __decorate$b([
  customElement("w3m-connect-custom-widget")
], W3mConnectCustomWidget);
const WalletUtil = {
  filterOutDuplicatesByRDNS(wallets) {
    const connectors = OptionsController.state.enableEIP6963 ? ConnectorController.state.connectors : [];
    const recent = StorageUtil.getRecentWallets();
    const connectorRDNSs = connectors.map((connector) => connector.info?.rdns).filter(Boolean);
    const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
    const allRDNSs = connectorRDNSs.concat(recentRDNSs);
    if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
      const index2 = allRDNSs.indexOf("io.metamask.mobile");
      allRDNSs[index2] = "io.metamask";
    }
    const filtered = wallets.filter((wallet) => !allRDNSs.includes(String(wallet?.rdns)));
    return filtered;
  },
  filterOutDuplicatesByIds(wallets) {
    const connectors = ConnectorController.state.connectors.filter((connector) => connector.type === "ANNOUNCED" || connector.type === "INJECTED");
    const recent = StorageUtil.getRecentWallets();
    const connectorIds = connectors.map((connector) => connector.explorerId);
    const recentIds = recent.map((wallet) => wallet.id);
    const allIds = connectorIds.concat(recentIds);
    const filtered = wallets.filter((wallet) => !allIds.includes(wallet?.id));
    return filtered;
  },
  filterOutDuplicateWallets(wallets) {
    const uniqueByRDNS = this.filterOutDuplicatesByRDNS(wallets);
    const uniqueWallets = this.filterOutDuplicatesByIds(uniqueByRDNS);
    return uniqueWallets;
  }
};
var __decorate$a = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectFeaturedWidget = class W3mConnectFeaturedWidget2 extends i$2 {
  constructor() {
    super(...arguments);
    this.unsubscribe = [];
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { featured } = ApiController.state;
    if (!featured.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    const wallets = WalletUtil.filterOutDuplicateWallets(featured);
    return x`
      <wui-flex flexDirection="column" gap="xs">
        ${wallets.map((wallet) => x`
            <wui-list-wallet
              imageSrc=${o$3(AssetUtil.getWalletImage(wallet))}
              name=${wallet.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mConnectFeaturedWidget = __decorate$a([
  customElement("w3m-connect-featured-widget")
], W3mConnectFeaturedWidget);
var __decorate$9 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectInjectedWidget = class W3mConnectInjectedWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const injectedConnectors = this.connectors.filter((connector) => connector.type === "INJECTED");
    if (!injectedConnectors?.length || injectedConnectors.length === 1 && injectedConnectors[0]?.name === "Browser Wallet" && !CoreHelperUtil.isMobile()) {
      this.style.cssText = `display: none`;
      return null;
    }
    return x`
      <wui-flex flexDirection="column" gap="xs">
        ${injectedConnectors.map((connector) => {
      if (!CoreHelperUtil.isMobile() && connector.name === "Browser Wallet") {
        return null;
      }
      if (!ConnectionController.checkInstalled(void 0, connector.chain)) {
        this.style.cssText = `display: none`;
        return null;
      }
      if (connector.info?.rdns && ApiController.state.excludedRDNS) {
        if (ApiController.state.excludedRDNS.includes(connector?.info?.rdns)) {
          return null;
        }
      }
      return x`
            <wui-list-wallet
              imageSrc=${o$3(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              tagVariant="success"
              tagLabel="installed"
              data-testid=${`wallet-selector-${connector.id}`}
              @click=${() => this.onConnector(connector)}
            >
            </wui-list-wallet>
          `;
    })}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    ChainController.setActiveConnector(connector);
    RouterController.push("ConnectingExternal", { connector });
  }
};
__decorate$9([
  r$1()
], W3mConnectInjectedWidget.prototype, "connectors", void 0);
W3mConnectInjectedWidget = __decorate$9([
  customElement("w3m-connect-injected-widget")
], W3mConnectInjectedWidget);
var __decorate$8 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectMultiChainWidget = class W3mConnectMultiChainWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const multiChainConnectors = this.connectors.filter((connector) => connector.type === "MULTI_CHAIN" && connector.name !== "WalletConnect");
    if (!multiChainConnectors?.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    return x`
      <wui-flex flexDirection="column" gap="xs">
        ${multiChainConnectors.map((connector) => x`
            <wui-list-wallet
              imageSrc=${o$3(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              tagVariant="shade"
              tagLabel="multichain"
              data-testid=${`wallet-selector-${connector.id}`}
              @click=${() => this.onConnector(connector)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    ChainController.setActiveConnector(connector);
    RouterController.push("ConnectingMultiChain");
  }
};
__decorate$8([
  r$1()
], W3mConnectMultiChainWidget.prototype, "connectors", void 0);
W3mConnectMultiChainWidget = __decorate$8([
  customElement("w3m-connect-multi-chain-widget")
], W3mConnectMultiChainWidget);
var __decorate$7 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectExternalWidget = class W3mConnectExternalWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const externalConnectors = this.connectors.filter((connector) => connector.type === "EXTERNAL");
    const filteredOutCoinbaseConnectors = externalConnectors.filter((connector) => connector.id !== "coinbaseWalletSDK");
    if (!filteredOutCoinbaseConnectors?.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    return x`
      <wui-flex flexDirection="column" gap="xs">
        ${filteredOutCoinbaseConnectors.map((connector) => x`
            <wui-list-wallet
              imageSrc=${o$3(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              data-testid=${`wallet-selector-external-${connector.id}`}
              @click=${() => this.onConnector(connector)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    RouterController.push("ConnectingExternal", { connector });
  }
};
__decorate$7([
  r$1()
], W3mConnectExternalWidget.prototype, "connectors", void 0);
W3mConnectExternalWidget = __decorate$7([
  customElement("w3m-connect-external-widget")
], W3mConnectExternalWidget);
var __decorate$6 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectRecentWidget = class W3mConnectRecentWidget2 extends i$2 {
  render() {
    const recent = StorageUtil.getRecentWallets();
    if (!recent?.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    return x`
      <wui-flex flexDirection="column" gap="xs">
        ${recent.map((wallet) => x`
            <wui-list-wallet
              imageSrc=${o$3(AssetUtil.getWalletImage(wallet))}
              name=${wallet.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
              tagLabel="recent"
              tagVariant="shade"
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnectWallet(wallet) {
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
W3mConnectRecentWidget = __decorate$6([
  customElement("w3m-connect-recent-widget")
], W3mConnectRecentWidget);
var __decorate$5 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectRecommendedWidget = class W3mConnectRecommendedWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (!connector) {
      return null;
    }
    const { recommended } = ApiController.state;
    const { customWallets, featuredWalletIds } = OptionsController.state;
    const { connectors } = ConnectorController.state;
    const recent = StorageUtil.getRecentWallets();
    const injected2 = connectors.filter((c2) => c2.type === "INJECTED" || c2.type === "ANNOUNCED");
    const injectedWallets = injected2.filter((i4) => i4.name !== "Browser Wallet");
    if (featuredWalletIds || customWallets || !recommended.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    const overrideLength = injectedWallets.length + recent.length;
    const maxRecommended = Math.max(0, 2 - overrideLength);
    const wallets = WalletUtil.filterOutDuplicateWallets(recommended).slice(0, maxRecommended);
    if (!wallets.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    return x`
      <wui-flex flexDirection="column" gap="xs">
        ${wallets.map((wallet) => x`
            <wui-list-wallet
              imageSrc=${o$3(AssetUtil.getWalletImage(wallet))}
              name=${wallet?.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
__decorate$5([
  r$1()
], W3mConnectRecommendedWidget.prototype, "connectors", void 0);
W3mConnectRecommendedWidget = __decorate$5([
  customElement("w3m-connect-recommended-widget")
], W3mConnectRecommendedWidget);
var __decorate$4 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectWalletConnectWidget = class W3mConnectWalletConnectWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (CoreHelperUtil.isMobile()) {
      this.style.cssText = `display: none`;
      return null;
    }
    const connector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    if (!connector) {
      this.style.cssText = `display: none`;
      return null;
    }
    return x`
      <wui-list-wallet
        imageSrc=${o$3(AssetUtil.getConnectorImage(connector))}
        name=${connector.name ?? "Unknown"}
        @click=${() => this.onConnector(connector)}
        tagLabel="qr code"
        tagVariant="main"
        data-testid="wallet-selector-walletconnect"
      >
      </wui-list-wallet>
    `;
  }
  onConnector(connector) {
    if (connector.type === "WALLET_CONNECT") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", { connector });
    }
  }
};
__decorate$4([
  r$1()
], W3mConnectWalletConnectWidget.prototype, "connectors", void 0);
W3mConnectWalletConnectWidget = __decorate$4([
  customElement("w3m-connect-walletconnect-widget")
], W3mConnectWalletConnectWidget);
const styles = i$5`
  :host {
    margin-top: var(--wui-spacing-3xs);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-xs)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;
var __decorate$3 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mConnectorList = class W3mConnectorList2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { custom: custom2, recent, announced, injected: injected2, multiChain, recommended, featured, external } = this.getConnectorsByType();
    return x`
      <wui-flex flexDirection="column" gap="xs">
        <w3m-connect-walletconnect-widget></w3m-connect-walletconnect-widget>
        ${recent.length ? x`<w3m-connect-recent-widget></w3m-connect-recent-widget>` : null}
        ${multiChain.length ? x`<w3m-connect-multi-chain-widget></w3m-connect-multi-chain-widget>` : null}
        ${announced.length ? x`<w3m-connect-announced-widget></w3m-connect-announced-widget>` : null}
        ${injected2.length ? x`<w3m-connect-injected-widget></w3m-connect-injected-widget>` : null}
        ${featured.length ? x`<w3m-connect-featured-widget></w3m-connect-featured-widget>` : null}
        ${custom2?.length ? x`<w3m-connect-custom-widget></w3m-connect-custom-widget>` : null}
        ${external.length ? x`<w3m-connect-external-widget></w3m-connect-external-widget>` : null}
        ${recommended.length ? x`<w3m-connect-recommended-widget></w3m-connect-recommended-widget>` : null}
      </wui-flex>
    `;
  }
  getConnectorsByType() {
    const { featured, recommended } = ApiController.state;
    const { customWallets: custom2 } = OptionsController.state;
    const recent = StorageUtil.getRecentWallets();
    const filteredRecommended = WalletUtil.filterOutDuplicateWallets(recommended);
    const filteredFeatured = WalletUtil.filterOutDuplicateWallets(featured);
    const multiChain = this.connectors.filter((connector) => connector.type === "MULTI_CHAIN");
    const announced = this.connectors.filter((connector) => connector.type === "ANNOUNCED");
    const injected2 = this.connectors.filter((connector) => connector.type === "INJECTED");
    const external = this.connectors.filter((connector) => connector.type === "EXTERNAL");
    const isEVM = ChainController.state.activeChain === ConstantsUtil$2.CHAIN.EVM;
    const includeAnnouncedAndInjected = isEVM ? OptionsController.state.enableEIP6963 : true;
    return {
      custom: custom2,
      recent,
      external,
      multiChain,
      announced: includeAnnouncedAndInjected ? announced : [],
      injected: includeAnnouncedAndInjected ? injected2 : [],
      recommended: filteredRecommended,
      featured: filteredFeatured
    };
  }
};
W3mConnectorList.styles = styles;
__decorate$3([
  r$1()
], W3mConnectorList.prototype, "connectors", void 0);
W3mConnectorList = __decorate$3([
  customElement("w3m-connector-list")
], W3mConnectorList);
var __decorate$2 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAllWalletsWidget = class W3mAllWalletsWidget2 extends i$2 {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.count = ApiController.state.count;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val), ApiController.subscribeKey("count", (val) => this.count = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const wcConnector = this.connectors.find((c2) => c2.type === "WALLET_CONNECT");
    const { allWallets } = OptionsController.state;
    if (!wcConnector || allWallets === "HIDE") {
      return null;
    }
    if (allWallets === "ONLY_MOBILE" && !CoreHelperUtil.isMobile()) {
      return null;
    }
    const featuredCount = ApiController.state.featured.length;
    const rawCount = this.count + featuredCount;
    const roundedCount = rawCount < 10 ? rawCount : Math.floor(rawCount / 10) * 10;
    const tagLabel = roundedCount < rawCount ? `${roundedCount}+` : `${roundedCount}`;
    return x`
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${tagLabel}
        tagVariant="shade"
        data-testid="all-wallets"
      ></wui-list-wallet>
    `;
  }
  onAllWallets() {
    EventsController.sendEvent({ type: "track", event: "CLICK_ALL_WALLETS" });
    RouterController.push("AllWallets");
  }
};
__decorate$2([
  r$1()
], W3mAllWalletsWidget.prototype, "connectors", void 0);
__decorate$2([
  r$1()
], W3mAllWalletsWidget.prototype, "count", void 0);
W3mAllWalletsWidget = __decorate$2([
  customElement("w3m-all-wallets-widget")
], W3mAllWalletsWidget);
var __decorate$1 = function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
let W3mAccountAuthButton = class W3mAccountAuthButton2 extends i$2 {
  constructor() {
    super(...arguments);
    this.socialProvider = StorageUtil.getConnectedSocialProvider();
    this.socialUsername = StorageUtil.getConnectedSocialUsername();
  }
  render() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector2 = ConnectorController.getAuthConnector();
    if (!authConnector2 || type !== "AUTH") {
      this.style.cssText = `display: none`;
      return null;
    }
    const email = authConnector2.provider.getEmail() ?? "";
    return x`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon=${this.socialProvider ?? "mail"}
        iconSize=${this.socialProvider ? "xxl" : "sm"}
        data-testid="w3m-account-email-update"
        ?chevron=${!this.socialProvider}
        @click=${() => {
      this.onGoToUpdateEmail(email, this.socialProvider);
    }}
      >
        <wui-text variant="paragraph-500" color="fg-100">${this.getAuthName(email)}</wui-text>
      </wui-list-item>
    `;
  }
  onGoToUpdateEmail(email, socialProvider) {
    if (!socialProvider) {
      RouterController.push("UpdateEmailWallet", { email });
    }
  }
  getAuthName(email) {
    if (this.socialUsername) {
      if (this.socialProvider === "discord" && this.socialUsername.endsWith("0")) {
        return this.socialUsername.slice(0, -1);
      }
      return this.socialUsername;
    }
    return email.length > 30 ? `${email.slice(0, -3)}...` : email;
  }
};
W3mAccountAuthButton = __decorate$1([
  customElement("w3m-account-auth-button")
], W3mAccountAuthButton);
var events = { exports: {} };
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var R2 = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R2 && typeof R2.ownKeys === "function") {
    ReflectOwnKeys = R2.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  function ProcessEmitWarning(warning2) {
    if (console && console.warn) console.warn(warning2);
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
    return value !== value;
  };
  function EventEmitter2() {
    EventEmitter2.init.call(this);
  }
  events.exports = EventEmitter2;
  events.exports.once = once;
  EventEmitter2.EventEmitter = EventEmitter2;
  EventEmitter2.prototype._events = void 0;
  EventEmitter2.prototype._eventsCount = 0;
  EventEmitter2.prototype._maxListeners = void 0;
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg2) {
      if (typeof arg2 !== "number" || arg2 < 0 || NumberIsNaN(arg2)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg2 + ".");
      }
      defaultMaxListeners = arg2;
    }
  });
  EventEmitter2.init = function() {
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n3) {
    if (typeof n3 !== "number" || n3 < 0 || NumberIsNaN(n3)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n3 + ".");
    }
    this._maxListeners = n3;
    return this;
  };
  function _getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter2.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };
  EventEmitter2.prototype.emit = function emit(type) {
    var args = [];
    for (var i4 = 1; i4 < arguments.length; i4++) args.push(arguments[i4]);
    var doError = type === "error";
    var events2 = this._events;
    if (events2 !== void 0)
      doError = doError && events2.error === void 0;
    else if (!doError)
      return false;
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        throw er;
      }
      var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
      err.context = er;
      throw err;
    }
    var handler = events2[type];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i4 = 0; i4 < len; ++i4)
        ReflectApply(listeners[i4], this, args);
    }
    return true;
  };
  function _addListener(target, type, listener, prepend) {
    var m3;
    var events2;
    var existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === void 0) {
      events2 = target._events = /* @__PURE__ */ Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events2.newListener !== void 0) {
        target.emit(
          "newListener",
          type,
          listener.listener ? listener.listener : listener
        );
        events2 = target._events;
      }
      existing = events2[type];
    }
    if (existing === void 0) {
      existing = events2[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m3 = _getMaxListeners(target);
      if (m3 > 0 && existing.length > m3 && !existing.warned) {
        existing.warned = true;
        var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w2.name = "MaxListenersExceededWarning";
        w2.emitter = target;
        w2.type = type;
        w2.count = existing.length;
        ProcessEmitWarning(w2);
      }
    }
    return target;
  }
  EventEmitter2.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };
  EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
  EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  function _onceWrap(target, type, listener) {
    var state2 = { fired: false, wrapFn: void 0, target, type, listener };
    var wrapped = onceWrapper.bind(state2);
    wrapped.listener = listener;
    state2.wrapFn = wrapped;
    return wrapped;
  }
  EventEmitter2.prototype.once = function once2(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
    var list, events2, position2, i4, originalListener;
    checkListener(listener);
    events2 = this._events;
    if (events2 === void 0)
      return this;
    list = events2[type];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else {
        delete events2[type];
        if (events2.removeListener)
          this.emit("removeListener", type, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position2 = -1;
      for (i4 = list.length - 1; i4 >= 0; i4--) {
        if (list[i4] === listener || list[i4].listener === listener) {
          originalListener = list[i4].listener;
          position2 = i4;
          break;
        }
      }
      if (position2 < 0)
        return this;
      if (position2 === 0)
        list.shift();
      else {
        spliceOne(list, position2);
      }
      if (list.length === 1)
        events2[type] = list[0];
      if (events2.removeListener !== void 0)
        this.emit("removeListener", type, originalListener || listener);
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events2, i4;
    events2 = this._events;
    if (events2 === void 0)
      return this;
    if (events2.removeListener === void 0) {
      if (arguments.length === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events2[type] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events2[type];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys = Object.keys(events2);
      var key2;
      for (i4 = 0; i4 < keys.length; ++i4) {
        key2 = keys[i4];
        if (key2 === "removeListener") continue;
        this.removeAllListeners(key2);
      }
      this.removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners = events2[type];
    if (typeof listeners === "function") {
      this.removeListener(type, listeners);
    } else if (listeners !== void 0) {
      for (i4 = listeners.length - 1; i4 >= 0; i4--) {
        this.removeListener(type, listeners[i4]);
      }
    }
    return this;
  };
  function _listeners(target, type, unwrap) {
    var events2 = target._events;
    if (events2 === void 0)
      return [];
    var evlistener = events2[type];
    if (evlistener === void 0)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  EventEmitter2.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
  };
  EventEmitter2.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
  };
  EventEmitter2.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };
  EventEmitter2.prototype.listenerCount = listenerCount;
  function listenerCount(type) {
    var events2 = this._events;
    if (events2 !== void 0) {
      var evlistener = events2[type];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== void 0) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  function arrayClone(arr, n3) {
    var copy2 = new Array(n3);
    for (var i4 = 0; i4 < n3; ++i4)
      copy2[i4] = arr[i4];
    return copy2;
  }
  function spliceOne(list, index2) {
    for (; index2 + 1 < list.length; index2++)
      list[index2] = list[index2 + 1];
    list.pop();
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i4 = 0; i4 < ret.length; ++i4) {
      ret[i4] = arr[i4].listener || arr[i4];
    }
    return ret;
  }
  function once(emitter, name) {
    return new Promise(function(resolve, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }
      function resolver() {
        if (typeof emitter.removeListener === "function") {
          emitter.removeListener("error", errorListener);
        }
        resolve([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
      if (name !== "error") {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  }
  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") {
      eventTargetAgnosticAddListener(emitter, "error", handler, flags);
    }
  }
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, function wrapListener(arg2) {
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg2);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }
  return events.exports;
}
var eventsExports = requireEvents();
const Nt = /* @__PURE__ */ getDefaultExportFromCjs(eventsExports);
var cjs$3 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d3, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d22, b22) {
    d22.__proto__ = b22;
  } || function(d22, b22) {
    for (var p2 in b22) if (b22.hasOwnProperty(p2)) d22[p2] = b22[p2];
  };
  return extendStatics(d3, b2);
};
function __extends(d3, b2) {
  extendStatics(d3, b2);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i4 = 1, n3 = arguments.length; i4 < n3; i4++) {
      s2 = arguments[i4];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p2 = Object.getOwnPropertySymbols(s2); i4 < p2.length; i4++) {
      if (e2.indexOf(p2[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i4]))
        t2[p2[i4]] = s2[p2[i4]];
    }
  return t2;
}
function __decorate(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key2, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d3 = decorators[i4]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key2, r2) : d3(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body2) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y3, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n3) {
    return function(v2) {
      return step([n3, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f2 = 1, y3 && (t2 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t2 = y3["return"]) && t2.call(y3), 0) : y3.next) && !(t2 = t2.call(y3, op[1])).done) return t2;
      if (y3 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y3 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body2.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y3 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o2, m3, k2, k22) {
  if (k22 === void 0) k22 = k2;
  o2[k22] = m3[k2];
}
function __exportStar(m3, exports) {
  for (var p2 in m3) if (p2 !== "default" && !exports.hasOwnProperty(p2)) exports[p2] = m3[p2];
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o2[s2], i4 = 0;
  if (m3) return m3.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i4 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i4++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n3) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i4 = m3.call(o2), r2, ar2 = [], e2;
  try {
    while ((n3 === void 0 || n3-- > 0) && !(r2 = i4.next()).done) ar2.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i4["return"])) m3.call(i4);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar2;
}
function __spread() {
  for (var ar2 = [], i4 = 0; i4 < arguments.length; i4++)
    ar2 = ar2.concat(__read(arguments[i4]));
  return ar2;
}
function __spreadArrays() {
  for (var s2 = 0, i4 = 0, il = arguments.length; i4 < il; i4++) s2 += arguments[i4].length;
  for (var r2 = Array(s2), k2 = 0, i4 = 0; i4 < il; i4++)
    for (var a2 = arguments[i4], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i4, q = [];
  return i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4;
  function verb(n3) {
    if (g2[n3]) i4[n3] = function(v2) {
      return new Promise(function(a2, b2) {
        q.push([n3, v2, a2, b2]) > 1 || resume(n3, v2);
      });
    };
  }
  function resume(n3, v2) {
    try {
      step(g2[n3](v2));
    } catch (e2) {
      settle(q[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i4, p2;
  return i4 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i4[Symbol.iterator] = function() {
    return this;
  }, i4;
  function verb(n3, f2) {
    i4[n3] = o2[n3] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o2[n3](v2)), done: n3 === "return" } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m3 = o2[Symbol.asyncIterator], i4;
  return m3 ? m3.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4);
  function verb(n3) {
    i4[n3] = o2[n3] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n3](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d3, v2) {
    Promise.resolve(v2).then(function(v22) {
      resolve({ value: v22, done: d3 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod) if (Object.hasOwnProperty.call(mod, k2)) result[k2] = mod[k2];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var utils$3 = {};
var delay = {};
var hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay) return delay;
  hasRequiredDelay = 1;
  Object.defineProperty(delay, "__esModule", { value: true });
  delay.delay = void 0;
  function delay$1(timeout) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(true);
      }, timeout);
    });
  }
  delay.delay = delay$1;
  return delay;
}
var convert = {};
var constants = {};
var misc = {};
var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc) return misc;
  hasRequiredMisc = 1;
  Object.defineProperty(misc, "__esModule", { value: true });
  misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0;
  misc.ONE_HUNDRED = 100;
  misc.ONE_THOUSAND = 1e3;
  return misc;
}
var time = {};
var hasRequiredTime;
function requireTime() {
  if (hasRequiredTime) return time;
  hasRequiredTime = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
    exports.ONE_SECOND = 1;
    exports.FIVE_SECONDS = 5;
    exports.TEN_SECONDS = 10;
    exports.THIRTY_SECONDS = 30;
    exports.SIXTY_SECONDS = 60;
    exports.ONE_MINUTE = exports.SIXTY_SECONDS;
    exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
    exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
    exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
    exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
    exports.ONE_HOUR = exports.SIXTY_MINUTES;
    exports.THREE_HOURS = exports.ONE_HOUR * 3;
    exports.SIX_HOURS = exports.ONE_HOUR * 6;
    exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
    exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
    exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
    exports.THREE_DAYS = exports.ONE_DAY * 3;
    exports.FIVE_DAYS = exports.ONE_DAY * 5;
    exports.SEVEN_DAYS = exports.ONE_DAY * 7;
    exports.THIRTY_DAYS = exports.ONE_DAY * 30;
    exports.ONE_WEEK = exports.SEVEN_DAYS;
    exports.TWO_WEEKS = exports.ONE_WEEK * 2;
    exports.THREE_WEEKS = exports.ONE_WEEK * 3;
    exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
    exports.ONE_YEAR = exports.ONE_DAY * 365;
  })(time);
  return time;
}
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0$1;
    tslib_1.__exportStar(requireMisc(), exports);
    tslib_1.__exportStar(requireTime(), exports);
  })(constants);
  return constants;
}
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert) return convert;
  hasRequiredConvert = 1;
  Object.defineProperty(convert, "__esModule", { value: true });
  convert.fromMiliseconds = convert.toMiliseconds = void 0;
  const constants_1 = requireConstants();
  function toMiliseconds(seconds) {
    return seconds * constants_1.ONE_THOUSAND;
  }
  convert.toMiliseconds = toMiliseconds;
  function fromMiliseconds(miliseconds) {
    return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
  }
  convert.fromMiliseconds = fromMiliseconds;
  return convert;
}
var hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$3;
  hasRequiredUtils$3 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0$1;
    tslib_1.__exportStar(requireDelay(), exports);
    tslib_1.__exportStar(requireConvert(), exports);
  })(utils$3);
  return utils$3;
}
var watch$1 = {};
var hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1) return watch$1;
  hasRequiredWatch$1 = 1;
  Object.defineProperty(watch$1, "__esModule", { value: true });
  watch$1.Watch = void 0;
  class Watch {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(label) {
      if (this.timestamps.has(label)) {
        throw new Error(`Watch already started for label: ${label}`);
      }
      this.timestamps.set(label, { started: Date.now() });
    }
    stop(label) {
      const timestamp = this.get(label);
      if (typeof timestamp.elapsed !== "undefined") {
        throw new Error(`Watch already stopped for label: ${label}`);
      }
      const elapsed = Date.now() - timestamp.started;
      this.timestamps.set(label, { started: timestamp.started, elapsed });
    }
    get(label) {
      const timestamp = this.timestamps.get(label);
      if (typeof timestamp === "undefined") {
        throw new Error(`No timestamp found for label: ${label}`);
      }
      return timestamp;
    }
    elapsed(label) {
      const timestamp = this.get(label);
      const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
      return elapsed;
    }
  }
  watch$1.Watch = Watch;
  watch$1.default = Watch;
  return watch$1;
}
var types = {};
var watch = {};
var hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch) return watch;
  hasRequiredWatch = 1;
  Object.defineProperty(watch, "__esModule", { value: true });
  watch.IWatch = void 0;
  class IWatch {
  }
  watch.IWatch = IWatch;
  return watch;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0$1;
    tslib_1.__exportStar(requireWatch(), exports);
  })(types);
  return types;
}
var hasRequiredCjs$3;
function requireCjs$3() {
  if (hasRequiredCjs$3) return cjs$3;
  hasRequiredCjs$3 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0$1;
    tslib_1.__exportStar(requireUtils$3(), exports);
    tslib_1.__exportStar(requireWatch$1(), exports);
    tslib_1.__exportStar(requireTypes(), exports);
    tslib_1.__exportStar(requireConstants(), exports);
  })(cjs$3);
  return cjs$3;
}
var cjsExports$3 = requireCjs$3();
var cjs$2 = {};
var hasRequiredCjs$2;
function requireCjs$2() {
  if (hasRequiredCjs$2) return cjs$2;
  hasRequiredCjs$2 = 1;
  Object.defineProperty(cjs$2, "__esModule", { value: true });
  cjs$2.getLocalStorage = cjs$2.getLocalStorageOrThrow = cjs$2.getCrypto = cjs$2.getCryptoOrThrow = cjs$2.getLocation = cjs$2.getLocationOrThrow = cjs$2.getNavigator = cjs$2.getNavigatorOrThrow = cjs$2.getDocument = cjs$2.getDocumentOrThrow = cjs$2.getFromWindowOrThrow = cjs$2.getFromWindow = void 0;
  function getFromWindow(name) {
    let res = void 0;
    if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
      res = window[name];
    }
    return res;
  }
  cjs$2.getFromWindow = getFromWindow;
  function getFromWindowOrThrow(name) {
    const res = getFromWindow(name);
    if (!res) {
      throw new Error(`${name} is not defined in Window`);
    }
    return res;
  }
  cjs$2.getFromWindowOrThrow = getFromWindowOrThrow;
  function getDocumentOrThrow() {
    return getFromWindowOrThrow("document");
  }
  cjs$2.getDocumentOrThrow = getDocumentOrThrow;
  function getDocument() {
    return getFromWindow("document");
  }
  cjs$2.getDocument = getDocument;
  function getNavigatorOrThrow() {
    return getFromWindowOrThrow("navigator");
  }
  cjs$2.getNavigatorOrThrow = getNavigatorOrThrow;
  function getNavigator() {
    return getFromWindow("navigator");
  }
  cjs$2.getNavigator = getNavigator;
  function getLocationOrThrow() {
    return getFromWindowOrThrow("location");
  }
  cjs$2.getLocationOrThrow = getLocationOrThrow;
  function getLocation() {
    return getFromWindow("location");
  }
  cjs$2.getLocation = getLocation;
  function getCryptoOrThrow() {
    return getFromWindowOrThrow("crypto");
  }
  cjs$2.getCryptoOrThrow = getCryptoOrThrow;
  function getCrypto() {
    return getFromWindow("crypto");
  }
  cjs$2.getCrypto = getCrypto;
  function getLocalStorageOrThrow() {
    return getFromWindowOrThrow("localStorage");
  }
  cjs$2.getLocalStorageOrThrow = getLocalStorageOrThrow;
  function getLocalStorage() {
    return getFromWindow("localStorage");
  }
  cjs$2.getLocalStorage = getLocalStorage;
  return cjs$2;
}
var cjsExports$2 = requireCjs$2();
var cjs$1 = {};
var hasRequiredCjs$1;
function requireCjs$1() {
  if (hasRequiredCjs$1) return cjs$1;
  hasRequiredCjs$1 = 1;
  Object.defineProperty(cjs$1, "__esModule", { value: true });
  cjs$1.getWindowMetadata = void 0;
  const window_getters_1 = requireCjs$2();
  function getWindowMetadata() {
    let doc;
    let loc;
    try {
      doc = window_getters_1.getDocumentOrThrow();
      loc = window_getters_1.getLocationOrThrow();
    } catch (e2) {
      return null;
    }
    function getIcons() {
      const links = doc.getElementsByTagName("link");
      const icons2 = [];
      for (let i4 = 0; i4 < links.length; i4++) {
        const link = links[i4];
        const rel = link.getAttribute("rel");
        if (rel) {
          if (rel.toLowerCase().indexOf("icon") > -1) {
            const href = link.getAttribute("href");
            if (href) {
              if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                let absoluteHref = loc.protocol + "//" + loc.host;
                if (href.indexOf("/") === 0) {
                  absoluteHref += href;
                } else {
                  const path = loc.pathname.split("/");
                  path.pop();
                  const finalPath = path.join("/");
                  absoluteHref += finalPath + "/" + href;
                }
                icons2.push(absoluteHref);
              } else if (href.indexOf("//") === 0) {
                const absoluteUrl = loc.protocol + href;
                icons2.push(absoluteUrl);
              } else {
                icons2.push(href);
              }
            }
          }
        }
      }
      return icons2;
    }
    function getWindowMetadataOfAny(...args) {
      const metaTags = doc.getElementsByTagName("meta");
      for (let i4 = 0; i4 < metaTags.length; i4++) {
        const tag = metaTags[i4];
        const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
          if (attr) {
            return args.includes(attr);
          }
          return false;
        });
        if (attributes.length && attributes) {
          const content = tag.getAttribute("content");
          if (content) {
            return content;
          }
        }
      }
      return "";
    }
    function getName() {
      let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
      if (!name2) {
        name2 = doc.title;
      }
      return name2;
    }
    function getDescription() {
      const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
      return description2;
    }
    const name = getName();
    const description = getDescription();
    const url = loc.origin;
    const icons = getIcons();
    const meta = {
      description,
      url,
      icons,
      name
    };
    return meta;
  }
  cjs$1.getWindowMetadata = getWindowMetadata;
  return cjs$1;
}
var cjsExports$1 = requireCjs$1();
var queryString = {};
var strictUriEncode;
var hasRequiredStrictUriEncode;
function requireStrictUriEncode() {
  if (hasRequiredStrictUriEncode) return strictUriEncode;
  hasRequiredStrictUriEncode = 1;
  strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`);
  return strictUriEncode;
}
var decodeUriComponent;
var hasRequiredDecodeUriComponent;
function requireDecodeUriComponent() {
  if (hasRequiredDecodeUriComponent) return decodeUriComponent;
  hasRequiredDecodeUriComponent = 1;
  var token2 = "%[a-f0-9]{2}";
  var singleMatcher = new RegExp("(" + token2 + ")|([^%]+?)", "gi");
  var multiMatcher = new RegExp("(" + token2 + ")+", "gi");
  function decodeComponents(components, split2) {
    try {
      return [decodeURIComponent(components.join(""))];
    } catch (err) {
    }
    if (components.length === 1) {
      return components;
    }
    split2 = split2 || 1;
    var left2 = components.slice(0, split2);
    var right2 = components.slice(split2);
    return Array.prototype.concat.call([], decodeComponents(left2), decodeComponents(right2));
  }
  function decode2(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher) || [];
      for (var i4 = 1; i4 < tokens.length; i4++) {
        input = decodeComponents(tokens, i4).join("");
        tokens = input.match(singleMatcher) || [];
      }
      return input;
    }
  }
  function customDecodeURIComponent(input) {
    var replaceMap = {
      "%FE%FF": "",
      "%FF%FE": ""
    };
    var match2 = multiMatcher.exec(input);
    while (match2) {
      try {
        replaceMap[match2[0]] = decodeURIComponent(match2[0]);
      } catch (err) {
        var result = decode2(match2[0]);
        if (result !== match2[0]) {
          replaceMap[match2[0]] = result;
        }
      }
      match2 = multiMatcher.exec(input);
    }
    replaceMap["%C2"] = "";
    var entries2 = Object.keys(replaceMap);
    for (var i4 = 0; i4 < entries2.length; i4++) {
      var key2 = entries2[i4];
      input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
    }
    return input;
  }
  decodeUriComponent = function(encodedURI) {
    if (typeof encodedURI !== "string") {
      throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
    }
    try {
      encodedURI = encodedURI.replace(/\+/g, " ");
      return decodeURIComponent(encodedURI);
    } catch (err) {
      return customDecodeURIComponent(encodedURI);
    }
  };
  return decodeUriComponent;
}
var splitOnFirst;
var hasRequiredSplitOnFirst;
function requireSplitOnFirst() {
  if (hasRequiredSplitOnFirst) return splitOnFirst;
  hasRequiredSplitOnFirst = 1;
  splitOnFirst = (string, separator) => {
    if (!(typeof string === "string" && typeof separator === "string")) {
      throw new TypeError("Expected the arguments to be of type `string`");
    }
    if (separator === "") {
      return [string];
    }
    const separatorIndex = string.indexOf(separator);
    if (separatorIndex === -1) {
      return [string];
    }
    return [
      string.slice(0, separatorIndex),
      string.slice(separatorIndex + separator.length)
    ];
  };
  return splitOnFirst;
}
var filterObj;
var hasRequiredFilterObj;
function requireFilterObj() {
  if (hasRequiredFilterObj) return filterObj;
  hasRequiredFilterObj = 1;
  filterObj = function(obj, predicate) {
    var ret = {};
    var keys = Object.keys(obj);
    var isArr = Array.isArray(predicate);
    for (var i4 = 0; i4 < keys.length; i4++) {
      var key2 = keys[i4];
      var val = obj[key2];
      if (isArr ? predicate.indexOf(key2) !== -1 : predicate(key2, val, obj)) {
        ret[key2] = val;
      }
    }
    return ret;
  };
  return filterObj;
}
var hasRequiredQueryString;
function requireQueryString() {
  if (hasRequiredQueryString) return queryString;
  hasRequiredQueryString = 1;
  (function(exports) {
    const strictUriEncode2 = requireStrictUriEncode();
    const decodeComponent = requireDecodeUriComponent();
    const splitOnFirst2 = requireSplitOnFirst();
    const filterObject = requireFilterObj();
    const isNullOrUndefined = (value) => value === null || value === void 0;
    const encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key2) => (result, value) => {
            const index2 = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key2, options), "[", index2, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key2, options), "[", encode2(index2, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key2) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key2, options), "[]"].join("")];
            }
            return [...result, [encode2(key2, options), "[]=", encode2(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key2) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key2, options), ":list="].join("")];
            }
            return [...result, [encode2(key2, options), ":list=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key2) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode2(key2, options), keyValueSep, encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key2) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key2, options)];
            }
            return [...result, [encode2(key2, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key2, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key2);
            key2 = key2.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key2] = value;
              return;
            }
            if (accumulator[key2] === void 0) {
              accumulator[key2] = {};
            }
            accumulator[key2][result[1]] = value;
          };
        case "bracket":
          return (key2, value, accumulator) => {
            result = /(\[\])$/.exec(key2);
            key2 = key2.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key2] = value;
              return;
            }
            if (accumulator[key2] === void 0) {
              accumulator[key2] = [value];
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], value);
          };
        case "colon-list-separator":
          return (key2, value, accumulator) => {
            result = /(:list)$/.exec(key2);
            key2 = key2.replace(/:list$/, "");
            if (!result) {
              accumulator[key2] = value;
              return;
            }
            if (accumulator[key2] === void 0) {
              accumulator[key2] = [value];
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], value);
          };
        case "comma":
        case "separator":
          return (key2, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode2(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode2(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
            accumulator[key2] = newValue;
          };
        case "bracket-separator":
          return (key2, value, accumulator) => {
            const isArray = /(\[\])$/.test(key2);
            key2 = key2.replace(/\[\]$/, "");
            if (!isArray) {
              accumulator[key2] = value ? decode2(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode2(item, options));
            if (accumulator[key2] === void 0) {
              accumulator[key2] = arrayValue;
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], arrayValue);
          };
        default:
          return (key2, value, accumulator) => {
            if (accumulator[key2] === void 0) {
              accumulator[key2] = value;
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode2(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode2(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a2, b2) => Number(a2) - Number(b2)).map((key2) => input[key2]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash2 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash2 = url.slice(hashStart);
      }
      return hash2;
    }
    function extract2(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse2(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key2, value] = splitOnFirst2(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options);
        formatter(decode2(key2, options), value, ret);
      }
      for (const key2 of Object.keys(ret)) {
        const value = ret[key2];
        if (typeof value === "object" && value !== null) {
          for (const k2 of Object.keys(value)) {
            value[k2] = parseValue(value[k2], options);
          }
        } else {
          ret[key2] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key2) => {
        const value = ret[key2];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key2] = keysSorter(value);
        } else {
          result[key2] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract2;
    exports.parse = parse2;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key2) => options.skipNull && isNullOrUndefined(object[key2]) || options.skipEmptyString && object[key2] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key2 of Object.keys(object)) {
        if (!shouldFilter(key2)) {
          objectCopy[key2] = object[key2];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key2) => {
        const value = object[key2];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key2, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode2(key2, options) + "[]";
          }
          return value.reduce(formatter(key2), []).join("&");
        }
        return encode2(key2, options) + "=" + encode2(value, options);
      }).filter((x2) => x2.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash2] = splitOnFirst2(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse2(extract2(url), options)
        },
        options && options.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode2(hash2, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString2 = exports.stringify(query, options);
      if (queryString2) {
        queryString2 = `?${queryString2}`;
      }
      let hash2 = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash2 = `#${options[encodeFragmentIdentifier] ? encode2(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString2}${hash2}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key2) => !filter.includes(key2) : (key2, value) => !filter(key2, value);
      return exports.pick(input, exclusionFilter, options);
    };
  })(queryString);
  return queryString;
}
requireQueryString();
var chacha20poly1305 = {};
var chacha = {};
var binary = {};
var int = {};
var hasRequiredInt;
function requireInt() {
  if (hasRequiredInt) return int;
  hasRequiredInt = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function imulShim(a2, b2) {
      var ah = a2 >>> 16 & 65535, al = a2 & 65535;
      var bh = b2 >>> 16 & 65535, bl = b2 & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    exports.mul = Math.imul || imulShim;
    function add2(a2, b2) {
      return a2 + b2 | 0;
    }
    exports.add = add2;
    function sub(a2, b2) {
      return a2 - b2 | 0;
    }
    exports.sub = sub;
    function rotl(x2, n3) {
      return x2 << n3 | x2 >>> 32 - n3;
    }
    exports.rotl = rotl;
    function rotr2(x2, n3) {
      return x2 << 32 - n3 | x2 >>> n3;
    }
    exports.rotr = rotr2;
    function isIntegerShim(n3) {
      return typeof n3 === "number" && isFinite(n3) && Math.floor(n3) === n3;
    }
    exports.isInteger = Number.isInteger || isIntegerShim;
    exports.MAX_SAFE_INTEGER = 9007199254740991;
    exports.isSafeInteger = function(n3) {
      return exports.isInteger(n3) && (n3 >= -exports.MAX_SAFE_INTEGER && n3 <= exports.MAX_SAFE_INTEGER);
    };
  })(int);
  return int;
}
var hasRequiredBinary;
function requireBinary() {
  if (hasRequiredBinary) return binary;
  hasRequiredBinary = 1;
  Object.defineProperty(binary, "__esModule", { value: true });
  var int_1 = requireInt();
  function readInt16BE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    return (array[offset2 + 0] << 8 | array[offset2 + 1]) << 16 >> 16;
  }
  binary.readInt16BE = readInt16BE;
  function readUint16BE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    return (array[offset2 + 0] << 8 | array[offset2 + 1]) >>> 0;
  }
  binary.readUint16BE = readUint16BE;
  function readInt16LE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    return (array[offset2 + 1] << 8 | array[offset2]) << 16 >> 16;
  }
  binary.readInt16LE = readInt16LE;
  function readUint16LE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    return (array[offset2 + 1] << 8 | array[offset2]) >>> 0;
  }
  binary.readUint16LE = readUint16LE;
  function writeUint16BE(value, out, offset2) {
    if (out === void 0) {
      out = new Uint8Array(2);
    }
    if (offset2 === void 0) {
      offset2 = 0;
    }
    out[offset2 + 0] = value >>> 8;
    out[offset2 + 1] = value >>> 0;
    return out;
  }
  binary.writeUint16BE = writeUint16BE;
  binary.writeInt16BE = writeUint16BE;
  function writeUint16LE(value, out, offset2) {
    if (out === void 0) {
      out = new Uint8Array(2);
    }
    if (offset2 === void 0) {
      offset2 = 0;
    }
    out[offset2 + 0] = value >>> 0;
    out[offset2 + 1] = value >>> 8;
    return out;
  }
  binary.writeUint16LE = writeUint16LE;
  binary.writeInt16LE = writeUint16LE;
  function readInt32BE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    return array[offset2] << 24 | array[offset2 + 1] << 16 | array[offset2 + 2] << 8 | array[offset2 + 3];
  }
  binary.readInt32BE = readInt32BE;
  function readUint32BE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    return (array[offset2] << 24 | array[offset2 + 1] << 16 | array[offset2 + 2] << 8 | array[offset2 + 3]) >>> 0;
  }
  binary.readUint32BE = readUint32BE;
  function readInt32LE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    return array[offset2 + 3] << 24 | array[offset2 + 2] << 16 | array[offset2 + 1] << 8 | array[offset2];
  }
  binary.readInt32LE = readInt32LE;
  function readUint32LE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    return (array[offset2 + 3] << 24 | array[offset2 + 2] << 16 | array[offset2 + 1] << 8 | array[offset2]) >>> 0;
  }
  binary.readUint32LE = readUint32LE;
  function writeUint32BE(value, out, offset2) {
    if (out === void 0) {
      out = new Uint8Array(4);
    }
    if (offset2 === void 0) {
      offset2 = 0;
    }
    out[offset2 + 0] = value >>> 24;
    out[offset2 + 1] = value >>> 16;
    out[offset2 + 2] = value >>> 8;
    out[offset2 + 3] = value >>> 0;
    return out;
  }
  binary.writeUint32BE = writeUint32BE;
  binary.writeInt32BE = writeUint32BE;
  function writeUint32LE(value, out, offset2) {
    if (out === void 0) {
      out = new Uint8Array(4);
    }
    if (offset2 === void 0) {
      offset2 = 0;
    }
    out[offset2 + 0] = value >>> 0;
    out[offset2 + 1] = value >>> 8;
    out[offset2 + 2] = value >>> 16;
    out[offset2 + 3] = value >>> 24;
    return out;
  }
  binary.writeUint32LE = writeUint32LE;
  binary.writeInt32LE = writeUint32LE;
  function readInt64BE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    var hi = readInt32BE(array, offset2);
    var lo = readInt32BE(array, offset2 + 4);
    return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
  }
  binary.readInt64BE = readInt64BE;
  function readUint64BE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    var hi = readUint32BE(array, offset2);
    var lo = readUint32BE(array, offset2 + 4);
    return hi * 4294967296 + lo;
  }
  binary.readUint64BE = readUint64BE;
  function readInt64LE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    var lo = readInt32LE(array, offset2);
    var hi = readInt32LE(array, offset2 + 4);
    return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
  }
  binary.readInt64LE = readInt64LE;
  function readUint64LE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    var lo = readUint32LE(array, offset2);
    var hi = readUint32LE(array, offset2 + 4);
    return hi * 4294967296 + lo;
  }
  binary.readUint64LE = readUint64LE;
  function writeUint64BE(value, out, offset2) {
    if (out === void 0) {
      out = new Uint8Array(8);
    }
    if (offset2 === void 0) {
      offset2 = 0;
    }
    writeUint32BE(value / 4294967296 >>> 0, out, offset2);
    writeUint32BE(value >>> 0, out, offset2 + 4);
    return out;
  }
  binary.writeUint64BE = writeUint64BE;
  binary.writeInt64BE = writeUint64BE;
  function writeUint64LE(value, out, offset2) {
    if (out === void 0) {
      out = new Uint8Array(8);
    }
    if (offset2 === void 0) {
      offset2 = 0;
    }
    writeUint32LE(value >>> 0, out, offset2);
    writeUint32LE(value / 4294967296 >>> 0, out, offset2 + 4);
    return out;
  }
  binary.writeUint64LE = writeUint64LE;
  binary.writeInt64LE = writeUint64LE;
  function readUintBE(bitLength, array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    if (bitLength % 8 !== 0) {
      throw new Error("readUintBE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset2) {
      throw new Error("readUintBE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for (var i4 = bitLength / 8 + offset2 - 1; i4 >= offset2; i4--) {
      result += array[i4] * mul;
      mul *= 256;
    }
    return result;
  }
  binary.readUintBE = readUintBE;
  function readUintLE(bitLength, array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    if (bitLength % 8 !== 0) {
      throw new Error("readUintLE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset2) {
      throw new Error("readUintLE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for (var i4 = offset2; i4 < offset2 + bitLength / 8; i4++) {
      result += array[i4] * mul;
      mul *= 256;
    }
    return result;
  }
  binary.readUintLE = readUintLE;
  function writeUintBE(bitLength, value, out, offset2) {
    if (out === void 0) {
      out = new Uint8Array(bitLength / 8);
    }
    if (offset2 === void 0) {
      offset2 = 0;
    }
    if (bitLength % 8 !== 0) {
      throw new Error("writeUintBE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
      throw new Error("writeUintBE value must be an integer");
    }
    var div = 1;
    for (var i4 = bitLength / 8 + offset2 - 1; i4 >= offset2; i4--) {
      out[i4] = value / div & 255;
      div *= 256;
    }
    return out;
  }
  binary.writeUintBE = writeUintBE;
  function writeUintLE(bitLength, value, out, offset2) {
    if (out === void 0) {
      out = new Uint8Array(bitLength / 8);
    }
    if (offset2 === void 0) {
      offset2 = 0;
    }
    if (bitLength % 8 !== 0) {
      throw new Error("writeUintLE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
      throw new Error("writeUintLE value must be an integer");
    }
    var div = 1;
    for (var i4 = offset2; i4 < offset2 + bitLength / 8; i4++) {
      out[i4] = value / div & 255;
      div *= 256;
    }
    return out;
  }
  binary.writeUintLE = writeUintLE;
  function readFloat32BE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset2);
  }
  binary.readFloat32BE = readFloat32BE;
  function readFloat32LE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset2, true);
  }
  binary.readFloat32LE = readFloat32LE;
  function readFloat64BE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset2);
  }
  binary.readFloat64BE = readFloat64BE;
  function readFloat64LE(array, offset2) {
    if (offset2 === void 0) {
      offset2 = 0;
    }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset2, true);
  }
  binary.readFloat64LE = readFloat64LE;
  function writeFloat32BE(value, out, offset2) {
    if (out === void 0) {
      out = new Uint8Array(4);
    }
    if (offset2 === void 0) {
      offset2 = 0;
    }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset2, value);
    return out;
  }
  binary.writeFloat32BE = writeFloat32BE;
  function writeFloat32LE(value, out, offset2) {
    if (out === void 0) {
      out = new Uint8Array(4);
    }
    if (offset2 === void 0) {
      offset2 = 0;
    }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset2, value, true);
    return out;
  }
  binary.writeFloat32LE = writeFloat32LE;
  function writeFloat64BE(value, out, offset2) {
    if (out === void 0) {
      out = new Uint8Array(8);
    }
    if (offset2 === void 0) {
      offset2 = 0;
    }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset2, value);
    return out;
  }
  binary.writeFloat64BE = writeFloat64BE;
  function writeFloat64LE(value, out, offset2) {
    if (out === void 0) {
      out = new Uint8Array(8);
    }
    if (offset2 === void 0) {
      offset2 = 0;
    }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset2, value, true);
    return out;
  }
  binary.writeFloat64LE = writeFloat64LE;
  return binary;
}
var wipe = {};
var hasRequiredWipe;
function requireWipe() {
  if (hasRequiredWipe) return wipe;
  hasRequiredWipe = 1;
  Object.defineProperty(wipe, "__esModule", { value: true });
  function wipe$1(array) {
    for (var i4 = 0; i4 < array.length; i4++) {
      array[i4] = 0;
    }
    return array;
  }
  wipe.wipe = wipe$1;
  return wipe;
}
var hasRequiredChacha;
function requireChacha() {
  if (hasRequiredChacha) return chacha;
  hasRequiredChacha = 1;
  Object.defineProperty(chacha, "__esModule", { value: true });
  var binary_1 = requireBinary();
  var wipe_1 = requireWipe();
  var ROUNDS = 20;
  function core(out, input, key2) {
    var j02 = 1634760805;
    var j1 = 857760878;
    var j2 = 2036477234;
    var j3 = 1797285236;
    var j4 = key2[3] << 24 | key2[2] << 16 | key2[1] << 8 | key2[0];
    var j5 = key2[7] << 24 | key2[6] << 16 | key2[5] << 8 | key2[4];
    var j6 = key2[11] << 24 | key2[10] << 16 | key2[9] << 8 | key2[8];
    var j7 = key2[15] << 24 | key2[14] << 16 | key2[13] << 8 | key2[12];
    var j8 = key2[19] << 24 | key2[18] << 16 | key2[17] << 8 | key2[16];
    var j9 = key2[23] << 24 | key2[22] << 16 | key2[21] << 8 | key2[20];
    var j10 = key2[27] << 24 | key2[26] << 16 | key2[25] << 8 | key2[24];
    var j11 = key2[31] << 24 | key2[30] << 16 | key2[29] << 8 | key2[28];
    var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
    var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
    var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
    var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
    var x02 = j02;
    var x1 = j1;
    var x2 = j2;
    var x3 = j3;
    var x4 = j4;
    var x5 = j5;
    var x6 = j6;
    var x7 = j7;
    var x8 = j8;
    var x9 = j9;
    var x10 = j10;
    var x11 = j11;
    var x12 = j12;
    var x13 = j13;
    var x14 = j14;
    var x15 = j15;
    for (var i4 = 0; i4 < ROUNDS; i4 += 2) {
      x02 = x02 + x4 | 0;
      x12 ^= x02;
      x12 = x12 >>> 32 - 16 | x12 << 16;
      x8 = x8 + x12 | 0;
      x4 ^= x8;
      x4 = x4 >>> 32 - 12 | x4 << 12;
      x1 = x1 + x5 | 0;
      x13 ^= x1;
      x13 = x13 >>> 32 - 16 | x13 << 16;
      x9 = x9 + x13 | 0;
      x5 ^= x9;
      x5 = x5 >>> 32 - 12 | x5 << 12;
      x2 = x2 + x6 | 0;
      x14 ^= x2;
      x14 = x14 >>> 32 - 16 | x14 << 16;
      x10 = x10 + x14 | 0;
      x6 ^= x10;
      x6 = x6 >>> 32 - 12 | x6 << 12;
      x3 = x3 + x7 | 0;
      x15 ^= x3;
      x15 = x15 >>> 32 - 16 | x15 << 16;
      x11 = x11 + x15 | 0;
      x7 ^= x11;
      x7 = x7 >>> 32 - 12 | x7 << 12;
      x2 = x2 + x6 | 0;
      x14 ^= x2;
      x14 = x14 >>> 32 - 8 | x14 << 8;
      x10 = x10 + x14 | 0;
      x6 ^= x10;
      x6 = x6 >>> 32 - 7 | x6 << 7;
      x3 = x3 + x7 | 0;
      x15 ^= x3;
      x15 = x15 >>> 32 - 8 | x15 << 8;
      x11 = x11 + x15 | 0;
      x7 ^= x11;
      x7 = x7 >>> 32 - 7 | x7 << 7;
      x1 = x1 + x5 | 0;
      x13 ^= x1;
      x13 = x13 >>> 32 - 8 | x13 << 8;
      x9 = x9 + x13 | 0;
      x5 ^= x9;
      x5 = x5 >>> 32 - 7 | x5 << 7;
      x02 = x02 + x4 | 0;
      x12 ^= x02;
      x12 = x12 >>> 32 - 8 | x12 << 8;
      x8 = x8 + x12 | 0;
      x4 ^= x8;
      x4 = x4 >>> 32 - 7 | x4 << 7;
      x02 = x02 + x5 | 0;
      x15 ^= x02;
      x15 = x15 >>> 32 - 16 | x15 << 16;
      x10 = x10 + x15 | 0;
      x5 ^= x10;
      x5 = x5 >>> 32 - 12 | x5 << 12;
      x1 = x1 + x6 | 0;
      x12 ^= x1;
      x12 = x12 >>> 32 - 16 | x12 << 16;
      x11 = x11 + x12 | 0;
      x6 ^= x11;
      x6 = x6 >>> 32 - 12 | x6 << 12;
      x2 = x2 + x7 | 0;
      x13 ^= x2;
      x13 = x13 >>> 32 - 16 | x13 << 16;
      x8 = x8 + x13 | 0;
      x7 ^= x8;
      x7 = x7 >>> 32 - 12 | x7 << 12;
      x3 = x3 + x4 | 0;
      x14 ^= x3;
      x14 = x14 >>> 32 - 16 | x14 << 16;
      x9 = x9 + x14 | 0;
      x4 ^= x9;
      x4 = x4 >>> 32 - 12 | x4 << 12;
      x2 = x2 + x7 | 0;
      x13 ^= x2;
      x13 = x13 >>> 32 - 8 | x13 << 8;
      x8 = x8 + x13 | 0;
      x7 ^= x8;
      x7 = x7 >>> 32 - 7 | x7 << 7;
      x3 = x3 + x4 | 0;
      x14 ^= x3;
      x14 = x14 >>> 32 - 8 | x14 << 8;
      x9 = x9 + x14 | 0;
      x4 ^= x9;
      x4 = x4 >>> 32 - 7 | x4 << 7;
      x1 = x1 + x6 | 0;
      x12 ^= x1;
      x12 = x12 >>> 32 - 8 | x12 << 8;
      x11 = x11 + x12 | 0;
      x6 ^= x11;
      x6 = x6 >>> 32 - 7 | x6 << 7;
      x02 = x02 + x5 | 0;
      x15 ^= x02;
      x15 = x15 >>> 32 - 8 | x15 << 8;
      x10 = x10 + x15 | 0;
      x5 ^= x10;
      x5 = x5 >>> 32 - 7 | x5 << 7;
    }
    binary_1.writeUint32LE(x02 + j02 | 0, out, 0);
    binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
    binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
    binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
    binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
    binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
    binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
    binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
    binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
    binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
    binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
    binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
    binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
    binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
    binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
    binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
  }
  function streamXOR(key2, nonce, src2, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) {
      nonceInplaceCounterLength = 0;
    }
    if (key2.length !== 32) {
      throw new Error("ChaCha: key size must be 32 bytes");
    }
    if (dst.length < src2.length) {
      throw new Error("ChaCha: destination is shorter than source");
    }
    var nc;
    var counterLength;
    if (nonceInplaceCounterLength === 0) {
      if (nonce.length !== 8 && nonce.length !== 12) {
        throw new Error("ChaCha nonce must be 8 or 12 bytes");
      }
      nc = new Uint8Array(16);
      counterLength = nc.length - nonce.length;
      nc.set(nonce, counterLength);
    } else {
      if (nonce.length !== 16) {
        throw new Error("ChaCha nonce with counter must be 16 bytes");
      }
      nc = nonce;
      counterLength = nonceInplaceCounterLength;
    }
    var block = new Uint8Array(64);
    for (var i4 = 0; i4 < src2.length; i4 += 64) {
      core(block, nc, key2);
      for (var j2 = i4; j2 < i4 + 64 && j2 < src2.length; j2++) {
        dst[j2] = src2[j2] ^ block[j2 - i4];
      }
      incrementCounter(nc, 0, counterLength);
    }
    wipe_1.wipe(block);
    if (nonceInplaceCounterLength === 0) {
      wipe_1.wipe(nc);
    }
    return dst;
  }
  chacha.streamXOR = streamXOR;
  function stream(key2, nonce, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) {
      nonceInplaceCounterLength = 0;
    }
    wipe_1.wipe(dst);
    return streamXOR(key2, nonce, dst, dst, nonceInplaceCounterLength);
  }
  chacha.stream = stream;
  function incrementCounter(counter, pos, len) {
    var carry = 1;
    while (len--) {
      carry = carry + (counter[pos] & 255) | 0;
      counter[pos] = carry & 255;
      carry >>>= 8;
      pos++;
    }
    if (carry > 0) {
      throw new Error("ChaCha: counter overflow");
    }
  }
  return chacha;
}
var poly1305 = {};
var constantTime = {};
var hasRequiredConstantTime;
function requireConstantTime() {
  if (hasRequiredConstantTime) return constantTime;
  hasRequiredConstantTime = 1;
  Object.defineProperty(constantTime, "__esModule", { value: true });
  function select(subject, resultIfOne, resultIfZero) {
    return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
  }
  constantTime.select = select;
  function lessOrEqual(a2, b2) {
    return (a2 | 0) - (b2 | 0) - 1 >>> 31 & 1;
  }
  constantTime.lessOrEqual = lessOrEqual;
  function compare2(a2, b2) {
    if (a2.length !== b2.length) {
      return 0;
    }
    var result = 0;
    for (var i4 = 0; i4 < a2.length; i4++) {
      result |= a2[i4] ^ b2[i4];
    }
    return 1 & result - 1 >>> 8;
  }
  constantTime.compare = compare2;
  function equal(a2, b2) {
    if (a2.length === 0 || b2.length === 0) {
      return false;
    }
    return compare2(a2, b2) !== 0;
  }
  constantTime.equal = equal;
  return constantTime;
}
var hasRequiredPoly1305;
function requirePoly1305() {
  if (hasRequiredPoly1305) return poly1305;
  hasRequiredPoly1305 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var constant_time_1 = requireConstantTime();
    var wipe_1 = requireWipe();
    exports.DIGEST_LENGTH = 16;
    var Poly1305 = (
      /** @class */
      (function() {
        function Poly13052(key2) {
          this.digestLength = exports.DIGEST_LENGTH;
          this._buffer = new Uint8Array(16);
          this._r = new Uint16Array(10);
          this._h = new Uint16Array(10);
          this._pad = new Uint16Array(8);
          this._leftover = 0;
          this._fin = 0;
          this._finished = false;
          var t02 = key2[0] | key2[1] << 8;
          this._r[0] = t02 & 8191;
          var t1 = key2[2] | key2[3] << 8;
          this._r[1] = (t02 >>> 13 | t1 << 3) & 8191;
          var t2 = key2[4] | key2[5] << 8;
          this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
          var t3 = key2[6] | key2[7] << 8;
          this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = key2[8] | key2[9] << 8;
          this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
          this._r[5] = t4 >>> 1 & 8190;
          var t5 = key2[10] | key2[11] << 8;
          this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = key2[12] | key2[13] << 8;
          this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
          var t7 = key2[14] | key2[15] << 8;
          this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
          this._r[9] = t7 >>> 5 & 127;
          this._pad[0] = key2[16] | key2[17] << 8;
          this._pad[1] = key2[18] | key2[19] << 8;
          this._pad[2] = key2[20] | key2[21] << 8;
          this._pad[3] = key2[22] | key2[23] << 8;
          this._pad[4] = key2[24] | key2[25] << 8;
          this._pad[5] = key2[26] | key2[27] << 8;
          this._pad[6] = key2[28] | key2[29] << 8;
          this._pad[7] = key2[30] | key2[31] << 8;
        }
        Poly13052.prototype._blocks = function(m3, mpos, bytes) {
          var hibit = this._fin ? 0 : 1 << 11;
          var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
          var r02 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
          while (bytes >= 16) {
            var t02 = m3[mpos + 0] | m3[mpos + 1] << 8;
            h0 += t02 & 8191;
            var t1 = m3[mpos + 2] | m3[mpos + 3] << 8;
            h1 += (t02 >>> 13 | t1 << 3) & 8191;
            var t2 = m3[mpos + 4] | m3[mpos + 5] << 8;
            h2 += (t1 >>> 10 | t2 << 6) & 8191;
            var t3 = m3[mpos + 6] | m3[mpos + 7] << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 8191;
            var t4 = m3[mpos + 8] | m3[mpos + 9] << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 8191;
            h5 += t4 >>> 1 & 8191;
            var t5 = m3[mpos + 10] | m3[mpos + 11] << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 8191;
            var t6 = m3[mpos + 12] | m3[mpos + 13] << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 8191;
            var t7 = m3[mpos + 14] | m3[mpos + 15] << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 8191;
            h9 += t7 >>> 5 | hibit;
            var c2 = 0;
            var d02 = c2;
            d02 += h0 * r02;
            d02 += h1 * (5 * r9);
            d02 += h2 * (5 * r8);
            d02 += h3 * (5 * r7);
            d02 += h4 * (5 * r6);
            c2 = d02 >>> 13;
            d02 &= 8191;
            d02 += h5 * (5 * r5);
            d02 += h6 * (5 * r4);
            d02 += h7 * (5 * r3);
            d02 += h8 * (5 * r2);
            d02 += h9 * (5 * r1);
            c2 += d02 >>> 13;
            d02 &= 8191;
            var d1 = c2;
            d1 += h0 * r1;
            d1 += h1 * r02;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c2 = d1 >>> 13;
            d1 &= 8191;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c2 += d1 >>> 13;
            d1 &= 8191;
            var d22 = c2;
            d22 += h0 * r2;
            d22 += h1 * r1;
            d22 += h2 * r02;
            d22 += h3 * (5 * r9);
            d22 += h4 * (5 * r8);
            c2 = d22 >>> 13;
            d22 &= 8191;
            d22 += h5 * (5 * r7);
            d22 += h6 * (5 * r6);
            d22 += h7 * (5 * r5);
            d22 += h8 * (5 * r4);
            d22 += h9 * (5 * r3);
            c2 += d22 >>> 13;
            d22 &= 8191;
            var d3 = c2;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r02;
            d3 += h4 * (5 * r9);
            c2 = d3 >>> 13;
            d3 &= 8191;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c2 += d3 >>> 13;
            d3 &= 8191;
            var d4 = c2;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r02;
            c2 = d4 >>> 13;
            d4 &= 8191;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c2 += d4 >>> 13;
            d4 &= 8191;
            var d5 = c2;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c2 = d5 >>> 13;
            d5 &= 8191;
            d5 += h5 * r02;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c2 += d5 >>> 13;
            d5 &= 8191;
            var d6 = c2;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c2 = d6 >>> 13;
            d6 &= 8191;
            d6 += h5 * r1;
            d6 += h6 * r02;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c2 += d6 >>> 13;
            d6 &= 8191;
            var d7 = c2;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c2 = d7 >>> 13;
            d7 &= 8191;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r02;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c2 += d7 >>> 13;
            d7 &= 8191;
            var d8 = c2;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c2 = d8 >>> 13;
            d8 &= 8191;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r02;
            d8 += h9 * (5 * r9);
            c2 += d8 >>> 13;
            d8 &= 8191;
            var d9 = c2;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c2 = d9 >>> 13;
            d9 &= 8191;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r02;
            c2 += d9 >>> 13;
            d9 &= 8191;
            c2 = (c2 << 2) + c2 | 0;
            c2 = c2 + d02 | 0;
            d02 = c2 & 8191;
            c2 = c2 >>> 13;
            d1 += c2;
            h0 = d02;
            h1 = d1;
            h2 = d22;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
          }
          this._h[0] = h0;
          this._h[1] = h1;
          this._h[2] = h2;
          this._h[3] = h3;
          this._h[4] = h4;
          this._h[5] = h5;
          this._h[6] = h6;
          this._h[7] = h7;
          this._h[8] = h8;
          this._h[9] = h9;
        };
        Poly13052.prototype.finish = function(mac, macpos) {
          if (macpos === void 0) {
            macpos = 0;
          }
          var g2 = new Uint16Array(10);
          var c2;
          var mask;
          var f2;
          var i4;
          if (this._leftover) {
            i4 = this._leftover;
            this._buffer[i4++] = 1;
            for (; i4 < 16; i4++) {
              this._buffer[i4] = 0;
            }
            this._fin = 1;
            this._blocks(this._buffer, 0, 16);
          }
          c2 = this._h[1] >>> 13;
          this._h[1] &= 8191;
          for (i4 = 2; i4 < 10; i4++) {
            this._h[i4] += c2;
            c2 = this._h[i4] >>> 13;
            this._h[i4] &= 8191;
          }
          this._h[0] += c2 * 5;
          c2 = this._h[0] >>> 13;
          this._h[0] &= 8191;
          this._h[1] += c2;
          c2 = this._h[1] >>> 13;
          this._h[1] &= 8191;
          this._h[2] += c2;
          g2[0] = this._h[0] + 5;
          c2 = g2[0] >>> 13;
          g2[0] &= 8191;
          for (i4 = 1; i4 < 10; i4++) {
            g2[i4] = this._h[i4] + c2;
            c2 = g2[i4] >>> 13;
            g2[i4] &= 8191;
          }
          g2[9] -= 1 << 13;
          mask = (c2 ^ 1) - 1;
          for (i4 = 0; i4 < 10; i4++) {
            g2[i4] &= mask;
          }
          mask = ~mask;
          for (i4 = 0; i4 < 10; i4++) {
            this._h[i4] = this._h[i4] & mask | g2[i4];
          }
          this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
          this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
          this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
          this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
          this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
          this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
          this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
          this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
          f2 = this._h[0] + this._pad[0];
          this._h[0] = f2 & 65535;
          for (i4 = 1; i4 < 8; i4++) {
            f2 = (this._h[i4] + this._pad[i4] | 0) + (f2 >>> 16) | 0;
            this._h[i4] = f2 & 65535;
          }
          mac[macpos + 0] = this._h[0] >>> 0;
          mac[macpos + 1] = this._h[0] >>> 8;
          mac[macpos + 2] = this._h[1] >>> 0;
          mac[macpos + 3] = this._h[1] >>> 8;
          mac[macpos + 4] = this._h[2] >>> 0;
          mac[macpos + 5] = this._h[2] >>> 8;
          mac[macpos + 6] = this._h[3] >>> 0;
          mac[macpos + 7] = this._h[3] >>> 8;
          mac[macpos + 8] = this._h[4] >>> 0;
          mac[macpos + 9] = this._h[4] >>> 8;
          mac[macpos + 10] = this._h[5] >>> 0;
          mac[macpos + 11] = this._h[5] >>> 8;
          mac[macpos + 12] = this._h[6] >>> 0;
          mac[macpos + 13] = this._h[6] >>> 8;
          mac[macpos + 14] = this._h[7] >>> 0;
          mac[macpos + 15] = this._h[7] >>> 8;
          this._finished = true;
          return this;
        };
        Poly13052.prototype.update = function(m3) {
          var mpos = 0;
          var bytes = m3.length;
          var want;
          if (this._leftover) {
            want = 16 - this._leftover;
            if (want > bytes) {
              want = bytes;
            }
            for (var i4 = 0; i4 < want; i4++) {
              this._buffer[this._leftover + i4] = m3[mpos + i4];
            }
            bytes -= want;
            mpos += want;
            this._leftover += want;
            if (this._leftover < 16) {
              return this;
            }
            this._blocks(this._buffer, 0, 16);
            this._leftover = 0;
          }
          if (bytes >= 16) {
            want = bytes - bytes % 16;
            this._blocks(m3, mpos, want);
            mpos += want;
            bytes -= want;
          }
          if (bytes) {
            for (var i4 = 0; i4 < bytes; i4++) {
              this._buffer[this._leftover + i4] = m3[mpos + i4];
            }
            this._leftover += bytes;
          }
          return this;
        };
        Poly13052.prototype.digest = function() {
          if (this._finished) {
            throw new Error("Poly1305 was finished");
          }
          var mac = new Uint8Array(16);
          this.finish(mac);
          return mac;
        };
        Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._r);
          wipe_1.wipe(this._h);
          wipe_1.wipe(this._pad);
          this._leftover = 0;
          this._fin = 0;
          this._finished = true;
          return this;
        };
        return Poly13052;
      })()
    );
    exports.Poly1305 = Poly1305;
    function oneTimeAuth(key2, data2) {
      var h2 = new Poly1305(key2);
      h2.update(data2);
      var digest = h2.digest();
      h2.clean();
      return digest;
    }
    exports.oneTimeAuth = oneTimeAuth;
    function equal(a2, b2) {
      if (a2.length !== exports.DIGEST_LENGTH || b2.length !== exports.DIGEST_LENGTH) {
        return false;
      }
      return constant_time_1.equal(a2, b2);
    }
    exports.equal = equal;
  })(poly1305);
  return poly1305;
}
var hasRequiredChacha20poly1305;
function requireChacha20poly1305() {
  if (hasRequiredChacha20poly1305) return chacha20poly1305;
  hasRequiredChacha20poly1305 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var chacha_1 = requireChacha();
    var poly1305_1 = requirePoly1305();
    var wipe_1 = requireWipe();
    var binary_1 = requireBinary();
    var constant_time_1 = requireConstantTime();
    exports.KEY_LENGTH = 32;
    exports.NONCE_LENGTH = 12;
    exports.TAG_LENGTH = 16;
    var ZEROS = new Uint8Array(16);
    var ChaCha20Poly1305 = (
      /** @class */
      (function() {
        function ChaCha20Poly13052(key2) {
          this.nonceLength = exports.NONCE_LENGTH;
          this.tagLength = exports.TAG_LENGTH;
          if (key2.length !== exports.KEY_LENGTH) {
            throw new Error("ChaCha20Poly1305 needs 32-byte key");
          }
          this._key = new Uint8Array(key2);
        }
        ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var resultLength = plaintext.length + this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
          this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          if (sealed.length < this.tagLength) {
            return null;
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var calculatedTag = new Uint8Array(this.tagLength);
          this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
          if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
            return null;
          }
          var resultLength = sealed.length - this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._key);
          return this;
        };
        ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
          var h2 = new poly1305_1.Poly1305(authKey);
          if (associatedData) {
            h2.update(associatedData);
            if (associatedData.length % 16 > 0) {
              h2.update(ZEROS.subarray(associatedData.length % 16));
            }
          }
          h2.update(ciphertext);
          if (ciphertext.length % 16 > 0) {
            h2.update(ZEROS.subarray(ciphertext.length % 16));
          }
          var length2 = new Uint8Array(8);
          if (associatedData) {
            binary_1.writeUint64LE(associatedData.length, length2);
          }
          h2.update(length2);
          binary_1.writeUint64LE(ciphertext.length, length2);
          h2.update(length2);
          var tag = h2.digest();
          for (var i4 = 0; i4 < tag.length; i4++) {
            tagOut[i4] = tag[i4];
          }
          h2.clean();
          wipe_1.wipe(tag);
          wipe_1.wipe(length2);
        };
        return ChaCha20Poly13052;
      })()
    );
    exports.ChaCha20Poly1305 = ChaCha20Poly1305;
  })(chacha20poly1305);
  return chacha20poly1305;
}
requireChacha20poly1305();
var hkdf = {};
var hmac$1 = {};
var hash$1 = {};
var hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1) return hash$1;
  hasRequiredHash$1 = 1;
  Object.defineProperty(hash$1, "__esModule", { value: true });
  function isSerializableHash(h2) {
    return typeof h2.saveState !== "undefined" && typeof h2.restoreState !== "undefined" && typeof h2.cleanSavedState !== "undefined";
  }
  hash$1.isSerializableHash = isSerializableHash;
  return hash$1;
}
var hasRequiredHmac$1;
function requireHmac$1() {
  if (hasRequiredHmac$1) return hmac$1;
  hasRequiredHmac$1 = 1;
  Object.defineProperty(hmac$1, "__esModule", { value: true });
  var hash_1 = requireHash$1();
  var constant_time_1 = requireConstantTime();
  var wipe_1 = requireWipe();
  var HMAC = (
    /** @class */
    (function() {
      function HMAC2(hash2, key2) {
        this._finished = false;
        this._inner = new hash2();
        this._outer = new hash2();
        this.blockSize = this._outer.blockSize;
        this.digestLength = this._outer.digestLength;
        var pad2 = new Uint8Array(this.blockSize);
        if (key2.length > this.blockSize) {
          this._inner.update(key2).finish(pad2).clean();
        } else {
          pad2.set(key2);
        }
        for (var i4 = 0; i4 < pad2.length; i4++) {
          pad2[i4] ^= 54;
        }
        this._inner.update(pad2);
        for (var i4 = 0; i4 < pad2.length; i4++) {
          pad2[i4] ^= 54 ^ 92;
        }
        this._outer.update(pad2);
        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
          this._innerKeyedState = this._inner.saveState();
          this._outerKeyedState = this._outer.saveState();
        }
        wipe_1.wipe(pad2);
      }
      HMAC2.prototype.reset = function() {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
          throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
        }
        this._inner.restoreState(this._innerKeyedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
      };
      HMAC2.prototype.clean = function() {
        if (hash_1.isSerializableHash(this._inner)) {
          this._inner.cleanSavedState(this._innerKeyedState);
        }
        if (hash_1.isSerializableHash(this._outer)) {
          this._outer.cleanSavedState(this._outerKeyedState);
        }
        this._inner.clean();
        this._outer.clean();
      };
      HMAC2.prototype.update = function(data2) {
        this._inner.update(data2);
        return this;
      };
      HMAC2.prototype.finish = function(out) {
        if (this._finished) {
          this._outer.finish(out);
          return this;
        }
        this._inner.finish(out);
        this._outer.update(out.subarray(0, this.digestLength)).finish(out);
        this._finished = true;
        return this;
      };
      HMAC2.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      HMAC2.prototype.saveState = function() {
        if (!hash_1.isSerializableHash(this._inner)) {
          throw new Error("hmac: can't saveState() because hash doesn't implement it");
        }
        return this._inner.saveState();
      };
      HMAC2.prototype.restoreState = function(savedState) {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
          throw new Error("hmac: can't restoreState() because hash doesn't implement it");
        }
        this._inner.restoreState(savedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
      };
      HMAC2.prototype.cleanSavedState = function(savedState) {
        if (!hash_1.isSerializableHash(this._inner)) {
          throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
        }
        this._inner.cleanSavedState(savedState);
      };
      return HMAC2;
    })()
  );
  hmac$1.HMAC = HMAC;
  function hmac2(hash2, key2, data2) {
    var h2 = new HMAC(hash2, key2);
    h2.update(data2);
    var digest = h2.digest();
    h2.clean();
    return digest;
  }
  hmac$1.hmac = hmac2;
  hmac$1.equal = constant_time_1.equal;
  return hmac$1;
}
var hasRequiredHkdf;
function requireHkdf() {
  if (hasRequiredHkdf) return hkdf;
  hasRequiredHkdf = 1;
  Object.defineProperty(hkdf, "__esModule", { value: true });
  var hmac_1 = requireHmac$1();
  var wipe_1 = requireWipe();
  var HKDF = (
    /** @class */
    (function() {
      function HKDF2(hash2, key2, salt, info) {
        if (salt === void 0) {
          salt = new Uint8Array(0);
        }
        this._counter = new Uint8Array(1);
        this._hash = hash2;
        this._info = info;
        var okm = hmac_1.hmac(this._hash, salt, key2);
        this._hmac = new hmac_1.HMAC(hash2, okm);
        this._buffer = new Uint8Array(this._hmac.digestLength);
        this._bufpos = this._buffer.length;
      }
      HKDF2.prototype._fillBuffer = function() {
        this._counter[0]++;
        var ctr = this._counter[0];
        if (ctr === 0) {
          throw new Error("hkdf: cannot expand more");
        }
        this._hmac.reset();
        if (ctr > 1) {
          this._hmac.update(this._buffer);
        }
        if (this._info) {
          this._hmac.update(this._info);
        }
        this._hmac.update(this._counter);
        this._hmac.finish(this._buffer);
        this._bufpos = 0;
      };
      HKDF2.prototype.expand = function(length2) {
        var out = new Uint8Array(length2);
        for (var i4 = 0; i4 < out.length; i4++) {
          if (this._bufpos === this._buffer.length) {
            this._fillBuffer();
          }
          out[i4] = this._buffer[this._bufpos++];
        }
        return out;
      };
      HKDF2.prototype.clean = function() {
        this._hmac.clean();
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._counter);
        this._bufpos = 0;
      };
      return HKDF2;
    })()
  );
  hkdf.HKDF = HKDF;
  return hkdf;
}
requireHkdf();
var random = {};
var system = {};
var browser = {};
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  Object.defineProperty(browser, "__esModule", { value: true });
  browser.BrowserRandomSource = void 0;
  const QUOTA = 65536;
  class BrowserRandomSource {
    constructor() {
      this.isAvailable = false;
      this.isInstantiated = false;
      const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
        this._crypto = browserCrypto;
        this.isAvailable = true;
        this.isInstantiated = true;
      }
    }
    randomBytes(length2) {
      if (!this.isAvailable || !this._crypto) {
        throw new Error("Browser random byte generator is not available.");
      }
      const out = new Uint8Array(length2);
      for (let i4 = 0; i4 < out.length; i4 += QUOTA) {
        this._crypto.getRandomValues(out.subarray(i4, i4 + Math.min(out.length - i4, QUOTA)));
      }
      return out;
    }
  }
  browser.BrowserRandomSource = BrowserRandomSource;
  return browser;
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var node = {};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  Object.defineProperty(node, "__esModule", { value: true });
  node.NodeRandomSource = void 0;
  const wipe_1 = requireWipe();
  class NodeRandomSource {
    constructor() {
      this.isAvailable = false;
      this.isInstantiated = false;
      if (typeof commonjsRequire !== "undefined") {
        const nodeCrypto = require$$3;
        if (nodeCrypto && nodeCrypto.randomBytes) {
          this._crypto = nodeCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
    }
    randomBytes(length2) {
      if (!this.isAvailable || !this._crypto) {
        throw new Error("Node.js random byte generator is not available.");
      }
      let buffer2 = this._crypto.randomBytes(length2);
      if (buffer2.length !== length2) {
        throw new Error("NodeRandomSource: got fewer bytes than requested");
      }
      const out = new Uint8Array(length2);
      for (let i4 = 0; i4 < out.length; i4++) {
        out[i4] = buffer2[i4];
      }
      (0, wipe_1.wipe)(buffer2);
      return out;
    }
  }
  node.NodeRandomSource = NodeRandomSource;
  return node;
}
var hasRequiredSystem;
function requireSystem() {
  if (hasRequiredSystem) return system;
  hasRequiredSystem = 1;
  Object.defineProperty(system, "__esModule", { value: true });
  system.SystemRandomSource = void 0;
  const browser_1 = requireBrowser();
  const node_1 = requireNode();
  class SystemRandomSource {
    constructor() {
      this.isAvailable = false;
      this.name = "";
      this._source = new browser_1.BrowserRandomSource();
      if (this._source.isAvailable) {
        this.isAvailable = true;
        this.name = "Browser";
        return;
      }
      this._source = new node_1.NodeRandomSource();
      if (this._source.isAvailable) {
        this.isAvailable = true;
        this.name = "Node";
        return;
      }
    }
    randomBytes(length2) {
      if (!this.isAvailable) {
        throw new Error("System random byte generator is not available.");
      }
      return this._source.randomBytes(length2);
    }
  }
  system.SystemRandomSource = SystemRandomSource;
  return system;
}
var hasRequiredRandom;
function requireRandom() {
  if (hasRequiredRandom) return random;
  hasRequiredRandom = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
    const system_1 = requireSystem();
    const binary_1 = requireBinary();
    const wipe_1 = requireWipe();
    exports.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes2(length2, prng = exports.defaultRandomSource) {
      return prng.randomBytes(length2);
    }
    exports.randomBytes = randomBytes2;
    function randomUint32(prng = exports.defaultRandomSource) {
      const buf = randomBytes2(4, prng);
      const result = (0, binary_1.readUint32LE)(buf);
      (0, wipe_1.wipe)(buf);
      return result;
    }
    exports.randomUint32 = randomUint32;
    const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(length2, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      let out = "";
      const charsLen = charset.length;
      const maxByte = 256 - 256 % charsLen;
      while (length2 > 0) {
        const buf = randomBytes2(Math.ceil(length2 * 256 / maxByte), prng);
        for (let i4 = 0; i4 < buf.length && length2 > 0; i4++) {
          const randomByte = buf[i4];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length2--;
          }
        }
        (0, wipe_1.wipe)(buf);
      }
      return out;
    }
    exports.randomString = randomString;
    function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString(length2, charset, prng);
    }
    exports.randomStringForEntropy = randomStringForEntropy;
  })(random);
  return random;
}
requireRandom();
var sha256 = {};
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256;
  hasRequiredSha256 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = requireBinary();
    var wipe_1 = requireWipe();
    exports.DIGEST_LENGTH = 32;
    exports.BLOCK_SIZE = 64;
    var SHA2562 = (
      /** @class */
      (function() {
        function SHA2563() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._state = new Int32Array(8);
          this._temp = new Int32Array(64);
          this._buffer = new Uint8Array(128);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA2563.prototype._initState = function() {
          this._state[0] = 1779033703;
          this._state[1] = 3144134277;
          this._state[2] = 1013904242;
          this._state[3] = 2773480762;
          this._state[4] = 1359893119;
          this._state[5] = 2600822924;
          this._state[6] = 528734635;
          this._state[7] = 1541459225;
        };
        SHA2563.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA2563.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._temp);
          this.reset();
        };
        SHA2563.prototype.update = function(data2, dataLength) {
          if (dataLength === void 0) {
            dataLength = data2.length;
          }
          if (this._finished) {
            throw new Error("SHA256: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < this.blockSize && dataLength > 0) {
              this._buffer[this._bufferLength++] = data2[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._temp, this._state, data2, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data2[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA2563.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left2 = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 64 < 56 ? 64 : 128;
            this._buffer[left2] = 128;
            for (var i4 = left2 + 1; i4 < padLength - 8; i4++) {
              this._buffer[i4] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i4 = 0; i4 < this.digestLength / 4; i4++) {
            binary_1.writeUint32BE(this._state[i4], out, i4 * 4);
          }
          return this;
        };
        SHA2563.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA2563.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            state: new Int32Array(this._state),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA2563.prototype.restoreState = function(savedState) {
          this._state.set(savedState.state);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA2563.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.state);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA2563;
      })()
    );
    exports.SHA256 = SHA2562;
    var K2 = new Int32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w2, v2, p2, pos, len) {
      while (len >= 64) {
        var a2 = v2[0];
        var b2 = v2[1];
        var c2 = v2[2];
        var d3 = v2[3];
        var e2 = v2[4];
        var f2 = v2[5];
        var g2 = v2[6];
        var h2 = v2[7];
        for (var i4 = 0; i4 < 16; i4++) {
          var j2 = pos + i4 * 4;
          w2[i4] = binary_1.readUint32BE(p2, j2);
        }
        for (var i4 = 16; i4 < 64; i4++) {
          var u2 = w2[i4 - 2];
          var t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
          u2 = w2[i4 - 15];
          var t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
          w2[i4] = (t1 + w2[i4 - 7] | 0) + (t2 + w2[i4 - 16] | 0);
        }
        for (var i4 = 0; i4 < 64; i4++) {
          var t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f2 ^ ~e2 & g2) | 0) + (h2 + (K2[i4] + w2[i4] | 0) | 0) | 0;
          var t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b2 ^ a2 & c2 ^ b2 & c2) | 0;
          h2 = g2;
          g2 = f2;
          f2 = e2;
          e2 = d3 + t1 | 0;
          d3 = c2;
          c2 = b2;
          b2 = a2;
          a2 = t1 + t2 | 0;
        }
        v2[0] += a2;
        v2[1] += b2;
        v2[2] += c2;
        v2[3] += d3;
        v2[4] += e2;
        v2[5] += f2;
        v2[6] += g2;
        v2[7] += h2;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    function hash2(data2) {
      var h2 = new SHA2562();
      h2.update(data2);
      var digest = h2.digest();
      h2.clean();
      return digest;
    }
    exports.hash = hash2;
  })(sha256);
  return sha256;
}
requireSha256();
var x25519 = {};
var hasRequiredX25519;
function requireX25519() {
  if (hasRequiredX25519) return x25519;
  hasRequiredX25519 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
    const random_1 = requireRandom();
    const wipe_1 = requireWipe();
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 32;
    exports.SHARED_KEY_LENGTH = 32;
    function gf2(init2) {
      const r2 = new Float64Array(16);
      if (init2) {
        for (let i4 = 0; i4 < init2.length; i4++) {
          r2[i4] = init2[i4];
        }
      }
      return r2;
    }
    const _9 = new Uint8Array(32);
    _9[0] = 9;
    const _121665 = gf2([56129, 1]);
    function car25519(o2) {
      let c2 = 1;
      for (let i4 = 0; i4 < 16; i4++) {
        let v2 = o2[i4] + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        o2[i4] = v2 - c2 * 65536;
      }
      o2[0] += c2 - 1 + 37 * (c2 - 1);
    }
    function sel25519(p2, q, b2) {
      const c2 = ~(b2 - 1);
      for (let i4 = 0; i4 < 16; i4++) {
        const t2 = c2 & (p2[i4] ^ q[i4]);
        p2[i4] ^= t2;
        q[i4] ^= t2;
      }
    }
    function pack25519(o2, n3) {
      const m3 = gf2();
      const t2 = gf2();
      for (let i4 = 0; i4 < 16; i4++) {
        t2[i4] = n3[i4];
      }
      car25519(t2);
      car25519(t2);
      car25519(t2);
      for (let j2 = 0; j2 < 2; j2++) {
        m3[0] = t2[0] - 65517;
        for (let i4 = 1; i4 < 15; i4++) {
          m3[i4] = t2[i4] - 65535 - (m3[i4 - 1] >> 16 & 1);
          m3[i4 - 1] &= 65535;
        }
        m3[15] = t2[15] - 32767 - (m3[14] >> 16 & 1);
        const b2 = m3[15] >> 16 & 1;
        m3[14] &= 65535;
        sel25519(t2, m3, 1 - b2);
      }
      for (let i4 = 0; i4 < 16; i4++) {
        o2[2 * i4] = t2[i4] & 255;
        o2[2 * i4 + 1] = t2[i4] >> 8;
      }
    }
    function unpack25519(o2, n3) {
      for (let i4 = 0; i4 < 16; i4++) {
        o2[i4] = n3[2 * i4] + (n3[2 * i4 + 1] << 8);
      }
      o2[15] &= 32767;
    }
    function add2(o2, a2, b2) {
      for (let i4 = 0; i4 < 16; i4++) {
        o2[i4] = a2[i4] + b2[i4];
      }
    }
    function sub(o2, a2, b2) {
      for (let i4 = 0; i4 < 16; i4++) {
        o2[i4] = a2[i4] - b2[i4];
      }
    }
    function mul(o2, a2, b2) {
      let v2, c2, t02 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b02 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v2 = a2[0];
      t02 += v2 * b02;
      t1 += v2 * b1;
      t2 += v2 * b22;
      t3 += v2 * b3;
      t4 += v2 * b4;
      t5 += v2 * b5;
      t6 += v2 * b6;
      t7 += v2 * b7;
      t8 += v2 * b8;
      t9 += v2 * b9;
      t10 += v2 * b10;
      t11 += v2 * b11;
      t12 += v2 * b12;
      t13 += v2 * b13;
      t14 += v2 * b14;
      t15 += v2 * b15;
      v2 = a2[1];
      t1 += v2 * b02;
      t2 += v2 * b1;
      t3 += v2 * b22;
      t4 += v2 * b3;
      t5 += v2 * b4;
      t6 += v2 * b5;
      t7 += v2 * b6;
      t8 += v2 * b7;
      t9 += v2 * b8;
      t10 += v2 * b9;
      t11 += v2 * b10;
      t12 += v2 * b11;
      t13 += v2 * b12;
      t14 += v2 * b13;
      t15 += v2 * b14;
      t16 += v2 * b15;
      v2 = a2[2];
      t2 += v2 * b02;
      t3 += v2 * b1;
      t4 += v2 * b22;
      t5 += v2 * b3;
      t6 += v2 * b4;
      t7 += v2 * b5;
      t8 += v2 * b6;
      t9 += v2 * b7;
      t10 += v2 * b8;
      t11 += v2 * b9;
      t12 += v2 * b10;
      t13 += v2 * b11;
      t14 += v2 * b12;
      t15 += v2 * b13;
      t16 += v2 * b14;
      t17 += v2 * b15;
      v2 = a2[3];
      t3 += v2 * b02;
      t4 += v2 * b1;
      t5 += v2 * b22;
      t6 += v2 * b3;
      t7 += v2 * b4;
      t8 += v2 * b5;
      t9 += v2 * b6;
      t10 += v2 * b7;
      t11 += v2 * b8;
      t12 += v2 * b9;
      t13 += v2 * b10;
      t14 += v2 * b11;
      t15 += v2 * b12;
      t16 += v2 * b13;
      t17 += v2 * b14;
      t18 += v2 * b15;
      v2 = a2[4];
      t4 += v2 * b02;
      t5 += v2 * b1;
      t6 += v2 * b22;
      t7 += v2 * b3;
      t8 += v2 * b4;
      t9 += v2 * b5;
      t10 += v2 * b6;
      t11 += v2 * b7;
      t12 += v2 * b8;
      t13 += v2 * b9;
      t14 += v2 * b10;
      t15 += v2 * b11;
      t16 += v2 * b12;
      t17 += v2 * b13;
      t18 += v2 * b14;
      t19 += v2 * b15;
      v2 = a2[5];
      t5 += v2 * b02;
      t6 += v2 * b1;
      t7 += v2 * b22;
      t8 += v2 * b3;
      t9 += v2 * b4;
      t10 += v2 * b5;
      t11 += v2 * b6;
      t12 += v2 * b7;
      t13 += v2 * b8;
      t14 += v2 * b9;
      t15 += v2 * b10;
      t16 += v2 * b11;
      t17 += v2 * b12;
      t18 += v2 * b13;
      t19 += v2 * b14;
      t20 += v2 * b15;
      v2 = a2[6];
      t6 += v2 * b02;
      t7 += v2 * b1;
      t8 += v2 * b22;
      t9 += v2 * b3;
      t10 += v2 * b4;
      t11 += v2 * b5;
      t12 += v2 * b6;
      t13 += v2 * b7;
      t14 += v2 * b8;
      t15 += v2 * b9;
      t16 += v2 * b10;
      t17 += v2 * b11;
      t18 += v2 * b12;
      t19 += v2 * b13;
      t20 += v2 * b14;
      t21 += v2 * b15;
      v2 = a2[7];
      t7 += v2 * b02;
      t8 += v2 * b1;
      t9 += v2 * b22;
      t10 += v2 * b3;
      t11 += v2 * b4;
      t12 += v2 * b5;
      t13 += v2 * b6;
      t14 += v2 * b7;
      t15 += v2 * b8;
      t16 += v2 * b9;
      t17 += v2 * b10;
      t18 += v2 * b11;
      t19 += v2 * b12;
      t20 += v2 * b13;
      t21 += v2 * b14;
      t22 += v2 * b15;
      v2 = a2[8];
      t8 += v2 * b02;
      t9 += v2 * b1;
      t10 += v2 * b22;
      t11 += v2 * b3;
      t12 += v2 * b4;
      t13 += v2 * b5;
      t14 += v2 * b6;
      t15 += v2 * b7;
      t16 += v2 * b8;
      t17 += v2 * b9;
      t18 += v2 * b10;
      t19 += v2 * b11;
      t20 += v2 * b12;
      t21 += v2 * b13;
      t22 += v2 * b14;
      t23 += v2 * b15;
      v2 = a2[9];
      t9 += v2 * b02;
      t10 += v2 * b1;
      t11 += v2 * b22;
      t12 += v2 * b3;
      t13 += v2 * b4;
      t14 += v2 * b5;
      t15 += v2 * b6;
      t16 += v2 * b7;
      t17 += v2 * b8;
      t18 += v2 * b9;
      t19 += v2 * b10;
      t20 += v2 * b11;
      t21 += v2 * b12;
      t22 += v2 * b13;
      t23 += v2 * b14;
      t24 += v2 * b15;
      v2 = a2[10];
      t10 += v2 * b02;
      t11 += v2 * b1;
      t12 += v2 * b22;
      t13 += v2 * b3;
      t14 += v2 * b4;
      t15 += v2 * b5;
      t16 += v2 * b6;
      t17 += v2 * b7;
      t18 += v2 * b8;
      t19 += v2 * b9;
      t20 += v2 * b10;
      t21 += v2 * b11;
      t22 += v2 * b12;
      t23 += v2 * b13;
      t24 += v2 * b14;
      t25 += v2 * b15;
      v2 = a2[11];
      t11 += v2 * b02;
      t12 += v2 * b1;
      t13 += v2 * b22;
      t14 += v2 * b3;
      t15 += v2 * b4;
      t16 += v2 * b5;
      t17 += v2 * b6;
      t18 += v2 * b7;
      t19 += v2 * b8;
      t20 += v2 * b9;
      t21 += v2 * b10;
      t22 += v2 * b11;
      t23 += v2 * b12;
      t24 += v2 * b13;
      t25 += v2 * b14;
      t26 += v2 * b15;
      v2 = a2[12];
      t12 += v2 * b02;
      t13 += v2 * b1;
      t14 += v2 * b22;
      t15 += v2 * b3;
      t16 += v2 * b4;
      t17 += v2 * b5;
      t18 += v2 * b6;
      t19 += v2 * b7;
      t20 += v2 * b8;
      t21 += v2 * b9;
      t22 += v2 * b10;
      t23 += v2 * b11;
      t24 += v2 * b12;
      t25 += v2 * b13;
      t26 += v2 * b14;
      t27 += v2 * b15;
      v2 = a2[13];
      t13 += v2 * b02;
      t14 += v2 * b1;
      t15 += v2 * b22;
      t16 += v2 * b3;
      t17 += v2 * b4;
      t18 += v2 * b5;
      t19 += v2 * b6;
      t20 += v2 * b7;
      t21 += v2 * b8;
      t22 += v2 * b9;
      t23 += v2 * b10;
      t24 += v2 * b11;
      t25 += v2 * b12;
      t26 += v2 * b13;
      t27 += v2 * b14;
      t28 += v2 * b15;
      v2 = a2[14];
      t14 += v2 * b02;
      t15 += v2 * b1;
      t16 += v2 * b22;
      t17 += v2 * b3;
      t18 += v2 * b4;
      t19 += v2 * b5;
      t20 += v2 * b6;
      t21 += v2 * b7;
      t22 += v2 * b8;
      t23 += v2 * b9;
      t24 += v2 * b10;
      t25 += v2 * b11;
      t26 += v2 * b12;
      t27 += v2 * b13;
      t28 += v2 * b14;
      t29 += v2 * b15;
      v2 = a2[15];
      t15 += v2 * b02;
      t16 += v2 * b1;
      t17 += v2 * b22;
      t18 += v2 * b3;
      t19 += v2 * b4;
      t20 += v2 * b5;
      t21 += v2 * b6;
      t22 += v2 * b7;
      t23 += v2 * b8;
      t24 += v2 * b9;
      t25 += v2 * b10;
      t26 += v2 * b11;
      t27 += v2 * b12;
      t28 += v2 * b13;
      t29 += v2 * b14;
      t30 += v2 * b15;
      t02 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v2 = t02 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t02 = v2 - c2 * 65536;
      v2 = t1 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t1 = v2 - c2 * 65536;
      v2 = t2 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t2 = v2 - c2 * 65536;
      v2 = t3 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t3 = v2 - c2 * 65536;
      v2 = t4 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t4 = v2 - c2 * 65536;
      v2 = t5 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t5 = v2 - c2 * 65536;
      v2 = t6 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t6 = v2 - c2 * 65536;
      v2 = t7 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t7 = v2 - c2 * 65536;
      v2 = t8 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t8 = v2 - c2 * 65536;
      v2 = t9 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t9 = v2 - c2 * 65536;
      v2 = t10 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t10 = v2 - c2 * 65536;
      v2 = t11 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t11 = v2 - c2 * 65536;
      v2 = t12 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t12 = v2 - c2 * 65536;
      v2 = t13 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t13 = v2 - c2 * 65536;
      v2 = t14 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t14 = v2 - c2 * 65536;
      v2 = t15 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t15 = v2 - c2 * 65536;
      t02 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v2 = t02 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t02 = v2 - c2 * 65536;
      v2 = t1 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t1 = v2 - c2 * 65536;
      v2 = t2 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t2 = v2 - c2 * 65536;
      v2 = t3 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t3 = v2 - c2 * 65536;
      v2 = t4 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t4 = v2 - c2 * 65536;
      v2 = t5 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t5 = v2 - c2 * 65536;
      v2 = t6 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t6 = v2 - c2 * 65536;
      v2 = t7 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t7 = v2 - c2 * 65536;
      v2 = t8 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t8 = v2 - c2 * 65536;
      v2 = t9 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t9 = v2 - c2 * 65536;
      v2 = t10 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t10 = v2 - c2 * 65536;
      v2 = t11 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t11 = v2 - c2 * 65536;
      v2 = t12 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t12 = v2 - c2 * 65536;
      v2 = t13 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t13 = v2 - c2 * 65536;
      v2 = t14 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t14 = v2 - c2 * 65536;
      v2 = t15 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t15 = v2 - c2 * 65536;
      t02 += c2 - 1 + 37 * (c2 - 1);
      o2[0] = t02;
      o2[1] = t1;
      o2[2] = t2;
      o2[3] = t3;
      o2[4] = t4;
      o2[5] = t5;
      o2[6] = t6;
      o2[7] = t7;
      o2[8] = t8;
      o2[9] = t9;
      o2[10] = t10;
      o2[11] = t11;
      o2[12] = t12;
      o2[13] = t13;
      o2[14] = t14;
      o2[15] = t15;
    }
    function square(o2, a2) {
      mul(o2, a2, a2);
    }
    function inv25519(o2, inp) {
      const c2 = gf2();
      for (let i4 = 0; i4 < 16; i4++) {
        c2[i4] = inp[i4];
      }
      for (let i4 = 253; i4 >= 0; i4--) {
        square(c2, c2);
        if (i4 !== 2 && i4 !== 4) {
          mul(c2, c2, inp);
        }
      }
      for (let i4 = 0; i4 < 16; i4++) {
        o2[i4] = c2[i4];
      }
    }
    function scalarMult(n3, p2) {
      const z3 = new Uint8Array(32);
      const x2 = new Float64Array(80);
      const a2 = gf2(), b2 = gf2(), c2 = gf2(), d3 = gf2(), e2 = gf2(), f2 = gf2();
      for (let i4 = 0; i4 < 31; i4++) {
        z3[i4] = n3[i4];
      }
      z3[31] = n3[31] & 127 | 64;
      z3[0] &= 248;
      unpack25519(x2, p2);
      for (let i4 = 0; i4 < 16; i4++) {
        b2[i4] = x2[i4];
      }
      a2[0] = d3[0] = 1;
      for (let i4 = 254; i4 >= 0; --i4) {
        const r2 = z3[i4 >>> 3] >>> (i4 & 7) & 1;
        sel25519(a2, b2, r2);
        sel25519(c2, d3, r2);
        add2(e2, a2, c2);
        sub(a2, a2, c2);
        add2(c2, b2, d3);
        sub(b2, b2, d3);
        square(d3, e2);
        square(f2, a2);
        mul(a2, c2, a2);
        mul(c2, b2, e2);
        add2(e2, a2, c2);
        sub(a2, a2, c2);
        square(b2, a2);
        sub(c2, d3, f2);
        mul(a2, c2, _121665);
        add2(a2, a2, d3);
        mul(c2, c2, a2);
        mul(a2, d3, f2);
        mul(d3, b2, x2);
        square(b2, e2);
        sel25519(a2, b2, r2);
        sel25519(c2, d3, r2);
      }
      for (let i4 = 0; i4 < 16; i4++) {
        x2[i4 + 16] = a2[i4];
        x2[i4 + 32] = c2[i4];
        x2[i4 + 48] = b2[i4];
        x2[i4 + 64] = d3[i4];
      }
      const x32 = x2.subarray(32);
      const x16 = x2.subarray(16);
      inv25519(x32, x32);
      mul(x16, x16, x32);
      const q = new Uint8Array(32);
      pack25519(q, x16);
      return q;
    }
    exports.scalarMult = scalarMult;
    function scalarMultBase(n3) {
      return scalarMult(n3, _9);
    }
    exports.scalarMultBase = scalarMultBase;
    function generateKeyPairFromSeed(seed) {
      if (seed.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      const secretKey = new Uint8Array(seed);
      const publicKey = scalarMultBase(secretKey);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
    function generateKeyPair(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports.generateKeyPair = generateKeyPair;
    function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
      if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
      }
      if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
      }
      const result = scalarMult(mySecretKey, theirPublicKey);
      if (rejectZero) {
        let zeros = 0;
        for (let i4 = 0; i4 < result.length; i4++) {
          zeros |= result[i4];
        }
        if (zeros === 0) {
          throw new Error("X25519: invalid shared key");
        }
      }
      return result;
    }
    exports.sharedKey = sharedKey;
  })(x25519);
  return x25519;
}
requireX25519();
function base$1(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i4 = 0; i4 < ALPHABET.length; i4++) {
    var x2 = ALPHABET.charAt(i4);
    var xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i4;
  }
  var BASE2 = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE2) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode2(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i5 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i5 < length2) && it1 !== -1; it1--, i5++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i5;
      pbegin++;
    }
    var it2 = size2 - length2;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i5 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i5 < length2) && it3 !== -1; it3--, i5++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i5;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length2;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j3 = zeroes;
    while (it4 !== size2) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string) {
    var buffer2 = decodeUnsafe(string);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name} character`);
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
var src = base$1;
var _brrp__multiformats_scope_baseX = src;
const coerce = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const fromString = (str) => new TextEncoder().encode(str);
const toString = (b2) => new TextDecoder().decode(b2);
class Encoder {
  constructor(name, prefix2, baseEncode) {
    this.name = name;
    this.prefix = prefix2;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder {
  constructor(name, prefix2, baseDecode) {
    this.name = name;
    this.prefix = prefix2;
    if (prefix2.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix2.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or$1(this, decoder);
  }
}
class ComposedDecoder {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or$1(this, decoder);
  }
  decode(input) {
    const prefix2 = input[0];
    const decoder = this.decoders[prefix2];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or$1 = (left2, right2) => new ComposedDecoder({
  ...left2.decoders || { [left2.prefix]: left2 },
  ...right2.decoders || { [right2.prefix]: right2 }
});
class Codec {
  constructor(name, prefix2, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix2;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix2, baseEncode);
    this.decoder = new Decoder(name, prefix2, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from = ({ name, prefix: prefix2, encode: encode2, decode: decode2 }) => new Codec(name, prefix2, encode2, decode2);
const baseX = ({ prefix: prefix2, name, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name);
  return from({
    prefix: prefix2,
    name,
    encode: encode2,
    decode: (text) => coerce(decode2(text))
  });
};
const decode$1 = (string, alphabet2, bitsPerChar, name) => {
  const codes = {};
  for (let i4 = 0; i4 < alphabet2.length; ++i4) {
    codes[alphabet2[i4]] = i4;
  }
  let end2 = string.length;
  while (string[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i4 = 0; i4 < end2; ++i4) {
    const value = codes[string[i4]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$1 = (data2, alphabet2, bitsPerChar) => {
  const pad2 = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i4 = 0; i4 < data2.length; ++i4) {
    buffer2 = buffer2 << 8 | data2[i4];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad2) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648 = ({ name, prefix: prefix2, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix: prefix2,
    name,
    encode(input) {
      return encode$1(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$1(input, alphabet2, bitsPerChar, name);
    }
  });
};
const identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString(buf),
  decode: (str) => fromString(str)
});
const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" }));
const base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" }));
const base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" }));
const base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" }));
const base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" }));
const base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" }));
const base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" }));
const base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" }));
const base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" }));
const alphabet = Array.from("");
const alphabetBytesToChars = alphabet.reduce((p2, c2, i4) => {
  p2[i4] = c2;
  return p2;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p2, c2, i4) => {
  p2[c2.codePointAt(0)] = i4;
  return p2;
}, []);
function encode(data2) {
  return data2.reduce((p2, c2) => {
    p2 += alphabetBytesToChars[c2];
    return p2;
  }, "");
}
function decode(str) {
  const byts = [];
  for (const char2 of str) {
    const byt = alphabetCharsToBytes[char2.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char2}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji = from({
  prefix: "",
  name: "base256emoji",
  encode,
  decode
});
const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
var elliptic = {};
const version = "6.6.1";
const require$$0 = {
  version
};
var utils$2 = {};
var bn$1 = { exports: {} };
var bn = bn$1.exports;
var hasRequiredBn;
function requireBn() {
  if (hasRequiredBn) return bn$1.exports;
  hasRequiredBn = 1;
  (function(module) {
    (function(module2, exports) {
      function assert2(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base3, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base3 === "le" || base3 === "be") {
            endian = base3;
            base3 = 10;
          }
          this._init(number || 0, base3 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require$$3.Buffer;
        }
      } catch (e2) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max2(left2, right2) {
        if (left2.cmp(right2) > 0) return left2;
        return right2;
      };
      BN.min = function min2(left2, right2) {
        if (left2.cmp(right2) < 0) return left2;
        return right2;
      };
      BN.prototype._init = function init2(number, base3, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base3, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base3, endian);
        }
        if (base3 === "hex") {
          base3 = 16;
        }
        assert2(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start2 = 0;
        if (number[0] === "-") {
          start2++;
          this.negative = 1;
        }
        if (start2 < number.length) {
          if (base3 === 16) {
            this._parseHex(number, start2, endian);
          } else {
            this._parseBase(number, base3, start2);
            if (endian === "le") {
              this._initArray(this.toArray(), base3, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base3, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base3, endian);
      };
      BN.prototype._initArray = function _initArray(number, base3, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j2, w2;
        var off = 0;
        if (endian === "be") {
          for (i4 = number.length - 1, j2 = 0; i4 >= 0; i4 -= 3) {
            w2 = number[i4] | number[i4 - 1] << 8 | number[i4 - 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j2 = 0; i4 < number.length; i4 += 3) {
            w2 = number[i4] | number[i4 + 1] << 8 | number[i4 + 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index2) {
        var c2 = string.charCodeAt(index2);
        if (c2 >= 65 && c2 <= 70) {
          return c2 - 55;
        } else if (c2 >= 97 && c2 <= 102) {
          return c2 - 87;
        } else {
          return c2 - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index2) {
        var r2 = parseHex4Bits(string, index2);
        if (index2 - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string, index2 - 1) << 4;
        }
        return r2;
      }
      BN.prototype._parseHex = function _parseHex(number, start2, endian) {
        this.length = Math.ceil((number.length - start2) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var off = 0;
        var j2 = 0;
        var w2;
        if (endian === "be") {
          for (i4 = number.length - 1; i4 >= start2; i4 -= 2) {
            w2 = parseHexByte(number, start2, i4) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start2;
          for (i4 = parseLength % 2 === 0 ? start2 + 1 : start2; i4 < number.length; i4 += 2) {
            w2 = parseHexByte(number, start2, i4) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start2, end2, mul) {
        var r2 = 0;
        var len = Math.min(str.length, end2);
        for (var i4 = start2; i4 < len; i4++) {
          var c2 = str.charCodeAt(i4) - 48;
          r2 *= mul;
          if (c2 >= 49) {
            r2 += c2 - 49 + 10;
          } else if (c2 >= 17) {
            r2 += c2 - 17 + 10;
          } else {
            r2 += c2;
          }
        }
        return r2;
      }
      BN.prototype._parseBase = function _parseBase(number, base3, start2) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base3 | 0;
        var total = number.length - start2;
        var mod = total % limbLen;
        var end2 = Math.min(total, total - mod) + start2;
        var word = 0;
        for (var i4 = start2; i4 < end2; i4 += limbLen) {
          word = parseBase(number, i4, i4 + limbLen, base3);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i4, number.length, base3);
          for (i4 = 0; i4 < mod; i4++) {
            pow *= base3;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy2(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone2() {
        var r2 = new BN(null);
        this.copy(r2);
        return r2;
      };
      BN.prototype._expand = function _expand(size2) {
        while (this.length < size2) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString2(base3, padding2) {
        base3 = base3 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base3 === 16 || base3 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w2 = this.words[i4];
            var word = ((w2 << off | carry) & 16777215).toString(16);
            carry = w2 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i4--;
            }
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
          var groupSize = groupSizes[base3];
          var groupBase = groupBases[base3];
          out = "";
          var c2 = this.clone();
          c2.negative = 0;
          while (!c2.isZero()) {
            var r2 = c2.modn(groupBase).toString(base3);
            c2 = c2.idivn(groupBase);
            if (!c2.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber2() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length2) {
        assert2(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length2);
      };
      BN.prototype.toArray = function toArray(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
        var byteLength = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b2, i4;
        var q = this.clone();
        if (!littleEndian) {
          for (i4 = 0; i4 < reqLength - byteLength; i4++) {
            res[i4] = 0;
          }
          for (i4 = 0; !q.isZero(); i4++) {
            b2 = q.andln(255);
            q.iushrn(8);
            res[reqLength - i4 - 1] = b2;
          }
        } else {
          for (i4 = 0; !q.isZero(); i4++) {
            b2 = q.andln(255);
            q.iushrn(8);
            res[i4] = b2;
          }
          for (; i4 < reqLength; i4++) {
            res[i4] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w2) {
          return 32 - Math.clz32(w2);
        };
      } else {
        BN.prototype._countBits = function _countBits(w2) {
          var t2 = w2;
          var r2 = 0;
          if (t2 >= 4096) {
            r2 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r2 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r2 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r2 += 2;
            t2 >>>= 2;
          }
          return r2 + t2;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w2) {
        if (w2 === 0) return 26;
        var t2 = w2;
        var r2 = 0;
        if ((t2 & 8191) === 0) {
          r2 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r2 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r2 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r2 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN.prototype.bitLength = function bitLength() {
        var w2 = this.words[this.length - 1];
        var hi = this._countBits(w2);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w2 = new Array(num.bitLength());
        for (var bit = 0; bit < w2.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w2[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w2;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r2 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b2 = this._zeroBits(this.words[i4]);
          r2 += b2;
          if (b2 !== 26) break;
        }
        return r2;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width2) {
        if (this.negative !== 0) {
          return this.abs().inotn(width2).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width2) {
        if (this.testn(width2 - 1)) {
          return this.notn(width2).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or2(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i4 = 0; i4 < b2.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b2.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a2;
        var b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        for (var i4 = 0; i4 < b2.length; i4++) {
          this.words[i4] = a2.words[i4] ^ b2.words[i4];
        }
        if (this !== a2) {
          for (; i4 < a2.length; i4++) {
            this.words[i4] = a2.words[i4];
          }
        }
        this.length = a2.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width2) {
        assert2(typeof width2 === "number" && width2 >= 0);
        var bytesNeeded = Math.ceil(width2 / 26) | 0;
        var bitsLeft = width2 % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width2) {
        return this.clone().inotn(width2);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a2, b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b2.length; i4++) {
          r2 = (a2.words[i4] | 0) + (b2.words[i4] | 0) + carry;
          this.words[i4] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i4 < a2.length; i4++) {
          r2 = (a2.words[i4] | 0) + carry;
          this.words[i4] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a2.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a2 !== this) {
          for (; i4 < a2.length; i4++) {
            this.words[i4] = a2.words[i4];
          }
        }
        return this;
      };
      BN.prototype.add = function add2(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a2, b2;
        if (cmp > 0) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b2.length; i4++) {
          r2 = (a2.words[i4] | 0) - (b2.words[i4] | 0) + carry;
          carry = r2 >> 26;
          this.words[i4] = r2 & 67108863;
        }
        for (; carry !== 0 && i4 < a2.length; i4++) {
          r2 = (a2.words[i4] | 0) + carry;
          carry = r2 >> 26;
          this.words[i4] = r2 & 67108863;
        }
        if (carry === 0 && i4 < a2.length && a2 !== this) {
          for (; i4 < a2.length; i4++) {
            this.words[i4] = a2.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a2 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a2 = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r2 = a2 * b2;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i4 = k2 - j2 | 0;
            a2 = self2.words[i4] | 0;
            b2 = num.words[j2] | 0;
            r2 = a2 * b2 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a2 = self2.words;
        var b2 = num.words;
        var o2 = out.words;
        var c2 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a2[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a2[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a2[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a3 = a2[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a2[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a2[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a2[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a2[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a2[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a2[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b02 = b2[0] | 0;
        var bl0 = b02 & 8191;
        var bh0 = b02 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w02 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w02 >>> 26) | 0;
        w02 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o2[0] = w02;
        o2[1] = w1;
        o2[2] = w2;
        o2[3] = w3;
        o2[4] = w4;
        o2[5] = w5;
        o2[6] = w6;
        o2[7] = w7;
        o2[8] = w8;
        o2[9] = w9;
        o2[10] = w10;
        o2[11] = w11;
        o2[12] = w12;
        o2[13] = w13;
        o2[14] = w14;
        o2[15] = w15;
        o2[16] = w16;
        o2[17] = w17;
        o2[18] = w18;
        if (c2 !== 0) {
          o2[19] = c2;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i4 = k2 - j2;
            var a2 = self2.words[i4] | 0;
            var b2 = num.words[j2] | 0;
            var r2 = a2 * b2;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x2, y3) {
        this.x = x2;
        this.y = y3;
      }
      FFTM.prototype.makeRBT = function makeRBT(N2) {
        var t2 = new Array(N2);
        var l2 = BN.prototype._countBits(N2) - 1;
        for (var i4 = 0; i4 < N2; i4++) {
          t2[i4] = this.revBin(i4, l2, N2);
        }
        return t2;
      };
      FFTM.prototype.revBin = function revBin(x2, l2, N2) {
        if (x2 === 0 || x2 === N2 - 1) return x2;
        var rb = 0;
        for (var i4 = 0; i4 < l2; i4++) {
          rb |= (x2 & 1) << l2 - i4 - 1;
          x2 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
        for (var i4 = 0; i4 < N2; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N2);
        for (var s2 = 1; s2 < N2; s2 <<= 1) {
          var l2 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p2 = 0; p2 < N2; p2 += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j2 = 0; j2 < s2; j2++) {
              var re2 = rtws[p2 + j2];
              var ie2 = itws[p2 + j2];
              var ro = rtws[p2 + j2 + s2];
              var io = itws[p2 + j2 + s2];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p2 + j2] = re2 + ro;
              itws[p2 + j2] = ie2 + io;
              rtws[p2 + j2 + s2] = re2 - ro;
              itws[p2 + j2 + s2] = ie2 - io;
              if (j2 !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m3) {
        var N2 = Math.max(m3, n3) | 1;
        var odd = N2 & 1;
        var i4 = 0;
        for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
        if (N2 <= 1) return;
        for (var i4 = 0; i4 < N2 / 2; i4++) {
          var t2 = rws[i4];
          rws[i4] = rws[N2 - i4 - 1];
          rws[N2 - i4 - 1] = t2;
          t2 = iws[i4];
          iws[i4] = -iws[N2 - i4 - 1];
          iws[N2 - i4 - 1] = -t2;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
        var carry = 0;
        for (var i4 = 0; i4 < N2 / 2; i4++) {
          var w2 = Math.round(ws[2 * i4 + 1] / N2) * 8192 + Math.round(ws[2 * i4] / N2) + carry;
          ws[i4] = w2 & 67108863;
          if (w2 < 67108864) {
            carry = 0;
          } else {
            carry = w2 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N2; ++i4) {
          rws[i4] = 0;
        }
        assert2(carry === 0);
        assert2((carry & -8192) === 0);
      };
      FFTM.prototype.stub = function stub(N2) {
        var ph = new Array(N2);
        for (var i4 = 0; i4 < N2; i4++) {
          ph[i4] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x2, y3, out) {
        var N2 = 2 * this.guessLen13b(x2.length, y3.length);
        var rbt = this.makeRBT(N2);
        var _2 = this.stub(N2);
        var rws = new Array(N2);
        var rwst = new Array(N2);
        var iwst = new Array(N2);
        var nrws = new Array(N2);
        var nrwst = new Array(N2);
        var niwst = new Array(N2);
        var rmws = out.words;
        rmws.length = N2;
        this.convert13b(x2.words, x2.length, rws, N2);
        this.convert13b(y3.words, y3.length, nrws, N2);
        this.transform(rws, _2, rwst, iwst, N2, rbt);
        this.transform(nrws, _2, nrwst, niwst, N2, rbt);
        for (var i4 = 0; i4 < N2; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N2);
        this.transform(rwst, iwst, rmws, _2, N2, rbt);
        this.conjugate(rmws, _2, N2);
        this.normalize13b(rmws, N2);
        out.negative = x2.negative ^ y3.negative;
        out.length = x2.length + y3.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w2 = (this.words[i4] | 0) * num;
          var lo = (w2 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w2 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i4] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w2 = toBitArray(num);
        if (w2.length === 0) return new BN(1);
        var res = this;
        for (var i4 = 0; i4 < w2.length; i4++, res = res.sqr()) {
          if (w2[i4] !== 0) break;
        }
        if (++i4 < w2.length) {
          for (var q = res.sqr(); i4 < w2.length; i4++, q = q.sqr()) {
            if (w2[i4] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i4;
        if (r2 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c2 = (this.words[i4] | 0) - newCarry << r2;
            this.words[i4] = c2 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s2] = this.words[i4];
          }
          for (i4 = 0; i4 < s2; i4++) {
            this.words[i4] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h2;
        if (hint) {
          h2 = (hint - hint % 26) / 26;
        } else {
          h2 = 0;
        }
        var r2 = bits % 26;
        var s2 = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h2 -= s2;
        h2 = Math.max(0, h2);
        if (maskedWords) {
          for (var i4 = 0; i4 < s2; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) ;
        else if (this.length > s2) {
          this.length -= s2;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h2); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s2) return false;
        var w2 = this.words[s2];
        return !!(w2 & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s2 = (bits - r2) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r2 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs2() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w2;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w2 = (this.words[i4 + shift] | 0) + carry;
          var right2 = (num.words[i4] | 0) * mul;
          w2 -= right2 & 67108863;
          carry = (w2 >> 26) - (right2 / 67108864 | 0);
          this.words[i4 + shift] = w2 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w2 = (this.words[i4 + shift] | 0) + carry;
          carry = w2 >> 26;
          this.words[i4 + shift] = w2 & 67108863;
        }
        if (carry === 0) return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w2 = -(this.words[i4] | 0) + carry;
          carry = w2 >> 26;
          this.words[i4] = w2 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode2) {
        var shift = this.length - num.length;
        var a2 = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a2.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m3 = a2.length - b2.length;
        var q;
        if (mode2 !== "mod") {
          q = new BN(null);
          q.length = m3 + 1;
          q.words = new Array(q.length);
          for (var i4 = 0; i4 < q.length; i4++) {
            q.words[i4] = 0;
          }
        }
        var diff = a2.clone()._ishlnsubmul(b2, 1, m3);
        if (diff.negative === 0) {
          a2 = diff;
          if (q) {
            q.words[m3] = 1;
          }
        }
        for (var j2 = m3 - 1; j2 >= 0; j2--) {
          var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a2._ishlnsubmul(b2, qj, j2);
          while (a2.negative !== 0) {
            qj--;
            a2.negative = 0;
            a2._ishlnsubmul(b2, 1, j2);
            if (!a2.isZero()) {
              a2.negative ^= 1;
            }
          }
          if (q) {
            q.words[j2] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a2.strip();
        if (mode2 !== "div" && shift !== 0) {
          a2.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a2
        };
      };
      BN.prototype.divmod = function divmod(num, mode2, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode2);
          if (mode2 !== "mod") {
            div = res.div.neg();
          }
          if (mode2 !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode2);
          if (mode2 !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode2);
          if (mode2 !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode2 === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode2 === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode2);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert2(num <= 67108863);
        var p2 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p2 * acc + (this.words[i4] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w2 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w2 / num | 0;
          carry = w2 % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var x2 = this;
        var y3 = p2.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p2);
        } else {
          x2 = x2.clone();
        }
        var A2 = new BN(1);
        var B3 = new BN(0);
        var C2 = new BN(0);
        var D = new BN(1);
        var g2 = 0;
        while (x2.isEven() && y3.isEven()) {
          x2.iushrn(1);
          y3.iushrn(1);
          ++g2;
        }
        var yp = y3.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i4 = 0, im = 1; (x2.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1) ;
          if (i4 > 0) {
            x2.iushrn(i4);
            while (i4-- > 0) {
              if (A2.isOdd() || B3.isOdd()) {
                A2.iadd(yp);
                B3.isub(xp);
              }
              A2.iushrn(1);
              B3.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (y3.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            y3.iushrn(j2);
            while (j2-- > 0) {
              if (C2.isOdd() || D.isOdd()) {
                C2.iadd(yp);
                D.isub(xp);
              }
              C2.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x2.cmp(y3) >= 0) {
            x2.isub(y3);
            A2.isub(C2);
            B3.isub(D);
          } else {
            y3.isub(x2);
            C2.isub(A2);
            D.isub(B3);
          }
        }
        return {
          a: C2,
          b: D,
          gcd: y3.iushln(g2)
        };
      };
      BN.prototype._invmp = function _invmp(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var a2 = this;
        var b2 = p2.clone();
        if (a2.negative !== 0) {
          a2 = a2.umod(p2);
        } else {
          a2 = a2.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b2.clone();
        while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a2.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1) ;
          if (i4 > 0) {
            a2.iushrn(i4);
            while (i4-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            b2.iushrn(j2);
            while (j2-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a2.cmp(b2) >= 0) {
            a2.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a2);
            x2.isub(x1);
          }
        }
        var res;
        if (a2.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p2);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a2 = this.clone();
        var b2 = num.clone();
        a2.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
          a2.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a2.isEven()) {
            a2.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r2 = a2.cmp(b2);
          if (r2 < 0) {
            var t2 = a2;
            a2 = b2;
            b2 = t2;
          } else if (r2 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a2.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd2() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r2 = bit % 26;
        var s2 = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q;
          return this;
        }
        var carry = q;
        for (var i4 = s2; carry !== 0 && i4 < this.length; i4++) {
          var w2 = this.words[i4] | 0;
          w2 += carry;
          carry = w2 >>> 26;
          w2 &= 67108863;
          this.words[i4] = w2;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w2 = this.words[0] | 0;
          res = w2 === num ? 0 : w2 < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a2 = this.words[i4] | 0;
          var b2 = num.words[i4] | 0;
          if (a2 === b2) continue;
          if (a2 < b2) {
            res = -1;
          } else if (a2 > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red2(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p2) {
        this.name = name;
        this.p = new BN(p2, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev2 = input.words[9];
        output.words[output.length++] = prev2 & mask;
        for (i4 = 10; i4 < input.length; i4++) {
          var next2 = input.words[i4] | 0;
          input.words[i4 - 10] = (next2 & mask) << 4 | prev2 >>> 22;
          prev2 = next2;
        }
        prev2 >>>= 22;
        input.words[i4 - 10] = prev2;
        if (prev2 === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w2 = num.words[i4] | 0;
          lo += w2 * 977;
          num.words[i4] = lo & 67108863;
          lo = w2 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi = (num.words[i4] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i4] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m3) {
        if (typeof m3 === "string") {
          var prime = BN._prime(m3);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m3.gtn(1), "modulus must be greater than 1");
          this.m = m3;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a2) {
        assert2(a2.negative === 0, "red works only with positives");
        assert2(a2.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a2, b2) {
        assert2((a2.negative | b2.negative) === 0, "red works only with positives");
        assert2(
          a2.red && a2.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a2) {
        if (this.prime) return this.prime.ireduce(a2)._forceRed(this);
        return a2.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a2) {
        if (a2.isZero()) {
          return a2.clone();
        }
        return this.m.sub(a2)._forceRed(this);
      };
      Red.prototype.add = function add2(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a2, num) {
        this._verify1(a2);
        return this.imod(a2.ushln(num));
      };
      Red.prototype.imul = function imul(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.imul(b2));
      };
      Red.prototype.mul = function mul(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.mul(b2));
      };
      Red.prototype.isqr = function isqr(a2) {
        return this.imul(a2, a2.clone());
      };
      Red.prototype.sqr = function sqr(a2) {
        return this.mul(a2, a2);
      };
      Red.prototype.sqrt = function sqrt(a2) {
        if (a2.isZero()) return a2.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a2, pow);
        }
        var q = this.m.subn(1);
        var s2 = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s2++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z3 = this.m.bitLength();
        z3 = new BN(2 * z3 * z3).toRed(this);
        while (this.pow(z3, lpow).cmp(nOne) !== 0) {
          z3.redIAdd(nOne);
        }
        var c2 = this.pow(z3, q);
        var r2 = this.pow(a2, q.addn(1).iushrn(1));
        var t2 = this.pow(a2, q);
        var m3 = s2;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert2(i4 < m3);
          var b2 = this.pow(c2, new BN(1).iushln(m3 - i4 - 1));
          r2 = r2.redMul(b2);
          c2 = b2.redSqr();
          t2 = t2.redMul(c2);
          m3 = i4;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a2) {
        var inv = a2._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a2, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a2.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a2;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a2);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start2 = num.bitLength() % 26;
        if (start2 === 0) {
          start2 = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j2 = start2 - 1; j2 >= 0; j2--) {
            var bit = word >> j2 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j2 !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start2 = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont2(num) {
        return new Mont(num);
      };
      function Mont(m3) {
        Red.call(this, m3);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a2, b2) {
        if (a2.isZero() || b2.isZero()) {
          a2.words[0] = 0;
          a2.length = 1;
          return a2;
        }
        var t2 = a2.imul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a2, b2) {
        if (a2.isZero() || b2.isZero()) return new BN(0)._forceRed(this);
        var t2 = a2.mul(b2);
        var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t2.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a2) {
        var res = this.imod(a2._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module, bn);
  })(bn$1);
  return bn$1.exports;
}
var minimalisticAssert;
var hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1;
  minimalisticAssert = assert2;
  function assert2(val, msg) {
    if (!val)
      throw new Error(msg || "Assertion failed");
  }
  assert2.equal = function assertEqual(l2, r2, msg) {
    if (l2 != r2)
      throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
  };
  return minimalisticAssert;
}
var utils$1 = {};
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$1;
  hasRequiredUtils$2 = 1;
  (function(exports) {
    var utils2 = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i4 = 0; i4 < msg.length; i4++)
          res[i4] = msg[i4] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i4 = 0; i4 < msg.length; i4 += 2)
          res.push(parseInt(msg[i4] + msg[i4 + 1], 16));
      } else {
        for (var i4 = 0; i4 < msg.length; i4++) {
          var c2 = msg.charCodeAt(i4);
          var hi = c2 >> 8;
          var lo = c2 & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils2.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils2.zero2 = zero2;
    function toHex2(msg) {
      var res = "";
      for (var i4 = 0; i4 < msg.length; i4++)
        res += zero2(msg[i4].toString(16));
      return res;
    }
    utils2.toHex = toHex2;
    utils2.encode = function encode2(arr, enc) {
      if (enc === "hex")
        return toHex2(arr);
      else
        return arr;
    };
  })(utils$1);
  return utils$1;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$2;
  hasRequiredUtils$1 = 1;
  (function(exports) {
    var utils2 = exports;
    var BN = requireBn();
    var minAssert = requireMinimalisticAssert();
    var minUtils = requireUtils$2();
    utils2.assert = minAssert;
    utils2.toArray = minUtils.toArray;
    utils2.zero2 = minUtils.zero2;
    utils2.toHex = minUtils.toHex;
    utils2.encode = minUtils.encode;
    function getNAF(num, w2, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i4;
      for (i4 = 0; i4 < naf.length; i4 += 1) {
        naf[i4] = 0;
      }
      var ws = 1 << w2 + 1;
      var k2 = num.clone();
      for (i4 = 0; i4 < naf.length; i4++) {
        var z3;
        var mod = k2.andln(ws - 1);
        if (k2.isOdd()) {
          if (mod > (ws >> 1) - 1)
            z3 = (ws >> 1) - mod;
          else
            z3 = mod;
          k2.isubn(z3);
        } else {
          z3 = 0;
        }
        naf[i4] = z3;
        k2.iushrn(1);
      }
      return naf;
    }
    utils2.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u2 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils2.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key2 = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
      };
    }
    utils2.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils2.toArray(bytes, "hex") : bytes;
    }
    utils2.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils2.intFromLE = intFromLE;
  })(utils$2);
  return utils$2;
}
var brorand = { exports: {} };
var hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var r2;
  brorand.exports = function rand(len) {
    if (!r2)
      r2 = new Rand(null);
    return r2.generate(len);
  };
  function Rand(rand) {
    this.rand = rand;
  }
  brorand.exports.Rand = Rand;
  Rand.prototype.generate = function generate(len) {
    return this._rand(len);
  };
  Rand.prototype._rand = function _rand(n3) {
    if (this.rand.getBytes)
      return this.rand.getBytes(n3);
    var res = new Uint8Array(n3);
    for (var i4 = 0; i4 < res.length; i4++)
      res[i4] = this.rand.getByte();
    return res;
  };
  if (typeof self === "object") {
    if (self.crypto && self.crypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n3) {
        var arr = new Uint8Array(n3);
        self.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (self.msCrypto && self.msCrypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n3) {
        var arr = new Uint8Array(n3);
        self.msCrypto.getRandomValues(arr);
        return arr;
      };
    } else if (typeof window === "object") {
      Rand.prototype._rand = function() {
        throw new Error("Not implemented yet");
      };
    }
  } else {
    try {
      var crypto2 = require$$3;
      if (typeof crypto2.randomBytes !== "function")
        throw new Error("Not supported");
      Rand.prototype._rand = function _rand(n3) {
        return crypto2.randomBytes(n3);
      };
    } catch (e2) {
    }
  }
  return brorand.exports;
}
var curve = {};
var base;
var hasRequiredBase;
function requireBase() {
  if (hasRequiredBase) return base;
  hasRequiredBase = 1;
  var BN = requireBn();
  var utils2 = requireUtils$1();
  var getNAF = utils2.getNAF;
  var getJSF = utils2.getJSF;
  var assert2 = utils2.assert;
  function BaseCurve(type, conf) {
    this.type = type;
    this.p = new BN(conf.p, 16);
    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
    this.zero = new BN(0).toRed(this.red);
    this.one = new BN(1).toRed(this.red);
    this.two = new BN(2).toRed(this.red);
    this.n = conf.n && new BN(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  base = BaseCurve;
  BaseCurve.prototype.point = function point() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype.validate = function validate2() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k2) {
    assert2(p2.precomputed);
    var doubles = p2._getDoubles();
    var naf = getNAF(k2, 1, this._bitLength);
    var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I2 /= 3;
    var repr = [];
    var j2;
    var nafW;
    for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
      nafW = 0;
      for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
        nafW = (nafW << 1) + naf[l2];
      repr.push(nafW);
    }
    var a2 = this.jpoint(null, null, null);
    var b2 = this.jpoint(null, null, null);
    for (var i4 = I2; i4 > 0; i4--) {
      for (j2 = 0; j2 < repr.length; j2++) {
        nafW = repr[j2];
        if (nafW === i4)
          b2 = b2.mixedAdd(doubles.points[j2]);
        else if (nafW === -i4)
          b2 = b2.mixedAdd(doubles.points[j2].neg());
      }
      a2 = a2.add(b2);
    }
    return a2.toP();
  };
  BaseCurve.prototype._wnafMul = function _wnafMul(p2, k2) {
    var w2 = 4;
    var nafPoints = p2._getNAFPoints(w2);
    w2 = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k2, w2, this._bitLength);
    var acc = this.jpoint(null, null, null);
    for (var i4 = naf.length - 1; i4 >= 0; i4--) {
      for (var l2 = 0; i4 >= 0 && naf[i4] === 0; i4--)
        l2++;
      if (i4 >= 0)
        l2++;
      acc = acc.dblp(l2);
      if (i4 < 0)
        break;
      var z3 = naf[i4];
      assert2(z3 !== 0);
      if (p2.type === "affine") {
        if (z3 > 0)
          acc = acc.mixedAdd(wnd[z3 - 1 >> 1]);
        else
          acc = acc.mixedAdd(wnd[-z3 - 1 >> 1].neg());
      } else {
        if (z3 > 0)
          acc = acc.add(wnd[z3 - 1 >> 1]);
        else
          acc = acc.add(wnd[-z3 - 1 >> 1].neg());
      }
    }
    return p2.type === "affine" ? acc.toP() : acc;
  };
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max2 = 0;
    var i4;
    var j2;
    var p2;
    for (i4 = 0; i4 < len; i4++) {
      p2 = points[i4];
      var nafPoints = p2._getNAFPoints(defW);
      wndWidth[i4] = nafPoints.wnd;
      wnd[i4] = nafPoints.points;
    }
    for (i4 = len - 1; i4 >= 1; i4 -= 2) {
      var a2 = i4 - 1;
      var b2 = i4;
      if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
        naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
        naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
        max2 = Math.max(naf[a2].length, max2);
        max2 = Math.max(naf[b2].length, max2);
        continue;
      }
      var comb = [
        points[a2],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        points[b2]
        /* 7 */
      ];
      if (points[a2].y.cmp(points[b2].y) === 0) {
        comb[1] = points[a2].add(points[b2]);
        comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
      } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
        comb[1] = points[a2].toJ().mixedAdd(points[b2]);
        comb[2] = points[a2].add(points[b2].neg());
      } else {
        comb[1] = points[a2].toJ().mixedAdd(points[b2]);
        comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
      }
      var index2 = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ];
      var jsf = getJSF(coeffs[a2], coeffs[b2]);
      max2 = Math.max(jsf[0].length, max2);
      naf[a2] = new Array(max2);
      naf[b2] = new Array(max2);
      for (j2 = 0; j2 < max2; j2++) {
        var ja2 = jsf[0][j2] | 0;
        var jb = jsf[1][j2] | 0;
        naf[a2][j2] = index2[(ja2 + 1) * 3 + (jb + 1)];
        naf[b2][j2] = 0;
        wnd[a2] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (i4 = max2; i4 >= 0; i4--) {
      var k2 = 0;
      while (i4 >= 0) {
        var zero = true;
        for (j2 = 0; j2 < len; j2++) {
          tmp[j2] = naf[j2][i4] | 0;
          if (tmp[j2] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k2++;
        i4--;
      }
      if (i4 >= 0)
        k2++;
      acc = acc.dblp(k2);
      if (i4 < 0)
        break;
      for (j2 = 0; j2 < len; j2++) {
        var z3 = tmp[j2];
        if (z3 === 0)
          continue;
        else if (z3 > 0)
          p2 = wnd[j2][z3 - 1 >> 1];
        else if (z3 < 0)
          p2 = wnd[j2][-z3 - 1 >> 1].neg();
        if (p2.type === "affine")
          acc = acc.mixedAdd(p2);
        else
          acc = acc.add(p2);
      }
    }
    for (i4 = 0; i4 < len; i4++)
      wnd[i4] = null;
    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };
  function BasePoint(curve2, type) {
    this.curve = curve2;
    this.type = type;
    this.precomputed = null;
  }
  BaseCurve.BasePoint = BasePoint;
  BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
  };
  BasePoint.prototype.validate = function validate2() {
    return this.curve.validate(this);
  };
  BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils2.toArray(bytes, enc);
    var len = this.p.byteLength();
    if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
      if (bytes[0] === 6)
        assert2(bytes[bytes.length - 1] % 2 === 0);
      else if (bytes[0] === 7)
        assert2(bytes[bytes.length - 1] % 2 === 1);
      var res = this.point(
        bytes.slice(1, 1 + len),
        bytes.slice(1 + len, 1 + 2 * len)
      );
      return res;
    } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
      return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
    }
    throw new Error("Unknown point format");
  };
  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };
  BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x2 = this.getX().toArray("be", len);
    if (compact)
      return [this.getY().isEven() ? 2 : 3].concat(x2);
    return [4].concat(x2, this.getY().toArray("be", len));
  };
  BasePoint.prototype.encode = function encode2(enc, compact) {
    return utils2.encode(this._encode(compact), enc);
  };
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint.prototype._hasDoubles = function _hasDoubles(k2) {
    if (!this.precomputed)
      return false;
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
    return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
  };
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;
    for (var i4 = 0; i4 < power; i4 += step) {
      for (var j2 = 0; j2 < step; j2++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step,
      points: doubles
    };
  };
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    var res = [this];
    var max2 = (1 << wnd) - 1;
    var dbl = max2 === 1 ? null : this.dbl();
    for (var i4 = 1; i4 < max2; i4++)
      res[i4] = res[i4 - 1].add(dbl);
    return {
      wnd,
      points: res
    };
  };
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  BasePoint.prototype.dblp = function dblp(k2) {
    var r2 = this;
    for (var i4 = 0; i4 < k2; i4++)
      r2 = r2.dbl();
    return r2;
  };
  return base;
}
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
var short;
var hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var utils2 = requireUtils$1();
  var BN = requireBn();
  var inherits = requireInherits_browser();
  var Base = requireBase();
  var assert2 = utils2.assert;
  function ShortCurve(conf) {
    Base.call(this, "short", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits(ShortCurve, Base);
  short = ShortCurve;
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new BN(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new BN(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new BN(vec.a, 16),
          b: new BN(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta,
      lambda,
      basis
    };
  };
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    var red2 = num === this.p ? this.red : BN.mont(num);
    var tinv = new BN(2).toRed(red2).redInvm();
    var ntinv = tinv.redNeg();
    var s2 = new BN(3).toRed(red2).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s2).fromRed();
    var l2 = ntinv.redSub(s2).fromRed();
    return [l1, l2];
  };
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    var u2 = lambda;
    var v2 = this.n.clone();
    var x1 = new BN(1);
    var y1 = new BN(0);
    var x2 = new BN(0);
    var y22 = new BN(1);
    var a0;
    var b02;
    var a1;
    var b1;
    var a2;
    var b2;
    var prevR;
    var i4 = 0;
    var r2;
    var x3;
    while (u2.cmpn(0) !== 0) {
      var q = v2.div(u2);
      r2 = v2.sub(q.mul(u2));
      x3 = x2.sub(q.mul(x1));
      var y3 = y22.sub(q.mul(y1));
      if (!a1 && r2.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b02 = x1;
        a1 = r2.neg();
        b1 = x3;
      } else if (a1 && ++i4 === 2) {
        break;
      }
      prevR = r2;
      v2 = u2;
      u2 = r2;
      x2 = x1;
      x1 = x3;
      y22 = y1;
      y1 = y3;
    }
    a2 = r2.neg();
    b2 = x3;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b02;
    }
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.negative) {
      a2 = a2.neg();
      b2 = b2.neg();
    }
    return [
      { a: a1, b: b1 },
      { a: a2, b: b2 }
    ];
  };
  ShortCurve.prototype._endoSplit = function _endoSplit(k2) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k2).divRound(this.n);
    var c2 = v1.b.neg().mul(k2).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    var k1 = k2.sub(p1).sub(p2);
    var k22 = q1.add(q2).neg();
    return { k1, k2: k22 };
  };
  ShortCurve.prototype.pointFromX = function pointFromX(x2, odd) {
    x2 = new BN(x2, 16);
    if (!x2.red)
      x2 = x2.toRed(this.red);
    var y22 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
    var y3 = y22.redSqrt();
    if (y3.redSqr().redSub(y22).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd2 = y3.fromRed().isOdd();
    if (odd && !isOdd2 || !odd && isOdd2)
      y3 = y3.redNeg();
    return this.point(x2, y3);
  };
  ShortCurve.prototype.validate = function validate2(point) {
    if (point.inf)
      return true;
    var x2 = point.x;
    var y3 = point.y;
    var ax = this.a.redMul(x2);
    var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
    return y3.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i4 = 0; i4 < points.length; i4++) {
      var split2 = this._endoSplit(coeffs[i4]);
      var p2 = points[i4];
      var beta = p2._getBeta();
      if (split2.k1.negative) {
        split2.k1.ineg();
        p2 = p2.neg(true);
      }
      if (split2.k2.negative) {
        split2.k2.ineg();
        beta = beta.neg(true);
      }
      npoints[i4 * 2] = p2;
      npoints[i4 * 2 + 1] = beta;
      ncoeffs[i4 * 2] = split2.k1;
      ncoeffs[i4 * 2 + 1] = split2.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i4 * 2, jacobianResult);
    for (var j2 = 0; j2 < i4 * 2; j2++) {
      npoints[j2] = null;
      ncoeffs[j2] = null;
    }
    return res;
  };
  function Point(curve2, x2, y3, isRed) {
    Base.BasePoint.call(this, curve2, "affine");
    if (x2 === null && y3 === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN(x2, 16);
      this.y = new BN(y3, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits(Point, Base.BasePoint);
  ShortCurve.prototype.point = function point(x2, y3, isRed) {
    return new Point(this, x2, y3, isRed);
  };
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red2) {
    return Point.fromJSON(this, obj, red2);
  };
  Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo)
      return;
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve2 = this.curve;
      var endoMul = function(p2) {
        return curve2.point(p2.x.redMul(curve2.endo.beta), p2.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }
    return beta;
  };
  Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed)
      return [this.x, this.y];
    return [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }];
  };
  Point.fromJSON = function fromJSON(curve2, obj, red2) {
    if (typeof obj === "string")
      obj = JSON.parse(obj);
    var res = curve2.point(obj[0], obj[1], red2);
    if (!obj[2])
      return res;
    function obj2point(obj2) {
      return curve2.point(obj2[0], obj2[1], red2);
    }
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  Point.prototype.add = function add2(p2) {
    if (this.inf)
      return p2;
    if (p2.inf)
      return this;
    if (this.eq(p2))
      return this.dbl();
    if (this.neg().eq(p2))
      return this.curve.point(null, null);
    if (this.x.cmp(p2.x) === 0)
      return this.curve.point(null, null);
    var c2 = this.y.redSub(p2.y);
    if (c2.cmpn(0) !== 0)
      c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
    var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
    var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.dbl = function dbl() {
    if (this.inf)
      return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
    var a2 = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
    var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  Point.prototype.mul = function mul(k2) {
    k2 = new BN(k2, 16);
    if (this.isInfinity())
      return this;
    else if (this._hasDoubles(k2))
      return this.curve._fixedNafMul(this, k2);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([this], [k2]);
    else
      return this.curve._wnafMul(this, k2);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  Point.prototype.eq = function eq(p2) {
    return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
  };
  Point.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p2) {
        return p2.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }
    return res;
  };
  Point.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  function JPoint(curve2, x2, y3, z3) {
    Base.BasePoint.call(this, curve2, "jacobian");
    if (x2 === null && y3 === null && z3 === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN(0);
    } else {
      this.x = new BN(x2, 16);
      this.y = new BN(y3, 16);
      this.z = new BN(z3, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  }
  inherits(JPoint, Base.BasePoint);
  ShortCurve.prototype.jpoint = function jpoint(x2, y3, z3) {
    return new JPoint(this, x2, y3, z3);
  };
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint.prototype.add = function add2(p2) {
    if (this.isInfinity())
      return p2;
    if (p2.isInfinity())
      return this;
    var pz2 = p2.z.redSqr();
    var z22 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p2.x.redMul(z22);
    var s1 = this.y.redMul(pz2.redMul(p2.z));
    var s2 = p2.y.redMul(z22.redMul(this.z));
    var h2 = u1.redSub(u2);
    var r2 = s1.redSub(s2);
    if (h2.cmpn(0) === 0) {
      if (r2.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h22 = h2.redSqr();
    var h3 = h22.redMul(h2);
    var v2 = u1.redMul(h22);
    var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
    var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p2.z).redMul(h2);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mixedAdd = function mixedAdd(p2) {
    if (this.isInfinity())
      return p2.toJ();
    if (p2.isInfinity())
      return this;
    var z22 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p2.x.redMul(z22);
    var s1 = this.y;
    var s2 = p2.y.redMul(z22).redMul(this.z);
    var h2 = u1.redSub(u2);
    var r2 = s1.redSub(s2);
    if (h2.cmpn(0) === 0) {
      if (r2.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h22 = h2.redSqr();
    var h3 = h22.redMul(h2);
    var v2 = u1.redMul(h22);
    var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
    var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h2);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow)
      return this.dbl();
    var i4;
    if (this.curve.zeroA || this.curve.threeA) {
      var r2 = this;
      for (i4 = 0; i4 < pow; i4++)
        r2 = r2.dbl();
      return r2;
    }
    var a2 = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (i4 = 0; i4 < pow; i4++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c2.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c2.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i4 + 1 < pow)
        jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s2 = s2.redIAdd(s2);
      var m3 = xx.redAdd(xx).redIAdd(xx);
      var t2 = m3.redSqr().redISub(s2).redISub(s2);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t2;
      ny = m3.redMul(s2.redISub(t2)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a2 = this.x.redSqr();
      var b2 = this.y.redSqr();
      var c2 = b2.redSqr();
      var d3 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
      d3 = d3.redIAdd(d3);
      var e2 = a2.redAdd(a2).redIAdd(a2);
      var f2 = e2.redSqr();
      var c8 = c2.redIAdd(c2);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f2.redISub(d3).redISub(d3);
      ny = e2.redMul(d3.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s2 = s2.redIAdd(s2);
      var m3 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t2 = m3.redSqr().redISub(s2).redISub(s2);
      nx = t2;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m3.redMul(s2.redISub(t2)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha2 = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha2 = alpha2.redAdd(alpha2).redIAdd(alpha2);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha2.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha2.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._dbl = function _dbl() {
    var a2 = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c2.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy.redSqr();
    var m3 = xx.redAdd(xx).redIAdd(xx);
    var mm = m3.redSqr();
    var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e2 = e2.redIAdd(e2);
    e2 = e2.redAdd(e2).redIAdd(e2);
    e2 = e2.redISub(mm);
    var ee2 = e2.redSqr();
    var t2 = yyyy.redIAdd(yyyy);
    t2 = t2.redIAdd(t2);
    t2 = t2.redIAdd(t2);
    t2 = t2.redIAdd(t2);
    var u2 = m3.redIAdd(e2).redSqr().redISub(mm).redISub(ee2).redISub(t2);
    var yyu4 = yy.redMul(u2);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee2).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee2)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee2);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mul = function mul(k2, kbase) {
    k2 = new BN(k2, kbase);
    return this.curve._wnafMul(this, k2);
  };
  JPoint.prototype.eq = function eq(p2) {
    if (p2.type === "affine")
      return this.eq(p2.toJ());
    if (this === p2)
      return true;
    var z22 = this.z.redSqr();
    var pz2 = p2.z.redSqr();
    if (this.x.redMul(pz2).redISub(p2.x.redMul(z22)).cmpn(0) !== 0)
      return false;
    var z3 = z22.redMul(this.z);
    var pz3 = pz2.redMul(p2.z);
    return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
  };
  JPoint.prototype.eqXToP = function eqXToP(x2) {
    var zs2 = this.z.redSqr();
    var rx = x2.toRed(this.curve.red).redMul(zs2);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x2.clone();
    var t2 = this.curve.redN.redMul(zs2);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t2);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  JPoint.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  return short;
}
var mont;
var hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var BN = requireBn();
  var inherits = requireInherits_browser();
  var Base = requireBase();
  var utils2 = requireUtils$1();
  function MontCurve(conf) {
    Base.call(this, "mont", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.i4 = new BN(4).toRed(this.red).redInvm();
    this.two = new BN(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  inherits(MontCurve, Base);
  mont = MontCurve;
  MontCurve.prototype.validate = function validate2(point) {
    var x2 = point.normalize().x;
    var x22 = x2.redSqr();
    var rhs = x22.redMul(x2).redAdd(x22.redMul(this.a)).redAdd(x2);
    var y3 = rhs.redSqrt();
    return y3.redSqr().cmp(rhs) === 0;
  };
  function Point(curve2, x2, z3) {
    Base.BasePoint.call(this, curve2, "projective");
    if (x2 === null && z3 === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN(x2, 16);
      this.z = new BN(z3, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
  }
  inherits(Point, Base.BasePoint);
  MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils2.toArray(bytes, enc), 1);
  };
  MontCurve.prototype.point = function point(x2, z3) {
    return new Point(this, x2, z3);
  };
  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  Point.prototype.precompute = function precompute() {
  };
  Point.prototype._encode = function _encode() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  Point.fromJSON = function fromJSON(curve2, obj) {
    return new Point(curve2, obj[0], obj[1] || curve2.one);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  Point.prototype.dbl = function dbl() {
    var a2 = this.x.redAdd(this.z);
    var aa2 = a2.redSqr();
    var b2 = this.x.redSub(this.z);
    var bb = b2.redSqr();
    var c2 = aa2.redSub(bb);
    var nx = aa2.redMul(bb);
    var nz = c2.redMul(bb.redAdd(this.curve.a24.redMul(c2)));
    return this.curve.point(nx, nz);
  };
  Point.prototype.add = function add2() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.diffAdd = function diffAdd(p2, diff) {
    var a2 = this.x.redAdd(this.z);
    var b2 = this.x.redSub(this.z);
    var c2 = p2.x.redAdd(p2.z);
    var d3 = p2.x.redSub(p2.z);
    var da2 = d3.redMul(a2);
    var cb = c2.redMul(b2);
    var nx = diff.z.redMul(da2.redAdd(cb).redSqr());
    var nz = diff.x.redMul(da2.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };
  Point.prototype.mul = function mul(k2) {
    var t2 = k2.clone();
    var a2 = this;
    var b2 = this.curve.point(null, null);
    var c2 = this;
    for (var bits = []; t2.cmpn(0) !== 0; t2.iushrn(1))
      bits.push(t2.andln(1));
    for (var i4 = bits.length - 1; i4 >= 0; i4--) {
      if (bits[i4] === 0) {
        a2 = a2.diffAdd(b2, c2);
        b2 = b2.dbl();
      } else {
        b2 = a2.diffAdd(b2, c2);
        a2 = a2.dbl();
      }
    }
    return b2;
  };
  Point.prototype.mulAdd = function mulAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.jumlAdd = function jumlAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
  };
  Point.prototype.normalize = function normalize2() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  return mont;
}
var edwards;
var hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var utils2 = requireUtils$1();
  var BN = requireBn();
  var inherits = requireInherits_browser();
  var Base = requireBase();
  var assert2 = utils2.assert;
  function EdwardsCurve(conf) {
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, "edwards", conf);
    this.a = new BN(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert2(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  }
  inherits(EdwardsCurve, Base);
  edwards = EdwardsCurve;
  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA)
      return num.redNeg();
    else
      return this.a.redMul(num);
  };
  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC)
      return num;
    else
      return this.c.redMul(num);
  };
  EdwardsCurve.prototype.jpoint = function jpoint(x2, y3, z3, t2) {
    return this.point(x2, y3, z3, t2);
  };
  EdwardsCurve.prototype.pointFromX = function pointFromX(x2, odd) {
    x2 = new BN(x2, 16);
    if (!x2.red)
      x2 = x2.toRed(this.red);
    var x22 = x2.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x22));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
    var y22 = rhs.redMul(lhs.redInvm());
    var y3 = y22.redSqrt();
    if (y3.redSqr().redSub(y22).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd2 = y3.fromRed().isOdd();
    if (odd && !isOdd2 || !odd && isOdd2)
      y3 = y3.redNeg();
    return this.point(x2, y3);
  };
  EdwardsCurve.prototype.pointFromY = function pointFromY(y3, odd) {
    y3 = new BN(y3, 16);
    if (!y3.red)
      y3 = y3.toRed(this.red);
    var y22 = y3.redSqr();
    var lhs = y22.redSub(this.c2);
    var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
      if (odd)
        throw new Error("invalid point");
      else
        return this.point(this.zero, y3);
    }
    var x3 = x2.redSqrt();
    if (x3.redSqr().redSub(x2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    if (x3.fromRed().isOdd() !== odd)
      x3 = x3.redNeg();
    return this.point(x3, y3);
  };
  EdwardsCurve.prototype.validate = function validate2(point) {
    if (point.isInfinity())
      return true;
    point.normalize();
    var x2 = point.x.redSqr();
    var y22 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y22);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y22)));
    return lhs.cmp(rhs) === 0;
  };
  function Point(curve2, x2, y3, z3, t2) {
    Base.BasePoint.call(this, curve2, "projective");
    if (x2 === null && y3 === null && z3 === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN(x2, 16);
      this.y = new BN(y3, 16);
      this.z = z3 ? new BN(z3, 16) : this.curve.one;
      this.t = t2 && new BN(t2, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redMul(this.z.redInvm());
      }
    }
  }
  inherits(Point, Base.BasePoint);
  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  EdwardsCurve.prototype.point = function point(x2, y3, z3, t2) {
    return new Point(this, x2, y3, z3, t2);
  };
  Point.fromJSON = function fromJSON(curve2, obj) {
    return new Point(curve2, obj[0], obj[1], obj[2]);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  Point.prototype._extDbl = function _extDbl() {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = this.z.redSqr();
    c2 = c2.redIAdd(c2);
    var d3 = this.curve._mulA(a2);
    var e2 = this.x.redAdd(this.y).redSqr().redISub(a2).redISub(b2);
    var g2 = d3.redAdd(b2);
    var f2 = g2.redSub(c2);
    var h2 = d3.redSub(b2);
    var nx = e2.redMul(f2);
    var ny = g2.redMul(h2);
    var nt = e2.redMul(h2);
    var nz = f2.redMul(g2);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projDbl = function _projDbl() {
    var b2 = this.x.redAdd(this.y).redSqr();
    var c2 = this.x.redSqr();
    var d3 = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    var e2;
    var h2;
    var j2;
    if (this.curve.twisted) {
      e2 = this.curve._mulA(c2);
      var f2 = e2.redAdd(d3);
      if (this.zOne) {
        nx = b2.redSub(c2).redSub(d3).redMul(f2.redSub(this.curve.two));
        ny = f2.redMul(e2.redSub(d3));
        nz = f2.redSqr().redSub(f2).redSub(f2);
      } else {
        h2 = this.z.redSqr();
        j2 = f2.redSub(h2).redISub(h2);
        nx = b2.redSub(c2).redISub(d3).redMul(j2);
        ny = f2.redMul(e2.redSub(d3));
        nz = f2.redMul(j2);
      }
    } else {
      e2 = c2.redAdd(d3);
      h2 = this.curve._mulC(this.z).redSqr();
      j2 = e2.redSub(h2).redSub(h2);
      nx = this.curve._mulC(b2.redISub(e2)).redMul(j2);
      ny = this.curve._mulC(e2).redMul(c2.redISub(d3));
      nz = e2.redMul(j2);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extDbl();
    else
      return this._projDbl();
  };
  Point.prototype._extAdd = function _extAdd(p2) {
    var a2 = this.y.redSub(this.x).redMul(p2.y.redSub(p2.x));
    var b2 = this.y.redAdd(this.x).redMul(p2.y.redAdd(p2.x));
    var c2 = this.t.redMul(this.curve.dd).redMul(p2.t);
    var d3 = this.z.redMul(p2.z.redAdd(p2.z));
    var e2 = b2.redSub(a2);
    var f2 = d3.redSub(c2);
    var g2 = d3.redAdd(c2);
    var h2 = b2.redAdd(a2);
    var nx = e2.redMul(f2);
    var ny = g2.redMul(h2);
    var nt = e2.redMul(h2);
    var nz = f2.redMul(g2);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projAdd = function _projAdd(p2) {
    var a2 = this.z.redMul(p2.z);
    var b2 = a2.redSqr();
    var c2 = this.x.redMul(p2.x);
    var d3 = this.y.redMul(p2.y);
    var e2 = this.curve.d.redMul(c2).redMul(d3);
    var f2 = b2.redSub(e2);
    var g2 = b2.redAdd(e2);
    var tmp = this.x.redAdd(this.y).redMul(p2.x.redAdd(p2.y)).redISub(c2).redISub(d3);
    var nx = a2.redMul(f2).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
      ny = a2.redMul(g2).redMul(d3.redSub(this.curve._mulA(c2)));
      nz = f2.redMul(g2);
    } else {
      ny = a2.redMul(g2).redMul(d3.redSub(c2));
      nz = this.curve._mulC(f2).redMul(g2);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.add = function add2(p2) {
    if (this.isInfinity())
      return p2;
    if (p2.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extAdd(p2);
    else
      return this._projAdd(p2);
  };
  Point.prototype.mul = function mul(k2) {
    if (this._hasDoubles(k2))
      return this.curve._fixedNafMul(this, k2);
    else
      return this.curve._wnafMul(this, k2);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, false);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, true);
  };
  Point.prototype.normalize = function normalize2() {
    if (this.zOne)
      return this;
    var zi2 = this.z.redInvm();
    this.x = this.x.redMul(zi2);
    this.y = this.y.redMul(zi2);
    if (this.t)
      this.t = this.t.redMul(zi2);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };
  Point.prototype.neg = function neg() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };
  Point.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
  };
  Point.prototype.eqXToP = function eqXToP(x2) {
    var rx = x2.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x2.clone();
    var t2 = this.curve.redN.redMul(this.z);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t2);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  Point.prototype.toP = Point.prototype.normalize;
  Point.prototype.mixedAdd = Point.prototype.add;
  return edwards;
}
var hasRequiredCurve;
function requireCurve() {
  if (hasRequiredCurve) return curve;
  hasRequiredCurve = 1;
  (function(exports) {
    var curve2 = exports;
    curve2.base = requireBase();
    curve2.short = requireShort();
    curve2.mont = requireMont();
    curve2.edwards = requireEdwards();
  })(curve);
  return curve;
}
var curves = {};
var hash = {};
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  var assert2 = requireMinimalisticAssert();
  var inherits = requireInherits_browser();
  utils.inherits = inherits;
  function isSurrogatePair(msg, i4) {
    if ((msg.charCodeAt(i4) & 64512) !== 55296) {
      return false;
    }
    if (i4 < 0 || i4 + 1 >= msg.length) {
      return false;
    }
    return (msg.charCodeAt(i4 + 1) & 64512) === 56320;
  }
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === "string") {
      if (!enc) {
        var p2 = 0;
        for (var i4 = 0; i4 < msg.length; i4++) {
          var c2 = msg.charCodeAt(i4);
          if (c2 < 128) {
            res[p2++] = c2;
          } else if (c2 < 2048) {
            res[p2++] = c2 >> 6 | 192;
            res[p2++] = c2 & 63 | 128;
          } else if (isSurrogatePair(msg, i4)) {
            c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i4) & 1023);
            res[p2++] = c2 >> 18 | 240;
            res[p2++] = c2 >> 12 & 63 | 128;
            res[p2++] = c2 >> 6 & 63 | 128;
            res[p2++] = c2 & 63 | 128;
          } else {
            res[p2++] = c2 >> 12 | 224;
            res[p2++] = c2 >> 6 & 63 | 128;
            res[p2++] = c2 & 63 | 128;
          }
        }
      } else if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (i4 = 0; i4 < msg.length; i4 += 2)
          res.push(parseInt(msg[i4] + msg[i4 + 1], 16));
      }
    } else {
      for (i4 = 0; i4 < msg.length; i4++)
        res[i4] = msg[i4] | 0;
    }
    return res;
  }
  utils.toArray = toArray;
  function toHex2(msg) {
    var res = "";
    for (var i4 = 0; i4 < msg.length; i4++)
      res += zero2(msg[i4].toString(16));
    return res;
  }
  utils.toHex = toHex2;
  function htonl(w2) {
    var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
    return res >>> 0;
  }
  utils.htonl = htonl;
  function toHex32(msg, endian) {
    var res = "";
    for (var i4 = 0; i4 < msg.length; i4++) {
      var w2 = msg[i4];
      if (endian === "little")
        w2 = htonl(w2);
      res += zero8(w2.toString(16));
    }
    return res;
  }
  utils.toHex32 = toHex32;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function zero8(word) {
    if (word.length === 7)
      return "0" + word;
    else if (word.length === 6)
      return "00" + word;
    else if (word.length === 5)
      return "000" + word;
    else if (word.length === 4)
      return "0000" + word;
    else if (word.length === 3)
      return "00000" + word;
    else if (word.length === 2)
      return "000000" + word;
    else if (word.length === 1)
      return "0000000" + word;
    else
      return word;
  }
  utils.zero8 = zero8;
  function join32(msg, start2, end2, endian) {
    var len = end2 - start2;
    assert2(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i4 = 0, k2 = start2; i4 < res.length; i4++, k2 += 4) {
      var w2;
      if (endian === "big")
        w2 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
      else
        w2 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
      res[i4] = w2 >>> 0;
    }
    return res;
  }
  utils.join32 = join32;
  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i4 = 0, k2 = 0; i4 < msg.length; i4++, k2 += 4) {
      var m3 = msg[i4];
      if (endian === "big") {
        res[k2] = m3 >>> 24;
        res[k2 + 1] = m3 >>> 16 & 255;
        res[k2 + 2] = m3 >>> 8 & 255;
        res[k2 + 3] = m3 & 255;
      } else {
        res[k2 + 3] = m3 >>> 24;
        res[k2 + 2] = m3 >>> 16 & 255;
        res[k2 + 1] = m3 >>> 8 & 255;
        res[k2] = m3 & 255;
      }
    }
    return res;
  }
  utils.split32 = split32;
  function rotr32(w2, b2) {
    return w2 >>> b2 | w2 << 32 - b2;
  }
  utils.rotr32 = rotr32;
  function rotl32(w2, b2) {
    return w2 << b2 | w2 >>> 32 - b2;
  }
  utils.rotl32 = rotl32;
  function sum32(a2, b2) {
    return a2 + b2 >>> 0;
  }
  utils.sum32 = sum32;
  function sum32_3(a2, b2, c2) {
    return a2 + b2 + c2 >>> 0;
  }
  utils.sum32_3 = sum32_3;
  function sum32_4(a2, b2, c2, d3) {
    return a2 + b2 + c2 + d3 >>> 0;
  }
  utils.sum32_4 = sum32_4;
  function sum32_5(a2, b2, c2, d3, e2) {
    return a2 + b2 + c2 + d3 + e2 >>> 0;
  }
  utils.sum32_5 = sum32_5;
  function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }
  utils.sum64 = sum64;
  function sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  }
  utils.sum64_hi = sum64_hi;
  function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }
  utils.sum64_lo = sum64_lo;
  function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  }
  utils.sum64_4_hi = sum64_4_hi;
  function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }
  utils.sum64_4_lo = sum64_4_lo;
  function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  }
  utils.sum64_5_hi = sum64_5_hi;
  function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
  }
  utils.sum64_5_lo = sum64_5_lo;
  function rotr64_hi(ah, al, num) {
    var r2 = al << 32 - num | ah >>> num;
    return r2 >>> 0;
  }
  utils.rotr64_hi = rotr64_hi;
  function rotr64_lo(ah, al, num) {
    var r2 = ah << 32 - num | al >>> num;
    return r2 >>> 0;
  }
  utils.rotr64_lo = rotr64_lo;
  function shr64_hi(ah, al, num) {
    return ah >>> num;
  }
  utils.shr64_hi = shr64_hi;
  function shr64_lo(ah, al, num) {
    var r2 = ah << 32 - num | al >>> num;
    return r2 >>> 0;
  }
  utils.shr64_lo = shr64_lo;
  return utils;
}
var common$1 = {};
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var utils2 = requireUtils();
  var assert2 = requireMinimalisticAssert();
  function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  common$1.BlockHash = BlockHash;
  BlockHash.prototype.update = function update(msg, enc) {
    msg = utils2.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r2 = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r2, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
      msg = utils2.join32(msg, 0, msg.length - r2, this.endian);
      for (var i4 = 0; i4 < msg.length; i4 += this._delta32)
        this._update(msg, i4, i4 + this._delta32);
    }
    return this;
  };
  BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert2(this.pending === null);
    return this._digest(enc);
  };
  BlockHash.prototype._pad = function pad2() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k2 = bytes - (len + this.padLength) % bytes;
    var res = new Array(k2 + this.padLength);
    res[0] = 128;
    for (var i4 = 1; i4 < k2; i4++)
      res[i4] = 0;
    len <<= 3;
    if (this.endian === "big") {
      for (var t2 = 8; t2 < this.padLength; t2++)
        res[i4++] = 0;
      res[i4++] = 0;
      res[i4++] = 0;
      res[i4++] = 0;
      res[i4++] = 0;
      res[i4++] = len >>> 24 & 255;
      res[i4++] = len >>> 16 & 255;
      res[i4++] = len >>> 8 & 255;
      res[i4++] = len & 255;
    } else {
      res[i4++] = len & 255;
      res[i4++] = len >>> 8 & 255;
      res[i4++] = len >>> 16 & 255;
      res[i4++] = len >>> 24 & 255;
      res[i4++] = 0;
      res[i4++] = 0;
      res[i4++] = 0;
      res[i4++] = 0;
      for (t2 = 8; t2 < this.padLength; t2++)
        res[i4++] = 0;
    }
    return res;
  };
  return common$1;
}
var sha = {};
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var utils2 = requireUtils();
  var rotr32 = utils2.rotr32;
  function ft_1(s2, x2, y3, z3) {
    if (s2 === 0)
      return ch32(x2, y3, z3);
    if (s2 === 1 || s2 === 3)
      return p32(x2, y3, z3);
    if (s2 === 2)
      return maj32(x2, y3, z3);
  }
  common.ft_1 = ft_1;
  function ch32(x2, y3, z3) {
    return x2 & y3 ^ ~x2 & z3;
  }
  common.ch32 = ch32;
  function maj32(x2, y3, z3) {
    return x2 & y3 ^ x2 & z3 ^ y3 & z3;
  }
  common.maj32 = maj32;
  function p32(x2, y3, z3) {
    return x2 ^ y3 ^ z3;
  }
  common.p32 = p32;
  function s0_256(x2) {
    return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
  }
  common.s0_256 = s0_256;
  function s1_256(x2) {
    return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
  }
  common.s1_256 = s1_256;
  function g0_256(x2) {
    return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
  }
  common.g0_256 = g0_256;
  function g1_256(x2) {
    return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
  }
  common.g1_256 = g1_256;
  return common;
}
var _1;
var hasRequired_1;
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var utils2 = requireUtils();
  var common2 = requireCommon$1();
  var shaCommon = requireCommon();
  var rotl32 = utils2.rotl32;
  var sum32 = utils2.sum32;
  var sum32_5 = utils2.sum32_5;
  var ft_1 = shaCommon.ft_1;
  var BlockHash = common2.BlockHash;
  var sha1_K = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function SHA1() {
    if (!(this instanceof SHA1))
      return new SHA1();
    BlockHash.call(this);
    this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ];
    this.W = new Array(80);
  }
  utils2.inherits(SHA1, BlockHash);
  _1 = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start2) {
    var W = this.W;
    for (var i4 = 0; i4 < 16; i4++)
      W[i4] = msg[start2 + i4];
    for (; i4 < W.length; i4++)
      W[i4] = rotl32(W[i4 - 3] ^ W[i4 - 8] ^ W[i4 - 14] ^ W[i4 - 16], 1);
    var a2 = this.h[0];
    var b2 = this.h[1];
    var c2 = this.h[2];
    var d3 = this.h[3];
    var e2 = this.h[4];
    for (i4 = 0; i4 < W.length; i4++) {
      var s2 = ~~(i4 / 20);
      var t2 = sum32_5(rotl32(a2, 5), ft_1(s2, b2, c2, d3), e2, W[i4], sha1_K[s2]);
      e2 = d3;
      d3 = c2;
      c2 = rotl32(b2, 30);
      b2 = a2;
      a2 = t2;
    }
    this.h[0] = sum32(this.h[0], a2);
    this.h[1] = sum32(this.h[1], b2);
    this.h[2] = sum32(this.h[2], c2);
    this.h[3] = sum32(this.h[3], d3);
    this.h[4] = sum32(this.h[4], e2);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "big");
    else
      return utils2.split32(this.h, "big");
  };
  return _1;
}
var _256;
var hasRequired_256;
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var utils2 = requireUtils();
  var common2 = requireCommon$1();
  var shaCommon = requireCommon();
  var assert2 = requireMinimalisticAssert();
  var sum32 = utils2.sum32;
  var sum32_4 = utils2.sum32_4;
  var sum32_5 = utils2.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;
  var BlockHash = common2.BlockHash;
  var sha256_K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function SHA2562() {
    if (!(this instanceof SHA2562))
      return new SHA2562();
    BlockHash.call(this);
    this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils2.inherits(SHA2562, BlockHash);
  _256 = SHA2562;
  SHA2562.blockSize = 512;
  SHA2562.outSize = 256;
  SHA2562.hmacStrength = 192;
  SHA2562.padLength = 64;
  SHA2562.prototype._update = function _update(msg, start2) {
    var W = this.W;
    for (var i4 = 0; i4 < 16; i4++)
      W[i4] = msg[start2 + i4];
    for (; i4 < W.length; i4++)
      W[i4] = sum32_4(g1_256(W[i4 - 2]), W[i4 - 7], g0_256(W[i4 - 15]), W[i4 - 16]);
    var a2 = this.h[0];
    var b2 = this.h[1];
    var c2 = this.h[2];
    var d3 = this.h[3];
    var e2 = this.h[4];
    var f2 = this.h[5];
    var g2 = this.h[6];
    var h2 = this.h[7];
    assert2(this.k.length === W.length);
    for (i4 = 0; i4 < W.length; i4++) {
      var T12 = sum32_5(h2, s1_256(e2), ch32(e2, f2, g2), this.k[i4], W[i4]);
      var T2 = sum32(s0_256(a2), maj32(a2, b2, c2));
      h2 = g2;
      g2 = f2;
      f2 = e2;
      e2 = sum32(d3, T12);
      d3 = c2;
      c2 = b2;
      b2 = a2;
      a2 = sum32(T12, T2);
    }
    this.h[0] = sum32(this.h[0], a2);
    this.h[1] = sum32(this.h[1], b2);
    this.h[2] = sum32(this.h[2], c2);
    this.h[3] = sum32(this.h[3], d3);
    this.h[4] = sum32(this.h[4], e2);
    this.h[5] = sum32(this.h[5], f2);
    this.h[6] = sum32(this.h[6], g2);
    this.h[7] = sum32(this.h[7], h2);
  };
  SHA2562.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "big");
    else
      return utils2.split32(this.h, "big");
  };
  return _256;
}
var _224;
var hasRequired_224;
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var utils2 = requireUtils();
  var SHA2562 = require_256();
  function SHA224() {
    if (!(this instanceof SHA224))
      return new SHA224();
    SHA2562.call(this);
    this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  utils2.inherits(SHA224, SHA2562);
  _224 = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  SHA224.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h.slice(0, 7), "big");
    else
      return utils2.split32(this.h.slice(0, 7), "big");
  };
  return _224;
}
var _512;
var hasRequired_512;
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var utils2 = requireUtils();
  var common2 = requireCommon$1();
  var assert2 = requireMinimalisticAssert();
  var rotr64_hi = utils2.rotr64_hi;
  var rotr64_lo = utils2.rotr64_lo;
  var shr64_hi = utils2.shr64_hi;
  var shr64_lo = utils2.shr64_lo;
  var sum64 = utils2.sum64;
  var sum64_hi = utils2.sum64_hi;
  var sum64_lo = utils2.sum64_lo;
  var sum64_4_hi = utils2.sum64_4_hi;
  var sum64_4_lo = utils2.sum64_4_lo;
  var sum64_5_hi = utils2.sum64_5_hi;
  var sum64_5_lo = utils2.sum64_5_lo;
  var BlockHash = common2.BlockHash;
  var sha512_K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function SHA5122() {
    if (!(this instanceof SHA5122))
      return new SHA5122();
    BlockHash.call(this);
    this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils2.inherits(SHA5122, BlockHash);
  _512 = SHA5122;
  SHA5122.blockSize = 1024;
  SHA5122.outSize = 512;
  SHA5122.hmacStrength = 192;
  SHA5122.padLength = 128;
  SHA5122.prototype._prepareBlock = function _prepareBlock(msg, start2) {
    var W = this.W;
    for (var i4 = 0; i4 < 32; i4++)
      W[i4] = msg[start2 + i4];
    for (; i4 < W.length; i4 += 2) {
      var c0_hi = g1_512_hi(W[i4 - 4], W[i4 - 3]);
      var c0_lo = g1_512_lo(W[i4 - 4], W[i4 - 3]);
      var c1_hi = W[i4 - 14];
      var c1_lo = W[i4 - 13];
      var c2_hi = g0_512_hi(W[i4 - 30], W[i4 - 29]);
      var c2_lo = g0_512_lo(W[i4 - 30], W[i4 - 29]);
      var c3_hi = W[i4 - 32];
      var c3_lo = W[i4 - 31];
      W[i4] = sum64_4_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
      W[i4 + 1] = sum64_4_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
    }
  };
  SHA5122.prototype._update = function _update(msg, start2) {
    this._prepareBlock(msg, start2);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert2(this.k.length === W.length);
    for (var i4 = 0; i4 < W.length; i4 += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i4];
      var c3_lo = this.k[i4 + 1];
      var c4_hi = W[i4];
      var c4_lo = W[i4 + 1];
      var T1_hi = sum64_5_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      var T1_lo = sum64_5_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };
  SHA5122.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "big");
    else
      return utils2.split32(this.h, "big");
  };
  function ch64_hi(xh, xl, yh, yl, zh) {
    var r2 = xh & yh ^ ~xh & zh;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r2 = xl & yl ^ ~xl & zl;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function maj64_hi(xh, xl, yh, yl, zh) {
    var r2 = xh & yh ^ xh & zh ^ yh & zh;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r2 = xl & yl ^ xl & zl ^ yl & zl;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);
    var c2_hi = rotr64_hi(xl, xh, 7);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);
    var c2_lo = rotr64_lo(xl, xh, 7);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);
    var c2_hi = shr64_hi(xh, xl, 6);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);
    var c2_lo = shr64_lo(xh, xl, 6);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  return _512;
}
var _384;
var hasRequired_384;
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var utils2 = requireUtils();
  var SHA5122 = require_512();
  function SHA3842() {
    if (!(this instanceof SHA3842))
      return new SHA3842();
    SHA5122.call(this);
    this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  utils2.inherits(SHA3842, SHA5122);
  _384 = SHA3842;
  SHA3842.blockSize = 1024;
  SHA3842.outSize = 384;
  SHA3842.hmacStrength = 192;
  SHA3842.padLength = 128;
  SHA3842.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h.slice(0, 12), "big");
    else
      return utils2.split32(this.h.slice(0, 12), "big");
  };
  return _384;
}
var hasRequiredSha;
function requireSha() {
  if (hasRequiredSha) return sha;
  hasRequiredSha = 1;
  sha.sha1 = require_1();
  sha.sha224 = require_224();
  sha.sha256 = require_256();
  sha.sha384 = require_384();
  sha.sha512 = require_512();
  return sha;
}
var ripemd = {};
var hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var utils2 = requireUtils();
  var common2 = requireCommon$1();
  var rotl32 = utils2.rotl32;
  var sum32 = utils2.sum32;
  var sum32_3 = utils2.sum32_3;
  var sum32_4 = utils2.sum32_4;
  var BlockHash = common2.BlockHash;
  function RIPEMD160() {
    if (!(this instanceof RIPEMD160))
      return new RIPEMD160();
    BlockHash.call(this);
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    this.endian = "little";
  }
  utils2.inherits(RIPEMD160, BlockHash);
  ripemd.ripemd160 = RIPEMD160;
  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;
  RIPEMD160.prototype._update = function update(msg, start2) {
    var A2 = this.h[0];
    var B3 = this.h[1];
    var C2 = this.h[2];
    var D = this.h[3];
    var E2 = this.h[4];
    var Ah = A2;
    var Bh = B3;
    var Ch = C2;
    var Dh = D;
    var Eh = E2;
    for (var j2 = 0; j2 < 80; j2++) {
      var T2 = sum32(
        rotl32(
          sum32_4(A2, f2(j2, B3, C2, D), msg[r2[j2] + start2], K2(j2)),
          s2[j2]
        ),
        E2
      );
      A2 = E2;
      E2 = D;
      D = rotl32(C2, 10);
      C2 = B3;
      B3 = T2;
      T2 = sum32(
        rotl32(
          sum32_4(Ah, f2(79 - j2, Bh, Ch, Dh), msg[rh[j2] + start2], Kh(j2)),
          sh[j2]
        ),
        Eh
      );
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T2;
    }
    T2 = sum32_3(this.h[1], C2, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E2, Ah);
    this.h[3] = sum32_3(this.h[4], A2, Bh);
    this.h[4] = sum32_3(this.h[0], B3, Ch);
    this.h[0] = T2;
  };
  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils2.toHex32(this.h, "little");
    else
      return utils2.split32(this.h, "little");
  };
  function f2(j2, x2, y3, z3) {
    if (j2 <= 15)
      return x2 ^ y3 ^ z3;
    else if (j2 <= 31)
      return x2 & y3 | ~x2 & z3;
    else if (j2 <= 47)
      return (x2 | ~y3) ^ z3;
    else if (j2 <= 63)
      return x2 & z3 | y3 & ~z3;
    else
      return x2 ^ (y3 | ~z3);
  }
  function K2(j2) {
    if (j2 <= 15)
      return 0;
    else if (j2 <= 31)
      return 1518500249;
    else if (j2 <= 47)
      return 1859775393;
    else if (j2 <= 63)
      return 2400959708;
    else
      return 2840853838;
  }
  function Kh(j2) {
    if (j2 <= 15)
      return 1352829926;
    else if (j2 <= 31)
      return 1548603684;
    else if (j2 <= 47)
      return 1836072691;
    else if (j2 <= 63)
      return 2053994217;
    else
      return 0;
  }
  var r2 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ];
  var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ];
  var s2 = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ];
  var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac;
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  var utils2 = requireUtils();
  var assert2 = requireMinimalisticAssert();
  function Hmac(hash2, key2, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash2, key2, enc);
    this.Hash = hash2;
    this.blockSize = hash2.blockSize / 8;
    this.outSize = hash2.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils2.toArray(key2, enc));
  }
  hmac = Hmac;
  Hmac.prototype._init = function init2(key2) {
    if (key2.length > this.blockSize)
      key2 = new this.Hash().update(key2).digest();
    assert2(key2.length <= this.blockSize);
    for (var i4 = key2.length; i4 < this.blockSize; i4++)
      key2.push(0);
    for (i4 = 0; i4 < key2.length; i4++)
      key2[i4] ^= 54;
    this.inner = new this.Hash().update(key2);
    for (i4 = 0; i4 < key2.length; i4++)
      key2[i4] ^= 106;
    this.outer = new this.Hash().update(key2);
  };
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
  return hmac;
}
var hasRequiredHash;
function requireHash() {
  if (hasRequiredHash) return hash;
  hasRequiredHash = 1;
  (function(exports) {
    var hash2 = exports;
    hash2.utils = requireUtils();
    hash2.common = requireCommon$1();
    hash2.sha = requireSha();
    hash2.ripemd = requireRipemd();
    hash2.hmac = requireHmac();
    hash2.sha1 = hash2.sha.sha1;
    hash2.sha256 = hash2.sha.sha256;
    hash2.sha224 = hash2.sha.sha224;
    hash2.sha384 = hash2.sha.sha384;
    hash2.sha512 = hash2.sha.sha512;
    hash2.ripemd160 = hash2.ripemd.ripemd160;
  })(hash);
  return hash;
}
var secp256k1;
var hasRequiredSecp256k1;
function requireSecp256k1() {
  if (hasRequiredSecp256k1) return secp256k1;
  hasRequiredSecp256k1 = 1;
  secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  };
  return secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  if (hasRequiredCurves) return curves;
  hasRequiredCurves = 1;
  (function(exports) {
    var curves2 = exports;
    var hash2 = requireHash();
    var curve2 = requireCurve();
    var utils2 = requireUtils$1();
    var assert2 = utils2.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve2.short(options);
      else if (options.type === "edwards")
        this.curve = new curve2.edwards(options);
      else
        this.curve = new curve2.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert2(this.g.validate(), "Invalid curve");
      assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves2.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves2, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve3 = new PresetCurve(options);
          Object.defineProperty(curves2, name, {
            configurable: true,
            enumerable: true,
            value: curve3
          });
          return curve3;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash2.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash2.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = requireSecp256k1();
    } catch (e2) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash2.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  })(curves);
  return curves;
}
var hmacDrbg;
var hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var hash2 = requireHash();
  var utils2 = requireUtils$2();
  var assert2 = requireMinimalisticAssert();
  function HmacDRBG(options) {
    if (!(this instanceof HmacDRBG))
      return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils2.toArray(options.entropy, options.entropyEnc || "hex");
    var nonce = utils2.toArray(options.nonce, options.nonceEnc || "hex");
    var pers = utils2.toArray(options.pers, options.persEnc || "hex");
    assert2(
      entropy.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    );
    this._init(entropy, nonce, pers);
  }
  hmacDrbg = HmacDRBG;
  HmacDRBG.prototype._init = function init2(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i4 = 0; i4 < this.V.length; i4++) {
      this.K[i4] = 0;
      this.V[i4] = 1;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 281474976710656;
  };
  HmacDRBG.prototype._hmac = function hmac2() {
    return new hash2.hmac(this.hash, this.K);
  };
  HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([0]);
    if (seed)
      kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed)
      return;
    this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
  };
  HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add2, addEnc) {
    if (typeof entropyEnc !== "string") {
      addEnc = add2;
      add2 = entropyEnc;
      entropyEnc = null;
    }
    entropy = utils2.toArray(entropy, entropyEnc);
    add2 = utils2.toArray(add2, addEnc);
    assert2(
      entropy.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    );
    this._update(entropy.concat(add2 || []));
    this._reseed = 1;
  };
  HmacDRBG.prototype.generate = function generate(len, enc, add2, addEnc) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    if (typeof enc !== "string") {
      addEnc = add2;
      add2 = enc;
      enc = null;
    }
    if (add2) {
      add2 = utils2.toArray(add2, addEnc || "hex");
      this._update(add2);
    }
    var temp = [];
    while (temp.length < len) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add2);
    this._reseed++;
    return utils2.encode(res, enc);
  };
  return hmacDrbg;
}
var key$1;
var hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$1;
  hasRequiredKey$1 = 1;
  var BN = requireBn();
  var utils2 = requireUtils$1();
  var assert2 = utils2.assert;
  function KeyPair(ec2, options) {
    this.ec = ec2;
    this.priv = null;
    this.pub = null;
    if (options.priv)
      this._importPrivate(options.priv, options.privEnc);
    if (options.pub)
      this._importPublic(options.pub, options.pubEnc);
  }
  key$1 = KeyPair;
  KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(ec2, {
      pub,
      pubEnc: enc
    });
  };
  KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
    if (priv instanceof KeyPair)
      return priv;
    return new KeyPair(ec2, {
      priv,
      privEnc: enc
    });
  };
  KeyPair.prototype.validate = function validate2() {
    var pub = this.getPublic();
    if (pub.isInfinity())
      return { result: false, reason: "Invalid public key" };
    if (!pub.validate())
      return { result: false, reason: "Public key is not a point" };
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return { result: false, reason: "Public key * N != O" };
    return { result: true, reason: null };
  };
  KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    if (typeof compact === "string") {
      enc = compact;
      compact = null;
    }
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
    if (!enc)
      return this.pub;
    return this.pub.encode(enc, compact);
  };
  KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex")
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
    this.priv = new BN(key2, enc || 16);
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
    if (key2.x || key2.y) {
      if (this.ec.curve.type === "mont") {
        assert2(key2.x, "Need x coordinate");
      } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
        assert2(key2.x && key2.y, "Need both x and y coordinate");
      }
      this.pub = this.ec.curve.point(key2.x, key2.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key2, enc);
  };
  KeyPair.prototype.derive = function derive(pub) {
    if (!pub.validate()) {
      assert2(pub.validate(), "public point not validated");
    }
    return pub.mul(this.priv).getX();
  };
  KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };
  KeyPair.prototype.verify = function verify(msg, signature2, options) {
    return this.ec.verify(msg, signature2, this, void 0, options);
  };
  KeyPair.prototype.inspect = function inspect() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
  return key$1;
}
var signature$1;
var hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$1;
  hasRequiredSignature$1 = 1;
  var BN = requireBn();
  var utils2 = requireUtils$1();
  var assert2 = utils2.assert;
  function Signature(options, enc) {
    if (options instanceof Signature)
      return options;
    if (this._importDER(options, enc))
      return;
    assert2(options.r && options.s, "Signature without r or s");
    this.r = new BN(options.r, 16);
    this.s = new BN(options.s, 16);
    if (options.recoveryParam === void 0)
      this.recoveryParam = null;
    else
      this.recoveryParam = options.recoveryParam;
  }
  signature$1 = Signature;
  function Position() {
    this.place = 0;
  }
  function getLength(buf, p2) {
    var initial = buf[p2.place++];
    if (!(initial & 128)) {
      return initial;
    }
    var octetLen = initial & 15;
    if (octetLen === 0 || octetLen > 4) {
      return false;
    }
    if (buf[p2.place] === 0) {
      return false;
    }
    var val = 0;
    for (var i4 = 0, off = p2.place; i4 < octetLen; i4++, off++) {
      val <<= 8;
      val |= buf[off];
      val >>>= 0;
    }
    if (val <= 127) {
      return false;
    }
    p2.place = off;
    return val;
  }
  function rmPadding(buf) {
    var i4 = 0;
    var len = buf.length - 1;
    while (!buf[i4] && !(buf[i4 + 1] & 128) && i4 < len) {
      i4++;
    }
    if (i4 === 0) {
      return buf;
    }
    return buf.slice(i4);
  }
  Signature.prototype._importDER = function _importDER(data2, enc) {
    data2 = utils2.toArray(data2, enc);
    var p2 = new Position();
    if (data2[p2.place++] !== 48) {
      return false;
    }
    var len = getLength(data2, p2);
    if (len === false) {
      return false;
    }
    if (len + p2.place !== data2.length) {
      return false;
    }
    if (data2[p2.place++] !== 2) {
      return false;
    }
    var rlen = getLength(data2, p2);
    if (rlen === false) {
      return false;
    }
    if ((data2[p2.place] & 128) !== 0) {
      return false;
    }
    var r2 = data2.slice(p2.place, rlen + p2.place);
    p2.place += rlen;
    if (data2[p2.place++] !== 2) {
      return false;
    }
    var slen = getLength(data2, p2);
    if (slen === false) {
      return false;
    }
    if (data2.length !== slen + p2.place) {
      return false;
    }
    if ((data2[p2.place] & 128) !== 0) {
      return false;
    }
    var s2 = data2.slice(p2.place, slen + p2.place);
    if (r2[0] === 0) {
      if (r2[1] & 128) {
        r2 = r2.slice(1);
      } else {
        return false;
      }
    }
    if (s2[0] === 0) {
      if (s2[1] & 128) {
        s2 = s2.slice(1);
      } else {
        return false;
      }
    }
    this.r = new BN(r2);
    this.s = new BN(s2);
    this.recoveryParam = null;
    return true;
  };
  function constructLength(arr, len) {
    if (len < 128) {
      arr.push(len);
      return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 128);
    while (--octets) {
      arr.push(len >>> (octets << 3) & 255);
    }
    arr.push(len);
  }
  Signature.prototype.toDER = function toDER(enc) {
    var r2 = this.r.toArray();
    var s2 = this.s.toArray();
    if (r2[0] & 128)
      r2 = [0].concat(r2);
    if (s2[0] & 128)
      s2 = [0].concat(s2);
    r2 = rmPadding(r2);
    s2 = rmPadding(s2);
    while (!s2[0] && !(s2[1] & 128)) {
      s2 = s2.slice(1);
    }
    var arr = [2];
    constructLength(arr, r2.length);
    arr = arr.concat(r2);
    arr.push(2);
    constructLength(arr, s2.length);
    var backHalf = arr.concat(s2);
    var res = [48];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils2.encode(res, enc);
  };
  return signature$1;
}
var ec;
var hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var BN = requireBn();
  var HmacDRBG = requireHmacDrbg();
  var utils2 = requireUtils$1();
  var curves2 = requireCurves();
  var rand = requireBrorand();
  var assert2 = utils2.assert;
  var KeyPair = requireKey$1();
  var Signature = requireSignature$1();
  function EC(options) {
    if (!(this instanceof EC))
      return new EC(options);
    if (typeof options === "string") {
      assert2(
        Object.prototype.hasOwnProperty.call(curves2, options),
        "Unknown curve " + options
      );
      options = curves2[options];
    }
    if (options instanceof curves2.PresetCurve)
      options = { curve: options };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  }
  ec = EC;
  EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair(this, options);
  };
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
  };
  EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
  };
  EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};
    var drbg = new HmacDRBG({
      hash: this.hash,
      pers: options.pers,
      persEnc: options.persEnc || "utf8",
      entropy: options.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options.entropy && options.entropyEnc || "utf8",
      nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN(2));
    for (; ; ) {
      var priv = new BN(drbg.generate(bytes));
      if (priv.cmp(ns2) > 0)
        continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    }
  };
  EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
    var byteLength;
    if (BN.isBN(msg) || typeof msg === "number") {
      msg = new BN(msg, 16);
      byteLength = msg.byteLength();
    } else if (typeof msg === "object") {
      byteLength = msg.length;
      msg = new BN(msg, 16);
    } else {
      var str = msg.toString();
      byteLength = str.length + 1 >>> 1;
      msg = new BN(str, 16);
    }
    if (typeof bitLength !== "number") {
      bitLength = byteLength * 8;
    }
    var delta = bitLength - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC.prototype.sign = function sign(msg, key2, enc, options) {
    if (typeof enc === "object") {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
    if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
      assert2(
        typeof msg === "object" && msg && typeof msg.length === "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      );
      assert2(msg.length >>> 0 === msg.length);
      for (var i4 = 0; i4 < msg.length; i4++) assert2((msg[i4] & 255) === msg[i4]);
    }
    key2 = this.keyFromPrivate(key2, enc);
    msg = this._truncateToN(msg, false, options.msgBitLength);
    assert2(!msg.isNeg(), "Can not sign a negative message");
    var bytes = this.n.byteLength();
    var bkey = key2.getPrivate().toArray("be", bytes);
    var nonce = msg.toArray("be", bytes);
    assert2(new BN(nonce).eq(msg), "Can not sign message");
    var drbg = new HmacDRBG({
      hash: this.hash,
      entropy: bkey,
      nonce,
      pers: options.pers,
      persEnc: options.persEnc || "utf8"
    });
    var ns1 = this.n.sub(new BN(1));
    for (var iter = 0; ; iter++) {
      var k2 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
      k2 = this._truncateToN(k2, true);
      if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k2);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r2 = kpX.umod(this.n);
      if (r2.cmpn(0) === 0)
        continue;
      var s2 = k2.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
      s2 = s2.umod(this.n);
      if (s2.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
      if (options.canonical && s2.cmp(this.nh) > 0) {
        s2 = this.n.sub(s2);
        recoveryParam ^= 1;
      }
      return new Signature({ r: r2, s: s2, recoveryParam });
    }
  };
  EC.prototype.verify = function verify(msg, signature2, key2, enc, options) {
    if (!options)
      options = {};
    msg = this._truncateToN(msg, false, options.msgBitLength);
    key2 = this.keyFromPublic(key2, enc);
    signature2 = new Signature(signature2, "hex");
    var r2 = signature2.r;
    var s2 = signature2.s;
    if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
      return false;
    if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
      return false;
    var sinv = s2.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r2).umod(this.n);
    var p2;
    if (!this.curve._maxwellTrick) {
      p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
      if (p2.isInfinity())
        return false;
      return p2.getX().umod(this.n).cmp(r2) === 0;
    }
    p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.eqXToP(r2);
  };
  EC.prototype.recoverPubKey = function(msg, signature2, j2, enc) {
    assert2((3 & j2) === j2, "The recovery param is more than two bits");
    signature2 = new Signature(signature2, enc);
    var n3 = this.n;
    var e2 = new BN(msg);
    var r2 = signature2.r;
    var s2 = signature2.s;
    var isYOdd = j2 & 1;
    var isSecondKey = j2 >> 1;
    if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error("Unable to find sencond key candinate");
    if (isSecondKey)
      r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
    else
      r2 = this.curve.pointFromX(r2, isYOdd);
    var rInv = signature2.r.invm(n3);
    var s1 = n3.sub(e2).mul(rInv).umod(n3);
    var s22 = s2.mul(rInv).umod(n3);
    return this.g.mulAdd(s1, r2, s22);
  };
  EC.prototype.getKeyRecoveryParam = function(e2, signature2, Q2, enc) {
    signature2 = new Signature(signature2, enc);
    if (signature2.recoveryParam !== null)
      return signature2.recoveryParam;
    for (var i4 = 0; i4 < 4; i4++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e2, signature2, i4);
      } catch (e3) {
        continue;
      }
      if (Qprime.eq(Q2))
        return i4;
    }
    throw new Error("Unable to find valid recovery factor");
  };
  return ec;
}
var key;
var hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  var utils2 = requireUtils$1();
  var assert2 = utils2.assert;
  var parseBytes = utils2.parseBytes;
  var cachedProperty = utils2.cachedProperty;
  function KeyPair(eddsa2, params) {
    this.eddsa = eddsa2;
    this._secret = parseBytes(params.secret);
    if (eddsa2.isPoint(params.pub))
      this._pub = params.pub;
    else
      this._pubBytes = parseBytes(params.pub);
  }
  KeyPair.fromPublic = function fromPublic(eddsa2, pub) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(eddsa2, { pub });
  };
  KeyPair.fromSecret = function fromSecret(eddsa2, secret) {
    if (secret instanceof KeyPair)
      return secret;
    return new KeyPair(eddsa2, { secret });
  };
  KeyPair.prototype.secret = function secret() {
    return this._secret;
  };
  cachedProperty(KeyPair, "pubBytes", function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
  });
  cachedProperty(KeyPair, "pub", function pub() {
    if (this._pubBytes)
      return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });
  cachedProperty(KeyPair, "privBytes", function privBytes() {
    var eddsa2 = this.eddsa;
    var hash2 = this.hash();
    var lastIx = eddsa2.encodingLength - 1;
    var a2 = hash2.slice(0, eddsa2.encodingLength);
    a2[0] &= 248;
    a2[lastIx] &= 127;
    a2[lastIx] |= 64;
    return a2;
  });
  cachedProperty(KeyPair, "priv", function priv() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  cachedProperty(KeyPair, "hash", function hash2() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  KeyPair.prototype.sign = function sign(message) {
    assert2(this._secret, "KeyPair can only verify");
    return this.eddsa.sign(message, this);
  };
  KeyPair.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };
  KeyPair.prototype.getSecret = function getSecret(enc) {
    assert2(this._secret, "KeyPair is public only");
    return utils2.encode(this.secret(), enc);
  };
  KeyPair.prototype.getPublic = function getPublic(enc) {
    return utils2.encode(this.pubBytes(), enc);
  };
  key = KeyPair;
  return key;
}
var signature;
var hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  var BN = requireBn();
  var utils2 = requireUtils$1();
  var assert2 = utils2.assert;
  var cachedProperty = utils2.cachedProperty;
  var parseBytes = utils2.parseBytes;
  function Signature(eddsa2, sig) {
    this.eddsa = eddsa2;
    if (typeof sig !== "object")
      sig = parseBytes(sig);
    if (Array.isArray(sig)) {
      assert2(sig.length === eddsa2.encodingLength * 2, "Signature has invalid size");
      sig = {
        R: sig.slice(0, eddsa2.encodingLength),
        S: sig.slice(eddsa2.encodingLength)
      };
    }
    assert2(sig.R && sig.S, "Signature without R or S");
    if (eddsa2.isPoint(sig.R))
      this._R = sig.R;
    if (sig.S instanceof BN)
      this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  }
  cachedProperty(Signature, "S", function S2() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  cachedProperty(Signature, "R", function R2() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  cachedProperty(Signature, "Rencoded", function Rencoded() {
    return this.eddsa.encodePoint(this.R());
  });
  cachedProperty(Signature, "Sencoded", function Sencoded() {
    return this.eddsa.encodeInt(this.S());
  });
  Signature.prototype.toBytes = function toBytes2() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Signature.prototype.toHex = function toHex2() {
    return utils2.encode(this.toBytes(), "hex").toUpperCase();
  };
  signature = Signature;
  return signature;
}
var eddsa;
var hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var hash2 = requireHash();
  var curves2 = requireCurves();
  var utils2 = requireUtils$1();
  var assert2 = utils2.assert;
  var parseBytes = utils2.parseBytes;
  var KeyPair = requireKey();
  var Signature = requireSignature();
  function EDDSA(curve2) {
    assert2(curve2 === "ed25519", "only tested with ed25519 so far");
    if (!(this instanceof EDDSA))
      return new EDDSA(curve2);
    curve2 = curves2[curve2].curve;
    this.curve = curve2;
    this.g = curve2.g;
    this.g.precompute(curve2.n.bitLength() + 1);
    this.pointClass = curve2.point().constructor;
    this.encodingLength = Math.ceil(curve2.n.bitLength() / 8);
    this.hash = hash2.sha512;
  }
  eddsa = EDDSA;
  EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key2 = this.keyFromSecret(secret);
    var r2 = this.hashInt(key2.messagePrefix(), message);
    var R2 = this.g.mul(r2);
    var Rencoded = this.encodePoint(R2);
    var s_ = this.hashInt(Rencoded, key2.pubBytes(), message).mul(key2.priv());
    var S2 = r2.add(s_).umod(this.curve.n);
    return this.makeSignature({ R: R2, S: S2, Rencoded });
  };
  EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
      return false;
    }
    var key2 = this.keyFromPublic(pub);
    var h2 = this.hashInt(sig.Rencoded(), key2.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key2.pub().mul(h2));
    return RplusAh.eq(SG);
  };
  EDDSA.prototype.hashInt = function hashInt() {
    var hash3 = this.hash();
    for (var i4 = 0; i4 < arguments.length; i4++)
      hash3.update(arguments[i4]);
    return utils2.intFromLE(hash3.digest()).umod(this.curve.n);
  };
  EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
  };
  EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
  };
  EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature)
      return sig;
    return new Signature(this, sig);
  };
  EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray("le", this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
    return enc;
  };
  EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils2.parseBytes(bytes);
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129);
    var xIsOdd = (bytes[lastIx] & 128) !== 0;
    var y3 = utils2.intFromLE(normed);
    return this.curve.pointFromY(y3, xIsOdd);
  };
  EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray("le", this.encodingLength);
  };
  EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return utils2.intFromLE(bytes);
  };
  EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
  };
  return eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  if (hasRequiredElliptic) return elliptic;
  hasRequiredElliptic = 1;
  (function(exports) {
    var elliptic2 = exports;
    elliptic2.version = require$$0.version;
    elliptic2.utils = requireUtils$1();
    elliptic2.rand = requireBrorand();
    elliptic2.curve = requireCurve();
    elliptic2.curves = requireCurves();
    elliptic2.ec = requireEc();
    elliptic2.eddsa = requireEddsa();
  })(elliptic);
  return elliptic;
}
requireElliptic();
var ed25519 = {};
var sha512 = {};
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512;
  hasRequiredSha512 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = requireBinary();
    var wipe_1 = requireWipe();
    exports.DIGEST_LENGTH = 64;
    exports.BLOCK_SIZE = 128;
    var SHA5122 = (
      /** @class */
      (function() {
        function SHA5123() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._stateHi = new Int32Array(8);
          this._stateLo = new Int32Array(8);
          this._tempHi = new Int32Array(16);
          this._tempLo = new Int32Array(16);
          this._buffer = new Uint8Array(256);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA5123.prototype._initState = function() {
          this._stateHi[0] = 1779033703;
          this._stateHi[1] = 3144134277;
          this._stateHi[2] = 1013904242;
          this._stateHi[3] = 2773480762;
          this._stateHi[4] = 1359893119;
          this._stateHi[5] = 2600822924;
          this._stateHi[6] = 528734635;
          this._stateHi[7] = 1541459225;
          this._stateLo[0] = 4089235720;
          this._stateLo[1] = 2227873595;
          this._stateLo[2] = 4271175723;
          this._stateLo[3] = 1595750129;
          this._stateLo[4] = 2917565137;
          this._stateLo[5] = 725511199;
          this._stateLo[6] = 4215389547;
          this._stateLo[7] = 327033209;
        };
        SHA5123.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA5123.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._tempHi);
          wipe_1.wipe(this._tempLo);
          this.reset();
        };
        SHA5123.prototype.update = function(data2, dataLength) {
          if (dataLength === void 0) {
            dataLength = data2.length;
          }
          if (this._finished) {
            throw new Error("SHA512: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
              this._buffer[this._bufferLength++] = data2[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data2, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data2[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA5123.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left2 = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 128 < 112 ? 128 : 256;
            this._buffer[left2] = 128;
            for (var i4 = left2 + 1; i4 < padLength - 8; i4++) {
              this._buffer[i4] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i4 = 0; i4 < this.digestLength / 8; i4++) {
            binary_1.writeUint32BE(this._stateHi[i4], out, i4 * 8);
            binary_1.writeUint32BE(this._stateLo[i4], out, i4 * 8 + 4);
          }
          return this;
        };
        SHA5123.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA5123.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA5123.prototype.restoreState = function(savedState) {
          this._stateHi.set(savedState.stateHi);
          this._stateLo.set(savedState.stateLo);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA5123.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.stateHi);
          wipe_1.wipe(savedState.stateLo);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA5123;
      })()
    );
    exports.SHA512 = SHA5122;
    var K2 = new Int32Array([
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ]);
    function hashBlocks(wh, wl, hh, hl, m3, pos, len) {
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var h2, l2;
      var th, tl;
      var a2, b2, c2, d3;
      while (len >= 128) {
        for (var i4 = 0; i4 < 16; i4++) {
          var j2 = 8 * i4 + pos;
          wh[i4] = binary_1.readUint32BE(m3, j2);
          wl[i4] = binary_1.readUint32BE(m3, j2 + 4);
        }
        for (var i4 = 0; i4 < 80; i4++) {
          var bh0 = ah0;
          var bh1 = ah1;
          var bh2 = ah2;
          var bh3 = ah3;
          var bh4 = ah4;
          var bh5 = ah5;
          var bh6 = ah6;
          var bh7 = ah7;
          var bl0 = al0;
          var bl1 = al1;
          var bl2 = al2;
          var bl3 = al3;
          var bl4 = al4;
          var bl5 = al5;
          var bl6 = al6;
          var bl7 = al7;
          h2 = ah7;
          l2 = al7;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d3 = h2 >>> 16;
          h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d3 += h2 >>> 16;
          h2 = ah4 & ah5 ^ ~ah4 & ah6;
          l2 = al4 & al5 ^ ~al4 & al6;
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d3 += h2 >>> 16;
          h2 = K2[i4 * 2];
          l2 = K2[i4 * 2 + 1];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d3 += h2 >>> 16;
          h2 = wh[i4 % 16];
          l2 = wl[i4 % 16];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d3 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d3 += c2 >>> 16;
          th = c2 & 65535 | d3 << 16;
          tl = a2 & 65535 | b2 << 16;
          h2 = th;
          l2 = tl;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d3 = h2 >>> 16;
          h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d3 += h2 >>> 16;
          h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d3 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d3 += c2 >>> 16;
          bh7 = c2 & 65535 | d3 << 16;
          bl7 = a2 & 65535 | b2 << 16;
          h2 = bh3;
          l2 = bl3;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d3 = h2 >>> 16;
          h2 = th;
          l2 = tl;
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d3 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d3 += c2 >>> 16;
          bh3 = c2 & 65535 | d3 << 16;
          bl3 = a2 & 65535 | b2 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i4 % 16 === 15) {
            for (var j2 = 0; j2 < 16; j2++) {
              h2 = wh[j2];
              l2 = wl[j2];
              a2 = l2 & 65535;
              b2 = l2 >>> 16;
              c2 = h2 & 65535;
              d3 = h2 >>> 16;
              h2 = wh[(j2 + 9) % 16];
              l2 = wl[(j2 + 9) % 16];
              a2 += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d3 += h2 >>> 16;
              th = wh[(j2 + 1) % 16];
              tl = wl[(j2 + 1) % 16];
              h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l2 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a2 += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d3 += h2 >>> 16;
              th = wh[(j2 + 14) % 16];
              tl = wl[(j2 + 14) % 16];
              h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l2 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a2 += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d3 += h2 >>> 16;
              b2 += a2 >>> 16;
              c2 += b2 >>> 16;
              d3 += c2 >>> 16;
              wh[j2] = c2 & 65535 | d3 << 16;
              wl[j2] = a2 & 65535 | b2 << 16;
            }
          }
        }
        h2 = ah0;
        l2 = al0;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d3 = h2 >>> 16;
        h2 = hh[0];
        l2 = hl[0];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d3 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[0] = ah0 = c2 & 65535 | d3 << 16;
        hl[0] = al0 = a2 & 65535 | b2 << 16;
        h2 = ah1;
        l2 = al1;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d3 = h2 >>> 16;
        h2 = hh[1];
        l2 = hl[1];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d3 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[1] = ah1 = c2 & 65535 | d3 << 16;
        hl[1] = al1 = a2 & 65535 | b2 << 16;
        h2 = ah2;
        l2 = al2;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d3 = h2 >>> 16;
        h2 = hh[2];
        l2 = hl[2];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d3 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[2] = ah2 = c2 & 65535 | d3 << 16;
        hl[2] = al2 = a2 & 65535 | b2 << 16;
        h2 = ah3;
        l2 = al3;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d3 = h2 >>> 16;
        h2 = hh[3];
        l2 = hl[3];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d3 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[3] = ah3 = c2 & 65535 | d3 << 16;
        hl[3] = al3 = a2 & 65535 | b2 << 16;
        h2 = ah4;
        l2 = al4;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d3 = h2 >>> 16;
        h2 = hh[4];
        l2 = hl[4];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d3 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[4] = ah4 = c2 & 65535 | d3 << 16;
        hl[4] = al4 = a2 & 65535 | b2 << 16;
        h2 = ah5;
        l2 = al5;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d3 = h2 >>> 16;
        h2 = hh[5];
        l2 = hl[5];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d3 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[5] = ah5 = c2 & 65535 | d3 << 16;
        hl[5] = al5 = a2 & 65535 | b2 << 16;
        h2 = ah6;
        l2 = al6;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d3 = h2 >>> 16;
        h2 = hh[6];
        l2 = hl[6];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d3 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[6] = ah6 = c2 & 65535 | d3 << 16;
        hl[6] = al6 = a2 & 65535 | b2 << 16;
        h2 = ah7;
        l2 = al7;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d3 = h2 >>> 16;
        h2 = hh[7];
        l2 = hl[7];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d3 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d3 += c2 >>> 16;
        hh[7] = ah7 = c2 & 65535 | d3 << 16;
        hl[7] = al7 = a2 & 65535 | b2 << 16;
        pos += 128;
        len -= 128;
      }
      return pos;
    }
    function hash2(data2) {
      var h2 = new SHA5122();
      h2.update(data2);
      var digest = h2.digest();
      h2.clean();
      return digest;
    }
    exports.hash = hash2;
  })(sha512);
  return sha512;
}
var hasRequiredEd25519;
function requireEd25519() {
  if (hasRequiredEd25519) return ed25519;
  hasRequiredEd25519 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertSecretKeyToX25519 = exports.convertPublicKeyToX25519 = exports.verify = exports.sign = exports.extractPublicKeyFromSecretKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.SEED_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = exports.SIGNATURE_LENGTH = void 0;
    const random_1 = requireRandom();
    const sha512_1 = requireSha512();
    const wipe_1 = requireWipe();
    exports.SIGNATURE_LENGTH = 64;
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 64;
    exports.SEED_LENGTH = 32;
    function gf2(init2) {
      const r2 = new Float64Array(16);
      if (init2) {
        for (let i4 = 0; i4 < init2.length; i4++) {
          r2[i4] = init2[i4];
        }
      }
      return r2;
    }
    const _9 = new Uint8Array(32);
    _9[0] = 9;
    const gf0 = gf2();
    const gf1 = gf2([1]);
    const D = gf2([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    const D2 = gf2([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    const X = gf2([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    const Y = gf2([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    const I2 = gf2([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function set25519(r2, a2) {
      for (let i4 = 0; i4 < 16; i4++) {
        r2[i4] = a2[i4] | 0;
      }
    }
    function car25519(o2) {
      let c2 = 1;
      for (let i4 = 0; i4 < 16; i4++) {
        let v2 = o2[i4] + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        o2[i4] = v2 - c2 * 65536;
      }
      o2[0] += c2 - 1 + 37 * (c2 - 1);
    }
    function sel25519(p2, q, b2) {
      const c2 = ~(b2 - 1);
      for (let i4 = 0; i4 < 16; i4++) {
        const t2 = c2 & (p2[i4] ^ q[i4]);
        p2[i4] ^= t2;
        q[i4] ^= t2;
      }
    }
    function pack25519(o2, n3) {
      const m3 = gf2();
      const t2 = gf2();
      for (let i4 = 0; i4 < 16; i4++) {
        t2[i4] = n3[i4];
      }
      car25519(t2);
      car25519(t2);
      car25519(t2);
      for (let j2 = 0; j2 < 2; j2++) {
        m3[0] = t2[0] - 65517;
        for (let i4 = 1; i4 < 15; i4++) {
          m3[i4] = t2[i4] - 65535 - (m3[i4 - 1] >> 16 & 1);
          m3[i4 - 1] &= 65535;
        }
        m3[15] = t2[15] - 32767 - (m3[14] >> 16 & 1);
        const b2 = m3[15] >> 16 & 1;
        m3[14] &= 65535;
        sel25519(t2, m3, 1 - b2);
      }
      for (let i4 = 0; i4 < 16; i4++) {
        o2[2 * i4] = t2[i4] & 255;
        o2[2 * i4 + 1] = t2[i4] >> 8;
      }
    }
    function verify32(x2, y3) {
      let d3 = 0;
      for (let i4 = 0; i4 < 32; i4++) {
        d3 |= x2[i4] ^ y3[i4];
      }
      return (1 & d3 - 1 >>> 8) - 1;
    }
    function neq25519(a2, b2) {
      const c2 = new Uint8Array(32);
      const d3 = new Uint8Array(32);
      pack25519(c2, a2);
      pack25519(d3, b2);
      return verify32(c2, d3);
    }
    function par25519(a2) {
      const d3 = new Uint8Array(32);
      pack25519(d3, a2);
      return d3[0] & 1;
    }
    function unpack25519(o2, n3) {
      for (let i4 = 0; i4 < 16; i4++) {
        o2[i4] = n3[2 * i4] + (n3[2 * i4 + 1] << 8);
      }
      o2[15] &= 32767;
    }
    function add2(o2, a2, b2) {
      for (let i4 = 0; i4 < 16; i4++) {
        o2[i4] = a2[i4] + b2[i4];
      }
    }
    function sub(o2, a2, b2) {
      for (let i4 = 0; i4 < 16; i4++) {
        o2[i4] = a2[i4] - b2[i4];
      }
    }
    function mul(o2, a2, b2) {
      let v2, c2, t02 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b02 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v2 = a2[0];
      t02 += v2 * b02;
      t1 += v2 * b1;
      t2 += v2 * b22;
      t3 += v2 * b3;
      t4 += v2 * b4;
      t5 += v2 * b5;
      t6 += v2 * b6;
      t7 += v2 * b7;
      t8 += v2 * b8;
      t9 += v2 * b9;
      t10 += v2 * b10;
      t11 += v2 * b11;
      t12 += v2 * b12;
      t13 += v2 * b13;
      t14 += v2 * b14;
      t15 += v2 * b15;
      v2 = a2[1];
      t1 += v2 * b02;
      t2 += v2 * b1;
      t3 += v2 * b22;
      t4 += v2 * b3;
      t5 += v2 * b4;
      t6 += v2 * b5;
      t7 += v2 * b6;
      t8 += v2 * b7;
      t9 += v2 * b8;
      t10 += v2 * b9;
      t11 += v2 * b10;
      t12 += v2 * b11;
      t13 += v2 * b12;
      t14 += v2 * b13;
      t15 += v2 * b14;
      t16 += v2 * b15;
      v2 = a2[2];
      t2 += v2 * b02;
      t3 += v2 * b1;
      t4 += v2 * b22;
      t5 += v2 * b3;
      t6 += v2 * b4;
      t7 += v2 * b5;
      t8 += v2 * b6;
      t9 += v2 * b7;
      t10 += v2 * b8;
      t11 += v2 * b9;
      t12 += v2 * b10;
      t13 += v2 * b11;
      t14 += v2 * b12;
      t15 += v2 * b13;
      t16 += v2 * b14;
      t17 += v2 * b15;
      v2 = a2[3];
      t3 += v2 * b02;
      t4 += v2 * b1;
      t5 += v2 * b22;
      t6 += v2 * b3;
      t7 += v2 * b4;
      t8 += v2 * b5;
      t9 += v2 * b6;
      t10 += v2 * b7;
      t11 += v2 * b8;
      t12 += v2 * b9;
      t13 += v2 * b10;
      t14 += v2 * b11;
      t15 += v2 * b12;
      t16 += v2 * b13;
      t17 += v2 * b14;
      t18 += v2 * b15;
      v2 = a2[4];
      t4 += v2 * b02;
      t5 += v2 * b1;
      t6 += v2 * b22;
      t7 += v2 * b3;
      t8 += v2 * b4;
      t9 += v2 * b5;
      t10 += v2 * b6;
      t11 += v2 * b7;
      t12 += v2 * b8;
      t13 += v2 * b9;
      t14 += v2 * b10;
      t15 += v2 * b11;
      t16 += v2 * b12;
      t17 += v2 * b13;
      t18 += v2 * b14;
      t19 += v2 * b15;
      v2 = a2[5];
      t5 += v2 * b02;
      t6 += v2 * b1;
      t7 += v2 * b22;
      t8 += v2 * b3;
      t9 += v2 * b4;
      t10 += v2 * b5;
      t11 += v2 * b6;
      t12 += v2 * b7;
      t13 += v2 * b8;
      t14 += v2 * b9;
      t15 += v2 * b10;
      t16 += v2 * b11;
      t17 += v2 * b12;
      t18 += v2 * b13;
      t19 += v2 * b14;
      t20 += v2 * b15;
      v2 = a2[6];
      t6 += v2 * b02;
      t7 += v2 * b1;
      t8 += v2 * b22;
      t9 += v2 * b3;
      t10 += v2 * b4;
      t11 += v2 * b5;
      t12 += v2 * b6;
      t13 += v2 * b7;
      t14 += v2 * b8;
      t15 += v2 * b9;
      t16 += v2 * b10;
      t17 += v2 * b11;
      t18 += v2 * b12;
      t19 += v2 * b13;
      t20 += v2 * b14;
      t21 += v2 * b15;
      v2 = a2[7];
      t7 += v2 * b02;
      t8 += v2 * b1;
      t9 += v2 * b22;
      t10 += v2 * b3;
      t11 += v2 * b4;
      t12 += v2 * b5;
      t13 += v2 * b6;
      t14 += v2 * b7;
      t15 += v2 * b8;
      t16 += v2 * b9;
      t17 += v2 * b10;
      t18 += v2 * b11;
      t19 += v2 * b12;
      t20 += v2 * b13;
      t21 += v2 * b14;
      t22 += v2 * b15;
      v2 = a2[8];
      t8 += v2 * b02;
      t9 += v2 * b1;
      t10 += v2 * b22;
      t11 += v2 * b3;
      t12 += v2 * b4;
      t13 += v2 * b5;
      t14 += v2 * b6;
      t15 += v2 * b7;
      t16 += v2 * b8;
      t17 += v2 * b9;
      t18 += v2 * b10;
      t19 += v2 * b11;
      t20 += v2 * b12;
      t21 += v2 * b13;
      t22 += v2 * b14;
      t23 += v2 * b15;
      v2 = a2[9];
      t9 += v2 * b02;
      t10 += v2 * b1;
      t11 += v2 * b22;
      t12 += v2 * b3;
      t13 += v2 * b4;
      t14 += v2 * b5;
      t15 += v2 * b6;
      t16 += v2 * b7;
      t17 += v2 * b8;
      t18 += v2 * b9;
      t19 += v2 * b10;
      t20 += v2 * b11;
      t21 += v2 * b12;
      t22 += v2 * b13;
      t23 += v2 * b14;
      t24 += v2 * b15;
      v2 = a2[10];
      t10 += v2 * b02;
      t11 += v2 * b1;
      t12 += v2 * b22;
      t13 += v2 * b3;
      t14 += v2 * b4;
      t15 += v2 * b5;
      t16 += v2 * b6;
      t17 += v2 * b7;
      t18 += v2 * b8;
      t19 += v2 * b9;
      t20 += v2 * b10;
      t21 += v2 * b11;
      t22 += v2 * b12;
      t23 += v2 * b13;
      t24 += v2 * b14;
      t25 += v2 * b15;
      v2 = a2[11];
      t11 += v2 * b02;
      t12 += v2 * b1;
      t13 += v2 * b22;
      t14 += v2 * b3;
      t15 += v2 * b4;
      t16 += v2 * b5;
      t17 += v2 * b6;
      t18 += v2 * b7;
      t19 += v2 * b8;
      t20 += v2 * b9;
      t21 += v2 * b10;
      t22 += v2 * b11;
      t23 += v2 * b12;
      t24 += v2 * b13;
      t25 += v2 * b14;
      t26 += v2 * b15;
      v2 = a2[12];
      t12 += v2 * b02;
      t13 += v2 * b1;
      t14 += v2 * b22;
      t15 += v2 * b3;
      t16 += v2 * b4;
      t17 += v2 * b5;
      t18 += v2 * b6;
      t19 += v2 * b7;
      t20 += v2 * b8;
      t21 += v2 * b9;
      t22 += v2 * b10;
      t23 += v2 * b11;
      t24 += v2 * b12;
      t25 += v2 * b13;
      t26 += v2 * b14;
      t27 += v2 * b15;
      v2 = a2[13];
      t13 += v2 * b02;
      t14 += v2 * b1;
      t15 += v2 * b22;
      t16 += v2 * b3;
      t17 += v2 * b4;
      t18 += v2 * b5;
      t19 += v2 * b6;
      t20 += v2 * b7;
      t21 += v2 * b8;
      t22 += v2 * b9;
      t23 += v2 * b10;
      t24 += v2 * b11;
      t25 += v2 * b12;
      t26 += v2 * b13;
      t27 += v2 * b14;
      t28 += v2 * b15;
      v2 = a2[14];
      t14 += v2 * b02;
      t15 += v2 * b1;
      t16 += v2 * b22;
      t17 += v2 * b3;
      t18 += v2 * b4;
      t19 += v2 * b5;
      t20 += v2 * b6;
      t21 += v2 * b7;
      t22 += v2 * b8;
      t23 += v2 * b9;
      t24 += v2 * b10;
      t25 += v2 * b11;
      t26 += v2 * b12;
      t27 += v2 * b13;
      t28 += v2 * b14;
      t29 += v2 * b15;
      v2 = a2[15];
      t15 += v2 * b02;
      t16 += v2 * b1;
      t17 += v2 * b22;
      t18 += v2 * b3;
      t19 += v2 * b4;
      t20 += v2 * b5;
      t21 += v2 * b6;
      t22 += v2 * b7;
      t23 += v2 * b8;
      t24 += v2 * b9;
      t25 += v2 * b10;
      t26 += v2 * b11;
      t27 += v2 * b12;
      t28 += v2 * b13;
      t29 += v2 * b14;
      t30 += v2 * b15;
      t02 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v2 = t02 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t02 = v2 - c2 * 65536;
      v2 = t1 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t1 = v2 - c2 * 65536;
      v2 = t2 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t2 = v2 - c2 * 65536;
      v2 = t3 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t3 = v2 - c2 * 65536;
      v2 = t4 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t4 = v2 - c2 * 65536;
      v2 = t5 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t5 = v2 - c2 * 65536;
      v2 = t6 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t6 = v2 - c2 * 65536;
      v2 = t7 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t7 = v2 - c2 * 65536;
      v2 = t8 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t8 = v2 - c2 * 65536;
      v2 = t9 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t9 = v2 - c2 * 65536;
      v2 = t10 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t10 = v2 - c2 * 65536;
      v2 = t11 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t11 = v2 - c2 * 65536;
      v2 = t12 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t12 = v2 - c2 * 65536;
      v2 = t13 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t13 = v2 - c2 * 65536;
      v2 = t14 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t14 = v2 - c2 * 65536;
      v2 = t15 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t15 = v2 - c2 * 65536;
      t02 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v2 = t02 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t02 = v2 - c2 * 65536;
      v2 = t1 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t1 = v2 - c2 * 65536;
      v2 = t2 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t2 = v2 - c2 * 65536;
      v2 = t3 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t3 = v2 - c2 * 65536;
      v2 = t4 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t4 = v2 - c2 * 65536;
      v2 = t5 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t5 = v2 - c2 * 65536;
      v2 = t6 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t6 = v2 - c2 * 65536;
      v2 = t7 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t7 = v2 - c2 * 65536;
      v2 = t8 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t8 = v2 - c2 * 65536;
      v2 = t9 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t9 = v2 - c2 * 65536;
      v2 = t10 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t10 = v2 - c2 * 65536;
      v2 = t11 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t11 = v2 - c2 * 65536;
      v2 = t12 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t12 = v2 - c2 * 65536;
      v2 = t13 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t13 = v2 - c2 * 65536;
      v2 = t14 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t14 = v2 - c2 * 65536;
      v2 = t15 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t15 = v2 - c2 * 65536;
      t02 += c2 - 1 + 37 * (c2 - 1);
      o2[0] = t02;
      o2[1] = t1;
      o2[2] = t2;
      o2[3] = t3;
      o2[4] = t4;
      o2[5] = t5;
      o2[6] = t6;
      o2[7] = t7;
      o2[8] = t8;
      o2[9] = t9;
      o2[10] = t10;
      o2[11] = t11;
      o2[12] = t12;
      o2[13] = t13;
      o2[14] = t14;
      o2[15] = t15;
    }
    function square(o2, a2) {
      mul(o2, a2, a2);
    }
    function inv25519(o2, i4) {
      const c2 = gf2();
      let a2;
      for (a2 = 0; a2 < 16; a2++) {
        c2[a2] = i4[a2];
      }
      for (a2 = 253; a2 >= 0; a2--) {
        square(c2, c2);
        if (a2 !== 2 && a2 !== 4) {
          mul(c2, c2, i4);
        }
      }
      for (a2 = 0; a2 < 16; a2++) {
        o2[a2] = c2[a2];
      }
    }
    function pow2523(o2, i4) {
      const c2 = gf2();
      let a2;
      for (a2 = 0; a2 < 16; a2++) {
        c2[a2] = i4[a2];
      }
      for (a2 = 250; a2 >= 0; a2--) {
        square(c2, c2);
        if (a2 !== 1) {
          mul(c2, c2, i4);
        }
      }
      for (a2 = 0; a2 < 16; a2++) {
        o2[a2] = c2[a2];
      }
    }
    function edadd(p2, q) {
      const a2 = gf2(), b2 = gf2(), c2 = gf2(), d3 = gf2(), e2 = gf2(), f2 = gf2(), g2 = gf2(), h2 = gf2(), t2 = gf2();
      sub(a2, p2[1], p2[0]);
      sub(t2, q[1], q[0]);
      mul(a2, a2, t2);
      add2(b2, p2[0], p2[1]);
      add2(t2, q[0], q[1]);
      mul(b2, b2, t2);
      mul(c2, p2[3], q[3]);
      mul(c2, c2, D2);
      mul(d3, p2[2], q[2]);
      add2(d3, d3, d3);
      sub(e2, b2, a2);
      sub(f2, d3, c2);
      add2(g2, d3, c2);
      add2(h2, b2, a2);
      mul(p2[0], e2, f2);
      mul(p2[1], h2, g2);
      mul(p2[2], g2, f2);
      mul(p2[3], e2, h2);
    }
    function cswap(p2, q, b2) {
      for (let i4 = 0; i4 < 4; i4++) {
        sel25519(p2[i4], q[i4], b2);
      }
    }
    function pack(r2, p2) {
      const tx = gf2(), ty = gf2(), zi2 = gf2();
      inv25519(zi2, p2[2]);
      mul(tx, p2[0], zi2);
      mul(ty, p2[1], zi2);
      pack25519(r2, ty);
      r2[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p2, q, s2) {
      set25519(p2[0], gf0);
      set25519(p2[1], gf1);
      set25519(p2[2], gf1);
      set25519(p2[3], gf0);
      for (let i4 = 255; i4 >= 0; --i4) {
        const b2 = s2[i4 / 8 | 0] >> (i4 & 7) & 1;
        cswap(p2, q, b2);
        edadd(q, p2);
        edadd(p2, p2);
        cswap(p2, q, b2);
      }
    }
    function scalarbase(p2, s2) {
      const q = [gf2(), gf2(), gf2(), gf2()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      mul(q[3], X, Y);
      scalarmult(p2, q, s2);
    }
    function generateKeyPairFromSeed(seed) {
      if (seed.length !== exports.SEED_LENGTH) {
        throw new Error(`ed25519: seed must be ${exports.SEED_LENGTH} bytes`);
      }
      const d3 = (0, sha512_1.hash)(seed);
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      const publicKey = new Uint8Array(32);
      const p2 = [gf2(), gf2(), gf2(), gf2()];
      scalarbase(p2, d3);
      pack(publicKey, p2);
      const secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
    function generateKeyPair(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports.generateKeyPair = generateKeyPair;
    function extractPublicKeyFromSecretKey(secretKey) {
      if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`ed25519: secret key must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      return new Uint8Array(secretKey.subarray(32));
    }
    exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    const L3 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function modL(r2, x2) {
      let carry;
      let i4;
      let j2;
      let k2;
      for (i4 = 63; i4 >= 32; --i4) {
        carry = 0;
        for (j2 = i4 - 32, k2 = i4 - 12; j2 < k2; ++j2) {
          x2[j2] += carry - 16 * x2[i4] * L3[j2 - (i4 - 32)];
          carry = Math.floor((x2[j2] + 128) / 256);
          x2[j2] -= carry * 256;
        }
        x2[j2] += carry;
        x2[i4] = 0;
      }
      carry = 0;
      for (j2 = 0; j2 < 32; j2++) {
        x2[j2] += carry - (x2[31] >> 4) * L3[j2];
        carry = x2[j2] >> 8;
        x2[j2] &= 255;
      }
      for (j2 = 0; j2 < 32; j2++) {
        x2[j2] -= carry * L3[j2];
      }
      for (i4 = 0; i4 < 32; i4++) {
        x2[i4 + 1] += x2[i4] >> 8;
        r2[i4] = x2[i4] & 255;
      }
    }
    function reduce(r2) {
      const x2 = new Float64Array(64);
      for (let i4 = 0; i4 < 64; i4++) {
        x2[i4] = r2[i4];
      }
      for (let i4 = 0; i4 < 64; i4++) {
        r2[i4] = 0;
      }
      modL(r2, x2);
    }
    function sign(secretKey, message) {
      const x2 = new Float64Array(64);
      const p2 = [gf2(), gf2(), gf2(), gf2()];
      const d3 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      const signature2 = new Uint8Array(64);
      signature2.set(d3.subarray(32), 32);
      const hs = new sha512_1.SHA512();
      hs.update(signature2.subarray(32));
      hs.update(message);
      const r2 = hs.digest();
      hs.clean();
      reduce(r2);
      scalarbase(p2, r2);
      pack(signature2, p2);
      hs.reset();
      hs.update(signature2.subarray(0, 32));
      hs.update(secretKey.subarray(32));
      hs.update(message);
      const h2 = hs.digest();
      reduce(h2);
      for (let i4 = 0; i4 < 32; i4++) {
        x2[i4] = r2[i4];
      }
      for (let i4 = 0; i4 < 32; i4++) {
        for (let j2 = 0; j2 < 32; j2++) {
          x2[i4 + j2] += h2[i4] * d3[j2];
        }
      }
      modL(signature2.subarray(32), x2);
      return signature2;
    }
    exports.sign = sign;
    function unpackneg(r2, p2) {
      const t2 = gf2(), chk = gf2(), num = gf2(), den = gf2(), den2 = gf2(), den4 = gf2(), den6 = gf2();
      set25519(r2[2], gf1);
      unpack25519(r2[1], p2);
      square(num, r2[1]);
      mul(den, num, D);
      sub(num, num, r2[2]);
      add2(den, r2[2], den);
      square(den2, den);
      square(den4, den2);
      mul(den6, den4, den2);
      mul(t2, den6, num);
      mul(t2, t2, den);
      pow2523(t2, t2);
      mul(t2, t2, num);
      mul(t2, t2, den);
      mul(t2, t2, den);
      mul(r2[0], t2, den);
      square(chk, r2[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        mul(r2[0], r2[0], I2);
      }
      square(chk, r2[0]);
      mul(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r2[0]) === p2[31] >> 7) {
        sub(r2[0], gf0, r2[0]);
      }
      mul(r2[3], r2[0], r2[1]);
      return 0;
    }
    function verify(publicKey, message, signature2) {
      const t2 = new Uint8Array(32);
      const p2 = [gf2(), gf2(), gf2(), gf2()];
      const q = [gf2(), gf2(), gf2(), gf2()];
      if (signature2.length !== exports.SIGNATURE_LENGTH) {
        throw new Error(`ed25519: signature must be ${exports.SIGNATURE_LENGTH} bytes`);
      }
      if (unpackneg(q, publicKey)) {
        return false;
      }
      const hs = new sha512_1.SHA512();
      hs.update(signature2.subarray(0, 32));
      hs.update(publicKey);
      hs.update(message);
      const h2 = hs.digest();
      reduce(h2);
      scalarmult(p2, q, h2);
      scalarbase(q, signature2.subarray(32));
      edadd(p2, q);
      pack(t2, p2);
      if (verify32(signature2, t2)) {
        return false;
      }
      return true;
    }
    exports.verify = verify;
    function convertPublicKeyToX25519(publicKey) {
      let q = [gf2(), gf2(), gf2(), gf2()];
      if (unpackneg(q, publicKey)) {
        throw new Error("Ed25519: invalid public key");
      }
      let a2 = gf2();
      let b2 = gf2();
      let y3 = q[1];
      add2(a2, gf1, y3);
      sub(b2, gf1, y3);
      inv25519(b2, b2);
      mul(a2, a2, b2);
      let z3 = new Uint8Array(32);
      pack25519(z3, a2);
      return z3;
    }
    exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
    function convertSecretKeyToX25519(secretKey) {
      const d3 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d3[0] &= 248;
      d3[31] &= 127;
      d3[31] |= 64;
      const o2 = new Uint8Array(d3.subarray(0, 32));
      (0, wipe_1.wipe)(d3);
      return o2;
    }
    exports.convertSecretKeyToX25519 = convertSecretKeyToX25519;
  })(ed25519);
  return ed25519;
}
requireEd25519();
const Rr = ":";
function An(e2) {
  const { namespace: t2, reference: r2 } = e2;
  return [t2, r2].join(Rr);
}
function gi(e2) {
  const [t2, r2, i4] = e2.split(Rr);
  return { namespace: t2, reference: r2, address: i4 };
}
function mi(e2, t2) {
  const r2 = [];
  return e2.forEach((i4) => {
    const n3 = t2(i4);
    r2.includes(n3) || r2.push(n3);
  }), r2;
}
function wn(e2) {
  const { namespace: t2, reference: r2 } = gi(e2);
  return An({ namespace: t2, reference: r2 });
}
function xn(e2) {
  return mi(e2, wn);
}
var Tn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
function Es(e2) {
  var t2 = e2.default;
  if (typeof t2 == "function") {
    var r2 = function() {
      return t2.apply(this, arguments);
    };
    r2.prototype = t2.prototype;
  } else r2 = {};
  return Object.defineProperty(r2, "__esModule", { value: true }), Object.keys(e2).forEach(function(i4) {
    var n3 = Object.getOwnPropertyDescriptor(e2, i4);
    Object.defineProperty(r2, i4, n3.get ? n3 : { enumerable: true, get: function() {
      return e2[i4];
    } });
  }), r2;
}
var Un = { exports: {} };
/**
* [js-sha3]{@link https://github.com/emn178/js-sha3}
*
* @version 0.8.0
* @author Chen, Yi-Cyuan [emn178@gmail.com]
* @copyright Chen, Yi-Cyuan 2015-2018
* @license MIT
*/
(function(e2) {
  (function() {
    var t2 = "input is invalid type", r2 = "finalize already called", i4 = typeof window == "object", n3 = i4 ? window : {};
    n3.JS_SHA3_NO_WINDOW && (i4 = false);
    var o2 = !i4 && typeof self == "object", h2 = !n3.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    h2 ? n3 = Tn : o2 && (n3 = self);
    var p2 = !n3.JS_SHA3_NO_COMMON_JS && true && e2.exports, A2 = !n3.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", v2 = "0123456789abcdef".split(""), w2 = [31, 7936, 2031616, 520093696], y3 = [4, 1024, 262144, 67108864], S2 = [1, 256, 65536, 16777216], I2 = [6, 1536, 393216, 100663296], N2 = [0, 8, 16, 24], C2 = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648], F = [224, 256, 384, 512], U = [128, 256], J = ["hex", "buffer", "arrayBuffer", "array", "digest"], Bt = { 128: 168, 256: 136 };
    (n3.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(u2) {
      return Object.prototype.toString.call(u2) === "[object Array]";
    }), A2 && (n3.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(u2) {
      return typeof u2 == "object" && u2.buffer && u2.buffer.constructor === ArrayBuffer;
    });
    for (var G = function(u2, E2, _2) {
      return function(B3) {
        return new s2(u2, E2, u2).update(B3)[_2]();
      };
    }, H2 = function(u2, E2, _2) {
      return function(B3, R2) {
        return new s2(u2, E2, R2).update(B3)[_2]();
      };
    }, L3 = function(u2, E2, _2) {
      return function(B3, R2, T2, P2) {
        return f2["cshake" + u2].update(B3, R2, T2, P2)[_2]();
      };
    }, Pt = function(u2, E2, _2) {
      return function(B3, R2, T2, P2) {
        return f2["kmac" + u2].update(B3, R2, T2, P2)[_2]();
      };
    }, W = function(u2, E2, _2, B3) {
      for (var R2 = 0; R2 < J.length; ++R2) {
        var T2 = J[R2];
        u2[T2] = E2(_2, B3, T2);
      }
      return u2;
    }, Rt = function(u2, E2) {
      var _2 = G(u2, E2, "hex");
      return _2.create = function() {
        return new s2(u2, E2, u2);
      }, _2.update = function(B3) {
        return _2.create().update(B3);
      }, W(_2, G, u2, E2);
    }, Vt = function(u2, E2) {
      var _2 = H2(u2, E2, "hex");
      return _2.create = function(B3) {
        return new s2(u2, E2, B3);
      }, _2.update = function(B3, R2) {
        return _2.create(R2).update(B3);
      }, W(_2, H2, u2, E2);
    }, Y = function(u2, E2) {
      var _2 = Bt[u2], B3 = L3(u2, E2, "hex");
      return B3.create = function(R2, T2, P2) {
        return !T2 && !P2 ? f2["shake" + u2].create(R2) : new s2(u2, E2, R2).bytepad([T2, P2], _2);
      }, B3.update = function(R2, T2, P2, O2) {
        return B3.create(T2, P2, O2).update(R2);
      }, W(B3, L3, u2, E2);
    }, Wt = function(u2, E2) {
      var _2 = Bt[u2], B3 = Pt(u2, E2, "hex");
      return B3.create = function(R2, T2, P2) {
        return new g2(u2, E2, T2).bytepad(["KMAC", P2], _2).bytepad([R2], _2);
      }, B3.update = function(R2, T2, P2, O2) {
        return B3.create(R2, P2, O2).update(T2);
      }, W(B3, Pt, u2, E2);
    }, b2 = [{ name: "keccak", padding: S2, bits: F, createMethod: Rt }, { name: "sha3", padding: I2, bits: F, createMethod: Rt }, { name: "shake", padding: w2, bits: U, createMethod: Vt }, { name: "cshake", padding: y3, bits: U, createMethod: Y }, { name: "kmac", padding: y3, bits: U, createMethod: Wt }], f2 = {}, a2 = [], c2 = 0; c2 < b2.length; ++c2) for (var d3 = b2[c2], m3 = d3.bits, x2 = 0; x2 < m3.length; ++x2) {
      var M2 = d3.name + "_" + m3[x2];
      if (a2.push(M2), f2[M2] = d3.createMethod(m3[x2], d3.padding), d3.name !== "sha3") {
        var l2 = d3.name + m3[x2];
        a2.push(l2), f2[l2] = f2[M2];
      }
    }
    function s2(u2, E2, _2) {
      this.blocks = [], this.s = [], this.padding = E2, this.outputBits = _2, this.reset = true, this.finalized = false, this.block = 0, this.start = 0, this.blockCount = 1600 - (u2 << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = _2 >> 5, this.extraBytes = (_2 & 31) >> 3;
      for (var B3 = 0; B3 < 50; ++B3) this.s[B3] = 0;
    }
    s2.prototype.update = function(u2) {
      if (this.finalized) throw new Error(r2);
      var E2, _2 = typeof u2;
      if (_2 !== "string") {
        if (_2 === "object") {
          if (u2 === null) throw new Error(t2);
          if (A2 && u2.constructor === ArrayBuffer) u2 = new Uint8Array(u2);
          else if (!Array.isArray(u2) && (!A2 || !ArrayBuffer.isView(u2))) throw new Error(t2);
        } else throw new Error(t2);
        E2 = true;
      }
      for (var B3 = this.blocks, R2 = this.byteCount, T2 = u2.length, P2 = this.blockCount, O2 = 0, Ct = this.s, D, q; O2 < T2; ) {
        if (this.reset) for (this.reset = false, B3[0] = this.block, D = 1; D < P2 + 1; ++D) B3[D] = 0;
        if (E2) for (D = this.start; O2 < T2 && D < R2; ++O2) B3[D >> 2] |= u2[O2] << N2[D++ & 3];
        else for (D = this.start; O2 < T2 && D < R2; ++O2) q = u2.charCodeAt(O2), q < 128 ? B3[D >> 2] |= q << N2[D++ & 3] : q < 2048 ? (B3[D >> 2] |= (192 | q >> 6) << N2[D++ & 3], B3[D >> 2] |= (128 | q & 63) << N2[D++ & 3]) : q < 55296 || q >= 57344 ? (B3[D >> 2] |= (224 | q >> 12) << N2[D++ & 3], B3[D >> 2] |= (128 | q >> 6 & 63) << N2[D++ & 3], B3[D >> 2] |= (128 | q & 63) << N2[D++ & 3]) : (q = 65536 + ((q & 1023) << 10 | u2.charCodeAt(++O2) & 1023), B3[D >> 2] |= (240 | q >> 18) << N2[D++ & 3], B3[D >> 2] |= (128 | q >> 12 & 63) << N2[D++ & 3], B3[D >> 2] |= (128 | q >> 6 & 63) << N2[D++ & 3], B3[D >> 2] |= (128 | q & 63) << N2[D++ & 3]);
        if (this.lastByteIndex = D, D >= R2) {
          for (this.start = D - R2, this.block = B3[P2], D = 0; D < P2; ++D) Ct[D] ^= B3[D];
          k2(Ct), this.reset = true;
        } else this.start = D;
      }
      return this;
    }, s2.prototype.encode = function(u2, E2) {
      var _2 = u2 & 255, B3 = 1, R2 = [_2];
      for (u2 = u2 >> 8, _2 = u2 & 255; _2 > 0; ) R2.unshift(_2), u2 = u2 >> 8, _2 = u2 & 255, ++B3;
      return E2 ? R2.push(B3) : R2.unshift(B3), this.update(R2), R2.length;
    }, s2.prototype.encodeString = function(u2) {
      var E2, _2 = typeof u2;
      if (_2 !== "string") {
        if (_2 === "object") {
          if (u2 === null) throw new Error(t2);
          if (A2 && u2.constructor === ArrayBuffer) u2 = new Uint8Array(u2);
          else if (!Array.isArray(u2) && (!A2 || !ArrayBuffer.isView(u2))) throw new Error(t2);
        } else throw new Error(t2);
        E2 = true;
      }
      var B3 = 0, R2 = u2.length;
      if (E2) B3 = R2;
      else for (var T2 = 0; T2 < u2.length; ++T2) {
        var P2 = u2.charCodeAt(T2);
        P2 < 128 ? B3 += 1 : P2 < 2048 ? B3 += 2 : P2 < 55296 || P2 >= 57344 ? B3 += 3 : (P2 = 65536 + ((P2 & 1023) << 10 | u2.charCodeAt(++T2) & 1023), B3 += 4);
      }
      return B3 += this.encode(B3 * 8), this.update(u2), B3;
    }, s2.prototype.bytepad = function(u2, E2) {
      for (var _2 = this.encode(E2), B3 = 0; B3 < u2.length; ++B3) _2 += this.encodeString(u2[B3]);
      var R2 = E2 - _2 % E2, T2 = [];
      return T2.length = R2, this.update(T2), this;
    }, s2.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = true;
        var u2 = this.blocks, E2 = this.lastByteIndex, _2 = this.blockCount, B3 = this.s;
        if (u2[E2 >> 2] |= this.padding[E2 & 3], this.lastByteIndex === this.byteCount) for (u2[0] = u2[_2], E2 = 1; E2 < _2 + 1; ++E2) u2[E2] = 0;
        for (u2[_2 - 1] |= 2147483648, E2 = 0; E2 < _2; ++E2) B3[E2] ^= u2[E2];
        k2(B3);
      }
    }, s2.prototype.toString = s2.prototype.hex = function() {
      this.finalize();
      for (var u2 = this.blockCount, E2 = this.s, _2 = this.outputBlocks, B3 = this.extraBytes, R2 = 0, T2 = 0, P2 = "", O2; T2 < _2; ) {
        for (R2 = 0; R2 < u2 && T2 < _2; ++R2, ++T2) O2 = E2[R2], P2 += v2[O2 >> 4 & 15] + v2[O2 & 15] + v2[O2 >> 12 & 15] + v2[O2 >> 8 & 15] + v2[O2 >> 20 & 15] + v2[O2 >> 16 & 15] + v2[O2 >> 28 & 15] + v2[O2 >> 24 & 15];
        T2 % u2 === 0 && (k2(E2), R2 = 0);
      }
      return B3 && (O2 = E2[R2], P2 += v2[O2 >> 4 & 15] + v2[O2 & 15], B3 > 1 && (P2 += v2[O2 >> 12 & 15] + v2[O2 >> 8 & 15]), B3 > 2 && (P2 += v2[O2 >> 20 & 15] + v2[O2 >> 16 & 15])), P2;
    }, s2.prototype.arrayBuffer = function() {
      this.finalize();
      var u2 = this.blockCount, E2 = this.s, _2 = this.outputBlocks, B3 = this.extraBytes, R2 = 0, T2 = 0, P2 = this.outputBits >> 3, O2;
      B3 ? O2 = new ArrayBuffer(_2 + 1 << 2) : O2 = new ArrayBuffer(P2);
      for (var Ct = new Uint32Array(O2); T2 < _2; ) {
        for (R2 = 0; R2 < u2 && T2 < _2; ++R2, ++T2) Ct[T2] = E2[R2];
        T2 % u2 === 0 && k2(E2);
      }
      return B3 && (Ct[R2] = E2[R2], O2 = O2.slice(0, P2)), O2;
    }, s2.prototype.buffer = s2.prototype.arrayBuffer, s2.prototype.digest = s2.prototype.array = function() {
      this.finalize();
      for (var u2 = this.blockCount, E2 = this.s, _2 = this.outputBlocks, B3 = this.extraBytes, R2 = 0, T2 = 0, P2 = [], O2, Ct; T2 < _2; ) {
        for (R2 = 0; R2 < u2 && T2 < _2; ++R2, ++T2) O2 = T2 << 2, Ct = E2[R2], P2[O2] = Ct & 255, P2[O2 + 1] = Ct >> 8 & 255, P2[O2 + 2] = Ct >> 16 & 255, P2[O2 + 3] = Ct >> 24 & 255;
        T2 % u2 === 0 && k2(E2);
      }
      return B3 && (O2 = T2 << 2, Ct = E2[R2], P2[O2] = Ct & 255, B3 > 1 && (P2[O2 + 1] = Ct >> 8 & 255), B3 > 2 && (P2[O2 + 2] = Ct >> 16 & 255)), P2;
    };
    function g2(u2, E2, _2) {
      s2.call(this, u2, E2, _2);
    }
    g2.prototype = new s2(), g2.prototype.finalize = function() {
      return this.encode(this.outputBits, true), s2.prototype.finalize.call(this);
    };
    var k2 = function(u2) {
      var E2, _2, B3, R2, T2, P2, O2, Ct, D, q, De, X, Z, Fe, $2, tt, Te, et, rt, Ue, it, nt, ke, ft, ot, qe, st, at, Ke, ut, ht, He, ct, lt, Le, dt, pt, ze, vt, gt, je, mt, At, Qe, bt, yt, Je, wt, xt, Ge, Mt, Et, Ye, St, Nt2, Ve, It, _t, Me, Ee, Se, Ne, Ie;
      for (B3 = 0; B3 < 48; B3 += 2) R2 = u2[0] ^ u2[10] ^ u2[20] ^ u2[30] ^ u2[40], T2 = u2[1] ^ u2[11] ^ u2[21] ^ u2[31] ^ u2[41], P2 = u2[2] ^ u2[12] ^ u2[22] ^ u2[32] ^ u2[42], O2 = u2[3] ^ u2[13] ^ u2[23] ^ u2[33] ^ u2[43], Ct = u2[4] ^ u2[14] ^ u2[24] ^ u2[34] ^ u2[44], D = u2[5] ^ u2[15] ^ u2[25] ^ u2[35] ^ u2[45], q = u2[6] ^ u2[16] ^ u2[26] ^ u2[36] ^ u2[46], De = u2[7] ^ u2[17] ^ u2[27] ^ u2[37] ^ u2[47], X = u2[8] ^ u2[18] ^ u2[28] ^ u2[38] ^ u2[48], Z = u2[9] ^ u2[19] ^ u2[29] ^ u2[39] ^ u2[49], E2 = X ^ (P2 << 1 | O2 >>> 31), _2 = Z ^ (O2 << 1 | P2 >>> 31), u2[0] ^= E2, u2[1] ^= _2, u2[10] ^= E2, u2[11] ^= _2, u2[20] ^= E2, u2[21] ^= _2, u2[30] ^= E2, u2[31] ^= _2, u2[40] ^= E2, u2[41] ^= _2, E2 = R2 ^ (Ct << 1 | D >>> 31), _2 = T2 ^ (D << 1 | Ct >>> 31), u2[2] ^= E2, u2[3] ^= _2, u2[12] ^= E2, u2[13] ^= _2, u2[22] ^= E2, u2[23] ^= _2, u2[32] ^= E2, u2[33] ^= _2, u2[42] ^= E2, u2[43] ^= _2, E2 = P2 ^ (q << 1 | De >>> 31), _2 = O2 ^ (De << 1 | q >>> 31), u2[4] ^= E2, u2[5] ^= _2, u2[14] ^= E2, u2[15] ^= _2, u2[24] ^= E2, u2[25] ^= _2, u2[34] ^= E2, u2[35] ^= _2, u2[44] ^= E2, u2[45] ^= _2, E2 = Ct ^ (X << 1 | Z >>> 31), _2 = D ^ (Z << 1 | X >>> 31), u2[6] ^= E2, u2[7] ^= _2, u2[16] ^= E2, u2[17] ^= _2, u2[26] ^= E2, u2[27] ^= _2, u2[36] ^= E2, u2[37] ^= _2, u2[46] ^= E2, u2[47] ^= _2, E2 = q ^ (R2 << 1 | T2 >>> 31), _2 = De ^ (T2 << 1 | R2 >>> 31), u2[8] ^= E2, u2[9] ^= _2, u2[18] ^= E2, u2[19] ^= _2, u2[28] ^= E2, u2[29] ^= _2, u2[38] ^= E2, u2[39] ^= _2, u2[48] ^= E2, u2[49] ^= _2, Fe = u2[0], $2 = u2[1], yt = u2[11] << 4 | u2[10] >>> 28, Je = u2[10] << 4 | u2[11] >>> 28, at = u2[20] << 3 | u2[21] >>> 29, Ke = u2[21] << 3 | u2[20] >>> 29, Ee = u2[31] << 9 | u2[30] >>> 23, Se = u2[30] << 9 | u2[31] >>> 23, mt = u2[40] << 18 | u2[41] >>> 14, At = u2[41] << 18 | u2[40] >>> 14, lt = u2[2] << 1 | u2[3] >>> 31, Le = u2[3] << 1 | u2[2] >>> 31, tt = u2[13] << 12 | u2[12] >>> 20, Te = u2[12] << 12 | u2[13] >>> 20, wt = u2[22] << 10 | u2[23] >>> 22, xt = u2[23] << 10 | u2[22] >>> 22, ut = u2[33] << 13 | u2[32] >>> 19, ht = u2[32] << 13 | u2[33] >>> 19, Ne = u2[42] << 2 | u2[43] >>> 30, Ie = u2[43] << 2 | u2[42] >>> 30, St = u2[5] << 30 | u2[4] >>> 2, Nt2 = u2[4] << 30 | u2[5] >>> 2, dt = u2[14] << 6 | u2[15] >>> 26, pt = u2[15] << 6 | u2[14] >>> 26, et = u2[25] << 11 | u2[24] >>> 21, rt = u2[24] << 11 | u2[25] >>> 21, Ge = u2[34] << 15 | u2[35] >>> 17, Mt = u2[35] << 15 | u2[34] >>> 17, He = u2[45] << 29 | u2[44] >>> 3, ct = u2[44] << 29 | u2[45] >>> 3, ft = u2[6] << 28 | u2[7] >>> 4, ot = u2[7] << 28 | u2[6] >>> 4, Ve = u2[17] << 23 | u2[16] >>> 9, It = u2[16] << 23 | u2[17] >>> 9, ze = u2[26] << 25 | u2[27] >>> 7, vt = u2[27] << 25 | u2[26] >>> 7, Ue = u2[36] << 21 | u2[37] >>> 11, it = u2[37] << 21 | u2[36] >>> 11, Et = u2[47] << 24 | u2[46] >>> 8, Ye = u2[46] << 24 | u2[47] >>> 8, Qe = u2[8] << 27 | u2[9] >>> 5, bt = u2[9] << 27 | u2[8] >>> 5, qe = u2[18] << 20 | u2[19] >>> 12, st = u2[19] << 20 | u2[18] >>> 12, _t = u2[29] << 7 | u2[28] >>> 25, Me = u2[28] << 7 | u2[29] >>> 25, gt = u2[38] << 8 | u2[39] >>> 24, je = u2[39] << 8 | u2[38] >>> 24, nt = u2[48] << 14 | u2[49] >>> 18, ke = u2[49] << 14 | u2[48] >>> 18, u2[0] = Fe ^ ~tt & et, u2[1] = $2 ^ ~Te & rt, u2[10] = ft ^ ~qe & at, u2[11] = ot ^ ~st & Ke, u2[20] = lt ^ ~dt & ze, u2[21] = Le ^ ~pt & vt, u2[30] = Qe ^ ~yt & wt, u2[31] = bt ^ ~Je & xt, u2[40] = St ^ ~Ve & _t, u2[41] = Nt2 ^ ~It & Me, u2[2] = tt ^ ~et & Ue, u2[3] = Te ^ ~rt & it, u2[12] = qe ^ ~at & ut, u2[13] = st ^ ~Ke & ht, u2[22] = dt ^ ~ze & gt, u2[23] = pt ^ ~vt & je, u2[32] = yt ^ ~wt & Ge, u2[33] = Je ^ ~xt & Mt, u2[42] = Ve ^ ~_t & Ee, u2[43] = It ^ ~Me & Se, u2[4] = et ^ ~Ue & nt, u2[5] = rt ^ ~it & ke, u2[14] = at ^ ~ut & He, u2[15] = Ke ^ ~ht & ct, u2[24] = ze ^ ~gt & mt, u2[25] = vt ^ ~je & At, u2[34] = wt ^ ~Ge & Et, u2[35] = xt ^ ~Mt & Ye, u2[44] = _t ^ ~Ee & Ne, u2[45] = Me ^ ~Se & Ie, u2[6] = Ue ^ ~nt & Fe, u2[7] = it ^ ~ke & $2, u2[16] = ut ^ ~He & ft, u2[17] = ht ^ ~ct & ot, u2[26] = gt ^ ~mt & lt, u2[27] = je ^ ~At & Le, u2[36] = Ge ^ ~Et & Qe, u2[37] = Mt ^ ~Ye & bt, u2[46] = Ee ^ ~Ne & St, u2[47] = Se ^ ~Ie & Nt2, u2[8] = nt ^ ~Fe & tt, u2[9] = ke ^ ~$2 & Te, u2[18] = He ^ ~ft & qe, u2[19] = ct ^ ~ot & st, u2[28] = mt ^ ~lt & dt, u2[29] = At ^ ~Le & pt, u2[38] = Et ^ ~Qe & yt, u2[39] = Ye ^ ~bt & Je, u2[48] = Ne ^ ~St & Ve, u2[49] = Ie ^ ~Nt2 & It, u2[0] ^= C2[B3], u2[1] ^= C2[B3 + 1];
    };
    if (p2) e2.exports = f2;
    else for (c2 = 0; c2 < a2.length; ++c2) n3[a2[c2]] = f2[a2[c2]];
  })();
})(Un);
const Ns = "logger/5.7.0";
let kn = false, qn = false;
const Dr = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let Kn = Dr.default, xi = null;
function Is() {
  try {
    const e2 = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((t2) => {
      try {
        if ("test".normalize(t2) !== "test") throw new Error("bad normalize");
      } catch {
        e2.push(t2);
      }
    }), e2.length) throw new Error("missing " + e2.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation");
  } catch (e2) {
    return e2.message;
  }
  return null;
}
const Hn = Is();
var Mi;
(function(e2) {
  e2.DEBUG = "DEBUG", e2.INFO = "INFO", e2.WARNING = "WARNING", e2.ERROR = "ERROR", e2.OFF = "OFF";
})(Mi || (Mi = {}));
var re;
(function(e2) {
  e2.UNKNOWN_ERROR = "UNKNOWN_ERROR", e2.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", e2.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.TIMEOUT = "TIMEOUT", e2.BUFFER_OVERRUN = "BUFFER_OVERRUN", e2.NUMERIC_FAULT = "NUMERIC_FAULT", e2.MISSING_NEW = "MISSING_NEW", e2.INVALID_ARGUMENT = "INVALID_ARGUMENT", e2.MISSING_ARGUMENT = "MISSING_ARGUMENT", e2.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", e2.CALL_EXCEPTION = "CALL_EXCEPTION", e2.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", e2.NONCE_EXPIRED = "NONCE_EXPIRED", e2.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", e2.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", e2.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", e2.ACTION_REJECTED = "ACTION_REJECTED";
})(re || (re = {}));
const Ln = "0123456789abcdef";
class z2 {
  constructor(t2) {
    Object.defineProperty(this, "version", { enumerable: true, value: t2, writable: false });
  }
  _log(t2, r2) {
    const i4 = t2.toLowerCase();
    Dr[i4] == null && this.throwArgumentError("invalid log level name", "logLevel", t2), !(Kn > Dr[i4]) && console.log.apply(console, r2);
  }
  debug(...t2) {
    this._log(z2.levels.DEBUG, t2);
  }
  info(...t2) {
    this._log(z2.levels.INFO, t2);
  }
  warn(...t2) {
    this._log(z2.levels.WARNING, t2);
  }
  makeError(t2, r2, i4) {
    if (qn) return this.makeError("censored error", r2, {});
    r2 || (r2 = z2.errors.UNKNOWN_ERROR), i4 || (i4 = {});
    const n3 = [];
    Object.keys(i4).forEach((A2) => {
      const v2 = i4[A2];
      try {
        if (v2 instanceof Uint8Array) {
          let w2 = "";
          for (let y3 = 0; y3 < v2.length; y3++) w2 += Ln[v2[y3] >> 4], w2 += Ln[v2[y3] & 15];
          n3.push(A2 + "=Uint8Array(0x" + w2 + ")");
        } else n3.push(A2 + "=" + JSON.stringify(v2));
      } catch {
        n3.push(A2 + "=" + JSON.stringify(i4[A2].toString()));
      }
    }), n3.push(`code=${r2}`), n3.push(`version=${this.version}`);
    const o2 = t2;
    let h2 = "";
    switch (r2) {
      case re.NUMERIC_FAULT: {
        h2 = "NUMERIC_FAULT";
        const A2 = t2;
        switch (A2) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            h2 += "-" + A2;
            break;
          case "negative-power":
          case "negative-width":
            h2 += "-unsupported";
            break;
          case "unbound-bitwise-result":
            h2 += "-unbound-result";
            break;
        }
        break;
      }
      case re.CALL_EXCEPTION:
      case re.INSUFFICIENT_FUNDS:
      case re.MISSING_NEW:
      case re.NONCE_EXPIRED:
      case re.REPLACEMENT_UNDERPRICED:
      case re.TRANSACTION_REPLACED:
      case re.UNPREDICTABLE_GAS_LIMIT:
        h2 = r2;
        break;
    }
    h2 && (t2 += " [ See: https://links.ethers.org/v5-errors-" + h2 + " ]"), n3.length && (t2 += " (" + n3.join(", ") + ")");
    const p2 = new Error(t2);
    return p2.reason = o2, p2.code = r2, Object.keys(i4).forEach(function(A2) {
      p2[A2] = i4[A2];
    }), p2;
  }
  throwError(t2, r2, i4) {
    throw this.makeError(t2, r2, i4);
  }
  throwArgumentError(t2, r2, i4) {
    return this.throwError(t2, z2.errors.INVALID_ARGUMENT, { argument: r2, value: i4 });
  }
  assert(t2, r2, i4, n3) {
    t2 || this.throwError(r2, i4, n3);
  }
  assertArgument(t2, r2, i4, n3) {
    t2 || this.throwArgumentError(r2, i4, n3);
  }
  checkNormalize(t2) {
    Hn && this.throwError("platform missing String.prototype.normalize", z2.errors.UNSUPPORTED_OPERATION, { operation: "String.prototype.normalize", form: Hn });
  }
  checkSafeUint53(t2, r2) {
    typeof t2 == "number" && (r2 == null && (r2 = "value not safe"), (t2 < 0 || t2 >= 9007199254740991) && this.throwError(r2, z2.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "out-of-safe-range", value: t2 }), t2 % 1 && this.throwError(r2, z2.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "non-integer", value: t2 }));
  }
  checkArgumentCount(t2, r2, i4) {
    i4 ? i4 = ": " + i4 : i4 = "", t2 < r2 && this.throwError("missing argument" + i4, z2.errors.MISSING_ARGUMENT, { count: t2, expectedCount: r2 }), t2 > r2 && this.throwError("too many arguments" + i4, z2.errors.UNEXPECTED_ARGUMENT, { count: t2, expectedCount: r2 });
  }
  checkNew(t2, r2) {
    (t2 === Object || t2 == null) && this.throwError("missing new", z2.errors.MISSING_NEW, { name: r2.name });
  }
  checkAbstract(t2, r2) {
    t2 === r2 ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r2.name) + " directly; use a sub-class", z2.errors.UNSUPPORTED_OPERATION, { name: t2.name, operation: "new" }) : (t2 === Object || t2 == null) && this.throwError("missing new", z2.errors.MISSING_NEW, { name: r2.name });
  }
  static globalLogger() {
    return xi || (xi = new z2(Ns)), xi;
  }
  static setCensorship(t2, r2) {
    if (!t2 && r2 && this.globalLogger().throwError("cannot permanently disable censorship", z2.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" }), kn) {
      if (!t2) return;
      this.globalLogger().throwError("error censorship permanent", z2.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" });
    }
    qn = !!t2, kn = !!r2;
  }
  static setLogLevel(t2) {
    const r2 = Dr[t2.toLowerCase()];
    if (r2 == null) {
      z2.globalLogger().warn("invalid log level - " + t2);
      return;
    }
    Kn = r2;
  }
  static from(t2) {
    return new z2(t2);
  }
}
z2.errors = re, z2.levels = Mi;
const _s = "bytes/5.7.0", Dt = new z2(_s);
function zn(e2) {
  return !!e2.toHexString;
}
function ir(e2) {
  return e2.slice || (e2.slice = function() {
    const t2 = Array.prototype.slice.call(arguments);
    return ir(new Uint8Array(Array.prototype.slice.apply(e2, t2)));
  }), e2;
}
function jn(e2) {
  return typeof e2 == "number" && e2 == e2 && e2 % 1 === 0;
}
function nr(e2) {
  if (e2 == null) return false;
  if (e2.constructor === Uint8Array) return true;
  if (typeof e2 == "string" || !jn(e2.length) || e2.length < 0) return false;
  for (let t2 = 0; t2 < e2.length; t2++) {
    const r2 = e2[t2];
    if (!jn(r2) || r2 < 0 || r2 >= 256) return false;
  }
  return true;
}
function Ot(e2, t2) {
  if (t2 || (t2 = {}), typeof e2 == "number") {
    Dt.checkSafeUint53(e2, "invalid arrayify value");
    const r2 = [];
    for (; e2; ) r2.unshift(e2 & 255), e2 = parseInt(String(e2 / 256));
    return r2.length === 0 && r2.push(0), ir(new Uint8Array(r2));
  }
  if (t2.allowMissingPrefix && typeof e2 == "string" && e2.substring(0, 2) !== "0x" && (e2 = "0x" + e2), zn(e2) && (e2 = e2.toHexString()), Jt(e2)) {
    let r2 = e2.substring(2);
    r2.length % 2 && (t2.hexPad === "left" ? r2 = "0" + r2 : t2.hexPad === "right" ? r2 += "0" : Dt.throwArgumentError("hex data is odd-length", "value", e2));
    const i4 = [];
    for (let n3 = 0; n3 < r2.length; n3 += 2) i4.push(parseInt(r2.substring(n3, n3 + 2), 16));
    return ir(new Uint8Array(i4));
  }
  return nr(e2) ? ir(new Uint8Array(e2)) : Dt.throwArgumentError("invalid arrayify value", "value", e2);
}
function Jt(e2, t2) {
  return !(typeof e2 != "string" || !e2.match(/^0x[0-9A-Fa-f]*$/) || t2 && e2.length !== 2 + 2 * t2);
}
const Ei = "0123456789abcdef";
function Kt(e2, t2) {
  if (t2 || (t2 = {}), typeof e2 == "number") {
    Dt.checkSafeUint53(e2, "invalid hexlify value");
    let r2 = "";
    for (; e2; ) r2 = Ei[e2 & 15] + r2, e2 = Math.floor(e2 / 16);
    return r2.length ? (r2.length % 2 && (r2 = "0" + r2), "0x" + r2) : "0x00";
  }
  if (typeof e2 == "bigint") return e2 = e2.toString(16), e2.length % 2 ? "0x0" + e2 : "0x" + e2;
  if (t2.allowMissingPrefix && typeof e2 == "string" && e2.substring(0, 2) !== "0x" && (e2 = "0x" + e2), zn(e2)) return e2.toHexString();
  if (Jt(e2)) return e2.length % 2 && (t2.hexPad === "left" ? e2 = "0x0" + e2.substring(2) : t2.hexPad === "right" ? e2 += "0" : Dt.throwArgumentError("hex data is odd-length", "value", e2)), e2.toLowerCase();
  if (nr(e2)) {
    let r2 = "0x";
    for (let i4 = 0; i4 < e2.length; i4++) {
      let n3 = e2[i4];
      r2 += Ei[(n3 & 240) >> 4] + Ei[n3 & 15];
    }
    return r2;
  }
  return Dt.throwArgumentError("invalid hexlify value", "value", e2);
}
function oe(e2, t2) {
  for (typeof e2 != "string" ? e2 = Kt(e2) : Jt(e2) || Dt.throwArgumentError("invalid hex string", "value", e2), e2.length > 2 * t2 + 2 && Dt.throwArgumentError("value out of range", "value", arguments[1]); e2.length < 2 * t2 + 2; ) e2 = "0x0" + e2.substring(2);
  return e2;
}
var Gn = { exports: {} }, Ps = {}, Ds = Object.freeze({ __proto__: null, default: Ps }), Fs = Es(Ds);
(function(e2) {
  (function(t2, r2) {
    function i4(b2, f2) {
      if (!b2) throw new Error(f2 || "Assertion failed");
    }
    function n3(b2, f2) {
      b2.super_ = f2;
      var a2 = function() {
      };
      a2.prototype = f2.prototype, b2.prototype = new a2(), b2.prototype.constructor = b2;
    }
    function o2(b2, f2, a2) {
      if (o2.isBN(b2)) return b2;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, b2 !== null && ((f2 === "le" || f2 === "be") && (a2 = f2, f2 = 10), this._init(b2 || 0, f2 || 10, a2 || "be"));
    }
    typeof t2 == "object" ? t2.exports = o2 : r2.BN = o2, o2.BN = o2, o2.wordSize = 26;
    var h2;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? h2 = window.Buffer : h2 = Fs.Buffer;
    } catch {
    }
    o2.isBN = function(f2) {
      return f2 instanceof o2 ? true : f2 !== null && typeof f2 == "object" && f2.constructor.wordSize === o2.wordSize && Array.isArray(f2.words);
    }, o2.max = function(f2, a2) {
      return f2.cmp(a2) > 0 ? f2 : a2;
    }, o2.min = function(f2, a2) {
      return f2.cmp(a2) < 0 ? f2 : a2;
    }, o2.prototype._init = function(f2, a2, c2) {
      if (typeof f2 == "number") return this._initNumber(f2, a2, c2);
      if (typeof f2 == "object") return this._initArray(f2, a2, c2);
      a2 === "hex" && (a2 = 16), i4(a2 === (a2 | 0) && a2 >= 2 && a2 <= 36), f2 = f2.toString().replace(/\s+/g, "");
      var d3 = 0;
      f2[0] === "-" && (d3++, this.negative = 1), d3 < f2.length && (a2 === 16 ? this._parseHex(f2, d3, c2) : (this._parseBase(f2, a2, d3), c2 === "le" && this._initArray(this.toArray(), a2, c2)));
    }, o2.prototype._initNumber = function(f2, a2, c2) {
      f2 < 0 && (this.negative = 1, f2 = -f2), f2 < 67108864 ? (this.words = [f2 & 67108863], this.length = 1) : f2 < 4503599627370496 ? (this.words = [f2 & 67108863, f2 / 67108864 & 67108863], this.length = 2) : (i4(f2 < 9007199254740992), this.words = [f2 & 67108863, f2 / 67108864 & 67108863, 1], this.length = 3), c2 === "le" && this._initArray(this.toArray(), a2, c2);
    }, o2.prototype._initArray = function(f2, a2, c2) {
      if (i4(typeof f2.length == "number"), f2.length <= 0) return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f2.length / 3), this.words = new Array(this.length);
      for (var d3 = 0; d3 < this.length; d3++) this.words[d3] = 0;
      var m3, x2, M2 = 0;
      if (c2 === "be") for (d3 = f2.length - 1, m3 = 0; d3 >= 0; d3 -= 3) x2 = f2[d3] | f2[d3 - 1] << 8 | f2[d3 - 2] << 16, this.words[m3] |= x2 << M2 & 67108863, this.words[m3 + 1] = x2 >>> 26 - M2 & 67108863, M2 += 24, M2 >= 26 && (M2 -= 26, m3++);
      else if (c2 === "le") for (d3 = 0, m3 = 0; d3 < f2.length; d3 += 3) x2 = f2[d3] | f2[d3 + 1] << 8 | f2[d3 + 2] << 16, this.words[m3] |= x2 << M2 & 67108863, this.words[m3 + 1] = x2 >>> 26 - M2 & 67108863, M2 += 24, M2 >= 26 && (M2 -= 26, m3++);
      return this._strip();
    };
    function p2(b2, f2) {
      var a2 = b2.charCodeAt(f2);
      if (a2 >= 48 && a2 <= 57) return a2 - 48;
      if (a2 >= 65 && a2 <= 70) return a2 - 55;
      if (a2 >= 97 && a2 <= 102) return a2 - 87;
      i4(false, "Invalid character in " + b2);
    }
    function A2(b2, f2, a2) {
      var c2 = p2(b2, a2);
      return a2 - 1 >= f2 && (c2 |= p2(b2, a2 - 1) << 4), c2;
    }
    o2.prototype._parseHex = function(f2, a2, c2) {
      this.length = Math.ceil((f2.length - a2) / 6), this.words = new Array(this.length);
      for (var d3 = 0; d3 < this.length; d3++) this.words[d3] = 0;
      var m3 = 0, x2 = 0, M2;
      if (c2 === "be") for (d3 = f2.length - 1; d3 >= a2; d3 -= 2) M2 = A2(f2, a2, d3) << m3, this.words[x2] |= M2 & 67108863, m3 >= 18 ? (m3 -= 18, x2 += 1, this.words[x2] |= M2 >>> 26) : m3 += 8;
      else {
        var l2 = f2.length - a2;
        for (d3 = l2 % 2 === 0 ? a2 + 1 : a2; d3 < f2.length; d3 += 2) M2 = A2(f2, a2, d3) << m3, this.words[x2] |= M2 & 67108863, m3 >= 18 ? (m3 -= 18, x2 += 1, this.words[x2] |= M2 >>> 26) : m3 += 8;
      }
      this._strip();
    };
    function v2(b2, f2, a2, c2) {
      for (var d3 = 0, m3 = 0, x2 = Math.min(b2.length, a2), M2 = f2; M2 < x2; M2++) {
        var l2 = b2.charCodeAt(M2) - 48;
        d3 *= c2, l2 >= 49 ? m3 = l2 - 49 + 10 : l2 >= 17 ? m3 = l2 - 17 + 10 : m3 = l2, i4(l2 >= 0 && m3 < c2, "Invalid character"), d3 += m3;
      }
      return d3;
    }
    o2.prototype._parseBase = function(f2, a2, c2) {
      this.words = [0], this.length = 1;
      for (var d3 = 0, m3 = 1; m3 <= 67108863; m3 *= a2) d3++;
      d3--, m3 = m3 / a2 | 0;
      for (var x2 = f2.length - c2, M2 = x2 % d3, l2 = Math.min(x2, x2 - M2) + c2, s2 = 0, g2 = c2; g2 < l2; g2 += d3) s2 = v2(f2, g2, g2 + d3, a2), this.imuln(m3), this.words[0] + s2 < 67108864 ? this.words[0] += s2 : this._iaddn(s2);
      if (M2 !== 0) {
        var k2 = 1;
        for (s2 = v2(f2, g2, f2.length, a2), g2 = 0; g2 < M2; g2++) k2 *= a2;
        this.imuln(k2), this.words[0] + s2 < 67108864 ? this.words[0] += s2 : this._iaddn(s2);
      }
      this._strip();
    }, o2.prototype.copy = function(f2) {
      f2.words = new Array(this.length);
      for (var a2 = 0; a2 < this.length; a2++) f2.words[a2] = this.words[a2];
      f2.length = this.length, f2.negative = this.negative, f2.red = this.red;
    };
    function w2(b2, f2) {
      b2.words = f2.words, b2.length = f2.length, b2.negative = f2.negative, b2.red = f2.red;
    }
    if (o2.prototype._move = function(f2) {
      w2(f2, this);
    }, o2.prototype.clone = function() {
      var f2 = new o2(null);
      return this.copy(f2), f2;
    }, o2.prototype._expand = function(f2) {
      for (; this.length < f2; ) this.words[this.length++] = 0;
      return this;
    }, o2.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
      return this._normSign();
    }, o2.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
      o2.prototype[Symbol.for("nodejs.util.inspect.custom")] = y3;
    } catch {
      o2.prototype.inspect = y3;
    }
    else o2.prototype.inspect = y3;
    function y3() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var S2 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], I2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], N2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    o2.prototype.toString = function(f2, a2) {
      f2 = f2 || 10, a2 = a2 | 0 || 1;
      var c2;
      if (f2 === 16 || f2 === "hex") {
        c2 = "";
        for (var d3 = 0, m3 = 0, x2 = 0; x2 < this.length; x2++) {
          var M2 = this.words[x2], l2 = ((M2 << d3 | m3) & 16777215).toString(16);
          m3 = M2 >>> 24 - d3 & 16777215, d3 += 2, d3 >= 26 && (d3 -= 26, x2--), m3 !== 0 || x2 !== this.length - 1 ? c2 = S2[6 - l2.length] + l2 + c2 : c2 = l2 + c2;
        }
        for (m3 !== 0 && (c2 = m3.toString(16) + c2); c2.length % a2 !== 0; ) c2 = "0" + c2;
        return this.negative !== 0 && (c2 = "-" + c2), c2;
      }
      if (f2 === (f2 | 0) && f2 >= 2 && f2 <= 36) {
        var s2 = I2[f2], g2 = N2[f2];
        c2 = "";
        var k2 = this.clone();
        for (k2.negative = 0; !k2.isZero(); ) {
          var u2 = k2.modrn(g2).toString(f2);
          k2 = k2.idivn(g2), k2.isZero() ? c2 = u2 + c2 : c2 = S2[s2 - u2.length] + u2 + c2;
        }
        for (this.isZero() && (c2 = "0" + c2); c2.length % a2 !== 0; ) c2 = "0" + c2;
        return this.negative !== 0 && (c2 = "-" + c2), c2;
      }
      i4(false, "Base should be between 2 and 36");
    }, o2.prototype.toNumber = function() {
      var f2 = this.words[0];
      return this.length === 2 ? f2 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f2 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i4(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f2 : f2;
    }, o2.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, h2 && (o2.prototype.toBuffer = function(f2, a2) {
      return this.toArrayLike(h2, f2, a2);
    }), o2.prototype.toArray = function(f2, a2) {
      return this.toArrayLike(Array, f2, a2);
    };
    var C2 = function(f2, a2) {
      return f2.allocUnsafe ? f2.allocUnsafe(a2) : new f2(a2);
    };
    o2.prototype.toArrayLike = function(f2, a2, c2) {
      this._strip();
      var d3 = this.byteLength(), m3 = c2 || Math.max(1, d3);
      i4(d3 <= m3, "byte array longer than desired length"), i4(m3 > 0, "Requested array length <= 0");
      var x2 = C2(f2, m3), M2 = a2 === "le" ? "LE" : "BE";
      return this["_toArrayLike" + M2](x2, d3), x2;
    }, o2.prototype._toArrayLikeLE = function(f2, a2) {
      for (var c2 = 0, d3 = 0, m3 = 0, x2 = 0; m3 < this.length; m3++) {
        var M2 = this.words[m3] << x2 | d3;
        f2[c2++] = M2 & 255, c2 < f2.length && (f2[c2++] = M2 >> 8 & 255), c2 < f2.length && (f2[c2++] = M2 >> 16 & 255), x2 === 6 ? (c2 < f2.length && (f2[c2++] = M2 >> 24 & 255), d3 = 0, x2 = 0) : (d3 = M2 >>> 24, x2 += 2);
      }
      if (c2 < f2.length) for (f2[c2++] = d3; c2 < f2.length; ) f2[c2++] = 0;
    }, o2.prototype._toArrayLikeBE = function(f2, a2) {
      for (var c2 = f2.length - 1, d3 = 0, m3 = 0, x2 = 0; m3 < this.length; m3++) {
        var M2 = this.words[m3] << x2 | d3;
        f2[c2--] = M2 & 255, c2 >= 0 && (f2[c2--] = M2 >> 8 & 255), c2 >= 0 && (f2[c2--] = M2 >> 16 & 255), x2 === 6 ? (c2 >= 0 && (f2[c2--] = M2 >> 24 & 255), d3 = 0, x2 = 0) : (d3 = M2 >>> 24, x2 += 2);
      }
      if (c2 >= 0) for (f2[c2--] = d3; c2 >= 0; ) f2[c2--] = 0;
    }, Math.clz32 ? o2.prototype._countBits = function(f2) {
      return 32 - Math.clz32(f2);
    } : o2.prototype._countBits = function(f2) {
      var a2 = f2, c2 = 0;
      return a2 >= 4096 && (c2 += 13, a2 >>>= 13), a2 >= 64 && (c2 += 7, a2 >>>= 7), a2 >= 8 && (c2 += 4, a2 >>>= 4), a2 >= 2 && (c2 += 2, a2 >>>= 2), c2 + a2;
    }, o2.prototype._zeroBits = function(f2) {
      if (f2 === 0) return 26;
      var a2 = f2, c2 = 0;
      return a2 & 8191 || (c2 += 13, a2 >>>= 13), a2 & 127 || (c2 += 7, a2 >>>= 7), a2 & 15 || (c2 += 4, a2 >>>= 4), a2 & 3 || (c2 += 2, a2 >>>= 2), a2 & 1 || c2++, c2;
    }, o2.prototype.bitLength = function() {
      var f2 = this.words[this.length - 1], a2 = this._countBits(f2);
      return (this.length - 1) * 26 + a2;
    };
    function F(b2) {
      for (var f2 = new Array(b2.bitLength()), a2 = 0; a2 < f2.length; a2++) {
        var c2 = a2 / 26 | 0, d3 = a2 % 26;
        f2[a2] = b2.words[c2] >>> d3 & 1;
      }
      return f2;
    }
    o2.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var f2 = 0, a2 = 0; a2 < this.length; a2++) {
        var c2 = this._zeroBits(this.words[a2]);
        if (f2 += c2, c2 !== 26) break;
      }
      return f2;
    }, o2.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, o2.prototype.toTwos = function(f2) {
      return this.negative !== 0 ? this.abs().inotn(f2).iaddn(1) : this.clone();
    }, o2.prototype.fromTwos = function(f2) {
      return this.testn(f2 - 1) ? this.notn(f2).iaddn(1).ineg() : this.clone();
    }, o2.prototype.isNeg = function() {
      return this.negative !== 0;
    }, o2.prototype.neg = function() {
      return this.clone().ineg();
    }, o2.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, o2.prototype.iuor = function(f2) {
      for (; this.length < f2.length; ) this.words[this.length++] = 0;
      for (var a2 = 0; a2 < f2.length; a2++) this.words[a2] = this.words[a2] | f2.words[a2];
      return this._strip();
    }, o2.prototype.ior = function(f2) {
      return i4((this.negative | f2.negative) === 0), this.iuor(f2);
    }, o2.prototype.or = function(f2) {
      return this.length > f2.length ? this.clone().ior(f2) : f2.clone().ior(this);
    }, o2.prototype.uor = function(f2) {
      return this.length > f2.length ? this.clone().iuor(f2) : f2.clone().iuor(this);
    }, o2.prototype.iuand = function(f2) {
      var a2;
      this.length > f2.length ? a2 = f2 : a2 = this;
      for (var c2 = 0; c2 < a2.length; c2++) this.words[c2] = this.words[c2] & f2.words[c2];
      return this.length = a2.length, this._strip();
    }, o2.prototype.iand = function(f2) {
      return i4((this.negative | f2.negative) === 0), this.iuand(f2);
    }, o2.prototype.and = function(f2) {
      return this.length > f2.length ? this.clone().iand(f2) : f2.clone().iand(this);
    }, o2.prototype.uand = function(f2) {
      return this.length > f2.length ? this.clone().iuand(f2) : f2.clone().iuand(this);
    }, o2.prototype.iuxor = function(f2) {
      var a2, c2;
      this.length > f2.length ? (a2 = this, c2 = f2) : (a2 = f2, c2 = this);
      for (var d3 = 0; d3 < c2.length; d3++) this.words[d3] = a2.words[d3] ^ c2.words[d3];
      if (this !== a2) for (; d3 < a2.length; d3++) this.words[d3] = a2.words[d3];
      return this.length = a2.length, this._strip();
    }, o2.prototype.ixor = function(f2) {
      return i4((this.negative | f2.negative) === 0), this.iuxor(f2);
    }, o2.prototype.xor = function(f2) {
      return this.length > f2.length ? this.clone().ixor(f2) : f2.clone().ixor(this);
    }, o2.prototype.uxor = function(f2) {
      return this.length > f2.length ? this.clone().iuxor(f2) : f2.clone().iuxor(this);
    }, o2.prototype.inotn = function(f2) {
      i4(typeof f2 == "number" && f2 >= 0);
      var a2 = Math.ceil(f2 / 26) | 0, c2 = f2 % 26;
      this._expand(a2), c2 > 0 && a2--;
      for (var d3 = 0; d3 < a2; d3++) this.words[d3] = ~this.words[d3] & 67108863;
      return c2 > 0 && (this.words[d3] = ~this.words[d3] & 67108863 >> 26 - c2), this._strip();
    }, o2.prototype.notn = function(f2) {
      return this.clone().inotn(f2);
    }, o2.prototype.setn = function(f2, a2) {
      i4(typeof f2 == "number" && f2 >= 0);
      var c2 = f2 / 26 | 0, d3 = f2 % 26;
      return this._expand(c2 + 1), a2 ? this.words[c2] = this.words[c2] | 1 << d3 : this.words[c2] = this.words[c2] & ~(1 << d3), this._strip();
    }, o2.prototype.iadd = function(f2) {
      var a2;
      if (this.negative !== 0 && f2.negative === 0) return this.negative = 0, a2 = this.isub(f2), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f2.negative !== 0) return f2.negative = 0, a2 = this.isub(f2), f2.negative = 1, a2._normSign();
      var c2, d3;
      this.length > f2.length ? (c2 = this, d3 = f2) : (c2 = f2, d3 = this);
      for (var m3 = 0, x2 = 0; x2 < d3.length; x2++) a2 = (c2.words[x2] | 0) + (d3.words[x2] | 0) + m3, this.words[x2] = a2 & 67108863, m3 = a2 >>> 26;
      for (; m3 !== 0 && x2 < c2.length; x2++) a2 = (c2.words[x2] | 0) + m3, this.words[x2] = a2 & 67108863, m3 = a2 >>> 26;
      if (this.length = c2.length, m3 !== 0) this.words[this.length] = m3, this.length++;
      else if (c2 !== this) for (; x2 < c2.length; x2++) this.words[x2] = c2.words[x2];
      return this;
    }, o2.prototype.add = function(f2) {
      var a2;
      return f2.negative !== 0 && this.negative === 0 ? (f2.negative = 0, a2 = this.sub(f2), f2.negative ^= 1, a2) : f2.negative === 0 && this.negative !== 0 ? (this.negative = 0, a2 = f2.sub(this), this.negative = 1, a2) : this.length > f2.length ? this.clone().iadd(f2) : f2.clone().iadd(this);
    }, o2.prototype.isub = function(f2) {
      if (f2.negative !== 0) {
        f2.negative = 0;
        var a2 = this.iadd(f2);
        return f2.negative = 1, a2._normSign();
      } else if (this.negative !== 0) return this.negative = 0, this.iadd(f2), this.negative = 1, this._normSign();
      var c2 = this.cmp(f2);
      if (c2 === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var d3, m3;
      c2 > 0 ? (d3 = this, m3 = f2) : (d3 = f2, m3 = this);
      for (var x2 = 0, M2 = 0; M2 < m3.length; M2++) a2 = (d3.words[M2] | 0) - (m3.words[M2] | 0) + x2, x2 = a2 >> 26, this.words[M2] = a2 & 67108863;
      for (; x2 !== 0 && M2 < d3.length; M2++) a2 = (d3.words[M2] | 0) + x2, x2 = a2 >> 26, this.words[M2] = a2 & 67108863;
      if (x2 === 0 && M2 < d3.length && d3 !== this) for (; M2 < d3.length; M2++) this.words[M2] = d3.words[M2];
      return this.length = Math.max(this.length, M2), d3 !== this && (this.negative = 1), this._strip();
    }, o2.prototype.sub = function(f2) {
      return this.clone().isub(f2);
    };
    function U(b2, f2, a2) {
      a2.negative = f2.negative ^ b2.negative;
      var c2 = b2.length + f2.length | 0;
      a2.length = c2, c2 = c2 - 1 | 0;
      var d3 = b2.words[0] | 0, m3 = f2.words[0] | 0, x2 = d3 * m3, M2 = x2 & 67108863, l2 = x2 / 67108864 | 0;
      a2.words[0] = M2;
      for (var s2 = 1; s2 < c2; s2++) {
        for (var g2 = l2 >>> 26, k2 = l2 & 67108863, u2 = Math.min(s2, f2.length - 1), E2 = Math.max(0, s2 - b2.length + 1); E2 <= u2; E2++) {
          var _2 = s2 - E2 | 0;
          d3 = b2.words[_2] | 0, m3 = f2.words[E2] | 0, x2 = d3 * m3 + k2, g2 += x2 / 67108864 | 0, k2 = x2 & 67108863;
        }
        a2.words[s2] = k2 | 0, l2 = g2 | 0;
      }
      return l2 !== 0 ? a2.words[s2] = l2 | 0 : a2.length--, a2._strip();
    }
    var J = function(f2, a2, c2) {
      var d3 = f2.words, m3 = a2.words, x2 = c2.words, M2 = 0, l2, s2, g2, k2 = d3[0] | 0, u2 = k2 & 8191, E2 = k2 >>> 13, _2 = d3[1] | 0, B3 = _2 & 8191, R2 = _2 >>> 13, T2 = d3[2] | 0, P2 = T2 & 8191, O2 = T2 >>> 13, Ct = d3[3] | 0, D = Ct & 8191, q = Ct >>> 13, De = d3[4] | 0, X = De & 8191, Z = De >>> 13, Fe = d3[5] | 0, $2 = Fe & 8191, tt = Fe >>> 13, Te = d3[6] | 0, et = Te & 8191, rt = Te >>> 13, Ue = d3[7] | 0, it = Ue & 8191, nt = Ue >>> 13, ke = d3[8] | 0, ft = ke & 8191, ot = ke >>> 13, qe = d3[9] | 0, st = qe & 8191, at = qe >>> 13, Ke = m3[0] | 0, ut = Ke & 8191, ht = Ke >>> 13, He = m3[1] | 0, ct = He & 8191, lt = He >>> 13, Le = m3[2] | 0, dt = Le & 8191, pt = Le >>> 13, ze = m3[3] | 0, vt = ze & 8191, gt = ze >>> 13, je = m3[4] | 0, mt = je & 8191, At = je >>> 13, Qe = m3[5] | 0, bt = Qe & 8191, yt = Qe >>> 13, Je = m3[6] | 0, wt = Je & 8191, xt = Je >>> 13, Ge = m3[7] | 0, Mt = Ge & 8191, Et = Ge >>> 13, Ye = m3[8] | 0, St = Ye & 8191, Nt2 = Ye >>> 13, Ve = m3[9] | 0, It = Ve & 8191, _t = Ve >>> 13;
      c2.negative = f2.negative ^ a2.negative, c2.length = 19, l2 = Math.imul(u2, ut), s2 = Math.imul(u2, ht), s2 = s2 + Math.imul(E2, ut) | 0, g2 = Math.imul(E2, ht);
      var Me = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, l2 = Math.imul(B3, ut), s2 = Math.imul(B3, ht), s2 = s2 + Math.imul(R2, ut) | 0, g2 = Math.imul(R2, ht), l2 = l2 + Math.imul(u2, ct) | 0, s2 = s2 + Math.imul(u2, lt) | 0, s2 = s2 + Math.imul(E2, ct) | 0, g2 = g2 + Math.imul(E2, lt) | 0;
      var Ee = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (Ee >>> 26) | 0, Ee &= 67108863, l2 = Math.imul(P2, ut), s2 = Math.imul(P2, ht), s2 = s2 + Math.imul(O2, ut) | 0, g2 = Math.imul(O2, ht), l2 = l2 + Math.imul(B3, ct) | 0, s2 = s2 + Math.imul(B3, lt) | 0, s2 = s2 + Math.imul(R2, ct) | 0, g2 = g2 + Math.imul(R2, lt) | 0, l2 = l2 + Math.imul(u2, dt) | 0, s2 = s2 + Math.imul(u2, pt) | 0, s2 = s2 + Math.imul(E2, dt) | 0, g2 = g2 + Math.imul(E2, pt) | 0;
      var Se = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, l2 = Math.imul(D, ut), s2 = Math.imul(D, ht), s2 = s2 + Math.imul(q, ut) | 0, g2 = Math.imul(q, ht), l2 = l2 + Math.imul(P2, ct) | 0, s2 = s2 + Math.imul(P2, lt) | 0, s2 = s2 + Math.imul(O2, ct) | 0, g2 = g2 + Math.imul(O2, lt) | 0, l2 = l2 + Math.imul(B3, dt) | 0, s2 = s2 + Math.imul(B3, pt) | 0, s2 = s2 + Math.imul(R2, dt) | 0, g2 = g2 + Math.imul(R2, pt) | 0, l2 = l2 + Math.imul(u2, vt) | 0, s2 = s2 + Math.imul(u2, gt) | 0, s2 = s2 + Math.imul(E2, vt) | 0, g2 = g2 + Math.imul(E2, gt) | 0;
      var Ne = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (Ne >>> 26) | 0, Ne &= 67108863, l2 = Math.imul(X, ut), s2 = Math.imul(X, ht), s2 = s2 + Math.imul(Z, ut) | 0, g2 = Math.imul(Z, ht), l2 = l2 + Math.imul(D, ct) | 0, s2 = s2 + Math.imul(D, lt) | 0, s2 = s2 + Math.imul(q, ct) | 0, g2 = g2 + Math.imul(q, lt) | 0, l2 = l2 + Math.imul(P2, dt) | 0, s2 = s2 + Math.imul(P2, pt) | 0, s2 = s2 + Math.imul(O2, dt) | 0, g2 = g2 + Math.imul(O2, pt) | 0, l2 = l2 + Math.imul(B3, vt) | 0, s2 = s2 + Math.imul(B3, gt) | 0, s2 = s2 + Math.imul(R2, vt) | 0, g2 = g2 + Math.imul(R2, gt) | 0, l2 = l2 + Math.imul(u2, mt) | 0, s2 = s2 + Math.imul(u2, At) | 0, s2 = s2 + Math.imul(E2, mt) | 0, g2 = g2 + Math.imul(E2, At) | 0;
      var Ie = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, l2 = Math.imul($2, ut), s2 = Math.imul($2, ht), s2 = s2 + Math.imul(tt, ut) | 0, g2 = Math.imul(tt, ht), l2 = l2 + Math.imul(X, ct) | 0, s2 = s2 + Math.imul(X, lt) | 0, s2 = s2 + Math.imul(Z, ct) | 0, g2 = g2 + Math.imul(Z, lt) | 0, l2 = l2 + Math.imul(D, dt) | 0, s2 = s2 + Math.imul(D, pt) | 0, s2 = s2 + Math.imul(q, dt) | 0, g2 = g2 + Math.imul(q, pt) | 0, l2 = l2 + Math.imul(P2, vt) | 0, s2 = s2 + Math.imul(P2, gt) | 0, s2 = s2 + Math.imul(O2, vt) | 0, g2 = g2 + Math.imul(O2, gt) | 0, l2 = l2 + Math.imul(B3, mt) | 0, s2 = s2 + Math.imul(B3, At) | 0, s2 = s2 + Math.imul(R2, mt) | 0, g2 = g2 + Math.imul(R2, At) | 0, l2 = l2 + Math.imul(u2, bt) | 0, s2 = s2 + Math.imul(u2, yt) | 0, s2 = s2 + Math.imul(E2, bt) | 0, g2 = g2 + Math.imul(E2, yt) | 0;
      var $r = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, l2 = Math.imul(et, ut), s2 = Math.imul(et, ht), s2 = s2 + Math.imul(rt, ut) | 0, g2 = Math.imul(rt, ht), l2 = l2 + Math.imul($2, ct) | 0, s2 = s2 + Math.imul($2, lt) | 0, s2 = s2 + Math.imul(tt, ct) | 0, g2 = g2 + Math.imul(tt, lt) | 0, l2 = l2 + Math.imul(X, dt) | 0, s2 = s2 + Math.imul(X, pt) | 0, s2 = s2 + Math.imul(Z, dt) | 0, g2 = g2 + Math.imul(Z, pt) | 0, l2 = l2 + Math.imul(D, vt) | 0, s2 = s2 + Math.imul(D, gt) | 0, s2 = s2 + Math.imul(q, vt) | 0, g2 = g2 + Math.imul(q, gt) | 0, l2 = l2 + Math.imul(P2, mt) | 0, s2 = s2 + Math.imul(P2, At) | 0, s2 = s2 + Math.imul(O2, mt) | 0, g2 = g2 + Math.imul(O2, At) | 0, l2 = l2 + Math.imul(B3, bt) | 0, s2 = s2 + Math.imul(B3, yt) | 0, s2 = s2 + Math.imul(R2, bt) | 0, g2 = g2 + Math.imul(R2, yt) | 0, l2 = l2 + Math.imul(u2, wt) | 0, s2 = s2 + Math.imul(u2, xt) | 0, s2 = s2 + Math.imul(E2, wt) | 0, g2 = g2 + Math.imul(E2, xt) | 0;
      var ti = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (ti >>> 26) | 0, ti &= 67108863, l2 = Math.imul(it, ut), s2 = Math.imul(it, ht), s2 = s2 + Math.imul(nt, ut) | 0, g2 = Math.imul(nt, ht), l2 = l2 + Math.imul(et, ct) | 0, s2 = s2 + Math.imul(et, lt) | 0, s2 = s2 + Math.imul(rt, ct) | 0, g2 = g2 + Math.imul(rt, lt) | 0, l2 = l2 + Math.imul($2, dt) | 0, s2 = s2 + Math.imul($2, pt) | 0, s2 = s2 + Math.imul(tt, dt) | 0, g2 = g2 + Math.imul(tt, pt) | 0, l2 = l2 + Math.imul(X, vt) | 0, s2 = s2 + Math.imul(X, gt) | 0, s2 = s2 + Math.imul(Z, vt) | 0, g2 = g2 + Math.imul(Z, gt) | 0, l2 = l2 + Math.imul(D, mt) | 0, s2 = s2 + Math.imul(D, At) | 0, s2 = s2 + Math.imul(q, mt) | 0, g2 = g2 + Math.imul(q, At) | 0, l2 = l2 + Math.imul(P2, bt) | 0, s2 = s2 + Math.imul(P2, yt) | 0, s2 = s2 + Math.imul(O2, bt) | 0, g2 = g2 + Math.imul(O2, yt) | 0, l2 = l2 + Math.imul(B3, wt) | 0, s2 = s2 + Math.imul(B3, xt) | 0, s2 = s2 + Math.imul(R2, wt) | 0, g2 = g2 + Math.imul(R2, xt) | 0, l2 = l2 + Math.imul(u2, Mt) | 0, s2 = s2 + Math.imul(u2, Et) | 0, s2 = s2 + Math.imul(E2, Mt) | 0, g2 = g2 + Math.imul(E2, Et) | 0;
      var ei = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (ei >>> 26) | 0, ei &= 67108863, l2 = Math.imul(ft, ut), s2 = Math.imul(ft, ht), s2 = s2 + Math.imul(ot, ut) | 0, g2 = Math.imul(ot, ht), l2 = l2 + Math.imul(it, ct) | 0, s2 = s2 + Math.imul(it, lt) | 0, s2 = s2 + Math.imul(nt, ct) | 0, g2 = g2 + Math.imul(nt, lt) | 0, l2 = l2 + Math.imul(et, dt) | 0, s2 = s2 + Math.imul(et, pt) | 0, s2 = s2 + Math.imul(rt, dt) | 0, g2 = g2 + Math.imul(rt, pt) | 0, l2 = l2 + Math.imul($2, vt) | 0, s2 = s2 + Math.imul($2, gt) | 0, s2 = s2 + Math.imul(tt, vt) | 0, g2 = g2 + Math.imul(tt, gt) | 0, l2 = l2 + Math.imul(X, mt) | 0, s2 = s2 + Math.imul(X, At) | 0, s2 = s2 + Math.imul(Z, mt) | 0, g2 = g2 + Math.imul(Z, At) | 0, l2 = l2 + Math.imul(D, bt) | 0, s2 = s2 + Math.imul(D, yt) | 0, s2 = s2 + Math.imul(q, bt) | 0, g2 = g2 + Math.imul(q, yt) | 0, l2 = l2 + Math.imul(P2, wt) | 0, s2 = s2 + Math.imul(P2, xt) | 0, s2 = s2 + Math.imul(O2, wt) | 0, g2 = g2 + Math.imul(O2, xt) | 0, l2 = l2 + Math.imul(B3, Mt) | 0, s2 = s2 + Math.imul(B3, Et) | 0, s2 = s2 + Math.imul(R2, Mt) | 0, g2 = g2 + Math.imul(R2, Et) | 0, l2 = l2 + Math.imul(u2, St) | 0, s2 = s2 + Math.imul(u2, Nt2) | 0, s2 = s2 + Math.imul(E2, St) | 0, g2 = g2 + Math.imul(E2, Nt2) | 0;
      var ri = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (ri >>> 26) | 0, ri &= 67108863, l2 = Math.imul(st, ut), s2 = Math.imul(st, ht), s2 = s2 + Math.imul(at, ut) | 0, g2 = Math.imul(at, ht), l2 = l2 + Math.imul(ft, ct) | 0, s2 = s2 + Math.imul(ft, lt) | 0, s2 = s2 + Math.imul(ot, ct) | 0, g2 = g2 + Math.imul(ot, lt) | 0, l2 = l2 + Math.imul(it, dt) | 0, s2 = s2 + Math.imul(it, pt) | 0, s2 = s2 + Math.imul(nt, dt) | 0, g2 = g2 + Math.imul(nt, pt) | 0, l2 = l2 + Math.imul(et, vt) | 0, s2 = s2 + Math.imul(et, gt) | 0, s2 = s2 + Math.imul(rt, vt) | 0, g2 = g2 + Math.imul(rt, gt) | 0, l2 = l2 + Math.imul($2, mt) | 0, s2 = s2 + Math.imul($2, At) | 0, s2 = s2 + Math.imul(tt, mt) | 0, g2 = g2 + Math.imul(tt, At) | 0, l2 = l2 + Math.imul(X, bt) | 0, s2 = s2 + Math.imul(X, yt) | 0, s2 = s2 + Math.imul(Z, bt) | 0, g2 = g2 + Math.imul(Z, yt) | 0, l2 = l2 + Math.imul(D, wt) | 0, s2 = s2 + Math.imul(D, xt) | 0, s2 = s2 + Math.imul(q, wt) | 0, g2 = g2 + Math.imul(q, xt) | 0, l2 = l2 + Math.imul(P2, Mt) | 0, s2 = s2 + Math.imul(P2, Et) | 0, s2 = s2 + Math.imul(O2, Mt) | 0, g2 = g2 + Math.imul(O2, Et) | 0, l2 = l2 + Math.imul(B3, St) | 0, s2 = s2 + Math.imul(B3, Nt2) | 0, s2 = s2 + Math.imul(R2, St) | 0, g2 = g2 + Math.imul(R2, Nt2) | 0, l2 = l2 + Math.imul(u2, It) | 0, s2 = s2 + Math.imul(u2, _t) | 0, s2 = s2 + Math.imul(E2, It) | 0, g2 = g2 + Math.imul(E2, _t) | 0;
      var ii = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (ii >>> 26) | 0, ii &= 67108863, l2 = Math.imul(st, ct), s2 = Math.imul(st, lt), s2 = s2 + Math.imul(at, ct) | 0, g2 = Math.imul(at, lt), l2 = l2 + Math.imul(ft, dt) | 0, s2 = s2 + Math.imul(ft, pt) | 0, s2 = s2 + Math.imul(ot, dt) | 0, g2 = g2 + Math.imul(ot, pt) | 0, l2 = l2 + Math.imul(it, vt) | 0, s2 = s2 + Math.imul(it, gt) | 0, s2 = s2 + Math.imul(nt, vt) | 0, g2 = g2 + Math.imul(nt, gt) | 0, l2 = l2 + Math.imul(et, mt) | 0, s2 = s2 + Math.imul(et, At) | 0, s2 = s2 + Math.imul(rt, mt) | 0, g2 = g2 + Math.imul(rt, At) | 0, l2 = l2 + Math.imul($2, bt) | 0, s2 = s2 + Math.imul($2, yt) | 0, s2 = s2 + Math.imul(tt, bt) | 0, g2 = g2 + Math.imul(tt, yt) | 0, l2 = l2 + Math.imul(X, wt) | 0, s2 = s2 + Math.imul(X, xt) | 0, s2 = s2 + Math.imul(Z, wt) | 0, g2 = g2 + Math.imul(Z, xt) | 0, l2 = l2 + Math.imul(D, Mt) | 0, s2 = s2 + Math.imul(D, Et) | 0, s2 = s2 + Math.imul(q, Mt) | 0, g2 = g2 + Math.imul(q, Et) | 0, l2 = l2 + Math.imul(P2, St) | 0, s2 = s2 + Math.imul(P2, Nt2) | 0, s2 = s2 + Math.imul(O2, St) | 0, g2 = g2 + Math.imul(O2, Nt2) | 0, l2 = l2 + Math.imul(B3, It) | 0, s2 = s2 + Math.imul(B3, _t) | 0, s2 = s2 + Math.imul(R2, It) | 0, g2 = g2 + Math.imul(R2, _t) | 0;
      var ni = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (ni >>> 26) | 0, ni &= 67108863, l2 = Math.imul(st, dt), s2 = Math.imul(st, pt), s2 = s2 + Math.imul(at, dt) | 0, g2 = Math.imul(at, pt), l2 = l2 + Math.imul(ft, vt) | 0, s2 = s2 + Math.imul(ft, gt) | 0, s2 = s2 + Math.imul(ot, vt) | 0, g2 = g2 + Math.imul(ot, gt) | 0, l2 = l2 + Math.imul(it, mt) | 0, s2 = s2 + Math.imul(it, At) | 0, s2 = s2 + Math.imul(nt, mt) | 0, g2 = g2 + Math.imul(nt, At) | 0, l2 = l2 + Math.imul(et, bt) | 0, s2 = s2 + Math.imul(et, yt) | 0, s2 = s2 + Math.imul(rt, bt) | 0, g2 = g2 + Math.imul(rt, yt) | 0, l2 = l2 + Math.imul($2, wt) | 0, s2 = s2 + Math.imul($2, xt) | 0, s2 = s2 + Math.imul(tt, wt) | 0, g2 = g2 + Math.imul(tt, xt) | 0, l2 = l2 + Math.imul(X, Mt) | 0, s2 = s2 + Math.imul(X, Et) | 0, s2 = s2 + Math.imul(Z, Mt) | 0, g2 = g2 + Math.imul(Z, Et) | 0, l2 = l2 + Math.imul(D, St) | 0, s2 = s2 + Math.imul(D, Nt2) | 0, s2 = s2 + Math.imul(q, St) | 0, g2 = g2 + Math.imul(q, Nt2) | 0, l2 = l2 + Math.imul(P2, It) | 0, s2 = s2 + Math.imul(P2, _t) | 0, s2 = s2 + Math.imul(O2, It) | 0, g2 = g2 + Math.imul(O2, _t) | 0;
      var fi = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, l2 = Math.imul(st, vt), s2 = Math.imul(st, gt), s2 = s2 + Math.imul(at, vt) | 0, g2 = Math.imul(at, gt), l2 = l2 + Math.imul(ft, mt) | 0, s2 = s2 + Math.imul(ft, At) | 0, s2 = s2 + Math.imul(ot, mt) | 0, g2 = g2 + Math.imul(ot, At) | 0, l2 = l2 + Math.imul(it, bt) | 0, s2 = s2 + Math.imul(it, yt) | 0, s2 = s2 + Math.imul(nt, bt) | 0, g2 = g2 + Math.imul(nt, yt) | 0, l2 = l2 + Math.imul(et, wt) | 0, s2 = s2 + Math.imul(et, xt) | 0, s2 = s2 + Math.imul(rt, wt) | 0, g2 = g2 + Math.imul(rt, xt) | 0, l2 = l2 + Math.imul($2, Mt) | 0, s2 = s2 + Math.imul($2, Et) | 0, s2 = s2 + Math.imul(tt, Mt) | 0, g2 = g2 + Math.imul(tt, Et) | 0, l2 = l2 + Math.imul(X, St) | 0, s2 = s2 + Math.imul(X, Nt2) | 0, s2 = s2 + Math.imul(Z, St) | 0, g2 = g2 + Math.imul(Z, Nt2) | 0, l2 = l2 + Math.imul(D, It) | 0, s2 = s2 + Math.imul(D, _t) | 0, s2 = s2 + Math.imul(q, It) | 0, g2 = g2 + Math.imul(q, _t) | 0;
      var oi = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (oi >>> 26) | 0, oi &= 67108863, l2 = Math.imul(st, mt), s2 = Math.imul(st, At), s2 = s2 + Math.imul(at, mt) | 0, g2 = Math.imul(at, At), l2 = l2 + Math.imul(ft, bt) | 0, s2 = s2 + Math.imul(ft, yt) | 0, s2 = s2 + Math.imul(ot, bt) | 0, g2 = g2 + Math.imul(ot, yt) | 0, l2 = l2 + Math.imul(it, wt) | 0, s2 = s2 + Math.imul(it, xt) | 0, s2 = s2 + Math.imul(nt, wt) | 0, g2 = g2 + Math.imul(nt, xt) | 0, l2 = l2 + Math.imul(et, Mt) | 0, s2 = s2 + Math.imul(et, Et) | 0, s2 = s2 + Math.imul(rt, Mt) | 0, g2 = g2 + Math.imul(rt, Et) | 0, l2 = l2 + Math.imul($2, St) | 0, s2 = s2 + Math.imul($2, Nt2) | 0, s2 = s2 + Math.imul(tt, St) | 0, g2 = g2 + Math.imul(tt, Nt2) | 0, l2 = l2 + Math.imul(X, It) | 0, s2 = s2 + Math.imul(X, _t) | 0, s2 = s2 + Math.imul(Z, It) | 0, g2 = g2 + Math.imul(Z, _t) | 0;
      var si = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (si >>> 26) | 0, si &= 67108863, l2 = Math.imul(st, bt), s2 = Math.imul(st, yt), s2 = s2 + Math.imul(at, bt) | 0, g2 = Math.imul(at, yt), l2 = l2 + Math.imul(ft, wt) | 0, s2 = s2 + Math.imul(ft, xt) | 0, s2 = s2 + Math.imul(ot, wt) | 0, g2 = g2 + Math.imul(ot, xt) | 0, l2 = l2 + Math.imul(it, Mt) | 0, s2 = s2 + Math.imul(it, Et) | 0, s2 = s2 + Math.imul(nt, Mt) | 0, g2 = g2 + Math.imul(nt, Et) | 0, l2 = l2 + Math.imul(et, St) | 0, s2 = s2 + Math.imul(et, Nt2) | 0, s2 = s2 + Math.imul(rt, St) | 0, g2 = g2 + Math.imul(rt, Nt2) | 0, l2 = l2 + Math.imul($2, It) | 0, s2 = s2 + Math.imul($2, _t) | 0, s2 = s2 + Math.imul(tt, It) | 0, g2 = g2 + Math.imul(tt, _t) | 0;
      var ai = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (ai >>> 26) | 0, ai &= 67108863, l2 = Math.imul(st, wt), s2 = Math.imul(st, xt), s2 = s2 + Math.imul(at, wt) | 0, g2 = Math.imul(at, xt), l2 = l2 + Math.imul(ft, Mt) | 0, s2 = s2 + Math.imul(ft, Et) | 0, s2 = s2 + Math.imul(ot, Mt) | 0, g2 = g2 + Math.imul(ot, Et) | 0, l2 = l2 + Math.imul(it, St) | 0, s2 = s2 + Math.imul(it, Nt2) | 0, s2 = s2 + Math.imul(nt, St) | 0, g2 = g2 + Math.imul(nt, Nt2) | 0, l2 = l2 + Math.imul(et, It) | 0, s2 = s2 + Math.imul(et, _t) | 0, s2 = s2 + Math.imul(rt, It) | 0, g2 = g2 + Math.imul(rt, _t) | 0;
      var ui = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (ui >>> 26) | 0, ui &= 67108863, l2 = Math.imul(st, Mt), s2 = Math.imul(st, Et), s2 = s2 + Math.imul(at, Mt) | 0, g2 = Math.imul(at, Et), l2 = l2 + Math.imul(ft, St) | 0, s2 = s2 + Math.imul(ft, Nt2) | 0, s2 = s2 + Math.imul(ot, St) | 0, g2 = g2 + Math.imul(ot, Nt2) | 0, l2 = l2 + Math.imul(it, It) | 0, s2 = s2 + Math.imul(it, _t) | 0, s2 = s2 + Math.imul(nt, It) | 0, g2 = g2 + Math.imul(nt, _t) | 0;
      var hi = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (hi >>> 26) | 0, hi &= 67108863, l2 = Math.imul(st, St), s2 = Math.imul(st, Nt2), s2 = s2 + Math.imul(at, St) | 0, g2 = Math.imul(at, Nt2), l2 = l2 + Math.imul(ft, It) | 0, s2 = s2 + Math.imul(ft, _t) | 0, s2 = s2 + Math.imul(ot, It) | 0, g2 = g2 + Math.imul(ot, _t) | 0;
      var ci = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      M2 = (g2 + (s2 >>> 13) | 0) + (ci >>> 26) | 0, ci &= 67108863, l2 = Math.imul(st, It), s2 = Math.imul(st, _t), s2 = s2 + Math.imul(at, It) | 0, g2 = Math.imul(at, _t);
      var li = (M2 + l2 | 0) + ((s2 & 8191) << 13) | 0;
      return M2 = (g2 + (s2 >>> 13) | 0) + (li >>> 26) | 0, li &= 67108863, x2[0] = Me, x2[1] = Ee, x2[2] = Se, x2[3] = Ne, x2[4] = Ie, x2[5] = $r, x2[6] = ti, x2[7] = ei, x2[8] = ri, x2[9] = ii, x2[10] = ni, x2[11] = fi, x2[12] = oi, x2[13] = si, x2[14] = ai, x2[15] = ui, x2[16] = hi, x2[17] = ci, x2[18] = li, M2 !== 0 && (x2[19] = M2, c2.length++), c2;
    };
    Math.imul || (J = U);
    function Bt(b2, f2, a2) {
      a2.negative = f2.negative ^ b2.negative, a2.length = b2.length + f2.length;
      for (var c2 = 0, d3 = 0, m3 = 0; m3 < a2.length - 1; m3++) {
        var x2 = d3;
        d3 = 0;
        for (var M2 = c2 & 67108863, l2 = Math.min(m3, f2.length - 1), s2 = Math.max(0, m3 - b2.length + 1); s2 <= l2; s2++) {
          var g2 = m3 - s2, k2 = b2.words[g2] | 0, u2 = f2.words[s2] | 0, E2 = k2 * u2, _2 = E2 & 67108863;
          x2 = x2 + (E2 / 67108864 | 0) | 0, _2 = _2 + M2 | 0, M2 = _2 & 67108863, x2 = x2 + (_2 >>> 26) | 0, d3 += x2 >>> 26, x2 &= 67108863;
        }
        a2.words[m3] = M2, c2 = x2, x2 = d3;
      }
      return c2 !== 0 ? a2.words[m3] = c2 : a2.length--, a2._strip();
    }
    function G(b2, f2, a2) {
      return Bt(b2, f2, a2);
    }
    o2.prototype.mulTo = function(f2, a2) {
      var c2, d3 = this.length + f2.length;
      return this.length === 10 && f2.length === 10 ? c2 = J(this, f2, a2) : d3 < 63 ? c2 = U(this, f2, a2) : d3 < 1024 ? c2 = Bt(this, f2, a2) : c2 = G(this, f2, a2), c2;
    }, o2.prototype.mul = function(f2) {
      var a2 = new o2(null);
      return a2.words = new Array(this.length + f2.length), this.mulTo(f2, a2);
    }, o2.prototype.mulf = function(f2) {
      var a2 = new o2(null);
      return a2.words = new Array(this.length + f2.length), G(this, f2, a2);
    }, o2.prototype.imul = function(f2) {
      return this.clone().mulTo(f2, this);
    }, o2.prototype.imuln = function(f2) {
      var a2 = f2 < 0;
      a2 && (f2 = -f2), i4(typeof f2 == "number"), i4(f2 < 67108864);
      for (var c2 = 0, d3 = 0; d3 < this.length; d3++) {
        var m3 = (this.words[d3] | 0) * f2, x2 = (m3 & 67108863) + (c2 & 67108863);
        c2 >>= 26, c2 += m3 / 67108864 | 0, c2 += x2 >>> 26, this.words[d3] = x2 & 67108863;
      }
      return c2 !== 0 && (this.words[d3] = c2, this.length++), a2 ? this.ineg() : this;
    }, o2.prototype.muln = function(f2) {
      return this.clone().imuln(f2);
    }, o2.prototype.sqr = function() {
      return this.mul(this);
    }, o2.prototype.isqr = function() {
      return this.imul(this.clone());
    }, o2.prototype.pow = function(f2) {
      var a2 = F(f2);
      if (a2.length === 0) return new o2(1);
      for (var c2 = this, d3 = 0; d3 < a2.length && a2[d3] === 0; d3++, c2 = c2.sqr()) ;
      if (++d3 < a2.length) for (var m3 = c2.sqr(); d3 < a2.length; d3++, m3 = m3.sqr()) a2[d3] !== 0 && (c2 = c2.mul(m3));
      return c2;
    }, o2.prototype.iushln = function(f2) {
      i4(typeof f2 == "number" && f2 >= 0);
      var a2 = f2 % 26, c2 = (f2 - a2) / 26, d3 = 67108863 >>> 26 - a2 << 26 - a2, m3;
      if (a2 !== 0) {
        var x2 = 0;
        for (m3 = 0; m3 < this.length; m3++) {
          var M2 = this.words[m3] & d3, l2 = (this.words[m3] | 0) - M2 << a2;
          this.words[m3] = l2 | x2, x2 = M2 >>> 26 - a2;
        }
        x2 && (this.words[m3] = x2, this.length++);
      }
      if (c2 !== 0) {
        for (m3 = this.length - 1; m3 >= 0; m3--) this.words[m3 + c2] = this.words[m3];
        for (m3 = 0; m3 < c2; m3++) this.words[m3] = 0;
        this.length += c2;
      }
      return this._strip();
    }, o2.prototype.ishln = function(f2) {
      return i4(this.negative === 0), this.iushln(f2);
    }, o2.prototype.iushrn = function(f2, a2, c2) {
      i4(typeof f2 == "number" && f2 >= 0);
      var d3;
      a2 ? d3 = (a2 - a2 % 26) / 26 : d3 = 0;
      var m3 = f2 % 26, x2 = Math.min((f2 - m3) / 26, this.length), M2 = 67108863 ^ 67108863 >>> m3 << m3, l2 = c2;
      if (d3 -= x2, d3 = Math.max(0, d3), l2) {
        for (var s2 = 0; s2 < x2; s2++) l2.words[s2] = this.words[s2];
        l2.length = x2;
      }
      if (x2 !== 0) if (this.length > x2) for (this.length -= x2, s2 = 0; s2 < this.length; s2++) this.words[s2] = this.words[s2 + x2];
      else this.words[0] = 0, this.length = 1;
      var g2 = 0;
      for (s2 = this.length - 1; s2 >= 0 && (g2 !== 0 || s2 >= d3); s2--) {
        var k2 = this.words[s2] | 0;
        this.words[s2] = g2 << 26 - m3 | k2 >>> m3, g2 = k2 & M2;
      }
      return l2 && g2 !== 0 && (l2.words[l2.length++] = g2), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, o2.prototype.ishrn = function(f2, a2, c2) {
      return i4(this.negative === 0), this.iushrn(f2, a2, c2);
    }, o2.prototype.shln = function(f2) {
      return this.clone().ishln(f2);
    }, o2.prototype.ushln = function(f2) {
      return this.clone().iushln(f2);
    }, o2.prototype.shrn = function(f2) {
      return this.clone().ishrn(f2);
    }, o2.prototype.ushrn = function(f2) {
      return this.clone().iushrn(f2);
    }, o2.prototype.testn = function(f2) {
      i4(typeof f2 == "number" && f2 >= 0);
      var a2 = f2 % 26, c2 = (f2 - a2) / 26, d3 = 1 << a2;
      if (this.length <= c2) return false;
      var m3 = this.words[c2];
      return !!(m3 & d3);
    }, o2.prototype.imaskn = function(f2) {
      i4(typeof f2 == "number" && f2 >= 0);
      var a2 = f2 % 26, c2 = (f2 - a2) / 26;
      if (i4(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c2) return this;
      if (a2 !== 0 && c2++, this.length = Math.min(c2, this.length), a2 !== 0) {
        var d3 = 67108863 ^ 67108863 >>> a2 << a2;
        this.words[this.length - 1] &= d3;
      }
      return this._strip();
    }, o2.prototype.maskn = function(f2) {
      return this.clone().imaskn(f2);
    }, o2.prototype.iaddn = function(f2) {
      return i4(typeof f2 == "number"), i4(f2 < 67108864), f2 < 0 ? this.isubn(-f2) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f2 ? (this.words[0] = f2 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f2), this.negative = 1, this) : this._iaddn(f2);
    }, o2.prototype._iaddn = function(f2) {
      this.words[0] += f2;
      for (var a2 = 0; a2 < this.length && this.words[a2] >= 67108864; a2++) this.words[a2] -= 67108864, a2 === this.length - 1 ? this.words[a2 + 1] = 1 : this.words[a2 + 1]++;
      return this.length = Math.max(this.length, a2 + 1), this;
    }, o2.prototype.isubn = function(f2) {
      if (i4(typeof f2 == "number"), i4(f2 < 67108864), f2 < 0) return this.iaddn(-f2);
      if (this.negative !== 0) return this.negative = 0, this.iaddn(f2), this.negative = 1, this;
      if (this.words[0] -= f2, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
      else for (var a2 = 0; a2 < this.length && this.words[a2] < 0; a2++) this.words[a2] += 67108864, this.words[a2 + 1] -= 1;
      return this._strip();
    }, o2.prototype.addn = function(f2) {
      return this.clone().iaddn(f2);
    }, o2.prototype.subn = function(f2) {
      return this.clone().isubn(f2);
    }, o2.prototype.iabs = function() {
      return this.negative = 0, this;
    }, o2.prototype.abs = function() {
      return this.clone().iabs();
    }, o2.prototype._ishlnsubmul = function(f2, a2, c2) {
      var d3 = f2.length + c2, m3;
      this._expand(d3);
      var x2, M2 = 0;
      for (m3 = 0; m3 < f2.length; m3++) {
        x2 = (this.words[m3 + c2] | 0) + M2;
        var l2 = (f2.words[m3] | 0) * a2;
        x2 -= l2 & 67108863, M2 = (x2 >> 26) - (l2 / 67108864 | 0), this.words[m3 + c2] = x2 & 67108863;
      }
      for (; m3 < this.length - c2; m3++) x2 = (this.words[m3 + c2] | 0) + M2, M2 = x2 >> 26, this.words[m3 + c2] = x2 & 67108863;
      if (M2 === 0) return this._strip();
      for (i4(M2 === -1), M2 = 0, m3 = 0; m3 < this.length; m3++) x2 = -(this.words[m3] | 0) + M2, M2 = x2 >> 26, this.words[m3] = x2 & 67108863;
      return this.negative = 1, this._strip();
    }, o2.prototype._wordDiv = function(f2, a2) {
      var c2 = this.length - f2.length, d3 = this.clone(), m3 = f2, x2 = m3.words[m3.length - 1] | 0, M2 = this._countBits(x2);
      c2 = 26 - M2, c2 !== 0 && (m3 = m3.ushln(c2), d3.iushln(c2), x2 = m3.words[m3.length - 1] | 0);
      var l2 = d3.length - m3.length, s2;
      if (a2 !== "mod") {
        s2 = new o2(null), s2.length = l2 + 1, s2.words = new Array(s2.length);
        for (var g2 = 0; g2 < s2.length; g2++) s2.words[g2] = 0;
      }
      var k2 = d3.clone()._ishlnsubmul(m3, 1, l2);
      k2.negative === 0 && (d3 = k2, s2 && (s2.words[l2] = 1));
      for (var u2 = l2 - 1; u2 >= 0; u2--) {
        var E2 = (d3.words[m3.length + u2] | 0) * 67108864 + (d3.words[m3.length + u2 - 1] | 0);
        for (E2 = Math.min(E2 / x2 | 0, 67108863), d3._ishlnsubmul(m3, E2, u2); d3.negative !== 0; ) E2--, d3.negative = 0, d3._ishlnsubmul(m3, 1, u2), d3.isZero() || (d3.negative ^= 1);
        s2 && (s2.words[u2] = E2);
      }
      return s2 && s2._strip(), d3._strip(), a2 !== "div" && c2 !== 0 && d3.iushrn(c2), { div: s2 || null, mod: d3 };
    }, o2.prototype.divmod = function(f2, a2, c2) {
      if (i4(!f2.isZero()), this.isZero()) return { div: new o2(0), mod: new o2(0) };
      var d3, m3, x2;
      return this.negative !== 0 && f2.negative === 0 ? (x2 = this.neg().divmod(f2, a2), a2 !== "mod" && (d3 = x2.div.neg()), a2 !== "div" && (m3 = x2.mod.neg(), c2 && m3.negative !== 0 && m3.iadd(f2)), { div: d3, mod: m3 }) : this.negative === 0 && f2.negative !== 0 ? (x2 = this.divmod(f2.neg(), a2), a2 !== "mod" && (d3 = x2.div.neg()), { div: d3, mod: x2.mod }) : this.negative & f2.negative ? (x2 = this.neg().divmod(f2.neg(), a2), a2 !== "div" && (m3 = x2.mod.neg(), c2 && m3.negative !== 0 && m3.isub(f2)), { div: x2.div, mod: m3 }) : f2.length > this.length || this.cmp(f2) < 0 ? { div: new o2(0), mod: this } : f2.length === 1 ? a2 === "div" ? { div: this.divn(f2.words[0]), mod: null } : a2 === "mod" ? { div: null, mod: new o2(this.modrn(f2.words[0])) } : { div: this.divn(f2.words[0]), mod: new o2(this.modrn(f2.words[0])) } : this._wordDiv(f2, a2);
    }, o2.prototype.div = function(f2) {
      return this.divmod(f2, "div", false).div;
    }, o2.prototype.mod = function(f2) {
      return this.divmod(f2, "mod", false).mod;
    }, o2.prototype.umod = function(f2) {
      return this.divmod(f2, "mod", true).mod;
    }, o2.prototype.divRound = function(f2) {
      var a2 = this.divmod(f2);
      if (a2.mod.isZero()) return a2.div;
      var c2 = a2.div.negative !== 0 ? a2.mod.isub(f2) : a2.mod, d3 = f2.ushrn(1), m3 = f2.andln(1), x2 = c2.cmp(d3);
      return x2 < 0 || m3 === 1 && x2 === 0 ? a2.div : a2.div.negative !== 0 ? a2.div.isubn(1) : a2.div.iaddn(1);
    }, o2.prototype.modrn = function(f2) {
      var a2 = f2 < 0;
      a2 && (f2 = -f2), i4(f2 <= 67108863);
      for (var c2 = (1 << 26) % f2, d3 = 0, m3 = this.length - 1; m3 >= 0; m3--) d3 = (c2 * d3 + (this.words[m3] | 0)) % f2;
      return a2 ? -d3 : d3;
    }, o2.prototype.modn = function(f2) {
      return this.modrn(f2);
    }, o2.prototype.idivn = function(f2) {
      var a2 = f2 < 0;
      a2 && (f2 = -f2), i4(f2 <= 67108863);
      for (var c2 = 0, d3 = this.length - 1; d3 >= 0; d3--) {
        var m3 = (this.words[d3] | 0) + c2 * 67108864;
        this.words[d3] = m3 / f2 | 0, c2 = m3 % f2;
      }
      return this._strip(), a2 ? this.ineg() : this;
    }, o2.prototype.divn = function(f2) {
      return this.clone().idivn(f2);
    }, o2.prototype.egcd = function(f2) {
      i4(f2.negative === 0), i4(!f2.isZero());
      var a2 = this, c2 = f2.clone();
      a2.negative !== 0 ? a2 = a2.umod(f2) : a2 = a2.clone();
      for (var d3 = new o2(1), m3 = new o2(0), x2 = new o2(0), M2 = new o2(1), l2 = 0; a2.isEven() && c2.isEven(); ) a2.iushrn(1), c2.iushrn(1), ++l2;
      for (var s2 = c2.clone(), g2 = a2.clone(); !a2.isZero(); ) {
        for (var k2 = 0, u2 = 1; !(a2.words[0] & u2) && k2 < 26; ++k2, u2 <<= 1) ;
        if (k2 > 0) for (a2.iushrn(k2); k2-- > 0; ) (d3.isOdd() || m3.isOdd()) && (d3.iadd(s2), m3.isub(g2)), d3.iushrn(1), m3.iushrn(1);
        for (var E2 = 0, _2 = 1; !(c2.words[0] & _2) && E2 < 26; ++E2, _2 <<= 1) ;
        if (E2 > 0) for (c2.iushrn(E2); E2-- > 0; ) (x2.isOdd() || M2.isOdd()) && (x2.iadd(s2), M2.isub(g2)), x2.iushrn(1), M2.iushrn(1);
        a2.cmp(c2) >= 0 ? (a2.isub(c2), d3.isub(x2), m3.isub(M2)) : (c2.isub(a2), x2.isub(d3), M2.isub(m3));
      }
      return { a: x2, b: M2, gcd: c2.iushln(l2) };
    }, o2.prototype._invmp = function(f2) {
      i4(f2.negative === 0), i4(!f2.isZero());
      var a2 = this, c2 = f2.clone();
      a2.negative !== 0 ? a2 = a2.umod(f2) : a2 = a2.clone();
      for (var d3 = new o2(1), m3 = new o2(0), x2 = c2.clone(); a2.cmpn(1) > 0 && c2.cmpn(1) > 0; ) {
        for (var M2 = 0, l2 = 1; !(a2.words[0] & l2) && M2 < 26; ++M2, l2 <<= 1) ;
        if (M2 > 0) for (a2.iushrn(M2); M2-- > 0; ) d3.isOdd() && d3.iadd(x2), d3.iushrn(1);
        for (var s2 = 0, g2 = 1; !(c2.words[0] & g2) && s2 < 26; ++s2, g2 <<= 1) ;
        if (s2 > 0) for (c2.iushrn(s2); s2-- > 0; ) m3.isOdd() && m3.iadd(x2), m3.iushrn(1);
        a2.cmp(c2) >= 0 ? (a2.isub(c2), d3.isub(m3)) : (c2.isub(a2), m3.isub(d3));
      }
      var k2;
      return a2.cmpn(1) === 0 ? k2 = d3 : k2 = m3, k2.cmpn(0) < 0 && k2.iadd(f2), k2;
    }, o2.prototype.gcd = function(f2) {
      if (this.isZero()) return f2.abs();
      if (f2.isZero()) return this.abs();
      var a2 = this.clone(), c2 = f2.clone();
      a2.negative = 0, c2.negative = 0;
      for (var d3 = 0; a2.isEven() && c2.isEven(); d3++) a2.iushrn(1), c2.iushrn(1);
      do {
        for (; a2.isEven(); ) a2.iushrn(1);
        for (; c2.isEven(); ) c2.iushrn(1);
        var m3 = a2.cmp(c2);
        if (m3 < 0) {
          var x2 = a2;
          a2 = c2, c2 = x2;
        } else if (m3 === 0 || c2.cmpn(1) === 0) break;
        a2.isub(c2);
      } while (true);
      return c2.iushln(d3);
    }, o2.prototype.invm = function(f2) {
      return this.egcd(f2).a.umod(f2);
    }, o2.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, o2.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, o2.prototype.andln = function(f2) {
      return this.words[0] & f2;
    }, o2.prototype.bincn = function(f2) {
      i4(typeof f2 == "number");
      var a2 = f2 % 26, c2 = (f2 - a2) / 26, d3 = 1 << a2;
      if (this.length <= c2) return this._expand(c2 + 1), this.words[c2] |= d3, this;
      for (var m3 = d3, x2 = c2; m3 !== 0 && x2 < this.length; x2++) {
        var M2 = this.words[x2] | 0;
        M2 += m3, m3 = M2 >>> 26, M2 &= 67108863, this.words[x2] = M2;
      }
      return m3 !== 0 && (this.words[x2] = m3, this.length++), this;
    }, o2.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, o2.prototype.cmpn = function(f2) {
      var a2 = f2 < 0;
      if (this.negative !== 0 && !a2) return -1;
      if (this.negative === 0 && a2) return 1;
      this._strip();
      var c2;
      if (this.length > 1) c2 = 1;
      else {
        a2 && (f2 = -f2), i4(f2 <= 67108863, "Number is too big");
        var d3 = this.words[0] | 0;
        c2 = d3 === f2 ? 0 : d3 < f2 ? -1 : 1;
      }
      return this.negative !== 0 ? -c2 | 0 : c2;
    }, o2.prototype.cmp = function(f2) {
      if (this.negative !== 0 && f2.negative === 0) return -1;
      if (this.negative === 0 && f2.negative !== 0) return 1;
      var a2 = this.ucmp(f2);
      return this.negative !== 0 ? -a2 | 0 : a2;
    }, o2.prototype.ucmp = function(f2) {
      if (this.length > f2.length) return 1;
      if (this.length < f2.length) return -1;
      for (var a2 = 0, c2 = this.length - 1; c2 >= 0; c2--) {
        var d3 = this.words[c2] | 0, m3 = f2.words[c2] | 0;
        if (d3 !== m3) {
          d3 < m3 ? a2 = -1 : d3 > m3 && (a2 = 1);
          break;
        }
      }
      return a2;
    }, o2.prototype.gtn = function(f2) {
      return this.cmpn(f2) === 1;
    }, o2.prototype.gt = function(f2) {
      return this.cmp(f2) === 1;
    }, o2.prototype.gten = function(f2) {
      return this.cmpn(f2) >= 0;
    }, o2.prototype.gte = function(f2) {
      return this.cmp(f2) >= 0;
    }, o2.prototype.ltn = function(f2) {
      return this.cmpn(f2) === -1;
    }, o2.prototype.lt = function(f2) {
      return this.cmp(f2) === -1;
    }, o2.prototype.lten = function(f2) {
      return this.cmpn(f2) <= 0;
    }, o2.prototype.lte = function(f2) {
      return this.cmp(f2) <= 0;
    }, o2.prototype.eqn = function(f2) {
      return this.cmpn(f2) === 0;
    }, o2.prototype.eq = function(f2) {
      return this.cmp(f2) === 0;
    }, o2.red = function(f2) {
      return new Y(f2);
    }, o2.prototype.toRed = function(f2) {
      return i4(!this.red, "Already a number in reduction context"), i4(this.negative === 0, "red works only with positives"), f2.convertTo(this)._forceRed(f2);
    }, o2.prototype.fromRed = function() {
      return i4(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, o2.prototype._forceRed = function(f2) {
      return this.red = f2, this;
    }, o2.prototype.forceRed = function(f2) {
      return i4(!this.red, "Already a number in reduction context"), this._forceRed(f2);
    }, o2.prototype.redAdd = function(f2) {
      return i4(this.red, "redAdd works only with red numbers"), this.red.add(this, f2);
    }, o2.prototype.redIAdd = function(f2) {
      return i4(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f2);
    }, o2.prototype.redSub = function(f2) {
      return i4(this.red, "redSub works only with red numbers"), this.red.sub(this, f2);
    }, o2.prototype.redISub = function(f2) {
      return i4(this.red, "redISub works only with red numbers"), this.red.isub(this, f2);
    }, o2.prototype.redShl = function(f2) {
      return i4(this.red, "redShl works only with red numbers"), this.red.shl(this, f2);
    }, o2.prototype.redMul = function(f2) {
      return i4(this.red, "redMul works only with red numbers"), this.red._verify2(this, f2), this.red.mul(this, f2);
    }, o2.prototype.redIMul = function(f2) {
      return i4(this.red, "redMul works only with red numbers"), this.red._verify2(this, f2), this.red.imul(this, f2);
    }, o2.prototype.redSqr = function() {
      return i4(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, o2.prototype.redISqr = function() {
      return i4(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, o2.prototype.redSqrt = function() {
      return i4(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, o2.prototype.redInvm = function() {
      return i4(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, o2.prototype.redNeg = function() {
      return i4(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, o2.prototype.redPow = function(f2) {
      return i4(this.red && !f2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f2);
    };
    var H2 = { k256: null, p224: null, p192: null, p25519: null };
    function L3(b2, f2) {
      this.name = b2, this.p = new o2(f2, 16), this.n = this.p.bitLength(), this.k = new o2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    L3.prototype._tmp = function() {
      var f2 = new o2(null);
      return f2.words = new Array(Math.ceil(this.n / 13)), f2;
    }, L3.prototype.ireduce = function(f2) {
      var a2 = f2, c2;
      do
        this.split(a2, this.tmp), a2 = this.imulK(a2), a2 = a2.iadd(this.tmp), c2 = a2.bitLength();
      while (c2 > this.n);
      var d3 = c2 < this.n ? -1 : a2.ucmp(this.p);
      return d3 === 0 ? (a2.words[0] = 0, a2.length = 1) : d3 > 0 ? a2.isub(this.p) : a2.strip !== void 0 ? a2.strip() : a2._strip(), a2;
    }, L3.prototype.split = function(f2, a2) {
      f2.iushrn(this.n, 0, a2);
    }, L3.prototype.imulK = function(f2) {
      return f2.imul(this.k);
    };
    function Pt() {
      L3.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    n3(Pt, L3), Pt.prototype.split = function(f2, a2) {
      for (var c2 = 4194303, d3 = Math.min(f2.length, 9), m3 = 0; m3 < d3; m3++) a2.words[m3] = f2.words[m3];
      if (a2.length = d3, f2.length <= 9) {
        f2.words[0] = 0, f2.length = 1;
        return;
      }
      var x2 = f2.words[9];
      for (a2.words[a2.length++] = x2 & c2, m3 = 10; m3 < f2.length; m3++) {
        var M2 = f2.words[m3] | 0;
        f2.words[m3 - 10] = (M2 & c2) << 4 | x2 >>> 22, x2 = M2;
      }
      x2 >>>= 22, f2.words[m3 - 10] = x2, x2 === 0 && f2.length > 10 ? f2.length -= 10 : f2.length -= 9;
    }, Pt.prototype.imulK = function(f2) {
      f2.words[f2.length] = 0, f2.words[f2.length + 1] = 0, f2.length += 2;
      for (var a2 = 0, c2 = 0; c2 < f2.length; c2++) {
        var d3 = f2.words[c2] | 0;
        a2 += d3 * 977, f2.words[c2] = a2 & 67108863, a2 = d3 * 64 + (a2 / 67108864 | 0);
      }
      return f2.words[f2.length - 1] === 0 && (f2.length--, f2.words[f2.length - 1] === 0 && f2.length--), f2;
    };
    function W() {
      L3.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    n3(W, L3);
    function Rt() {
      L3.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    n3(Rt, L3);
    function Vt() {
      L3.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    n3(Vt, L3), Vt.prototype.imulK = function(f2) {
      for (var a2 = 0, c2 = 0; c2 < f2.length; c2++) {
        var d3 = (f2.words[c2] | 0) * 19 + a2, m3 = d3 & 67108863;
        d3 >>>= 26, f2.words[c2] = m3, a2 = d3;
      }
      return a2 !== 0 && (f2.words[f2.length++] = a2), f2;
    }, o2._prime = function(f2) {
      if (H2[f2]) return H2[f2];
      var a2;
      if (f2 === "k256") a2 = new Pt();
      else if (f2 === "p224") a2 = new W();
      else if (f2 === "p192") a2 = new Rt();
      else if (f2 === "p25519") a2 = new Vt();
      else throw new Error("Unknown prime " + f2);
      return H2[f2] = a2, a2;
    };
    function Y(b2) {
      if (typeof b2 == "string") {
        var f2 = o2._prime(b2);
        this.m = f2.p, this.prime = f2;
      } else i4(b2.gtn(1), "modulus must be greater than 1"), this.m = b2, this.prime = null;
    }
    Y.prototype._verify1 = function(f2) {
      i4(f2.negative === 0, "red works only with positives"), i4(f2.red, "red works only with red numbers");
    }, Y.prototype._verify2 = function(f2, a2) {
      i4((f2.negative | a2.negative) === 0, "red works only with positives"), i4(f2.red && f2.red === a2.red, "red works only with red numbers");
    }, Y.prototype.imod = function(f2) {
      return this.prime ? this.prime.ireduce(f2)._forceRed(this) : (w2(f2, f2.umod(this.m)._forceRed(this)), f2);
    }, Y.prototype.neg = function(f2) {
      return f2.isZero() ? f2.clone() : this.m.sub(f2)._forceRed(this);
    }, Y.prototype.add = function(f2, a2) {
      this._verify2(f2, a2);
      var c2 = f2.add(a2);
      return c2.cmp(this.m) >= 0 && c2.isub(this.m), c2._forceRed(this);
    }, Y.prototype.iadd = function(f2, a2) {
      this._verify2(f2, a2);
      var c2 = f2.iadd(a2);
      return c2.cmp(this.m) >= 0 && c2.isub(this.m), c2;
    }, Y.prototype.sub = function(f2, a2) {
      this._verify2(f2, a2);
      var c2 = f2.sub(a2);
      return c2.cmpn(0) < 0 && c2.iadd(this.m), c2._forceRed(this);
    }, Y.prototype.isub = function(f2, a2) {
      this._verify2(f2, a2);
      var c2 = f2.isub(a2);
      return c2.cmpn(0) < 0 && c2.iadd(this.m), c2;
    }, Y.prototype.shl = function(f2, a2) {
      return this._verify1(f2), this.imod(f2.ushln(a2));
    }, Y.prototype.imul = function(f2, a2) {
      return this._verify2(f2, a2), this.imod(f2.imul(a2));
    }, Y.prototype.mul = function(f2, a2) {
      return this._verify2(f2, a2), this.imod(f2.mul(a2));
    }, Y.prototype.isqr = function(f2) {
      return this.imul(f2, f2.clone());
    }, Y.prototype.sqr = function(f2) {
      return this.mul(f2, f2);
    }, Y.prototype.sqrt = function(f2) {
      if (f2.isZero()) return f2.clone();
      var a2 = this.m.andln(3);
      if (i4(a2 % 2 === 1), a2 === 3) {
        var c2 = this.m.add(new o2(1)).iushrn(2);
        return this.pow(f2, c2);
      }
      for (var d3 = this.m.subn(1), m3 = 0; !d3.isZero() && d3.andln(1) === 0; ) m3++, d3.iushrn(1);
      i4(!d3.isZero());
      var x2 = new o2(1).toRed(this), M2 = x2.redNeg(), l2 = this.m.subn(1).iushrn(1), s2 = this.m.bitLength();
      for (s2 = new o2(2 * s2 * s2).toRed(this); this.pow(s2, l2).cmp(M2) !== 0; ) s2.redIAdd(M2);
      for (var g2 = this.pow(s2, d3), k2 = this.pow(f2, d3.addn(1).iushrn(1)), u2 = this.pow(f2, d3), E2 = m3; u2.cmp(x2) !== 0; ) {
        for (var _2 = u2, B3 = 0; _2.cmp(x2) !== 0; B3++) _2 = _2.redSqr();
        i4(B3 < E2);
        var R2 = this.pow(g2, new o2(1).iushln(E2 - B3 - 1));
        k2 = k2.redMul(R2), g2 = R2.redSqr(), u2 = u2.redMul(g2), E2 = B3;
      }
      return k2;
    }, Y.prototype.invm = function(f2) {
      var a2 = f2._invmp(this.m);
      return a2.negative !== 0 ? (a2.negative = 0, this.imod(a2).redNeg()) : this.imod(a2);
    }, Y.prototype.pow = function(f2, a2) {
      if (a2.isZero()) return new o2(1).toRed(this);
      if (a2.cmpn(1) === 0) return f2.clone();
      var c2 = 4, d3 = new Array(1 << c2);
      d3[0] = new o2(1).toRed(this), d3[1] = f2;
      for (var m3 = 2; m3 < d3.length; m3++) d3[m3] = this.mul(d3[m3 - 1], f2);
      var x2 = d3[0], M2 = 0, l2 = 0, s2 = a2.bitLength() % 26;
      for (s2 === 0 && (s2 = 26), m3 = a2.length - 1; m3 >= 0; m3--) {
        for (var g2 = a2.words[m3], k2 = s2 - 1; k2 >= 0; k2--) {
          var u2 = g2 >> k2 & 1;
          if (x2 !== d3[0] && (x2 = this.sqr(x2)), u2 === 0 && M2 === 0) {
            l2 = 0;
            continue;
          }
          M2 <<= 1, M2 |= u2, l2++, !(l2 !== c2 && (m3 !== 0 || k2 !== 0)) && (x2 = this.mul(x2, d3[M2]), l2 = 0, M2 = 0);
        }
        s2 = 26;
      }
      return x2;
    }, Y.prototype.convertTo = function(f2) {
      var a2 = f2.umod(this.m);
      return a2 === f2 ? a2.clone() : a2;
    }, Y.prototype.convertFrom = function(f2) {
      var a2 = f2.clone();
      return a2.red = null, a2;
    }, o2.mont = function(f2) {
      return new Wt(f2);
    };
    function Wt(b2) {
      Y.call(this, b2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    n3(Wt, Y), Wt.prototype.convertTo = function(f2) {
      return this.imod(f2.ushln(this.shift));
    }, Wt.prototype.convertFrom = function(f2) {
      var a2 = this.imod(f2.mul(this.rinv));
      return a2.red = null, a2;
    }, Wt.prototype.imul = function(f2, a2) {
      if (f2.isZero() || a2.isZero()) return f2.words[0] = 0, f2.length = 1, f2;
      var c2 = f2.imul(a2), d3 = c2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m3 = c2.isub(d3).iushrn(this.shift), x2 = m3;
      return m3.cmp(this.m) >= 0 ? x2 = m3.isub(this.m) : m3.cmpn(0) < 0 && (x2 = m3.iadd(this.m)), x2._forceRed(this);
    }, Wt.prototype.mul = function(f2, a2) {
      if (f2.isZero() || a2.isZero()) return new o2(0)._forceRed(this);
      var c2 = f2.mul(a2), d3 = c2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), m3 = c2.isub(d3).iushrn(this.shift), x2 = m3;
      return m3.cmp(this.m) >= 0 ? x2 = m3.isub(this.m) : m3.cmpn(0) < 0 && (x2 = m3.iadd(this.m)), x2._forceRed(this);
    }, Wt.prototype.invm = function(f2) {
      var a2 = this.imod(f2._invmp(this.m).mul(this.r2));
      return a2._forceRed(this);
    };
  })(e2, Tn);
})(Gn);
var K = Gn.exports;
const Yn = "bignumber/5.7.0";
var Fr = K.BN;
const Ae = new z2(Yn), Ni = {}, Vn = 9007199254740991;
function Ts(e2) {
  return e2 != null && (V.isBigNumber(e2) || typeof e2 == "number" && e2 % 1 === 0 || typeof e2 == "string" && !!e2.match(/^-?[0-9]+$/) || Jt(e2) || typeof e2 == "bigint" || nr(e2));
}
let Wn = false;
class V {
  constructor(t2, r2) {
    t2 !== Ni && Ae.throwError("cannot call constructor directly; use BigNumber.from", z2.errors.UNSUPPORTED_OPERATION, { operation: "new (BigNumber)" }), this._hex = r2, this._isBigNumber = true, Object.freeze(this);
  }
  fromTwos(t2) {
    return zt(j(this).fromTwos(t2));
  }
  toTwos(t2) {
    return zt(j(this).toTwos(t2));
  }
  abs() {
    return this._hex[0] === "-" ? V.from(this._hex.substring(1)) : this;
  }
  add(t2) {
    return zt(j(this).add(j(t2)));
  }
  sub(t2) {
    return zt(j(this).sub(j(t2)));
  }
  div(t2) {
    return V.from(t2).isZero() && Zt("division-by-zero", "div"), zt(j(this).div(j(t2)));
  }
  mul(t2) {
    return zt(j(this).mul(j(t2)));
  }
  mod(t2) {
    const r2 = j(t2);
    return r2.isNeg() && Zt("division-by-zero", "mod"), zt(j(this).umod(r2));
  }
  pow(t2) {
    const r2 = j(t2);
    return r2.isNeg() && Zt("negative-power", "pow"), zt(j(this).pow(r2));
  }
  and(t2) {
    const r2 = j(t2);
    return (this.isNegative() || r2.isNeg()) && Zt("unbound-bitwise-result", "and"), zt(j(this).and(r2));
  }
  or(t2) {
    const r2 = j(t2);
    return (this.isNegative() || r2.isNeg()) && Zt("unbound-bitwise-result", "or"), zt(j(this).or(r2));
  }
  xor(t2) {
    const r2 = j(t2);
    return (this.isNegative() || r2.isNeg()) && Zt("unbound-bitwise-result", "xor"), zt(j(this).xor(r2));
  }
  mask(t2) {
    return (this.isNegative() || t2 < 0) && Zt("negative-width", "mask"), zt(j(this).maskn(t2));
  }
  shl(t2) {
    return (this.isNegative() || t2 < 0) && Zt("negative-width", "shl"), zt(j(this).shln(t2));
  }
  shr(t2) {
    return (this.isNegative() || t2 < 0) && Zt("negative-width", "shr"), zt(j(this).shrn(t2));
  }
  eq(t2) {
    return j(this).eq(j(t2));
  }
  lt(t2) {
    return j(this).lt(j(t2));
  }
  lte(t2) {
    return j(this).lte(j(t2));
  }
  gt(t2) {
    return j(this).gt(j(t2));
  }
  gte(t2) {
    return j(this).gte(j(t2));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return j(this).isZero();
  }
  toNumber() {
    try {
      return j(this).toNumber();
    } catch {
      Zt("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return Ae.throwError("this platform does not support BigInt", z2.errors.UNSUPPORTED_OPERATION, { value: this.toString() });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? Wn || (Wn = true, Ae.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? Ae.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", z2.errors.UNEXPECTED_ARGUMENT, {}) : Ae.throwError("BigNumber.toString does not accept parameters", z2.errors.UNEXPECTED_ARGUMENT, {})), j(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(t2) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(t2) {
    if (t2 instanceof V) return t2;
    if (typeof t2 == "string") return t2.match(/^-?0x[0-9a-f]+$/i) ? new V(Ni, mr(t2)) : t2.match(/^-?[0-9]+$/) ? new V(Ni, mr(new Fr(t2))) : Ae.throwArgumentError("invalid BigNumber string", "value", t2);
    if (typeof t2 == "number") return t2 % 1 && Zt("underflow", "BigNumber.from", t2), (t2 >= Vn || t2 <= -Vn) && Zt("overflow", "BigNumber.from", t2), V.from(String(t2));
    const r2 = t2;
    if (typeof r2 == "bigint") return V.from(r2.toString());
    if (nr(r2)) return V.from(Kt(r2));
    if (r2) if (r2.toHexString) {
      const i4 = r2.toHexString();
      if (typeof i4 == "string") return V.from(i4);
    } else {
      let i4 = r2._hex;
      if (i4 == null && r2.type === "BigNumber" && (i4 = r2.hex), typeof i4 == "string" && (Jt(i4) || i4[0] === "-" && Jt(i4.substring(1)))) return V.from(i4);
    }
    return Ae.throwArgumentError("invalid BigNumber value", "value", t2);
  }
  static isBigNumber(t2) {
    return !!(t2 && t2._isBigNumber);
  }
}
function mr(e2) {
  if (typeof e2 != "string") return mr(e2.toString(16));
  if (e2[0] === "-") return e2 = e2.substring(1), e2[0] === "-" && Ae.throwArgumentError("invalid hex", "value", e2), e2 = mr(e2), e2 === "0x00" ? e2 : "-" + e2;
  if (e2.substring(0, 2) !== "0x" && (e2 = "0x" + e2), e2 === "0x") return "0x00";
  for (e2.length % 2 && (e2 = "0x0" + e2.substring(2)); e2.length > 4 && e2.substring(0, 4) === "0x00"; ) e2 = "0x" + e2.substring(4);
  return e2;
}
function zt(e2) {
  return V.from(mr(e2));
}
function j(e2) {
  const t2 = V.from(e2).toHexString();
  return t2[0] === "-" ? new Fr("-" + t2.substring(3), 16) : new Fr(t2.substring(2), 16);
}
function Zt(e2, t2, r2) {
  const i4 = { fault: e2, operation: t2 };
  return r2 != null && (i4.value = r2), Ae.throwError(e2, z2.errors.NUMERIC_FAULT, i4);
}
const Ht = new z2(Yn), Ar = {}, Xn = V.from(0), Zn = V.from(-1);
function $n(e2, t2, r2, i4) {
  const n3 = { fault: t2, operation: r2 };
  return i4 !== void 0 && (n3.value = i4), Ht.throwError(e2, z2.errors.NUMERIC_FAULT, n3);
}
let br = "0";
for (; br.length < 256; ) br += br;
function Ii(e2) {
  if (typeof e2 != "number") try {
    e2 = V.from(e2).toNumber();
  } catch {
  }
  return typeof e2 == "number" && e2 >= 0 && e2 <= 256 && !(e2 % 1) ? "1" + br.substring(0, e2) : Ht.throwArgumentError("invalid decimal size", "decimals", e2);
}
function _i(e2, t2) {
  t2 == null && (t2 = 0);
  const r2 = Ii(t2);
  e2 = V.from(e2);
  const i4 = e2.lt(Xn);
  i4 && (e2 = e2.mul(Zn));
  let n3 = e2.mod(r2).toString();
  for (; n3.length < r2.length - 1; ) n3 = "0" + n3;
  n3 = n3.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const o2 = e2.div(r2).toString();
  return r2.length === 1 ? e2 = o2 : e2 = o2 + "." + n3, i4 && (e2 = "-" + e2), e2;
}
function be(e2, t2) {
  t2 == null && (t2 = 0);
  const r2 = Ii(t2);
  (typeof e2 != "string" || !e2.match(/^-?[0-9.]+$/)) && Ht.throwArgumentError("invalid decimal value", "value", e2);
  const i4 = e2.substring(0, 1) === "-";
  i4 && (e2 = e2.substring(1)), e2 === "." && Ht.throwArgumentError("missing value", "value", e2);
  const n3 = e2.split(".");
  n3.length > 2 && Ht.throwArgumentError("too many decimal points", "value", e2);
  let o2 = n3[0], h2 = n3[1];
  for (o2 || (o2 = "0"), h2 || (h2 = "0"); h2[h2.length - 1] === "0"; ) h2 = h2.substring(0, h2.length - 1);
  for (h2.length > r2.length - 1 && $n("fractional component exceeds decimals", "underflow", "parseFixed"), h2 === "" && (h2 = "0"); h2.length < r2.length - 1; ) h2 += "0";
  const p2 = V.from(o2), A2 = V.from(h2);
  let v2 = p2.mul(r2).add(A2);
  return i4 && (v2 = v2.mul(Zn)), v2;
}
class vr {
  constructor(t2, r2, i4, n3) {
    t2 !== Ar && Ht.throwError("cannot use FixedFormat constructor; use FixedFormat.from", z2.errors.UNSUPPORTED_OPERATION, { operation: "new FixedFormat" }), this.signed = r2, this.width = i4, this.decimals = n3, this.name = (r2 ? "" : "u") + "fixed" + String(i4) + "x" + String(n3), this._multiplier = Ii(n3), Object.freeze(this);
  }
  static from(t2) {
    if (t2 instanceof vr) return t2;
    typeof t2 == "number" && (t2 = `fixed128x${t2}`);
    let r2 = true, i4 = 128, n3 = 18;
    if (typeof t2 == "string") {
      if (t2 !== "fixed") if (t2 === "ufixed") r2 = false;
      else {
        const o2 = t2.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        o2 || Ht.throwArgumentError("invalid fixed format", "format", t2), r2 = o2[1] !== "u", i4 = parseInt(o2[2]), n3 = parseInt(o2[3]);
      }
    } else if (t2) {
      const o2 = (h2, p2, A2) => t2[h2] == null ? A2 : (typeof t2[h2] !== p2 && Ht.throwArgumentError("invalid fixed format (" + h2 + " not " + p2 + ")", "format." + h2, t2[h2]), t2[h2]);
      r2 = o2("signed", "boolean", r2), i4 = o2("width", "number", i4), n3 = o2("decimals", "number", n3);
    }
    return i4 % 8 && Ht.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", i4), n3 > 80 && Ht.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", n3), new vr(Ar, r2, i4, n3);
  }
}
class Ut {
  constructor(t2, r2, i4, n3) {
    t2 !== Ar && Ht.throwError("cannot use FixedNumber constructor; use FixedNumber.from", z2.errors.UNSUPPORTED_OPERATION, { operation: "new FixedFormat" }), this.format = n3, this._hex = r2, this._value = i4, this._isFixedNumber = true, Object.freeze(this);
  }
  _checkFormat(t2) {
    this.format.name !== t2.format.name && Ht.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", t2);
  }
  addUnsafe(t2) {
    this._checkFormat(t2);
    const r2 = be(this._value, this.format.decimals), i4 = be(t2._value, t2.format.decimals);
    return Ut.fromValue(r2.add(i4), this.format.decimals, this.format);
  }
  subUnsafe(t2) {
    this._checkFormat(t2);
    const r2 = be(this._value, this.format.decimals), i4 = be(t2._value, t2.format.decimals);
    return Ut.fromValue(r2.sub(i4), this.format.decimals, this.format);
  }
  mulUnsafe(t2) {
    this._checkFormat(t2);
    const r2 = be(this._value, this.format.decimals), i4 = be(t2._value, t2.format.decimals);
    return Ut.fromValue(r2.mul(i4).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(t2) {
    this._checkFormat(t2);
    const r2 = be(this._value, this.format.decimals), i4 = be(t2._value, t2.format.decimals);
    return Ut.fromValue(r2.mul(this.format._multiplier).div(i4), this.format.decimals, this.format);
  }
  floor() {
    const t2 = this.toString().split(".");
    t2.length === 1 && t2.push("0");
    let r2 = Ut.from(t2[0], this.format);
    const i4 = !t2[1].match(/^(0*)$/);
    return this.isNegative() && i4 && (r2 = r2.subUnsafe(tf.toFormat(r2.format))), r2;
  }
  ceiling() {
    const t2 = this.toString().split(".");
    t2.length === 1 && t2.push("0");
    let r2 = Ut.from(t2[0], this.format);
    const i4 = !t2[1].match(/^(0*)$/);
    return !this.isNegative() && i4 && (r2 = r2.addUnsafe(tf.toFormat(r2.format))), r2;
  }
  round(t2) {
    t2 == null && (t2 = 0);
    const r2 = this.toString().split(".");
    if (r2.length === 1 && r2.push("0"), (t2 < 0 || t2 > 80 || t2 % 1) && Ht.throwArgumentError("invalid decimal count", "decimals", t2), r2[1].length <= t2) return this;
    const i4 = Ut.from("1" + br.substring(0, t2), this.format), n3 = ks.toFormat(this.format);
    return this.mulUnsafe(i4).addUnsafe(n3).floor().divUnsafe(i4);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(t2) {
    if (t2 == null) return this._hex;
    t2 % 8 && Ht.throwArgumentError("invalid byte width", "width", t2);
    const r2 = V.from(this._hex).fromTwos(this.format.width).toTwos(t2).toHexString();
    return oe(r2, t2 / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(t2) {
    return Ut.fromString(this._value, t2);
  }
  static fromValue(t2, r2, i4) {
    return i4 == null && r2 != null && !Ts(r2) && (i4 = r2, r2 = null), r2 == null && (r2 = 0), i4 == null && (i4 = "fixed"), Ut.fromString(_i(t2, r2), vr.from(i4));
  }
  static fromString(t2, r2) {
    r2 == null && (r2 = "fixed");
    const i4 = vr.from(r2), n3 = be(t2, i4.decimals);
    !i4.signed && n3.lt(Xn) && $n("unsigned value cannot be negative", "overflow", "value", t2);
    let o2 = null;
    i4.signed ? o2 = n3.toTwos(i4.width).toHexString() : (o2 = n3.toHexString(), o2 = oe(o2, i4.width / 8));
    const h2 = _i(n3, i4.decimals);
    return new Ut(Ar, o2, h2, i4);
  }
  static fromBytes(t2, r2) {
    r2 == null && (r2 = "fixed");
    const i4 = vr.from(r2);
    if (Ot(t2).length > i4.width / 8) throw new Error("overflow");
    let n3 = V.from(t2);
    i4.signed && (n3 = n3.fromTwos(i4.width));
    const o2 = n3.toTwos((i4.signed ? 0 : 1) + i4.width).toHexString(), h2 = _i(n3, i4.decimals);
    return new Ut(Ar, o2, h2, i4);
  }
  static from(t2, r2) {
    if (typeof t2 == "string") return Ut.fromString(t2, r2);
    if (nr(t2)) return Ut.fromBytes(t2, r2);
    try {
      return Ut.fromValue(t2, 0, r2);
    } catch (i4) {
      if (i4.code !== z2.errors.INVALID_ARGUMENT) throw i4;
    }
    return Ht.throwArgumentError("invalid FixedNumber value", "value", t2);
  }
  static isFixedNumber(t2) {
    return !!(t2 && t2._isFixedNumber);
  }
}
const tf = Ut.from(1), ks = Ut.from("0.5");
var Tr;
(function(e2) {
  e2.current = "", e2.NFC = "NFC", e2.NFD = "NFD", e2.NFKC = "NFKC", e2.NFKD = "NFKD";
})(Tr || (Tr = {}));
var fr;
(function(e2) {
  e2.UNEXPECTED_CONTINUE = "unexpected continuation byte", e2.BAD_PREFIX = "bad codepoint prefix", e2.OVERRUN = "string overrun", e2.MISSING_CONTINUE = "missing continuation byte", e2.OUT_OF_RANGE = "out of UTF-8 range", e2.UTF16_SURROGATE = "UTF-16 surrogate", e2.OVERLONG = "overlong representation";
})(fr || (fr = {}));
function Ls(e2) {
  if (e2.length % 4 !== 0) throw new Error("bad data");
  let t2 = [];
  for (let r2 = 0; r2 < e2.length; r2 += 4) t2.push(parseInt(e2.substring(r2, r2 + 4), 16));
  return t2;
}
function Ci(e2, t2) {
  t2 || (t2 = function(n3) {
    return [parseInt(n3, 16)];
  });
  let r2 = 0, i4 = {};
  return e2.split(",").forEach((n3) => {
    let o2 = n3.split(":");
    r2 += parseInt(o2[0], 16), i4[r2] = t2(o2[1]);
  }), i4;
}
function nf(e2) {
  let t2 = 0;
  return e2.split(",").map((r2) => {
    let i4 = r2.split("-");
    i4.length === 1 ? i4[1] = "0" : i4[1] === "" && (i4[1] = "1");
    let n3 = t2 + parseInt(i4[0], 16);
    return t2 = parseInt(i4[1], 16), { l: n3, h: t2 };
  });
}
nf("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"), "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((e2) => parseInt(e2, 16)), Ci("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"), Ci("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"), Ci("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", Ls), nf("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function zs(e2) {
  e2 = atob(e2);
  const t2 = [];
  for (let r2 = 0; r2 < e2.length; r2++) t2.push(e2.charCodeAt(r2));
  return Ot(t2);
}
function of(e2, t2) {
  t2 == null && (t2 = 1);
  const r2 = [], i4 = r2.forEach, n3 = function(o2, h2) {
    i4.call(o2, function(p2) {
      h2 > 0 && Array.isArray(p2) ? n3(p2, h2 - 1) : r2.push(p2);
    });
  };
  return n3(e2, t2), r2;
}
function js(e2) {
  const t2 = {};
  for (let r2 = 0; r2 < e2.length; r2++) {
    const i4 = e2[r2];
    t2[i4[0]] = i4[1];
  }
  return t2;
}
function Qs(e2) {
  let t2 = 0;
  function r2() {
    return e2[t2++] << 8 | e2[t2++];
  }
  let i4 = r2(), n3 = 1, o2 = [0, 1];
  for (let H2 = 1; H2 < i4; H2++) o2.push(n3 += r2());
  let h2 = r2(), p2 = t2;
  t2 += h2;
  let A2 = 0, v2 = 0;
  function w2() {
    return A2 == 0 && (v2 = v2 << 8 | e2[t2++], A2 = 8), v2 >> --A2 & 1;
  }
  const y3 = 31, S2 = Math.pow(2, y3), I2 = S2 >>> 1, N2 = I2 >> 1, C2 = S2 - 1;
  let F = 0;
  for (let H2 = 0; H2 < y3; H2++) F = F << 1 | w2();
  let U = [], J = 0, Bt = S2;
  for (; ; ) {
    let H2 = Math.floor(((F - J + 1) * n3 - 1) / Bt), L3 = 0, Pt = i4;
    for (; Pt - L3 > 1; ) {
      let Vt = L3 + Pt >>> 1;
      H2 < o2[Vt] ? Pt = Vt : L3 = Vt;
    }
    if (L3 == 0) break;
    U.push(L3);
    let W = J + Math.floor(Bt * o2[L3] / n3), Rt = J + Math.floor(Bt * o2[L3 + 1] / n3) - 1;
    for (; !((W ^ Rt) & I2); ) F = F << 1 & C2 | w2(), W = W << 1 & C2, Rt = Rt << 1 & C2 | 1;
    for (; W & ~Rt & N2; ) F = F & I2 | F << 1 & C2 >>> 1 | w2(), W = W << 1 ^ I2, Rt = (Rt ^ I2) << 1 | I2 | 1;
    J = W, Bt = 1 + Rt - W;
  }
  let G = i4 - 4;
  return U.map((H2) => {
    switch (H2 - G) {
      case 3:
        return G + 65792 + (e2[p2++] << 16 | e2[p2++] << 8 | e2[p2++]);
      case 2:
        return G + 256 + (e2[p2++] << 8 | e2[p2++]);
      case 1:
        return G + e2[p2++];
      default:
        return H2 - 1;
    }
  });
}
function Js(e2) {
  let t2 = 0;
  return () => e2[t2++];
}
function Gs(e2) {
  return Js(Qs(e2));
}
function Ys(e2) {
  return e2 & 1 ? ~e2 >> 1 : e2 >> 1;
}
function Vs(e2, t2) {
  let r2 = Array(e2);
  for (let i4 = 0; i4 < e2; i4++) r2[i4] = 1 + t2();
  return r2;
}
function sf(e2, t2) {
  let r2 = Array(e2);
  for (let i4 = 0, n3 = -1; i4 < e2; i4++) r2[i4] = n3 += 1 + t2();
  return r2;
}
function Ws(e2, t2) {
  let r2 = Array(e2);
  for (let i4 = 0, n3 = 0; i4 < e2; i4++) r2[i4] = n3 += Ys(t2());
  return r2;
}
function Ur(e2, t2) {
  let r2 = sf(e2(), e2), i4 = e2(), n3 = sf(i4, e2), o2 = Vs(i4, e2);
  for (let h2 = 0; h2 < i4; h2++) for (let p2 = 0; p2 < o2[h2]; p2++) r2.push(n3[h2] + p2);
  return t2 ? r2.map((h2) => t2[h2]) : r2;
}
function Xs(e2) {
  let t2 = [];
  for (; ; ) {
    let r2 = e2();
    if (r2 == 0) break;
    t2.push($s(r2, e2));
  }
  for (; ; ) {
    let r2 = e2() - 1;
    if (r2 < 0) break;
    t2.push(t0(r2, e2));
  }
  return js(of(t2));
}
function Zs(e2) {
  let t2 = [];
  for (; ; ) {
    let r2 = e2();
    if (r2 == 0) break;
    t2.push(r2);
  }
  return t2;
}
function af(e2, t2, r2) {
  let i4 = Array(e2).fill(void 0).map(() => []);
  for (let n3 = 0; n3 < t2; n3++) Ws(e2, r2).forEach((o2, h2) => i4[h2].push(o2));
  return i4;
}
function $s(e2, t2) {
  let r2 = 1 + t2(), i4 = t2(), n3 = Zs(t2), o2 = af(n3.length, 1 + e2, t2);
  return of(o2.map((h2, p2) => {
    const A2 = h2[0], v2 = h2.slice(1);
    return Array(n3[p2]).fill(void 0).map((w2, y3) => {
      let S2 = y3 * i4;
      return [A2 + y3 * r2, v2.map((I2) => I2 + S2)];
    });
  }));
}
function t0(e2, t2) {
  let r2 = 1 + t2();
  return af(r2, 1 + e2, t2).map((n3) => [n3[0], n3.slice(1)]);
}
function e0(e2) {
  let t2 = Ur(e2).sort((i4, n3) => i4 - n3);
  return r2();
  function r2() {
    let i4 = [];
    for (; ; ) {
      let v2 = Ur(e2, t2);
      if (v2.length == 0) break;
      i4.push({ set: new Set(v2), node: r2() });
    }
    i4.sort((v2, w2) => w2.set.size - v2.set.size);
    let n3 = e2(), o2 = n3 % 3;
    n3 = n3 / 3 | 0;
    let h2 = !!(n3 & 1);
    n3 >>= 1;
    let p2 = n3 == 1, A2 = n3 == 2;
    return { branches: i4, valid: o2, fe0f: h2, save: p2, check: A2 };
  }
}
function r0() {
  return Gs(zs("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const kr = r0();
new Set(Ur(kr)), new Set(Ur(kr)), Xs(kr), e0(kr);
const i0 = new Uint8Array(32);
i0.fill(0);
const l0 = new Uint8Array(32);
l0.fill(0), V.from(-1);
const d0 = V.from(0), p0 = V.from(1);
V.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), oe(p0.toHexString(), 32), oe(d0.toHexString(), 32);
var se = {}, Q = {}, xr = lf;
function lf(e2, t2) {
  if (!e2) throw new Error(t2 || "Assertion failed");
}
lf.equal = function(t2, r2, i4) {
  if (t2 != r2) throw new Error(i4 || "Assertion failed: " + t2 + " != " + r2);
};
var Oi = { exports: {} };
typeof Object.create == "function" ? Oi.exports = function(t2, r2) {
  r2 && (t2.super_ = r2, t2.prototype = Object.create(r2.prototype, { constructor: { value: t2, enumerable: false, writable: true, configurable: true } }));
} : Oi.exports = function(t2, r2) {
  if (r2) {
    t2.super_ = r2;
    var i4 = function() {
    };
    i4.prototype = r2.prototype, t2.prototype = new i4(), t2.prototype.constructor = t2;
  }
};
var v0 = xr, g0 = Oi.exports;
Q.inherits = g0;
function m0(e2, t2) {
  return (e2.charCodeAt(t2) & 64512) !== 55296 || t2 < 0 || t2 + 1 >= e2.length ? false : (e2.charCodeAt(t2 + 1) & 64512) === 56320;
}
function A0(e2, t2) {
  if (Array.isArray(e2)) return e2.slice();
  if (!e2) return [];
  var r2 = [];
  if (typeof e2 == "string") if (t2) {
    if (t2 === "hex") for (e2 = e2.replace(/[^a-z0-9]+/ig, ""), e2.length % 2 !== 0 && (e2 = "0" + e2), n3 = 0; n3 < e2.length; n3 += 2) r2.push(parseInt(e2[n3] + e2[n3 + 1], 16));
  } else for (var i4 = 0, n3 = 0; n3 < e2.length; n3++) {
    var o2 = e2.charCodeAt(n3);
    o2 < 128 ? r2[i4++] = o2 : o2 < 2048 ? (r2[i4++] = o2 >> 6 | 192, r2[i4++] = o2 & 63 | 128) : m0(e2, n3) ? (o2 = 65536 + ((o2 & 1023) << 10) + (e2.charCodeAt(++n3) & 1023), r2[i4++] = o2 >> 18 | 240, r2[i4++] = o2 >> 12 & 63 | 128, r2[i4++] = o2 >> 6 & 63 | 128, r2[i4++] = o2 & 63 | 128) : (r2[i4++] = o2 >> 12 | 224, r2[i4++] = o2 >> 6 & 63 | 128, r2[i4++] = o2 & 63 | 128);
  }
  else for (n3 = 0; n3 < e2.length; n3++) r2[n3] = e2[n3] | 0;
  return r2;
}
Q.toArray = A0;
function b0(e2) {
  for (var t2 = "", r2 = 0; r2 < e2.length; r2++) t2 += pf(e2[r2].toString(16));
  return t2;
}
Q.toHex = b0;
function df(e2) {
  var t2 = e2 >>> 24 | e2 >>> 8 & 65280 | e2 << 8 & 16711680 | (e2 & 255) << 24;
  return t2 >>> 0;
}
Q.htonl = df;
function y0(e2, t2) {
  for (var r2 = "", i4 = 0; i4 < e2.length; i4++) {
    var n3 = e2[i4];
    t2 === "little" && (n3 = df(n3)), r2 += vf(n3.toString(16));
  }
  return r2;
}
Q.toHex32 = y0;
function pf(e2) {
  return e2.length === 1 ? "0" + e2 : e2;
}
Q.zero2 = pf;
function vf(e2) {
  return e2.length === 7 ? "0" + e2 : e2.length === 6 ? "00" + e2 : e2.length === 5 ? "000" + e2 : e2.length === 4 ? "0000" + e2 : e2.length === 3 ? "00000" + e2 : e2.length === 2 ? "000000" + e2 : e2.length === 1 ? "0000000" + e2 : e2;
}
Q.zero8 = vf;
function w0(e2, t2, r2, i4) {
  var n3 = r2 - t2;
  v0(n3 % 4 === 0);
  for (var o2 = new Array(n3 / 4), h2 = 0, p2 = t2; h2 < o2.length; h2++, p2 += 4) {
    var A2;
    i4 === "big" ? A2 = e2[p2] << 24 | e2[p2 + 1] << 16 | e2[p2 + 2] << 8 | e2[p2 + 3] : A2 = e2[p2 + 3] << 24 | e2[p2 + 2] << 16 | e2[p2 + 1] << 8 | e2[p2], o2[h2] = A2 >>> 0;
  }
  return o2;
}
Q.join32 = w0;
function x0(e2, t2) {
  for (var r2 = new Array(e2.length * 4), i4 = 0, n3 = 0; i4 < e2.length; i4++, n3 += 4) {
    var o2 = e2[i4];
    t2 === "big" ? (r2[n3] = o2 >>> 24, r2[n3 + 1] = o2 >>> 16 & 255, r2[n3 + 2] = o2 >>> 8 & 255, r2[n3 + 3] = o2 & 255) : (r2[n3 + 3] = o2 >>> 24, r2[n3 + 2] = o2 >>> 16 & 255, r2[n3 + 1] = o2 >>> 8 & 255, r2[n3] = o2 & 255);
  }
  return r2;
}
Q.split32 = x0;
function M0(e2, t2) {
  return e2 >>> t2 | e2 << 32 - t2;
}
Q.rotr32 = M0;
function E0(e2, t2) {
  return e2 << t2 | e2 >>> 32 - t2;
}
Q.rotl32 = E0;
function S0$1(e2, t2) {
  return e2 + t2 >>> 0;
}
Q.sum32 = S0$1;
function N0(e2, t2, r2) {
  return e2 + t2 + r2 >>> 0;
}
Q.sum32_3 = N0;
function I0(e2, t2, r2, i4) {
  return e2 + t2 + r2 + i4 >>> 0;
}
Q.sum32_4 = I0;
function _0(e2, t2, r2, i4, n3) {
  return e2 + t2 + r2 + i4 + n3 >>> 0;
}
Q.sum32_5 = _0;
function B0(e2, t2, r2, i4) {
  var n3 = e2[t2], o2 = e2[t2 + 1], h2 = i4 + o2 >>> 0, p2 = (h2 < i4 ? 1 : 0) + r2 + n3;
  e2[t2] = p2 >>> 0, e2[t2 + 1] = h2;
}
Q.sum64 = B0;
function C0(e2, t2, r2, i4) {
  var n3 = t2 + i4 >>> 0, o2 = (n3 < t2 ? 1 : 0) + e2 + r2;
  return o2 >>> 0;
}
Q.sum64_hi = C0;
function R0(e2, t2, r2, i4) {
  var n3 = t2 + i4;
  return n3 >>> 0;
}
Q.sum64_lo = R0;
function O0(e2, t2, r2, i4, n3, o2, h2, p2) {
  var A2 = 0, v2 = t2;
  v2 = v2 + i4 >>> 0, A2 += v2 < t2 ? 1 : 0, v2 = v2 + o2 >>> 0, A2 += v2 < o2 ? 1 : 0, v2 = v2 + p2 >>> 0, A2 += v2 < p2 ? 1 : 0;
  var w2 = e2 + r2 + n3 + h2 + A2;
  return w2 >>> 0;
}
Q.sum64_4_hi = O0;
function P0(e2, t2, r2, i4, n3, o2, h2, p2) {
  var A2 = t2 + i4 + o2 + p2;
  return A2 >>> 0;
}
Q.sum64_4_lo = P0;
function D0(e2, t2, r2, i4, n3, o2, h2, p2, A2, v2) {
  var w2 = 0, y3 = t2;
  y3 = y3 + i4 >>> 0, w2 += y3 < t2 ? 1 : 0, y3 = y3 + o2 >>> 0, w2 += y3 < o2 ? 1 : 0, y3 = y3 + p2 >>> 0, w2 += y3 < p2 ? 1 : 0, y3 = y3 + v2 >>> 0, w2 += y3 < v2 ? 1 : 0;
  var S2 = e2 + r2 + n3 + h2 + A2 + w2;
  return S2 >>> 0;
}
Q.sum64_5_hi = D0;
function F0(e2, t2, r2, i4, n3, o2, h2, p2, A2, v2) {
  var w2 = t2 + i4 + o2 + p2 + v2;
  return w2 >>> 0;
}
Q.sum64_5_lo = F0;
function T0$1(e2, t2, r2) {
  var i4 = t2 << 32 - r2 | e2 >>> r2;
  return i4 >>> 0;
}
Q.rotr64_hi = T0$1;
function U0(e2, t2, r2) {
  var i4 = e2 << 32 - r2 | t2 >>> r2;
  return i4 >>> 0;
}
Q.rotr64_lo = U0;
function k0(e2, t2, r2) {
  return e2 >>> r2;
}
Q.shr64_hi = k0;
function q0(e2, t2, r2) {
  var i4 = e2 << 32 - r2 | t2 >>> r2;
  return i4 >>> 0;
}
Q.shr64_lo = q0;
var or = {}, gf = Q, K0 = xr;
function qr() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
or.BlockHash = qr, qr.prototype.update = function(t2, r2) {
  if (t2 = gf.toArray(t2, r2), this.pending ? this.pending = this.pending.concat(t2) : this.pending = t2, this.pendingTotal += t2.length, this.pending.length >= this._delta8) {
    t2 = this.pending;
    var i4 = t2.length % this._delta8;
    this.pending = t2.slice(t2.length - i4, t2.length), this.pending.length === 0 && (this.pending = null), t2 = gf.join32(t2, 0, t2.length - i4, this.endian);
    for (var n3 = 0; n3 < t2.length; n3 += this._delta32) this._update(t2, n3, n3 + this._delta32);
  }
  return this;
}, qr.prototype.digest = function(t2) {
  return this.update(this._pad()), K0(this.pending === null), this._digest(t2);
}, qr.prototype._pad = function() {
  var t2 = this.pendingTotal, r2 = this._delta8, i4 = r2 - (t2 + this.padLength) % r2, n3 = new Array(i4 + this.padLength);
  n3[0] = 128;
  for (var o2 = 1; o2 < i4; o2++) n3[o2] = 0;
  if (t2 <<= 3, this.endian === "big") {
    for (var h2 = 8; h2 < this.padLength; h2++) n3[o2++] = 0;
    n3[o2++] = 0, n3[o2++] = 0, n3[o2++] = 0, n3[o2++] = 0, n3[o2++] = t2 >>> 24 & 255, n3[o2++] = t2 >>> 16 & 255, n3[o2++] = t2 >>> 8 & 255, n3[o2++] = t2 & 255;
  } else for (n3[o2++] = t2 & 255, n3[o2++] = t2 >>> 8 & 255, n3[o2++] = t2 >>> 16 & 255, n3[o2++] = t2 >>> 24 & 255, n3[o2++] = 0, n3[o2++] = 0, n3[o2++] = 0, n3[o2++] = 0, h2 = 8; h2 < this.padLength; h2++) n3[o2++] = 0;
  return n3;
};
var sr = {}, ae = {}, H0 = Q, ue = H0.rotr32;
function L0$1(e2, t2, r2, i4) {
  if (e2 === 0) return mf(t2, r2, i4);
  if (e2 === 1 || e2 === 3) return bf(t2, r2, i4);
  if (e2 === 2) return Af(t2, r2, i4);
}
ae.ft_1 = L0$1;
function mf(e2, t2, r2) {
  return e2 & t2 ^ ~e2 & r2;
}
ae.ch32 = mf;
function Af(e2, t2, r2) {
  return e2 & t2 ^ e2 & r2 ^ t2 & r2;
}
ae.maj32 = Af;
function bf(e2, t2, r2) {
  return e2 ^ t2 ^ r2;
}
ae.p32 = bf;
function z0(e2) {
  return ue(e2, 2) ^ ue(e2, 13) ^ ue(e2, 22);
}
ae.s0_256 = z0;
function j0(e2) {
  return ue(e2, 6) ^ ue(e2, 11) ^ ue(e2, 25);
}
ae.s1_256 = j0;
function Q0(e2) {
  return ue(e2, 7) ^ ue(e2, 18) ^ e2 >>> 3;
}
ae.g0_256 = Q0;
function J0(e2) {
  return ue(e2, 17) ^ ue(e2, 19) ^ e2 >>> 10;
}
ae.g1_256 = J0;
var ar = Q, G0 = or, Y0 = ae, Pi = ar.rotl32, Mr = ar.sum32, V0$1 = ar.sum32_5, W0 = Y0.ft_1, yf = G0.BlockHash, X0 = [1518500249, 1859775393, 2400959708, 3395469782];
function he() {
  if (!(this instanceof he)) return new he();
  yf.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
}
ar.inherits(he, yf);
var Z0 = he;
he.blockSize = 512, he.outSize = 160, he.hmacStrength = 80, he.padLength = 64, he.prototype._update = function(t2, r2) {
  for (var i4 = this.W, n3 = 0; n3 < 16; n3++) i4[n3] = t2[r2 + n3];
  for (; n3 < i4.length; n3++) i4[n3] = Pi(i4[n3 - 3] ^ i4[n3 - 8] ^ i4[n3 - 14] ^ i4[n3 - 16], 1);
  var o2 = this.h[0], h2 = this.h[1], p2 = this.h[2], A2 = this.h[3], v2 = this.h[4];
  for (n3 = 0; n3 < i4.length; n3++) {
    var w2 = ~~(n3 / 20), y3 = V0$1(Pi(o2, 5), W0(w2, h2, p2, A2), v2, i4[n3], X0[w2]);
    v2 = A2, A2 = p2, p2 = Pi(h2, 30), h2 = o2, o2 = y3;
  }
  this.h[0] = Mr(this.h[0], o2), this.h[1] = Mr(this.h[1], h2), this.h[2] = Mr(this.h[2], p2), this.h[3] = Mr(this.h[3], A2), this.h[4] = Mr(this.h[4], v2);
}, he.prototype._digest = function(t2) {
  return t2 === "hex" ? ar.toHex32(this.h, "big") : ar.split32(this.h, "big");
};
var ur = Q, $0 = or, hr = ae, ta = xr, ie = ur.sum32, ea = ur.sum32_4, ra = ur.sum32_5, ia = hr.ch32, na = hr.maj32, fa = hr.s0_256, oa = hr.s1_256, sa = hr.g0_256, aa = hr.g1_256, wf = $0.BlockHash, ua = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
function ce() {
  if (!(this instanceof ce)) return new ce();
  wf.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = ua, this.W = new Array(64);
}
ur.inherits(ce, wf);
var xf = ce;
ce.blockSize = 512, ce.outSize = 256, ce.hmacStrength = 192, ce.padLength = 64, ce.prototype._update = function(t2, r2) {
  for (var i4 = this.W, n3 = 0; n3 < 16; n3++) i4[n3] = t2[r2 + n3];
  for (; n3 < i4.length; n3++) i4[n3] = ea(aa(i4[n3 - 2]), i4[n3 - 7], sa(i4[n3 - 15]), i4[n3 - 16]);
  var o2 = this.h[0], h2 = this.h[1], p2 = this.h[2], A2 = this.h[3], v2 = this.h[4], w2 = this.h[5], y3 = this.h[6], S2 = this.h[7];
  for (ta(this.k.length === i4.length), n3 = 0; n3 < i4.length; n3++) {
    var I2 = ra(S2, oa(v2), ia(v2, w2, y3), this.k[n3], i4[n3]), N2 = ie(fa(o2), na(o2, h2, p2));
    S2 = y3, y3 = w2, w2 = v2, v2 = ie(A2, I2), A2 = p2, p2 = h2, h2 = o2, o2 = ie(I2, N2);
  }
  this.h[0] = ie(this.h[0], o2), this.h[1] = ie(this.h[1], h2), this.h[2] = ie(this.h[2], p2), this.h[3] = ie(this.h[3], A2), this.h[4] = ie(this.h[4], v2), this.h[5] = ie(this.h[5], w2), this.h[6] = ie(this.h[6], y3), this.h[7] = ie(this.h[7], S2);
}, ce.prototype._digest = function(t2) {
  return t2 === "hex" ? ur.toHex32(this.h, "big") : ur.split32(this.h, "big");
};
var Di = Q, Mf = xf;
function ye() {
  if (!(this instanceof ye)) return new ye();
  Mf.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
}
Di.inherits(ye, Mf);
var ha = ye;
ye.blockSize = 512, ye.outSize = 224, ye.hmacStrength = 192, ye.padLength = 64, ye.prototype._digest = function(t2) {
  return t2 === "hex" ? Di.toHex32(this.h.slice(0, 7), "big") : Di.split32(this.h.slice(0, 7), "big");
};
var jt = Q, ca = or, la = xr, le = jt.rotr64_hi, de = jt.rotr64_lo, Ef = jt.shr64_hi, Sf = jt.shr64_lo, Be = jt.sum64, Fi = jt.sum64_hi, Ti = jt.sum64_lo, da = jt.sum64_4_hi, pa = jt.sum64_4_lo, va = jt.sum64_5_hi, ga = jt.sum64_5_lo, Nf = ca.BlockHash, ma = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
function ne() {
  if (!(this instanceof ne)) return new ne();
  Nf.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = ma, this.W = new Array(160);
}
jt.inherits(ne, Nf);
var If = ne;
ne.blockSize = 1024, ne.outSize = 512, ne.hmacStrength = 192, ne.padLength = 128, ne.prototype._prepareBlock = function(t2, r2) {
  for (var i4 = this.W, n3 = 0; n3 < 32; n3++) i4[n3] = t2[r2 + n3];
  for (; n3 < i4.length; n3 += 2) {
    var o2 = _a(i4[n3 - 4], i4[n3 - 3]), h2 = Ba(i4[n3 - 4], i4[n3 - 3]), p2 = i4[n3 - 14], A2 = i4[n3 - 13], v2 = Na(i4[n3 - 30], i4[n3 - 29]), w2 = Ia(i4[n3 - 30], i4[n3 - 29]), y3 = i4[n3 - 32], S2 = i4[n3 - 31];
    i4[n3] = da(o2, h2, p2, A2, v2, w2, y3, S2), i4[n3 + 1] = pa(o2, h2, p2, A2, v2, w2, y3, S2);
  }
}, ne.prototype._update = function(t2, r2) {
  this._prepareBlock(t2, r2);
  var i4 = this.W, n3 = this.h[0], o2 = this.h[1], h2 = this.h[2], p2 = this.h[3], A2 = this.h[4], v2 = this.h[5], w2 = this.h[6], y3 = this.h[7], S2 = this.h[8], I2 = this.h[9], N2 = this.h[10], C2 = this.h[11], F = this.h[12], U = this.h[13], J = this.h[14], Bt = this.h[15];
  la(this.k.length === i4.length);
  for (var G = 0; G < i4.length; G += 2) {
    var H2 = J, L3 = Bt, Pt = Ea(S2, I2), W = Sa(S2, I2), Rt = Aa(S2, I2, N2, C2, F), Vt = ba(S2, I2, N2, C2, F, U), Y = this.k[G], Wt = this.k[G + 1], b2 = i4[G], f2 = i4[G + 1], a2 = va(H2, L3, Pt, W, Rt, Vt, Y, Wt, b2, f2), c2 = ga(H2, L3, Pt, W, Rt, Vt, Y, Wt, b2, f2);
    H2 = xa(n3, o2), L3 = Ma(n3, o2), Pt = ya(n3, o2, h2, p2, A2), W = wa(n3, o2, h2, p2, A2, v2);
    var d3 = Fi(H2, L3, Pt, W), m3 = Ti(H2, L3, Pt, W);
    J = F, Bt = U, F = N2, U = C2, N2 = S2, C2 = I2, S2 = Fi(w2, y3, a2, c2), I2 = Ti(y3, y3, a2, c2), w2 = A2, y3 = v2, A2 = h2, v2 = p2, h2 = n3, p2 = o2, n3 = Fi(a2, c2, d3, m3), o2 = Ti(a2, c2, d3, m3);
  }
  Be(this.h, 0, n3, o2), Be(this.h, 2, h2, p2), Be(this.h, 4, A2, v2), Be(this.h, 6, w2, y3), Be(this.h, 8, S2, I2), Be(this.h, 10, N2, C2), Be(this.h, 12, F, U), Be(this.h, 14, J, Bt);
}, ne.prototype._digest = function(t2) {
  return t2 === "hex" ? jt.toHex32(this.h, "big") : jt.split32(this.h, "big");
};
function Aa(e2, t2, r2, i4, n3) {
  var o2 = e2 & r2 ^ ~e2 & n3;
  return o2 < 0 && (o2 += 4294967296), o2;
}
function ba(e2, t2, r2, i4, n3, o2) {
  var h2 = t2 & i4 ^ ~t2 & o2;
  return h2 < 0 && (h2 += 4294967296), h2;
}
function ya(e2, t2, r2, i4, n3) {
  var o2 = e2 & r2 ^ e2 & n3 ^ r2 & n3;
  return o2 < 0 && (o2 += 4294967296), o2;
}
function wa(e2, t2, r2, i4, n3, o2) {
  var h2 = t2 & i4 ^ t2 & o2 ^ i4 & o2;
  return h2 < 0 && (h2 += 4294967296), h2;
}
function xa(e2, t2) {
  var r2 = le(e2, t2, 28), i4 = le(t2, e2, 2), n3 = le(t2, e2, 7), o2 = r2 ^ i4 ^ n3;
  return o2 < 0 && (o2 += 4294967296), o2;
}
function Ma(e2, t2) {
  var r2 = de(e2, t2, 28), i4 = de(t2, e2, 2), n3 = de(t2, e2, 7), o2 = r2 ^ i4 ^ n3;
  return o2 < 0 && (o2 += 4294967296), o2;
}
function Ea(e2, t2) {
  var r2 = le(e2, t2, 14), i4 = le(e2, t2, 18), n3 = le(t2, e2, 9), o2 = r2 ^ i4 ^ n3;
  return o2 < 0 && (o2 += 4294967296), o2;
}
function Sa(e2, t2) {
  var r2 = de(e2, t2, 14), i4 = de(e2, t2, 18), n3 = de(t2, e2, 9), o2 = r2 ^ i4 ^ n3;
  return o2 < 0 && (o2 += 4294967296), o2;
}
function Na(e2, t2) {
  var r2 = le(e2, t2, 1), i4 = le(e2, t2, 8), n3 = Ef(e2, t2, 7), o2 = r2 ^ i4 ^ n3;
  return o2 < 0 && (o2 += 4294967296), o2;
}
function Ia(e2, t2) {
  var r2 = de(e2, t2, 1), i4 = de(e2, t2, 8), n3 = Sf(e2, t2, 7), o2 = r2 ^ i4 ^ n3;
  return o2 < 0 && (o2 += 4294967296), o2;
}
function _a(e2, t2) {
  var r2 = le(e2, t2, 19), i4 = le(t2, e2, 29), n3 = Ef(e2, t2, 6), o2 = r2 ^ i4 ^ n3;
  return o2 < 0 && (o2 += 4294967296), o2;
}
function Ba(e2, t2) {
  var r2 = de(e2, t2, 19), i4 = de(t2, e2, 29), n3 = Sf(e2, t2, 6), o2 = r2 ^ i4 ^ n3;
  return o2 < 0 && (o2 += 4294967296), o2;
}
var Ui$1 = Q, _f = If;
function we() {
  if (!(this instanceof we)) return new we();
  _f.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
}
Ui$1.inherits(we, _f);
var Ca = we;
we.blockSize = 1024, we.outSize = 384, we.hmacStrength = 192, we.padLength = 128, we.prototype._digest = function(t2) {
  return t2 === "hex" ? Ui$1.toHex32(this.h.slice(0, 12), "big") : Ui$1.split32(this.h.slice(0, 12), "big");
}, sr.sha1 = Z0, sr.sha224 = ha, sr.sha256 = xf, sr.sha384 = Ca, sr.sha512 = If;
var Bf = {}, Xe = Q, Ra = or, Kr = Xe.rotl32, Cf = Xe.sum32, Er = Xe.sum32_3, Rf = Xe.sum32_4, Of = Ra.BlockHash;
function pe() {
  if (!(this instanceof pe)) return new pe();
  Of.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
Xe.inherits(pe, Of), Bf.ripemd160 = pe, pe.blockSize = 512, pe.outSize = 160, pe.hmacStrength = 192, pe.padLength = 64, pe.prototype._update = function(t2, r2) {
  for (var i4 = this.h[0], n3 = this.h[1], o2 = this.h[2], h2 = this.h[3], p2 = this.h[4], A2 = i4, v2 = n3, w2 = o2, y3 = h2, S2 = p2, I2 = 0; I2 < 80; I2++) {
    var N2 = Cf(Kr(Rf(i4, Pf(I2, n3, o2, h2), t2[Da[I2] + r2], Oa(I2)), Ta[I2]), p2);
    i4 = p2, p2 = h2, h2 = Kr(o2, 10), o2 = n3, n3 = N2, N2 = Cf(Kr(Rf(A2, Pf(79 - I2, v2, w2, y3), t2[Fa[I2] + r2], Pa(I2)), Ua[I2]), S2), A2 = S2, S2 = y3, y3 = Kr(w2, 10), w2 = v2, v2 = N2;
  }
  N2 = Er(this.h[1], o2, y3), this.h[1] = Er(this.h[2], h2, S2), this.h[2] = Er(this.h[3], p2, A2), this.h[3] = Er(this.h[4], i4, v2), this.h[4] = Er(this.h[0], n3, w2), this.h[0] = N2;
}, pe.prototype._digest = function(t2) {
  return t2 === "hex" ? Xe.toHex32(this.h, "little") : Xe.split32(this.h, "little");
};
function Pf(e2, t2, r2, i4) {
  return e2 <= 15 ? t2 ^ r2 ^ i4 : e2 <= 31 ? t2 & r2 | ~t2 & i4 : e2 <= 47 ? (t2 | ~r2) ^ i4 : e2 <= 63 ? t2 & i4 | r2 & ~i4 : t2 ^ (r2 | ~i4);
}
function Oa(e2) {
  return e2 <= 15 ? 0 : e2 <= 31 ? 1518500249 : e2 <= 47 ? 1859775393 : e2 <= 63 ? 2400959708 : 2840853838;
}
function Pa(e2) {
  return e2 <= 15 ? 1352829926 : e2 <= 31 ? 1548603684 : e2 <= 47 ? 1836072691 : e2 <= 63 ? 2053994217 : 0;
}
var Da = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], Fa = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], Ta = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], Ua = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], ka = Q, qa = xr;
function cr(e2, t2, r2) {
  if (!(this instanceof cr)) return new cr(e2, t2, r2);
  this.Hash = e2, this.blockSize = e2.blockSize / 8, this.outSize = e2.outSize / 8, this.inner = null, this.outer = null, this._init(ka.toArray(t2, r2));
}
var Ka = cr;
cr.prototype._init = function(t2) {
  t2.length > this.blockSize && (t2 = new this.Hash().update(t2).digest()), qa(t2.length <= this.blockSize);
  for (var r2 = t2.length; r2 < this.blockSize; r2++) t2.push(0);
  for (r2 = 0; r2 < t2.length; r2++) t2[r2] ^= 54;
  for (this.inner = new this.Hash().update(t2), r2 = 0; r2 < t2.length; r2++) t2[r2] ^= 106;
  this.outer = new this.Hash().update(t2);
}, cr.prototype.update = function(t2, r2) {
  return this.inner.update(t2, r2), this;
}, cr.prototype.digest = function(t2) {
  return this.outer.update(this.inner.digest()), this.outer.digest(t2);
}, (function(e2) {
  var t2 = e2;
  t2.utils = Q, t2.common = or, t2.sha = sr, t2.ripemd = Bf, t2.hmac = Ka, t2.sha1 = t2.sha.sha1, t2.sha256 = t2.sha.sha256, t2.sha224 = t2.sha.sha224, t2.sha384 = t2.sha.sha384, t2.sha512 = t2.sha.sha512, t2.ripemd160 = t2.ripemd.ripemd160;
})(se);
function lr(e2, t2, r2) {
  return r2 = { path: t2, exports: {}, require: function(i4, n3) {
    return Ha(i4, n3 ?? r2.path);
  } }, e2(r2, r2.exports), r2.exports;
}
function Ha() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var ki = Df;
function Df(e2, t2) {
  if (!e2) throw new Error(t2 || "Assertion failed");
}
Df.equal = function(t2, r2, i4) {
  if (t2 != r2) throw new Error(i4 || "Assertion failed: " + t2 + " != " + r2);
};
var fe = lr(function(e2, t2) {
  var r2 = t2;
  function i4(h2, p2) {
    if (Array.isArray(h2)) return h2.slice();
    if (!h2) return [];
    var A2 = [];
    if (typeof h2 != "string") {
      for (var v2 = 0; v2 < h2.length; v2++) A2[v2] = h2[v2] | 0;
      return A2;
    }
    if (p2 === "hex") {
      h2 = h2.replace(/[^a-z0-9]+/ig, ""), h2.length % 2 !== 0 && (h2 = "0" + h2);
      for (var v2 = 0; v2 < h2.length; v2 += 2) A2.push(parseInt(h2[v2] + h2[v2 + 1], 16));
    } else for (var v2 = 0; v2 < h2.length; v2++) {
      var w2 = h2.charCodeAt(v2), y3 = w2 >> 8, S2 = w2 & 255;
      y3 ? A2.push(y3, S2) : A2.push(S2);
    }
    return A2;
  }
  r2.toArray = i4;
  function n3(h2) {
    return h2.length === 1 ? "0" + h2 : h2;
  }
  r2.zero2 = n3;
  function o2(h2) {
    for (var p2 = "", A2 = 0; A2 < h2.length; A2++) p2 += n3(h2[A2].toString(16));
    return p2;
  }
  r2.toHex = o2, r2.encode = function(p2, A2) {
    return A2 === "hex" ? o2(p2) : p2;
  };
}), Gt = lr(function(e2, t2) {
  var r2 = t2;
  r2.assert = ki, r2.toArray = fe.toArray, r2.zero2 = fe.zero2, r2.toHex = fe.toHex, r2.encode = fe.encode;
  function i4(A2, v2, w2) {
    var y3 = new Array(Math.max(A2.bitLength(), w2) + 1);
    y3.fill(0);
    for (var S2 = 1 << v2 + 1, I2 = A2.clone(), N2 = 0; N2 < y3.length; N2++) {
      var C2, F = I2.andln(S2 - 1);
      I2.isOdd() ? (F > (S2 >> 1) - 1 ? C2 = (S2 >> 1) - F : C2 = F, I2.isubn(C2)) : C2 = 0, y3[N2] = C2, I2.iushrn(1);
    }
    return y3;
  }
  r2.getNAF = i4;
  function n3(A2, v2) {
    var w2 = [[], []];
    A2 = A2.clone(), v2 = v2.clone();
    for (var y3 = 0, S2 = 0, I2; A2.cmpn(-y3) > 0 || v2.cmpn(-S2) > 0; ) {
      var N2 = A2.andln(3) + y3 & 3, C2 = v2.andln(3) + S2 & 3;
      N2 === 3 && (N2 = -1), C2 === 3 && (C2 = -1);
      var F;
      N2 & 1 ? (I2 = A2.andln(7) + y3 & 7, (I2 === 3 || I2 === 5) && C2 === 2 ? F = -N2 : F = N2) : F = 0, w2[0].push(F);
      var U;
      C2 & 1 ? (I2 = v2.andln(7) + S2 & 7, (I2 === 3 || I2 === 5) && N2 === 2 ? U = -C2 : U = C2) : U = 0, w2[1].push(U), 2 * y3 === F + 1 && (y3 = 1 - y3), 2 * S2 === U + 1 && (S2 = 1 - S2), A2.iushrn(1), v2.iushrn(1);
    }
    return w2;
  }
  r2.getJSF = n3;
  function o2(A2, v2, w2) {
    var y3 = "_" + v2;
    A2.prototype[v2] = function() {
      return this[y3] !== void 0 ? this[y3] : this[y3] = w2.call(this);
    };
  }
  r2.cachedProperty = o2;
  function h2(A2) {
    return typeof A2 == "string" ? r2.toArray(A2, "hex") : A2;
  }
  r2.parseBytes = h2;
  function p2(A2) {
    return new K(A2, "hex", "le");
  }
  r2.intFromLE = p2;
}), Hr = Gt.getNAF, La = Gt.getJSF, Lr = Gt.assert;
function Ce(e2, t2) {
  this.type = e2, this.p = new K(t2.p, 16), this.red = t2.prime ? K.red(t2.prime) : K.mont(this.p), this.zero = new K(0).toRed(this.red), this.one = new K(1).toRed(this.red), this.two = new K(2).toRed(this.red), this.n = t2.n && new K(t2.n, 16), this.g = t2.g && this.pointFromJSON(t2.g, t2.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var r2 = this.n && this.p.div(this.n);
  !r2 || r2.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
}
var Ze = Ce;
Ce.prototype.point = function() {
  throw new Error("Not implemented");
}, Ce.prototype.validate = function() {
  throw new Error("Not implemented");
}, Ce.prototype._fixedNafMul = function(t2, r2) {
  Lr(t2.precomputed);
  var i4 = t2._getDoubles(), n3 = Hr(r2, 1, this._bitLength), o2 = (1 << i4.step + 1) - (i4.step % 2 === 0 ? 2 : 1);
  o2 /= 3;
  var h2 = [], p2, A2;
  for (p2 = 0; p2 < n3.length; p2 += i4.step) {
    A2 = 0;
    for (var v2 = p2 + i4.step - 1; v2 >= p2; v2--) A2 = (A2 << 1) + n3[v2];
    h2.push(A2);
  }
  for (var w2 = this.jpoint(null, null, null), y3 = this.jpoint(null, null, null), S2 = o2; S2 > 0; S2--) {
    for (p2 = 0; p2 < h2.length; p2++) A2 = h2[p2], A2 === S2 ? y3 = y3.mixedAdd(i4.points[p2]) : A2 === -S2 && (y3 = y3.mixedAdd(i4.points[p2].neg()));
    w2 = w2.add(y3);
  }
  return w2.toP();
}, Ce.prototype._wnafMul = function(t2, r2) {
  var i4 = 4, n3 = t2._getNAFPoints(i4);
  i4 = n3.wnd;
  for (var o2 = n3.points, h2 = Hr(r2, i4, this._bitLength), p2 = this.jpoint(null, null, null), A2 = h2.length - 1; A2 >= 0; A2--) {
    for (var v2 = 0; A2 >= 0 && h2[A2] === 0; A2--) v2++;
    if (A2 >= 0 && v2++, p2 = p2.dblp(v2), A2 < 0) break;
    var w2 = h2[A2];
    Lr(w2 !== 0), t2.type === "affine" ? w2 > 0 ? p2 = p2.mixedAdd(o2[w2 - 1 >> 1]) : p2 = p2.mixedAdd(o2[-w2 - 1 >> 1].neg()) : w2 > 0 ? p2 = p2.add(o2[w2 - 1 >> 1]) : p2 = p2.add(o2[-w2 - 1 >> 1].neg());
  }
  return t2.type === "affine" ? p2.toP() : p2;
}, Ce.prototype._wnafMulAdd = function(t2, r2, i4, n3, o2) {
  var h2 = this._wnafT1, p2 = this._wnafT2, A2 = this._wnafT3, v2 = 0, w2, y3, S2;
  for (w2 = 0; w2 < n3; w2++) {
    S2 = r2[w2];
    var I2 = S2._getNAFPoints(t2);
    h2[w2] = I2.wnd, p2[w2] = I2.points;
  }
  for (w2 = n3 - 1; w2 >= 1; w2 -= 2) {
    var N2 = w2 - 1, C2 = w2;
    if (h2[N2] !== 1 || h2[C2] !== 1) {
      A2[N2] = Hr(i4[N2], h2[N2], this._bitLength), A2[C2] = Hr(i4[C2], h2[C2], this._bitLength), v2 = Math.max(A2[N2].length, v2), v2 = Math.max(A2[C2].length, v2);
      continue;
    }
    var F = [r2[N2], null, null, r2[C2]];
    r2[N2].y.cmp(r2[C2].y) === 0 ? (F[1] = r2[N2].add(r2[C2]), F[2] = r2[N2].toJ().mixedAdd(r2[C2].neg())) : r2[N2].y.cmp(r2[C2].y.redNeg()) === 0 ? (F[1] = r2[N2].toJ().mixedAdd(r2[C2]), F[2] = r2[N2].add(r2[C2].neg())) : (F[1] = r2[N2].toJ().mixedAdd(r2[C2]), F[2] = r2[N2].toJ().mixedAdd(r2[C2].neg()));
    var U = [-3, -1, -5, -7, 0, 7, 5, 1, 3], J = La(i4[N2], i4[C2]);
    for (v2 = Math.max(J[0].length, v2), A2[N2] = new Array(v2), A2[C2] = new Array(v2), y3 = 0; y3 < v2; y3++) {
      var Bt = J[0][y3] | 0, G = J[1][y3] | 0;
      A2[N2][y3] = U[(Bt + 1) * 3 + (G + 1)], A2[C2][y3] = 0, p2[N2] = F;
    }
  }
  var H2 = this.jpoint(null, null, null), L3 = this._wnafT4;
  for (w2 = v2; w2 >= 0; w2--) {
    for (var Pt = 0; w2 >= 0; ) {
      var W = true;
      for (y3 = 0; y3 < n3; y3++) L3[y3] = A2[y3][w2] | 0, L3[y3] !== 0 && (W = false);
      if (!W) break;
      Pt++, w2--;
    }
    if (w2 >= 0 && Pt++, H2 = H2.dblp(Pt), w2 < 0) break;
    for (y3 = 0; y3 < n3; y3++) {
      var Rt = L3[y3];
      Rt !== 0 && (Rt > 0 ? S2 = p2[y3][Rt - 1 >> 1] : Rt < 0 && (S2 = p2[y3][-Rt - 1 >> 1].neg()), S2.type === "affine" ? H2 = H2.mixedAdd(S2) : H2 = H2.add(S2));
    }
  }
  for (w2 = 0; w2 < n3; w2++) p2[w2] = null;
  return o2 ? H2 : H2.toP();
};
function $t(e2, t2) {
  this.curve = e2, this.type = t2, this.precomputed = null;
}
Ce.BasePoint = $t, $t.prototype.eq = function() {
  throw new Error("Not implemented");
}, $t.prototype.validate = function() {
  return this.curve.validate(this);
}, Ce.prototype.decodePoint = function(t2, r2) {
  t2 = Gt.toArray(t2, r2);
  var i4 = this.p.byteLength();
  if ((t2[0] === 4 || t2[0] === 6 || t2[0] === 7) && t2.length - 1 === 2 * i4) {
    t2[0] === 6 ? Lr(t2[t2.length - 1] % 2 === 0) : t2[0] === 7 && Lr(t2[t2.length - 1] % 2 === 1);
    var n3 = this.point(t2.slice(1, 1 + i4), t2.slice(1 + i4, 1 + 2 * i4));
    return n3;
  } else if ((t2[0] === 2 || t2[0] === 3) && t2.length - 1 === i4) return this.pointFromX(t2.slice(1, 1 + i4), t2[0] === 3);
  throw new Error("Unknown point format");
}, $t.prototype.encodeCompressed = function(t2) {
  return this.encode(t2, true);
}, $t.prototype._encode = function(t2) {
  var r2 = this.curve.p.byteLength(), i4 = this.getX().toArray("be", r2);
  return t2 ? [this.getY().isEven() ? 2 : 3].concat(i4) : [4].concat(i4, this.getY().toArray("be", r2));
}, $t.prototype.encode = function(t2, r2) {
  return Gt.encode(this._encode(r2), t2);
}, $t.prototype.precompute = function(t2) {
  if (this.precomputed) return this;
  var r2 = { doubles: null, naf: null, beta: null };
  return r2.naf = this._getNAFPoints(8), r2.doubles = this._getDoubles(4, t2), r2.beta = this._getBeta(), this.precomputed = r2, this;
}, $t.prototype._hasDoubles = function(t2) {
  if (!this.precomputed) return false;
  var r2 = this.precomputed.doubles;
  return r2 ? r2.points.length >= Math.ceil((t2.bitLength() + 1) / r2.step) : false;
}, $t.prototype._getDoubles = function(t2, r2) {
  if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
  for (var i4 = [this], n3 = this, o2 = 0; o2 < r2; o2 += t2) {
    for (var h2 = 0; h2 < t2; h2++) n3 = n3.dbl();
    i4.push(n3);
  }
  return { step: t2, points: i4 };
}, $t.prototype._getNAFPoints = function(t2) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  for (var r2 = [this], i4 = (1 << t2) - 1, n3 = i4 === 1 ? null : this.dbl(), o2 = 1; o2 < i4; o2++) r2[o2] = r2[o2 - 1].add(n3);
  return { wnd: t2, points: r2 };
}, $t.prototype._getBeta = function() {
  return null;
}, $t.prototype.dblp = function(t2) {
  for (var r2 = this, i4 = 0; i4 < t2; i4++) r2 = r2.dbl();
  return r2;
};
var qi = lr(function(e2) {
  typeof Object.create == "function" ? e2.exports = function(r2, i4) {
    i4 && (r2.super_ = i4, r2.prototype = Object.create(i4.prototype, { constructor: { value: r2, enumerable: false, writable: true, configurable: true } }));
  } : e2.exports = function(r2, i4) {
    if (i4) {
      r2.super_ = i4;
      var n3 = function() {
      };
      n3.prototype = i4.prototype, r2.prototype = new n3(), r2.prototype.constructor = r2;
    }
  };
}), za = Gt.assert;
function te(e2) {
  Ze.call(this, "short", e2), this.a = new K(e2.a, 16).toRed(this.red), this.b = new K(e2.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(e2), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
qi(te, Ze);
var ja = te;
te.prototype._getEndomorphism = function(t2) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var r2, i4;
    if (t2.beta) r2 = new K(t2.beta, 16).toRed(this.red);
    else {
      var n3 = this._getEndoRoots(this.p);
      r2 = n3[0].cmp(n3[1]) < 0 ? n3[0] : n3[1], r2 = r2.toRed(this.red);
    }
    if (t2.lambda) i4 = new K(t2.lambda, 16);
    else {
      var o2 = this._getEndoRoots(this.n);
      this.g.mul(o2[0]).x.cmp(this.g.x.redMul(r2)) === 0 ? i4 = o2[0] : (i4 = o2[1], za(this.g.mul(i4).x.cmp(this.g.x.redMul(r2)) === 0));
    }
    var h2;
    return t2.basis ? h2 = t2.basis.map(function(p2) {
      return { a: new K(p2.a, 16), b: new K(p2.b, 16) };
    }) : h2 = this._getEndoBasis(i4), { beta: r2, lambda: i4, basis: h2 };
  }
}, te.prototype._getEndoRoots = function(t2) {
  var r2 = t2 === this.p ? this.red : K.mont(t2), i4 = new K(2).toRed(r2).redInvm(), n3 = i4.redNeg(), o2 = new K(3).toRed(r2).redNeg().redSqrt().redMul(i4), h2 = n3.redAdd(o2).fromRed(), p2 = n3.redSub(o2).fromRed();
  return [h2, p2];
}, te.prototype._getEndoBasis = function(t2) {
  for (var r2 = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), i4 = t2, n3 = this.n.clone(), o2 = new K(1), h2 = new K(0), p2 = new K(0), A2 = new K(1), v2, w2, y3, S2, I2, N2, C2, F = 0, U, J; i4.cmpn(0) !== 0; ) {
    var Bt = n3.div(i4);
    U = n3.sub(Bt.mul(i4)), J = p2.sub(Bt.mul(o2));
    var G = A2.sub(Bt.mul(h2));
    if (!y3 && U.cmp(r2) < 0) v2 = C2.neg(), w2 = o2, y3 = U.neg(), S2 = J;
    else if (y3 && ++F === 2) break;
    C2 = U, n3 = i4, i4 = U, p2 = o2, o2 = J, A2 = h2, h2 = G;
  }
  I2 = U.neg(), N2 = J;
  var H2 = y3.sqr().add(S2.sqr()), L3 = I2.sqr().add(N2.sqr());
  return L3.cmp(H2) >= 0 && (I2 = v2, N2 = w2), y3.negative && (y3 = y3.neg(), S2 = S2.neg()), I2.negative && (I2 = I2.neg(), N2 = N2.neg()), [{ a: y3, b: S2 }, { a: I2, b: N2 }];
}, te.prototype._endoSplit = function(t2) {
  var r2 = this.endo.basis, i4 = r2[0], n3 = r2[1], o2 = n3.b.mul(t2).divRound(this.n), h2 = i4.b.neg().mul(t2).divRound(this.n), p2 = o2.mul(i4.a), A2 = h2.mul(n3.a), v2 = o2.mul(i4.b), w2 = h2.mul(n3.b), y3 = t2.sub(p2).sub(A2), S2 = v2.add(w2).neg();
  return { k1: y3, k2: S2 };
}, te.prototype.pointFromX = function(t2, r2) {
  t2 = new K(t2, 16), t2.red || (t2 = t2.toRed(this.red));
  var i4 = t2.redSqr().redMul(t2).redIAdd(t2.redMul(this.a)).redIAdd(this.b), n3 = i4.redSqrt();
  if (n3.redSqr().redSub(i4).cmp(this.zero) !== 0) throw new Error("invalid point");
  var o2 = n3.fromRed().isOdd();
  return (r2 && !o2 || !r2 && o2) && (n3 = n3.redNeg()), this.point(t2, n3);
}, te.prototype.validate = function(t2) {
  if (t2.inf) return true;
  var r2 = t2.x, i4 = t2.y, n3 = this.a.redMul(r2), o2 = r2.redSqr().redMul(r2).redIAdd(n3).redIAdd(this.b);
  return i4.redSqr().redISub(o2).cmpn(0) === 0;
}, te.prototype._endoWnafMulAdd = function(t2, r2, i4) {
  for (var n3 = this._endoWnafT1, o2 = this._endoWnafT2, h2 = 0; h2 < t2.length; h2++) {
    var p2 = this._endoSplit(r2[h2]), A2 = t2[h2], v2 = A2._getBeta();
    p2.k1.negative && (p2.k1.ineg(), A2 = A2.neg(true)), p2.k2.negative && (p2.k2.ineg(), v2 = v2.neg(true)), n3[h2 * 2] = A2, n3[h2 * 2 + 1] = v2, o2[h2 * 2] = p2.k1, o2[h2 * 2 + 1] = p2.k2;
  }
  for (var w2 = this._wnafMulAdd(1, n3, o2, h2 * 2, i4), y3 = 0; y3 < h2 * 2; y3++) n3[y3] = null, o2[y3] = null;
  return w2;
};
function Ft(e2, t2, r2, i4) {
  Ze.BasePoint.call(this, e2, "affine"), t2 === null && r2 === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new K(t2, 16), this.y = new K(r2, 16), i4 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
}
qi(Ft, Ze.BasePoint), te.prototype.point = function(t2, r2, i4) {
  return new Ft(this, t2, r2, i4);
}, te.prototype.pointFromJSON = function(t2, r2) {
  return Ft.fromJSON(this, t2, r2);
}, Ft.prototype._getBeta = function() {
  if (this.curve.endo) {
    var t2 = this.precomputed;
    if (t2 && t2.beta) return t2.beta;
    var r2 = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (t2) {
      var i4 = this.curve, n3 = function(o2) {
        return i4.point(o2.x.redMul(i4.endo.beta), o2.y);
      };
      t2.beta = r2, r2.precomputed = { beta: null, naf: t2.naf && { wnd: t2.naf.wnd, points: t2.naf.points.map(n3) }, doubles: t2.doubles && { step: t2.doubles.step, points: t2.doubles.points.map(n3) } };
    }
    return r2;
  }
}, Ft.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
}, Ft.fromJSON = function(t2, r2, i4) {
  typeof r2 == "string" && (r2 = JSON.parse(r2));
  var n3 = t2.point(r2[0], r2[1], i4);
  if (!r2[2]) return n3;
  function o2(p2) {
    return t2.point(p2[0], p2[1], i4);
  }
  var h2 = r2[2];
  return n3.precomputed = { beta: null, doubles: h2.doubles && { step: h2.doubles.step, points: [n3].concat(h2.doubles.points.map(o2)) }, naf: h2.naf && { wnd: h2.naf.wnd, points: [n3].concat(h2.naf.points.map(o2)) } }, n3;
}, Ft.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
}, Ft.prototype.isInfinity = function() {
  return this.inf;
}, Ft.prototype.add = function(t2) {
  if (this.inf) return t2;
  if (t2.inf) return this;
  if (this.eq(t2)) return this.dbl();
  if (this.neg().eq(t2)) return this.curve.point(null, null);
  if (this.x.cmp(t2.x) === 0) return this.curve.point(null, null);
  var r2 = this.y.redSub(t2.y);
  r2.cmpn(0) !== 0 && (r2 = r2.redMul(this.x.redSub(t2.x).redInvm()));
  var i4 = r2.redSqr().redISub(this.x).redISub(t2.x), n3 = r2.redMul(this.x.redSub(i4)).redISub(this.y);
  return this.curve.point(i4, n3);
}, Ft.prototype.dbl = function() {
  if (this.inf) return this;
  var t2 = this.y.redAdd(this.y);
  if (t2.cmpn(0) === 0) return this.curve.point(null, null);
  var r2 = this.curve.a, i4 = this.x.redSqr(), n3 = t2.redInvm(), o2 = i4.redAdd(i4).redIAdd(i4).redIAdd(r2).redMul(n3), h2 = o2.redSqr().redISub(this.x.redAdd(this.x)), p2 = o2.redMul(this.x.redSub(h2)).redISub(this.y);
  return this.curve.point(h2, p2);
}, Ft.prototype.getX = function() {
  return this.x.fromRed();
}, Ft.prototype.getY = function() {
  return this.y.fromRed();
}, Ft.prototype.mul = function(t2) {
  return t2 = new K(t2, 16), this.isInfinity() ? this : this._hasDoubles(t2) ? this.curve._fixedNafMul(this, t2) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t2]) : this.curve._wnafMul(this, t2);
}, Ft.prototype.mulAdd = function(t2, r2, i4) {
  var n3 = [this, r2], o2 = [t2, i4];
  return this.curve.endo ? this.curve._endoWnafMulAdd(n3, o2) : this.curve._wnafMulAdd(1, n3, o2, 2);
}, Ft.prototype.jmulAdd = function(t2, r2, i4) {
  var n3 = [this, r2], o2 = [t2, i4];
  return this.curve.endo ? this.curve._endoWnafMulAdd(n3, o2, true) : this.curve._wnafMulAdd(1, n3, o2, 2, true);
}, Ft.prototype.eq = function(t2) {
  return this === t2 || this.inf === t2.inf && (this.inf || this.x.cmp(t2.x) === 0 && this.y.cmp(t2.y) === 0);
}, Ft.prototype.neg = function(t2) {
  if (this.inf) return this;
  var r2 = this.curve.point(this.x, this.y.redNeg());
  if (t2 && this.precomputed) {
    var i4 = this.precomputed, n3 = function(o2) {
      return o2.neg();
    };
    r2.precomputed = { naf: i4.naf && { wnd: i4.naf.wnd, points: i4.naf.points.map(n3) }, doubles: i4.doubles && { step: i4.doubles.step, points: i4.doubles.points.map(n3) } };
  }
  return r2;
}, Ft.prototype.toJ = function() {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var t2 = this.curve.jpoint(this.x, this.y, this.curve.one);
  return t2;
};
function Tt(e2, t2, r2, i4) {
  Ze.BasePoint.call(this, e2, "jacobian"), t2 === null && r2 === null && i4 === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new K(0)) : (this.x = new K(t2, 16), this.y = new K(r2, 16), this.z = new K(i4, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
qi(Tt, Ze.BasePoint), te.prototype.jpoint = function(t2, r2, i4) {
  return new Tt(this, t2, r2, i4);
}, Tt.prototype.toP = function() {
  if (this.isInfinity()) return this.curve.point(null, null);
  var t2 = this.z.redInvm(), r2 = t2.redSqr(), i4 = this.x.redMul(r2), n3 = this.y.redMul(r2).redMul(t2);
  return this.curve.point(i4, n3);
}, Tt.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
}, Tt.prototype.add = function(t2) {
  if (this.isInfinity()) return t2;
  if (t2.isInfinity()) return this;
  var r2 = t2.z.redSqr(), i4 = this.z.redSqr(), n3 = this.x.redMul(r2), o2 = t2.x.redMul(i4), h2 = this.y.redMul(r2.redMul(t2.z)), p2 = t2.y.redMul(i4.redMul(this.z)), A2 = n3.redSub(o2), v2 = h2.redSub(p2);
  if (A2.cmpn(0) === 0) return v2.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var w2 = A2.redSqr(), y3 = w2.redMul(A2), S2 = n3.redMul(w2), I2 = v2.redSqr().redIAdd(y3).redISub(S2).redISub(S2), N2 = v2.redMul(S2.redISub(I2)).redISub(h2.redMul(y3)), C2 = this.z.redMul(t2.z).redMul(A2);
  return this.curve.jpoint(I2, N2, C2);
}, Tt.prototype.mixedAdd = function(t2) {
  if (this.isInfinity()) return t2.toJ();
  if (t2.isInfinity()) return this;
  var r2 = this.z.redSqr(), i4 = this.x, n3 = t2.x.redMul(r2), o2 = this.y, h2 = t2.y.redMul(r2).redMul(this.z), p2 = i4.redSub(n3), A2 = o2.redSub(h2);
  if (p2.cmpn(0) === 0) return A2.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var v2 = p2.redSqr(), w2 = v2.redMul(p2), y3 = i4.redMul(v2), S2 = A2.redSqr().redIAdd(w2).redISub(y3).redISub(y3), I2 = A2.redMul(y3.redISub(S2)).redISub(o2.redMul(w2)), N2 = this.z.redMul(p2);
  return this.curve.jpoint(S2, I2, N2);
}, Tt.prototype.dblp = function(t2) {
  if (t2 === 0) return this;
  if (this.isInfinity()) return this;
  if (!t2) return this.dbl();
  var r2;
  if (this.curve.zeroA || this.curve.threeA) {
    var i4 = this;
    for (r2 = 0; r2 < t2; r2++) i4 = i4.dbl();
    return i4;
  }
  var n3 = this.curve.a, o2 = this.curve.tinv, h2 = this.x, p2 = this.y, A2 = this.z, v2 = A2.redSqr().redSqr(), w2 = p2.redAdd(p2);
  for (r2 = 0; r2 < t2; r2++) {
    var y3 = h2.redSqr(), S2 = w2.redSqr(), I2 = S2.redSqr(), N2 = y3.redAdd(y3).redIAdd(y3).redIAdd(n3.redMul(v2)), C2 = h2.redMul(S2), F = N2.redSqr().redISub(C2.redAdd(C2)), U = C2.redISub(F), J = N2.redMul(U);
    J = J.redIAdd(J).redISub(I2);
    var Bt = w2.redMul(A2);
    r2 + 1 < t2 && (v2 = v2.redMul(I2)), h2 = F, A2 = Bt, w2 = J;
  }
  return this.curve.jpoint(h2, w2.redMul(o2), A2);
}, Tt.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
}, Tt.prototype._zeroDbl = function() {
  var t2, r2, i4;
  if (this.zOne) {
    var n3 = this.x.redSqr(), o2 = this.y.redSqr(), h2 = o2.redSqr(), p2 = this.x.redAdd(o2).redSqr().redISub(n3).redISub(h2);
    p2 = p2.redIAdd(p2);
    var A2 = n3.redAdd(n3).redIAdd(n3), v2 = A2.redSqr().redISub(p2).redISub(p2), w2 = h2.redIAdd(h2);
    w2 = w2.redIAdd(w2), w2 = w2.redIAdd(w2), t2 = v2, r2 = A2.redMul(p2.redISub(v2)).redISub(w2), i4 = this.y.redAdd(this.y);
  } else {
    var y3 = this.x.redSqr(), S2 = this.y.redSqr(), I2 = S2.redSqr(), N2 = this.x.redAdd(S2).redSqr().redISub(y3).redISub(I2);
    N2 = N2.redIAdd(N2);
    var C2 = y3.redAdd(y3).redIAdd(y3), F = C2.redSqr(), U = I2.redIAdd(I2);
    U = U.redIAdd(U), U = U.redIAdd(U), t2 = F.redISub(N2).redISub(N2), r2 = C2.redMul(N2.redISub(t2)).redISub(U), i4 = this.y.redMul(this.z), i4 = i4.redIAdd(i4);
  }
  return this.curve.jpoint(t2, r2, i4);
}, Tt.prototype._threeDbl = function() {
  var t2, r2, i4;
  if (this.zOne) {
    var n3 = this.x.redSqr(), o2 = this.y.redSqr(), h2 = o2.redSqr(), p2 = this.x.redAdd(o2).redSqr().redISub(n3).redISub(h2);
    p2 = p2.redIAdd(p2);
    var A2 = n3.redAdd(n3).redIAdd(n3).redIAdd(this.curve.a), v2 = A2.redSqr().redISub(p2).redISub(p2);
    t2 = v2;
    var w2 = h2.redIAdd(h2);
    w2 = w2.redIAdd(w2), w2 = w2.redIAdd(w2), r2 = A2.redMul(p2.redISub(v2)).redISub(w2), i4 = this.y.redAdd(this.y);
  } else {
    var y3 = this.z.redSqr(), S2 = this.y.redSqr(), I2 = this.x.redMul(S2), N2 = this.x.redSub(y3).redMul(this.x.redAdd(y3));
    N2 = N2.redAdd(N2).redIAdd(N2);
    var C2 = I2.redIAdd(I2);
    C2 = C2.redIAdd(C2);
    var F = C2.redAdd(C2);
    t2 = N2.redSqr().redISub(F), i4 = this.y.redAdd(this.z).redSqr().redISub(S2).redISub(y3);
    var U = S2.redSqr();
    U = U.redIAdd(U), U = U.redIAdd(U), U = U.redIAdd(U), r2 = N2.redMul(C2.redISub(t2)).redISub(U);
  }
  return this.curve.jpoint(t2, r2, i4);
}, Tt.prototype._dbl = function() {
  var t2 = this.curve.a, r2 = this.x, i4 = this.y, n3 = this.z, o2 = n3.redSqr().redSqr(), h2 = r2.redSqr(), p2 = i4.redSqr(), A2 = h2.redAdd(h2).redIAdd(h2).redIAdd(t2.redMul(o2)), v2 = r2.redAdd(r2);
  v2 = v2.redIAdd(v2);
  var w2 = v2.redMul(p2), y3 = A2.redSqr().redISub(w2.redAdd(w2)), S2 = w2.redISub(y3), I2 = p2.redSqr();
  I2 = I2.redIAdd(I2), I2 = I2.redIAdd(I2), I2 = I2.redIAdd(I2);
  var N2 = A2.redMul(S2).redISub(I2), C2 = i4.redAdd(i4).redMul(n3);
  return this.curve.jpoint(y3, N2, C2);
}, Tt.prototype.trpl = function() {
  if (!this.curve.zeroA) return this.dbl().add(this);
  var t2 = this.x.redSqr(), r2 = this.y.redSqr(), i4 = this.z.redSqr(), n3 = r2.redSqr(), o2 = t2.redAdd(t2).redIAdd(t2), h2 = o2.redSqr(), p2 = this.x.redAdd(r2).redSqr().redISub(t2).redISub(n3);
  p2 = p2.redIAdd(p2), p2 = p2.redAdd(p2).redIAdd(p2), p2 = p2.redISub(h2);
  var A2 = p2.redSqr(), v2 = n3.redIAdd(n3);
  v2 = v2.redIAdd(v2), v2 = v2.redIAdd(v2), v2 = v2.redIAdd(v2);
  var w2 = o2.redIAdd(p2).redSqr().redISub(h2).redISub(A2).redISub(v2), y3 = r2.redMul(w2);
  y3 = y3.redIAdd(y3), y3 = y3.redIAdd(y3);
  var S2 = this.x.redMul(A2).redISub(y3);
  S2 = S2.redIAdd(S2), S2 = S2.redIAdd(S2);
  var I2 = this.y.redMul(w2.redMul(v2.redISub(w2)).redISub(p2.redMul(A2)));
  I2 = I2.redIAdd(I2), I2 = I2.redIAdd(I2), I2 = I2.redIAdd(I2);
  var N2 = this.z.redAdd(p2).redSqr().redISub(i4).redISub(A2);
  return this.curve.jpoint(S2, I2, N2);
}, Tt.prototype.mul = function(t2, r2) {
  return t2 = new K(t2, r2), this.curve._wnafMul(this, t2);
}, Tt.prototype.eq = function(t2) {
  if (t2.type === "affine") return this.eq(t2.toJ());
  if (this === t2) return true;
  var r2 = this.z.redSqr(), i4 = t2.z.redSqr();
  if (this.x.redMul(i4).redISub(t2.x.redMul(r2)).cmpn(0) !== 0) return false;
  var n3 = r2.redMul(this.z), o2 = i4.redMul(t2.z);
  return this.y.redMul(o2).redISub(t2.y.redMul(n3)).cmpn(0) === 0;
}, Tt.prototype.eqXToP = function(t2) {
  var r2 = this.z.redSqr(), i4 = t2.toRed(this.curve.red).redMul(r2);
  if (this.x.cmp(i4) === 0) return true;
  for (var n3 = t2.clone(), o2 = this.curve.redN.redMul(r2); ; ) {
    if (n3.iadd(this.curve.n), n3.cmp(this.curve.p) >= 0) return false;
    if (i4.redIAdd(o2), this.x.cmp(i4) === 0) return true;
  }
}, Tt.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
}, Tt.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var zr = lr(function(e2, t2) {
  var r2 = t2;
  r2.base = Ze, r2.short = ja, r2.mont = null, r2.edwards = null;
}), jr = lr(function(e2, t2) {
  var r2 = t2, i4 = Gt.assert;
  function n3(p2) {
    p2.type === "short" ? this.curve = new zr.short(p2) : p2.type === "edwards" ? this.curve = new zr.edwards(p2) : this.curve = new zr.mont(p2), this.g = this.curve.g, this.n = this.curve.n, this.hash = p2.hash, i4(this.g.validate(), "Invalid curve"), i4(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  r2.PresetCurve = n3;
  function o2(p2, A2) {
    Object.defineProperty(r2, p2, { configurable: true, enumerable: true, get: function() {
      var v2 = new n3(A2);
      return Object.defineProperty(r2, p2, { configurable: true, enumerable: true, value: v2 }), v2;
    } });
  }
  o2("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: se.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), o2("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: se.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), o2("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: se.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), o2("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: se.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), o2("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: se.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), o2("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: se.sha256, gRed: false, g: ["9"] }), o2("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: se.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
  var h2;
  try {
    h2 = null.crash();
  } catch {
    h2 = void 0;
  }
  o2("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: se.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", h2] });
});
function Re(e2) {
  if (!(this instanceof Re)) return new Re(e2);
  this.hash = e2.hash, this.predResist = !!e2.predResist, this.outLen = this.hash.outSize, this.minEntropy = e2.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t2 = fe.toArray(e2.entropy, e2.entropyEnc || "hex"), r2 = fe.toArray(e2.nonce, e2.nonceEnc || "hex"), i4 = fe.toArray(e2.pers, e2.persEnc || "hex");
  ki(t2.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(t2, r2, i4);
}
var Ff = Re;
Re.prototype._init = function(t2, r2, i4) {
  var n3 = t2.concat(r2).concat(i4);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var o2 = 0; o2 < this.V.length; o2++) this.K[o2] = 0, this.V[o2] = 1;
  this._update(n3), this._reseed = 1, this.reseedInterval = 281474976710656;
}, Re.prototype._hmac = function() {
  return new se.hmac(this.hash, this.K);
}, Re.prototype._update = function(t2) {
  var r2 = this._hmac().update(this.V).update([0]);
  t2 && (r2 = r2.update(t2)), this.K = r2.digest(), this.V = this._hmac().update(this.V).digest(), t2 && (this.K = this._hmac().update(this.V).update([1]).update(t2).digest(), this.V = this._hmac().update(this.V).digest());
}, Re.prototype.reseed = function(t2, r2, i4, n3) {
  typeof r2 != "string" && (n3 = i4, i4 = r2, r2 = null), t2 = fe.toArray(t2, r2), i4 = fe.toArray(i4, n3), ki(t2.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(t2.concat(i4 || [])), this._reseed = 1;
}, Re.prototype.generate = function(t2, r2, i4, n3) {
  if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
  typeof r2 != "string" && (n3 = i4, i4 = r2, r2 = null), i4 && (i4 = fe.toArray(i4, n3 || "hex"), this._update(i4));
  for (var o2 = []; o2.length < t2; ) this.V = this._hmac().update(this.V).digest(), o2 = o2.concat(this.V);
  var h2 = o2.slice(0, t2);
  return this._update(i4), this._reseed++, fe.encode(h2, r2);
};
var Ki = Gt.assert;
function kt(e2, t2) {
  this.ec = e2, this.priv = null, this.pub = null, t2.priv && this._importPrivate(t2.priv, t2.privEnc), t2.pub && this._importPublic(t2.pub, t2.pubEnc);
}
var Hi = kt;
kt.fromPublic = function(t2, r2, i4) {
  return r2 instanceof kt ? r2 : new kt(t2, { pub: r2, pubEnc: i4 });
}, kt.fromPrivate = function(t2, r2, i4) {
  return r2 instanceof kt ? r2 : new kt(t2, { priv: r2, privEnc: i4 });
}, kt.prototype.validate = function() {
  var t2 = this.getPublic();
  return t2.isInfinity() ? { result: false, reason: "Invalid public key" } : t2.validate() ? t2.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
}, kt.prototype.getPublic = function(t2, r2) {
  return typeof t2 == "string" && (r2 = t2, t2 = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r2 ? this.pub.encode(r2, t2) : this.pub;
}, kt.prototype.getPrivate = function(t2) {
  return t2 === "hex" ? this.priv.toString(16, 2) : this.priv;
}, kt.prototype._importPrivate = function(t2, r2) {
  this.priv = new K(t2, r2 || 16), this.priv = this.priv.umod(this.ec.curve.n);
}, kt.prototype._importPublic = function(t2, r2) {
  if (t2.x || t2.y) {
    this.ec.curve.type === "mont" ? Ki(t2.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Ki(t2.x && t2.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(t2.x, t2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(t2, r2);
}, kt.prototype.derive = function(t2) {
  return t2.validate() || Ki(t2.validate(), "public point not validated"), t2.mul(this.priv).getX();
}, kt.prototype.sign = function(t2, r2, i4) {
  return this.ec.sign(t2, this, r2, i4);
}, kt.prototype.verify = function(t2, r2) {
  return this.ec.verify(t2, r2, this);
}, kt.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var Qa = Gt.assert;
function Qr(e2, t2) {
  if (e2 instanceof Qr) return e2;
  this._importDER(e2, t2) || (Qa(e2.r && e2.s, "Signature without r or s"), this.r = new K(e2.r, 16), this.s = new K(e2.s, 16), e2.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = e2.recoveryParam);
}
var Jr = Qr;
function Ja() {
  this.place = 0;
}
function Li(e2, t2) {
  var r2 = e2[t2.place++];
  if (!(r2 & 128)) return r2;
  var i4 = r2 & 15;
  if (i4 === 0 || i4 > 4) return false;
  for (var n3 = 0, o2 = 0, h2 = t2.place; o2 < i4; o2++, h2++) n3 <<= 8, n3 |= e2[h2], n3 >>>= 0;
  return n3 <= 127 ? false : (t2.place = h2, n3);
}
function Tf(e2) {
  for (var t2 = 0, r2 = e2.length - 1; !e2[t2] && !(e2[t2 + 1] & 128) && t2 < r2; ) t2++;
  return t2 === 0 ? e2 : e2.slice(t2);
}
Qr.prototype._importDER = function(t2, r2) {
  t2 = Gt.toArray(t2, r2);
  var i4 = new Ja();
  if (t2[i4.place++] !== 48) return false;
  var n3 = Li(t2, i4);
  if (n3 === false || n3 + i4.place !== t2.length || t2[i4.place++] !== 2) return false;
  var o2 = Li(t2, i4);
  if (o2 === false) return false;
  var h2 = t2.slice(i4.place, o2 + i4.place);
  if (i4.place += o2, t2[i4.place++] !== 2) return false;
  var p2 = Li(t2, i4);
  if (p2 === false || t2.length !== p2 + i4.place) return false;
  var A2 = t2.slice(i4.place, p2 + i4.place);
  if (h2[0] === 0) if (h2[1] & 128) h2 = h2.slice(1);
  else return false;
  if (A2[0] === 0) if (A2[1] & 128) A2 = A2.slice(1);
  else return false;
  return this.r = new K(h2), this.s = new K(A2), this.recoveryParam = null, true;
};
function zi(e2, t2) {
  if (t2 < 128) {
    e2.push(t2);
    return;
  }
  var r2 = 1 + (Math.log(t2) / Math.LN2 >>> 3);
  for (e2.push(r2 | 128); --r2; ) e2.push(t2 >>> (r2 << 3) & 255);
  e2.push(t2);
}
Qr.prototype.toDER = function(t2) {
  var r2 = this.r.toArray(), i4 = this.s.toArray();
  for (r2[0] & 128 && (r2 = [0].concat(r2)), i4[0] & 128 && (i4 = [0].concat(i4)), r2 = Tf(r2), i4 = Tf(i4); !i4[0] && !(i4[1] & 128); ) i4 = i4.slice(1);
  var n3 = [2];
  zi(n3, r2.length), n3 = n3.concat(r2), n3.push(2), zi(n3, i4.length);
  var o2 = n3.concat(i4), h2 = [48];
  return zi(h2, o2.length), h2 = h2.concat(o2), Gt.encode(h2, t2);
};
var Ga = function() {
  throw new Error("unsupported");
}, Uf = Gt.assert;
function ee(e2) {
  if (!(this instanceof ee)) return new ee(e2);
  typeof e2 == "string" && (Uf(Object.prototype.hasOwnProperty.call(jr, e2), "Unknown curve " + e2), e2 = jr[e2]), e2 instanceof jr.PresetCurve && (e2 = { curve: e2 }), this.curve = e2.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e2.curve.g, this.g.precompute(e2.curve.n.bitLength() + 1), this.hash = e2.hash || e2.curve.hash;
}
var Ya = ee;
ee.prototype.keyPair = function(t2) {
  return new Hi(this, t2);
}, ee.prototype.keyFromPrivate = function(t2, r2) {
  return Hi.fromPrivate(this, t2, r2);
}, ee.prototype.keyFromPublic = function(t2, r2) {
  return Hi.fromPublic(this, t2, r2);
}, ee.prototype.genKeyPair = function(t2) {
  t2 || (t2 = {});
  for (var r2 = new Ff({ hash: this.hash, pers: t2.pers, persEnc: t2.persEnc || "utf8", entropy: t2.entropy || Ga(this.hash.hmacStrength), entropyEnc: t2.entropy && t2.entropyEnc || "utf8", nonce: this.n.toArray() }), i4 = this.n.byteLength(), n3 = this.n.sub(new K(2)); ; ) {
    var o2 = new K(r2.generate(i4));
    if (!(o2.cmp(n3) > 0)) return o2.iaddn(1), this.keyFromPrivate(o2);
  }
}, ee.prototype._truncateToN = function(t2, r2) {
  var i4 = t2.byteLength() * 8 - this.n.bitLength();
  return i4 > 0 && (t2 = t2.ushrn(i4)), !r2 && t2.cmp(this.n) >= 0 ? t2.sub(this.n) : t2;
}, ee.prototype.sign = function(t2, r2, i4, n3) {
  typeof i4 == "object" && (n3 = i4, i4 = null), n3 || (n3 = {}), r2 = this.keyFromPrivate(r2, i4), t2 = this._truncateToN(new K(t2, 16));
  for (var o2 = this.n.byteLength(), h2 = r2.getPrivate().toArray("be", o2), p2 = t2.toArray("be", o2), A2 = new Ff({ hash: this.hash, entropy: h2, nonce: p2, pers: n3.pers, persEnc: n3.persEnc || "utf8" }), v2 = this.n.sub(new K(1)), w2 = 0; ; w2++) {
    var y3 = n3.k ? n3.k(w2) : new K(A2.generate(this.n.byteLength()));
    if (y3 = this._truncateToN(y3, true), !(y3.cmpn(1) <= 0 || y3.cmp(v2) >= 0)) {
      var S2 = this.g.mul(y3);
      if (!S2.isInfinity()) {
        var I2 = S2.getX(), N2 = I2.umod(this.n);
        if (N2.cmpn(0) !== 0) {
          var C2 = y3.invm(this.n).mul(N2.mul(r2.getPrivate()).iadd(t2));
          if (C2 = C2.umod(this.n), C2.cmpn(0) !== 0) {
            var F = (S2.getY().isOdd() ? 1 : 0) | (I2.cmp(N2) !== 0 ? 2 : 0);
            return n3.canonical && C2.cmp(this.nh) > 0 && (C2 = this.n.sub(C2), F ^= 1), new Jr({ r: N2, s: C2, recoveryParam: F });
          }
        }
      }
    }
  }
}, ee.prototype.verify = function(t2, r2, i4, n3) {
  t2 = this._truncateToN(new K(t2, 16)), i4 = this.keyFromPublic(i4, n3), r2 = new Jr(r2, "hex");
  var o2 = r2.r, h2 = r2.s;
  if (o2.cmpn(1) < 0 || o2.cmp(this.n) >= 0 || h2.cmpn(1) < 0 || h2.cmp(this.n) >= 0) return false;
  var p2 = h2.invm(this.n), A2 = p2.mul(t2).umod(this.n), v2 = p2.mul(o2).umod(this.n), w2;
  return this.curve._maxwellTrick ? (w2 = this.g.jmulAdd(A2, i4.getPublic(), v2), w2.isInfinity() ? false : w2.eqXToP(o2)) : (w2 = this.g.mulAdd(A2, i4.getPublic(), v2), w2.isInfinity() ? false : w2.getX().umod(this.n).cmp(o2) === 0);
}, ee.prototype.recoverPubKey = function(e2, t2, r2, i4) {
  Uf((3 & r2) === r2, "The recovery param is more than two bits"), t2 = new Jr(t2, i4);
  var n3 = this.n, o2 = new K(e2), h2 = t2.r, p2 = t2.s, A2 = r2 & 1, v2 = r2 >> 1;
  if (h2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && v2) throw new Error("Unable to find sencond key candinate");
  v2 ? h2 = this.curve.pointFromX(h2.add(this.curve.n), A2) : h2 = this.curve.pointFromX(h2, A2);
  var w2 = t2.r.invm(n3), y3 = n3.sub(o2).mul(w2).umod(n3), S2 = p2.mul(w2).umod(n3);
  return this.g.mulAdd(y3, h2, S2);
}, ee.prototype.getKeyRecoveryParam = function(e2, t2, r2, i4) {
  if (t2 = new Jr(t2, i4), t2.recoveryParam !== null) return t2.recoveryParam;
  for (var n3 = 0; n3 < 4; n3++) {
    var o2;
    try {
      o2 = this.recoverPubKey(e2, t2, n3);
    } catch {
      continue;
    }
    if (o2.eq(r2)) return n3;
  }
  throw new Error("Unable to find valid recovery factor");
};
var Va = lr(function(e2, t2) {
  var r2 = t2;
  r2.version = "6.5.4", r2.utils = Gt, r2.rand = function() {
    throw new Error("unsupported");
  }, r2.curve = zr, r2.curves = jr, r2.ec = Ya, r2.eddsa = null;
});
Va.ec;
var qf;
(function(e2) {
  e2[e2.legacy = 0] = "legacy", e2[e2.eip2930 = 1] = "eip2930", e2[e2.eip1559 = 2] = "eip1559";
})(qf || (qf = {}));
const hu = "did:pkh:", Gr = (e2) => e2?.split(":"), Gi = (e2) => {
  const t2 = e2 && Gr(e2);
  if (t2) return e2.includes(hu) ? t2[3] : t2[1];
}, Yi = (e2) => {
  const t2 = e2 && Gr(e2);
  if (t2) return t2.pop();
};
var cjs = {};
var crypto$1 = {};
var hasRequiredCrypto;
function requireCrypto() {
  if (hasRequiredCrypto) return crypto$1;
  hasRequiredCrypto = 1;
  Object.defineProperty(crypto$1, "__esModule", { value: true });
  crypto$1.isBrowserCryptoAvailable = crypto$1.getSubtleCrypto = crypto$1.getBrowerCrypto = void 0;
  function getBrowerCrypto() {
    return (globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) || (globalThis === null || globalThis === void 0 ? void 0 : globalThis.msCrypto) || {};
  }
  crypto$1.getBrowerCrypto = getBrowerCrypto;
  function getSubtleCrypto() {
    const browserCrypto = getBrowerCrypto();
    return browserCrypto.subtle || browserCrypto.webkitSubtle;
  }
  crypto$1.getSubtleCrypto = getSubtleCrypto;
  function isBrowserCryptoAvailable() {
    return !!getBrowerCrypto() && !!getSubtleCrypto();
  }
  crypto$1.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  return crypto$1;
}
var env = {};
var hasRequiredEnv;
function requireEnv() {
  if (hasRequiredEnv) return env;
  hasRequiredEnv = 1;
  Object.defineProperty(env, "__esModule", { value: true });
  env.isBrowser = env.isNode = env.isReactNative = void 0;
  function isReactNative() {
    return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
  }
  env.isReactNative = isReactNative;
  function isNode() {
    return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
  }
  env.isNode = isNode;
  function isBrowser2() {
    return !isReactNative() && !isNode();
  }
  env.isBrowser = isBrowser2;
  return env;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0$1;
    tslib_1.__exportStar(requireCrypto(), exports);
    tslib_1.__exportStar(requireEnv(), exports);
  })(cjs);
  return cjs;
}
var cjsExports = requireCjs();
var browserPonyfill = { exports: {} };
var hasRequiredBrowserPonyfill;
function requireBrowserPonyfill() {
  if (hasRequiredBrowserPonyfill) return browserPonyfill.exports;
  hasRequiredBrowserPonyfill = 1;
  (function(module, exports) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof globalThis !== "undefined" && globalThis;
    var __globalThis__ = (function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    })();
    (function(globalThis2) {
      (function(exports2) {
        var g2 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof globalThis2 !== "undefined" && globalThis2 || {};
        var support = {
          searchParams: "URLSearchParams" in g2,
          iterable: "Symbol" in g2 && "iterator" in Symbol,
          blob: "FileReader" in g2 && "Blob" in g2 && (function() {
            try {
              new Blob();
              return true;
            } catch (e2) {
              return false;
            }
          })(),
          formData: "FormData" in g2,
          arrayBuffer: "ArrayBuffer" in g2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body2) {
          if (body2._noBody) return;
          if (body2.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body2.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match2 = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match2 ? match2[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i4 = 0; i4 < view.length; i4++) {
            chars[i4] = String.fromCharCode(view[i4]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body2) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body2;
            if (!body2) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body2 === "string") {
              this._bodyText = body2;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body2)) {
              this._bodyBlob = body2;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body2)) {
              this._bodyFormData = body2;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body2)) {
              this._bodyText = body2.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body2)) {
              this._bodyArrayBuffer = bufferClone(body2.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body2) || isArrayBufferView(body2))) {
              this._bodyArrayBuffer = bufferClone(body2);
            } else {
              this._bodyText = body2 = Object.prototype.toString.call(body2);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body2 === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body2)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode2);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request2(input, options) {
          if (!(this instanceof Request2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body2 = options.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body2 && input._bodyInit != null) {
              body2 = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || (function() {
            if ("AbortController" in g2) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          })();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body2) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body2);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode2(body2) {
          var form = new FormData();
          body2.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split2 = bytes.split("=");
              var name = split2.shift().replace(/\+/g, " ");
              var value = split2.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line2) {
            var parts = line2.split(":");
            var key2 = parts.shift().trim();
            if (key2) {
              var value = parts.join(":").trim();
              try {
                headers.append(key2, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request2.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init2) {
          return new Promise(function(resolve, reject) {
            var request = new Request2(input, init2);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body2 = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body2, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g2.location.href ? g2.location.href : url;
              } catch (e2) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers || g2.Headers && init2.headers instanceof g2.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init2.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init2.headers[name]));
              });
              request.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g2.fetch) {
          g2.fetch = fetch2;
          g2.Headers = Headers;
          g2.Request = Request2;
          g2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request2;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      })({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  })(browserPonyfill, browserPonyfill.exports);
  return browserPonyfill.exports;
}
var browserPonyfillExports = requireBrowserPonyfill();
const o = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfillExports);
var _e = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {}, Ui = { exports: {} };
/**
* @license
* Lodash <https://lodash.com/>
* Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
* Released under MIT license <https://lodash.com/license>
* Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
* Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
*/
(function(P2, s2) {
  (function() {
    var i4, p2 = "4.17.21", w2 = 200, x2 = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", O2 = "Expected a function", k2 = "Invalid `variable` option passed into `_.template`", tn = "__lodash_hash_undefined__", Jn = 500, xn2 = "__lodash_placeholder__", Ht2 = 1, Mt = 2, En = 4, yn = 1, me = 2, vt = 1, ln = 2, Gi2 = 4, Dt2 = 8, Sn = 16, Nt2 = 32, On = 64, Bt = 128, Yn2 = 256, gr = 512, Wa = 30, Ma2 = "...", Ba2 = 800, Ga2 = 16, zi2 = 1, za2 = 2, Ka2 = 3, pn = 1 / 0, nn = 9007199254740991, Ja2 = 17976931348623157e292, we2 = 0 / 0, $t2 = 4294967295, Ya2 = $t2 - 1, Za = $t2 >>> 1, Xa = [["ary", Bt], ["bind", vt], ["bindKey", ln], ["curry", Dt2], ["curryRight", Sn], ["flip", gr], ["partial", Nt2], ["partialRight", On], ["rearg", Yn2]], Rn = "[object Arguments]", Pe = "[object Array]", Qa2 = "[object AsyncFunction]", Zn2 = "[object Boolean]", Xn2 = "[object Date]", Va2 = "[object DOMException]", Ce2 = "[object Error]", Ae2 = "[object Function]", Ki2 = "[object GeneratorFunction]", Et = "[object Map]", Qn = "[object Number]", ka2 = "[object Null]", Gt2 = "[object Object]", Ji = "[object Promise]", ja2 = "[object Proxy]", Vn2 = "[object RegExp]", yt = "[object Set]", kn2 = "[object String]", Ie = "[object Symbol]", to = "[object Undefined]", jn2 = "[object WeakMap]", no = "[object WeakSet]", te2 = "[object ArrayBuffer]", bn2 = "[object DataView]", vr2 = "[object Float32Array]", _r = "[object Float64Array]", mr2 = "[object Int8Array]", wr = "[object Int16Array]", Pr = "[object Int32Array]", Cr = "[object Uint8Array]", Ar2 = "[object Uint8ClampedArray]", Ir = "[object Uint16Array]", xr2 = "[object Uint32Array]", eo = /\b__p \+= '';/g, ro = /\b(__p \+=) '' \+/g, io = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Yi2 = /&(?:amp|lt|gt|quot|#39);/g, Zi = /[&<>"']/g, so = RegExp(Yi2.source), uo = RegExp(Zi.source), ao = /<%-([\s\S]+?)%>/g, oo = /<%([\s\S]+?)%>/g, Xi = /<%=([\s\S]+?)%>/g, fo = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, co = /^\w*$/, ho = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Er2 = /[\\^$.*+?()[\]{}|]/g, lo = RegExp(Er2.source), yr = /^\s+/, po = /\s/, go = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, vo = /\{\n\/\* \[wrapped with (.+)\] \*/, _o = /,? & /, mo = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, wo = /[()=,{}\[\]\/\s]/, Po = /\\(\\)?/g, Co = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Qi = /\w*$/, Ao = /^[-+]0x[0-9a-f]+$/i, Io = /^0b[01]+$/i, xo = /^\[object .+?Constructor\]$/, Eo = /^0o[0-7]+$/i, yo = /^(?:0|[1-9]\d*)$/, So = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, xe = /($^)/, Oo = /['\n\r\u2028\u2029\\]/g, Ee = "\\ud800-\\udfff", Ro = "\\u0300-\\u036f", bo = "\\ufe20-\\ufe2f", To = "\\u20d0-\\u20ff", Vi = Ro + bo + To, ki2 = "\\u2700-\\u27bf", ji = "a-z\\xdf-\\xf6\\xf8-\\xff", Lo = "\\xac\\xb1\\xd7\\xf7", Ho = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Do = "\\u2000-\\u206f", No = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ts = "A-Z\\xc0-\\xd6\\xd8-\\xde", ns = "\\ufe0e\\ufe0f", es = Lo + Ho + Do + No, Sr = "[']", $o = "[" + Ee + "]", rs = "[" + es + "]", ye2 = "[" + Vi + "]", is = "\\d+", qo = "[" + ki2 + "]", ss = "[" + ji + "]", us = "[^" + Ee + es + is + ki2 + ji + ts + "]", Or = "\\ud83c[\\udffb-\\udfff]", Uo = "(?:" + ye2 + "|" + Or + ")", as = "[^" + Ee + "]", Rr2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", br2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", Tn2 = "[" + ts + "]", os = "\\u200d", fs = "(?:" + ss + "|" + us + ")", Fo = "(?:" + Tn2 + "|" + us + ")", cs = "(?:" + Sr + "(?:d|ll|m|re|s|t|ve))?", hs = "(?:" + Sr + "(?:D|LL|M|RE|S|T|VE))?", ls = Uo + "?", ps = "[" + ns + "]?", Wo = "(?:" + os + "(?:" + [as, Rr2, br2].join("|") + ")" + ps + ls + ")*", Mo = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Bo = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ds = ps + ls + Wo, Go = "(?:" + [qo, Rr2, br2].join("|") + ")" + ds, zo = "(?:" + [as + ye2 + "?", ye2, Rr2, br2, $o].join("|") + ")", Ko = RegExp(Sr, "g"), Jo = RegExp(ye2, "g"), Tr2 = RegExp(Or + "(?=" + Or + ")|" + zo + ds, "g"), Yo = RegExp([Tn2 + "?" + ss + "+" + cs + "(?=" + [rs, Tn2, "$"].join("|") + ")", Fo + "+" + hs + "(?=" + [rs, Tn2 + fs, "$"].join("|") + ")", Tn2 + "?" + fs + "+" + cs, Tn2 + "+" + hs, Bo, Mo, is, Go].join("|"), "g"), Zo = RegExp("[" + os + Ee + Vi + ns + "]"), Xo = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Qo = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], Vo = -1, G = {};
    G[vr2] = G[_r] = G[mr2] = G[wr] = G[Pr] = G[Cr] = G[Ar2] = G[Ir] = G[xr2] = true, G[Rn] = G[Pe] = G[te2] = G[Zn2] = G[bn2] = G[Xn2] = G[Ce2] = G[Ae2] = G[Et] = G[Qn] = G[Gt2] = G[Vn2] = G[yt] = G[kn2] = G[jn2] = false;
    var B3 = {};
    B3[Rn] = B3[Pe] = B3[te2] = B3[bn2] = B3[Zn2] = B3[Xn2] = B3[vr2] = B3[_r] = B3[mr2] = B3[wr] = B3[Pr] = B3[Et] = B3[Qn] = B3[Gt2] = B3[Vn2] = B3[yt] = B3[kn2] = B3[Ie] = B3[Cr] = B3[Ar2] = B3[Ir] = B3[xr2] = true, B3[Ce2] = B3[Ae2] = B3[jn2] = false;
    var ko = { : "A", : "A", : "A", : "A", : "A", : "A", : "a", : "a", : "a", : "a", : "a", : "a", : "C", : "c", : "D", : "d", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "N", : "n", : "O", : "O", : "O", : "O", : "O", : "O", : "o", : "o", : "o", : "o", : "o", : "o", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "Y", : "y", : "y", : "Ae", : "ae", : "Th", : "th", : "ss", : "A", : "A", : "A", : "a", : "a", : "a", : "C", : "C", : "C", : "C", : "c", : "c", : "c", : "c", : "D", : "D", : "d", : "d", : "E", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "e", : "G", : "G", : "G", : "G", : "g", : "g", : "g", : "g", : "H", : "H", : "h", : "h", : "I", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "i", : "J", : "j", : "K", : "k", : "k", : "L", : "L", : "L", : "L", : "L", : "l", : "l", : "l", : "l", : "l", : "N", : "N", : "N", : "N", : "n", : "n", : "n", : "n", : "O", : "O", : "O", : "o", : "o", : "o", : "R", : "R", : "R", : "r", : "r", : "r", : "S", : "S", : "S", : "S", : "s", : "s", : "s", : "s", : "T", : "T", : "T", : "t", : "t", : "t", : "U", : "U", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "u", : "u", : "W", : "w", : "Y", : "y", : "Y", : "Z", : "Z", : "Z", : "z", : "z", : "z", : "IJ", : "ij", : "Oe", : "oe", : "'n", : "s" }, jo = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, tf2 = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, nf2 = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, ef = parseFloat, rf = parseInt, gs = typeof _e == "object" && _e && _e.Object === Object && _e, sf2 = typeof self == "object" && self && self.Object === Object && self, j2 = gs || sf2 || Function("return this")(), Lr2 = s2 && !s2.nodeType && s2, dn = Lr2 && true && P2 && !P2.nodeType && P2, vs = dn && dn.exports === Lr2, Hr2 = vs && gs.process, _t = (function() {
      try {
        var h2 = dn && dn.require && dn.require("util").types;
        return h2 || Hr2 && Hr2.binding && Hr2.binding("util");
      } catch {
      }
    })(), _s2 = _t && _t.isArrayBuffer, ms = _t && _t.isDate, ws = _t && _t.isMap, Ps2 = _t && _t.isRegExp, Cs = _t && _t.isSet, As = _t && _t.isTypedArray;
    function ct(h2, g2, d3) {
      switch (d3.length) {
        case 0:
          return h2.call(g2);
        case 1:
          return h2.call(g2, d3[0]);
        case 2:
          return h2.call(g2, d3[0], d3[1]);
        case 3:
          return h2.call(g2, d3[0], d3[1], d3[2]);
      }
      return h2.apply(g2, d3);
    }
    function uf(h2, g2, d3, A2) {
      for (var R2 = -1, q = h2 == null ? 0 : h2.length; ++R2 < q; ) {
        var X = h2[R2];
        g2(A2, X, d3(X), h2);
      }
      return A2;
    }
    function mt(h2, g2) {
      for (var d3 = -1, A2 = h2 == null ? 0 : h2.length; ++d3 < A2 && g2(h2[d3], d3, h2) !== false; ) ;
      return h2;
    }
    function af2(h2, g2) {
      for (var d3 = h2 == null ? 0 : h2.length; d3-- && g2(h2[d3], d3, h2) !== false; ) ;
      return h2;
    }
    function Is2(h2, g2) {
      for (var d3 = -1, A2 = h2 == null ? 0 : h2.length; ++d3 < A2; ) if (!g2(h2[d3], d3, h2)) return false;
      return true;
    }
    function en2(h2, g2) {
      for (var d3 = -1, A2 = h2 == null ? 0 : h2.length, R2 = 0, q = []; ++d3 < A2; ) {
        var X = h2[d3];
        g2(X, d3, h2) && (q[R2++] = X);
      }
      return q;
    }
    function Se(h2, g2) {
      var d3 = h2 == null ? 0 : h2.length;
      return !!d3 && Ln2(h2, g2, 0) > -1;
    }
    function Dr2(h2, g2, d3) {
      for (var A2 = -1, R2 = h2 == null ? 0 : h2.length; ++A2 < R2; ) if (d3(g2, h2[A2])) return true;
      return false;
    }
    function z3(h2, g2) {
      for (var d3 = -1, A2 = h2 == null ? 0 : h2.length, R2 = Array(A2); ++d3 < A2; ) R2[d3] = g2(h2[d3], d3, h2);
      return R2;
    }
    function rn(h2, g2) {
      for (var d3 = -1, A2 = g2.length, R2 = h2.length; ++d3 < A2; ) h2[R2 + d3] = g2[d3];
      return h2;
    }
    function Nr(h2, g2, d3, A2) {
      var R2 = -1, q = h2 == null ? 0 : h2.length;
      for (A2 && q && (d3 = h2[++R2]); ++R2 < q; ) d3 = g2(d3, h2[R2], R2, h2);
      return d3;
    }
    function of2(h2, g2, d3, A2) {
      var R2 = h2 == null ? 0 : h2.length;
      for (A2 && R2 && (d3 = h2[--R2]); R2--; ) d3 = g2(d3, h2[R2], R2, h2);
      return d3;
    }
    function $r(h2, g2) {
      for (var d3 = -1, A2 = h2 == null ? 0 : h2.length; ++d3 < A2; ) if (g2(h2[d3], d3, h2)) return true;
      return false;
    }
    var ff = qr2("length");
    function cf(h2) {
      return h2.split("");
    }
    function hf(h2) {
      return h2.match(mo) || [];
    }
    function xs(h2, g2, d3) {
      var A2;
      return d3(h2, function(R2, q, X) {
        if (g2(R2, q, X)) return A2 = q, false;
      }), A2;
    }
    function Oe(h2, g2, d3, A2) {
      for (var R2 = h2.length, q = d3 + (A2 ? 1 : -1); A2 ? q-- : ++q < R2; ) if (g2(h2[q], q, h2)) return q;
      return -1;
    }
    function Ln2(h2, g2, d3) {
      return g2 === g2 ? If2(h2, g2, d3) : Oe(h2, Es2, d3);
    }
    function lf2(h2, g2, d3, A2) {
      for (var R2 = d3 - 1, q = h2.length; ++R2 < q; ) if (A2(h2[R2], g2)) return R2;
      return -1;
    }
    function Es2(h2) {
      return h2 !== h2;
    }
    function ys(h2, g2) {
      var d3 = h2 == null ? 0 : h2.length;
      return d3 ? Fr2(h2, g2) / d3 : we2;
    }
    function qr2(h2) {
      return function(g2) {
        return g2 == null ? i4 : g2[h2];
      };
    }
    function Ur2(h2) {
      return function(g2) {
        return h2 == null ? i4 : h2[g2];
      };
    }
    function Ss(h2, g2, d3, A2, R2) {
      return R2(h2, function(q, X, M2) {
        d3 = A2 ? (A2 = false, q) : g2(d3, q, X, M2);
      }), d3;
    }
    function pf2(h2, g2) {
      var d3 = h2.length;
      for (h2.sort(g2); d3--; ) h2[d3] = h2[d3].value;
      return h2;
    }
    function Fr2(h2, g2) {
      for (var d3, A2 = -1, R2 = h2.length; ++A2 < R2; ) {
        var q = g2(h2[A2]);
        q !== i4 && (d3 = d3 === i4 ? q : d3 + q);
      }
      return d3;
    }
    function Wr(h2, g2) {
      for (var d3 = -1, A2 = Array(h2); ++d3 < h2; ) A2[d3] = g2(d3);
      return A2;
    }
    function df2(h2, g2) {
      return z3(g2, function(d3) {
        return [d3, h2[d3]];
      });
    }
    function Os(h2) {
      return h2 && h2.slice(0, Ls2(h2) + 1).replace(yr, "");
    }
    function ht(h2) {
      return function(g2) {
        return h2(g2);
      };
    }
    function Mr2(h2, g2) {
      return z3(g2, function(d3) {
        return h2[d3];
      });
    }
    function ne2(h2, g2) {
      return h2.has(g2);
    }
    function Rs(h2, g2) {
      for (var d3 = -1, A2 = h2.length; ++d3 < A2 && Ln2(g2, h2[d3], 0) > -1; ) ;
      return d3;
    }
    function bs(h2, g2) {
      for (var d3 = h2.length; d3-- && Ln2(g2, h2[d3], 0) > -1; ) ;
      return d3;
    }
    function gf2(h2, g2) {
      for (var d3 = h2.length, A2 = 0; d3--; ) h2[d3] === g2 && ++A2;
      return A2;
    }
    var vf2 = Ur2(ko), _f3 = Ur2(jo);
    function mf2(h2) {
      return "\\" + nf2[h2];
    }
    function wf2(h2, g2) {
      return h2 == null ? i4 : h2[g2];
    }
    function Hn2(h2) {
      return Zo.test(h2);
    }
    function Pf2(h2) {
      return Xo.test(h2);
    }
    function Cf2(h2) {
      for (var g2, d3 = []; !(g2 = h2.next()).done; ) d3.push(g2.value);
      return d3;
    }
    function Br(h2) {
      var g2 = -1, d3 = Array(h2.size);
      return h2.forEach(function(A2, R2) {
        d3[++g2] = [R2, A2];
      }), d3;
    }
    function Ts2(h2, g2) {
      return function(d3) {
        return h2(g2(d3));
      };
    }
    function sn(h2, g2) {
      for (var d3 = -1, A2 = h2.length, R2 = 0, q = []; ++d3 < A2; ) {
        var X = h2[d3];
        (X === g2 || X === xn2) && (h2[d3] = xn2, q[R2++] = d3);
      }
      return q;
    }
    function Re2(h2) {
      var g2 = -1, d3 = Array(h2.size);
      return h2.forEach(function(A2) {
        d3[++g2] = A2;
      }), d3;
    }
    function Af2(h2) {
      var g2 = -1, d3 = Array(h2.size);
      return h2.forEach(function(A2) {
        d3[++g2] = [A2, A2];
      }), d3;
    }
    function If2(h2, g2, d3) {
      for (var A2 = d3 - 1, R2 = h2.length; ++A2 < R2; ) if (h2[A2] === g2) return A2;
      return -1;
    }
    function xf2(h2, g2, d3) {
      for (var A2 = d3 + 1; A2--; ) if (h2[A2] === g2) return A2;
      return A2;
    }
    function Dn(h2) {
      return Hn2(h2) ? yf2(h2) : ff(h2);
    }
    function St(h2) {
      return Hn2(h2) ? Sf2(h2) : cf(h2);
    }
    function Ls2(h2) {
      for (var g2 = h2.length; g2-- && po.test(h2.charAt(g2)); ) ;
      return g2;
    }
    var Ef2 = Ur2(tf2);
    function yf2(h2) {
      for (var g2 = Tr2.lastIndex = 0; Tr2.test(h2); ) ++g2;
      return g2;
    }
    function Sf2(h2) {
      return h2.match(Tr2) || [];
    }
    function Of2(h2) {
      return h2.match(Yo) || [];
    }
    var Rf2 = function h2(g2) {
      g2 = g2 == null ? j2 : Nn.defaults(j2.Object(), g2, Nn.pick(j2, Qo));
      var d3 = g2.Array, A2 = g2.Date, R2 = g2.Error, q = g2.Function, X = g2.Math, M2 = g2.Object, Gr2 = g2.RegExp, bf2 = g2.String, wt = g2.TypeError, be2 = d3.prototype, Tf2 = q.prototype, $n2 = M2.prototype, Te = g2["__core-js_shared__"], Le = Tf2.toString, W = $n2.hasOwnProperty, Lf = 0, Hs = (function() {
        var t2 = /[^.]+$/.exec(Te && Te.keys && Te.keys.IE_PROTO || "");
        return t2 ? "Symbol(src)_1." + t2 : "";
      })(), He = $n2.toString, Hf = Le.call(M2), Df2 = j2._, Nf2 = Gr2("^" + Le.call(W).replace(Er2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), De = vs ? g2.Buffer : i4, un = g2.Symbol, Ne = g2.Uint8Array, Ds2 = De ? De.allocUnsafe : i4, $e = Ts2(M2.getPrototypeOf, M2), Ns2 = M2.create, $s2 = $n2.propertyIsEnumerable, qe = be2.splice, qs = un ? un.isConcatSpreadable : i4, ee2 = un ? un.iterator : i4, gn = un ? un.toStringTag : i4, Ue = (function() {
        try {
          var t2 = Pn(M2, "defineProperty");
          return t2({}, "", {}), t2;
        } catch {
        }
      })(), $f = g2.clearTimeout !== j2.clearTimeout && g2.clearTimeout, qf2 = A2 && A2.now !== j2.Date.now && A2.now, Uf2 = g2.setTimeout !== j2.setTimeout && g2.setTimeout, Fe = X.ceil, We = X.floor, zr2 = M2.getOwnPropertySymbols, Ff2 = De ? De.isBuffer : i4, Us = g2.isFinite, Wf = be2.join, Mf2 = Ts2(M2.keys, M2), Q2 = X.max, nt = X.min, Bf2 = A2.now, Gf = g2.parseInt, Fs2 = X.random, zf = be2.reverse, Kr2 = Pn(g2, "DataView"), re2 = Pn(g2, "Map"), Jr2 = Pn(g2, "Promise"), qn2 = Pn(g2, "Set"), ie2 = Pn(g2, "WeakMap"), se2 = Pn(M2, "create"), Me = ie2 && new ie2(), Un2 = {}, Kf = Cn(Kr2), Jf = Cn(re2), Yf = Cn(Jr2), Zf = Cn(qn2), Xf = Cn(ie2), Be2 = un ? un.prototype : i4, ue2 = Be2 ? Be2.valueOf : i4, Ws2 = Be2 ? Be2.toString : i4;
      function a2(t2) {
        if (J(t2) && !b2(t2) && !(t2 instanceof N2)) {
          if (t2 instanceof Pt) return t2;
          if (W.call(t2, "__wrapped__")) return Mu(t2);
        }
        return new Pt(t2);
      }
      var Fn = /* @__PURE__ */ (function() {
        function t2() {
        }
        return function(n3) {
          if (!K2(n3)) return {};
          if (Ns2) return Ns2(n3);
          t2.prototype = n3;
          var e2 = new t2();
          return t2.prototype = i4, e2;
        };
      })();
      function Ge() {
      }
      function Pt(t2, n3) {
        this.__wrapped__ = t2, this.__actions__ = [], this.__chain__ = !!n3, this.__index__ = 0, this.__values__ = i4;
      }
      a2.templateSettings = { escape: ao, evaluate: oo, interpolate: Xi, variable: "", imports: { _: a2 } }, a2.prototype = Ge.prototype, a2.prototype.constructor = a2, Pt.prototype = Fn(Ge.prototype), Pt.prototype.constructor = Pt;
      function N2(t2) {
        this.__wrapped__ = t2, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = $t2, this.__views__ = [];
      }
      function Qf() {
        var t2 = new N2(this.__wrapped__);
        return t2.__actions__ = ut(this.__actions__), t2.__dir__ = this.__dir__, t2.__filtered__ = this.__filtered__, t2.__iteratees__ = ut(this.__iteratees__), t2.__takeCount__ = this.__takeCount__, t2.__views__ = ut(this.__views__), t2;
      }
      function Vf() {
        if (this.__filtered__) {
          var t2 = new N2(this);
          t2.__dir__ = -1, t2.__filtered__ = true;
        } else t2 = this.clone(), t2.__dir__ *= -1;
        return t2;
      }
      function kf() {
        var t2 = this.__wrapped__.value(), n3 = this.__dir__, e2 = b2(t2), r2 = n3 < 0, u2 = e2 ? t2.length : 0, o2 = ch(0, u2, this.__views__), f2 = o2.start, c2 = o2.end, l2 = c2 - f2, v2 = r2 ? c2 : f2 - 1, _2 = this.__iteratees__, m3 = _2.length, C2 = 0, I2 = nt(l2, this.__takeCount__);
        if (!e2 || !r2 && u2 == l2 && I2 == l2) return cu(t2, this.__actions__);
        var y3 = [];
        t: for (; l2-- && C2 < I2; ) {
          v2 += n3;
          for (var L3 = -1, S2 = t2[v2]; ++L3 < m3; ) {
            var D = _2[L3], $2 = D.iteratee, dt = D.type, st = $2(S2);
            if (dt == za2) S2 = st;
            else if (!st) {
              if (dt == zi2) continue t;
              break t;
            }
          }
          y3[C2++] = S2;
        }
        return y3;
      }
      N2.prototype = Fn(Ge.prototype), N2.prototype.constructor = N2;
      function vn(t2) {
        var n3 = -1, e2 = t2 == null ? 0 : t2.length;
        for (this.clear(); ++n3 < e2; ) {
          var r2 = t2[n3];
          this.set(r2[0], r2[1]);
        }
      }
      function jf() {
        this.__data__ = se2 ? se2(null) : {}, this.size = 0;
      }
      function tc(t2) {
        var n3 = this.has(t2) && delete this.__data__[t2];
        return this.size -= n3 ? 1 : 0, n3;
      }
      function nc(t2) {
        var n3 = this.__data__;
        if (se2) {
          var e2 = n3[t2];
          return e2 === tn ? i4 : e2;
        }
        return W.call(n3, t2) ? n3[t2] : i4;
      }
      function ec2(t2) {
        var n3 = this.__data__;
        return se2 ? n3[t2] !== i4 : W.call(n3, t2);
      }
      function rc(t2, n3) {
        var e2 = this.__data__;
        return this.size += this.has(t2) ? 0 : 1, e2[t2] = se2 && n3 === i4 ? tn : n3, this;
      }
      vn.prototype.clear = jf, vn.prototype.delete = tc, vn.prototype.get = nc, vn.prototype.has = ec2, vn.prototype.set = rc;
      function zt2(t2) {
        var n3 = -1, e2 = t2 == null ? 0 : t2.length;
        for (this.clear(); ++n3 < e2; ) {
          var r2 = t2[n3];
          this.set(r2[0], r2[1]);
        }
      }
      function ic() {
        this.__data__ = [], this.size = 0;
      }
      function sc(t2) {
        var n3 = this.__data__, e2 = ze(n3, t2);
        if (e2 < 0) return false;
        var r2 = n3.length - 1;
        return e2 == r2 ? n3.pop() : qe.call(n3, e2, 1), --this.size, true;
      }
      function uc(t2) {
        var n3 = this.__data__, e2 = ze(n3, t2);
        return e2 < 0 ? i4 : n3[e2][1];
      }
      function ac(t2) {
        return ze(this.__data__, t2) > -1;
      }
      function oc(t2, n3) {
        var e2 = this.__data__, r2 = ze(e2, t2);
        return r2 < 0 ? (++this.size, e2.push([t2, n3])) : e2[r2][1] = n3, this;
      }
      zt2.prototype.clear = ic, zt2.prototype.delete = sc, zt2.prototype.get = uc, zt2.prototype.has = ac, zt2.prototype.set = oc;
      function Kt2(t2) {
        var n3 = -1, e2 = t2 == null ? 0 : t2.length;
        for (this.clear(); ++n3 < e2; ) {
          var r2 = t2[n3];
          this.set(r2[0], r2[1]);
        }
      }
      function fc() {
        this.size = 0, this.__data__ = { hash: new vn(), map: new (re2 || zt2)(), string: new vn() };
      }
      function cc(t2) {
        var n3 = er(this, t2).delete(t2);
        return this.size -= n3 ? 1 : 0, n3;
      }
      function hc(t2) {
        return er(this, t2).get(t2);
      }
      function lc(t2) {
        return er(this, t2).has(t2);
      }
      function pc(t2, n3) {
        var e2 = er(this, t2), r2 = e2.size;
        return e2.set(t2, n3), this.size += e2.size == r2 ? 0 : 1, this;
      }
      Kt2.prototype.clear = fc, Kt2.prototype.delete = cc, Kt2.prototype.get = hc, Kt2.prototype.has = lc, Kt2.prototype.set = pc;
      function _n(t2) {
        var n3 = -1, e2 = t2 == null ? 0 : t2.length;
        for (this.__data__ = new Kt2(); ++n3 < e2; ) this.add(t2[n3]);
      }
      function dc(t2) {
        return this.__data__.set(t2, tn), this;
      }
      function gc(t2) {
        return this.__data__.has(t2);
      }
      _n.prototype.add = _n.prototype.push = dc, _n.prototype.has = gc;
      function Ot2(t2) {
        var n3 = this.__data__ = new zt2(t2);
        this.size = n3.size;
      }
      function vc() {
        this.__data__ = new zt2(), this.size = 0;
      }
      function _c2(t2) {
        var n3 = this.__data__, e2 = n3.delete(t2);
        return this.size = n3.size, e2;
      }
      function mc(t2) {
        return this.__data__.get(t2);
      }
      function wc(t2) {
        return this.__data__.has(t2);
      }
      function Pc(t2, n3) {
        var e2 = this.__data__;
        if (e2 instanceof zt2) {
          var r2 = e2.__data__;
          if (!re2 || r2.length < w2 - 1) return r2.push([t2, n3]), this.size = ++e2.size, this;
          e2 = this.__data__ = new Kt2(r2);
        }
        return e2.set(t2, n3), this.size = e2.size, this;
      }
      Ot2.prototype.clear = vc, Ot2.prototype.delete = _c2, Ot2.prototype.get = mc, Ot2.prototype.has = wc, Ot2.prototype.set = Pc;
      function Ms(t2, n3) {
        var e2 = b2(t2), r2 = !e2 && An2(t2), u2 = !e2 && !r2 && hn(t2), o2 = !e2 && !r2 && !u2 && Gn2(t2), f2 = e2 || r2 || u2 || o2, c2 = f2 ? Wr(t2.length, bf2) : [], l2 = c2.length;
        for (var v2 in t2) (n3 || W.call(t2, v2)) && !(f2 && (v2 == "length" || u2 && (v2 == "offset" || v2 == "parent") || o2 && (v2 == "buffer" || v2 == "byteLength" || v2 == "byteOffset") || Xt(v2, l2))) && c2.push(v2);
        return c2;
      }
      function Bs(t2) {
        var n3 = t2.length;
        return n3 ? t2[ri(0, n3 - 1)] : i4;
      }
      function Cc(t2, n3) {
        return rr(ut(t2), mn(n3, 0, t2.length));
      }
      function Ac(t2) {
        return rr(ut(t2));
      }
      function Yr(t2, n3, e2) {
        (e2 !== i4 && !Rt(t2[n3], e2) || e2 === i4 && !(n3 in t2)) && Jt2(t2, n3, e2);
      }
      function ae2(t2, n3, e2) {
        var r2 = t2[n3];
        (!(W.call(t2, n3) && Rt(r2, e2)) || e2 === i4 && !(n3 in t2)) && Jt2(t2, n3, e2);
      }
      function ze(t2, n3) {
        for (var e2 = t2.length; e2--; ) if (Rt(t2[e2][0], n3)) return e2;
        return -1;
      }
      function Ic(t2, n3, e2, r2) {
        return an(t2, function(u2, o2, f2) {
          n3(r2, u2, e2(u2), f2);
        }), r2;
      }
      function Gs2(t2, n3) {
        return t2 && Ut2(n3, V2(n3), t2);
      }
      function xc(t2, n3) {
        return t2 && Ut2(n3, ot(n3), t2);
      }
      function Jt2(t2, n3, e2) {
        n3 == "__proto__" && Ue ? Ue(t2, n3, { configurable: true, enumerable: true, value: e2, writable: true }) : t2[n3] = e2;
      }
      function Zr(t2, n3) {
        for (var e2 = -1, r2 = n3.length, u2 = d3(r2), o2 = t2 == null; ++e2 < r2; ) u2[e2] = o2 ? i4 : Oi2(t2, n3[e2]);
        return u2;
      }
      function mn(t2, n3, e2) {
        return t2 === t2 && (e2 !== i4 && (t2 = t2 <= e2 ? t2 : e2), n3 !== i4 && (t2 = t2 >= n3 ? t2 : n3)), t2;
      }
      function Ct(t2, n3, e2, r2, u2, o2) {
        var f2, c2 = n3 & Ht2, l2 = n3 & Mt, v2 = n3 & En;
        if (e2 && (f2 = u2 ? e2(t2, r2, u2, o2) : e2(t2)), f2 !== i4) return f2;
        if (!K2(t2)) return t2;
        var _2 = b2(t2);
        if (_2) {
          if (f2 = lh(t2), !c2) return ut(t2, f2);
        } else {
          var m3 = et(t2), C2 = m3 == Ae2 || m3 == Ki2;
          if (hn(t2)) return pu(t2, c2);
          if (m3 == Gt2 || m3 == Rn || C2 && !u2) {
            if (f2 = l2 || C2 ? {} : Lu(t2), !c2) return l2 ? nh(t2, xc(f2, t2)) : th(t2, Gs2(f2, t2));
          } else {
            if (!B3[m3]) return u2 ? t2 : {};
            f2 = ph(t2, m3, c2);
          }
        }
        o2 || (o2 = new Ot2());
        var I2 = o2.get(t2);
        if (I2) return I2;
        o2.set(t2, f2), aa2(t2) ? t2.forEach(function(S2) {
          f2.add(Ct(S2, n3, e2, S2, t2, o2));
        }) : sa2(t2) && t2.forEach(function(S2, D) {
          f2.set(D, Ct(S2, n3, e2, D, t2, o2));
        });
        var y3 = v2 ? l2 ? di : pi : l2 ? ot : V2, L3 = _2 ? i4 : y3(t2);
        return mt(L3 || t2, function(S2, D) {
          L3 && (D = S2, S2 = t2[D]), ae2(f2, D, Ct(S2, n3, e2, D, t2, o2));
        }), f2;
      }
      function Ec(t2) {
        var n3 = V2(t2);
        return function(e2) {
          return zs2(e2, t2, n3);
        };
      }
      function zs2(t2, n3, e2) {
        var r2 = e2.length;
        if (t2 == null) return !r2;
        for (t2 = M2(t2); r2--; ) {
          var u2 = e2[r2], o2 = n3[u2], f2 = t2[u2];
          if (f2 === i4 && !(u2 in t2) || !o2(f2)) return false;
        }
        return true;
      }
      function Ks(t2, n3, e2) {
        if (typeof t2 != "function") throw new wt(O2);
        return de2(function() {
          t2.apply(i4, e2);
        }, n3);
      }
      function oe2(t2, n3, e2, r2) {
        var u2 = -1, o2 = Se, f2 = true, c2 = t2.length, l2 = [], v2 = n3.length;
        if (!c2) return l2;
        e2 && (n3 = z3(n3, ht(e2))), r2 ? (o2 = Dr2, f2 = false) : n3.length >= w2 && (o2 = ne2, f2 = false, n3 = new _n(n3));
        t: for (; ++u2 < c2; ) {
          var _2 = t2[u2], m3 = e2 == null ? _2 : e2(_2);
          if (_2 = r2 || _2 !== 0 ? _2 : 0, f2 && m3 === m3) {
            for (var C2 = v2; C2--; ) if (n3[C2] === m3) continue t;
            l2.push(_2);
          } else o2(n3, m3, r2) || l2.push(_2);
        }
        return l2;
      }
      var an = mu(qt), Js2 = mu(Qr2, true);
      function yc(t2, n3) {
        var e2 = true;
        return an(t2, function(r2, u2, o2) {
          return e2 = !!n3(r2, u2, o2), e2;
        }), e2;
      }
      function Ke(t2, n3, e2) {
        for (var r2 = -1, u2 = t2.length; ++r2 < u2; ) {
          var o2 = t2[r2], f2 = n3(o2);
          if (f2 != null && (c2 === i4 ? f2 === f2 && !pt(f2) : e2(f2, c2))) var c2 = f2, l2 = o2;
        }
        return l2;
      }
      function Sc(t2, n3, e2, r2) {
        var u2 = t2.length;
        for (e2 = T2(e2), e2 < 0 && (e2 = -e2 > u2 ? 0 : u2 + e2), r2 = r2 === i4 || r2 > u2 ? u2 : T2(r2), r2 < 0 && (r2 += u2), r2 = e2 > r2 ? 0 : fa2(r2); e2 < r2; ) t2[e2++] = n3;
        return t2;
      }
      function Ys2(t2, n3) {
        var e2 = [];
        return an(t2, function(r2, u2, o2) {
          n3(r2, u2, o2) && e2.push(r2);
        }), e2;
      }
      function tt(t2, n3, e2, r2, u2) {
        var o2 = -1, f2 = t2.length;
        for (e2 || (e2 = gh), u2 || (u2 = []); ++o2 < f2; ) {
          var c2 = t2[o2];
          n3 > 0 && e2(c2) ? n3 > 1 ? tt(c2, n3 - 1, e2, r2, u2) : rn(u2, c2) : r2 || (u2[u2.length] = c2);
        }
        return u2;
      }
      var Xr = wu(), Zs2 = wu(true);
      function qt(t2, n3) {
        return t2 && Xr(t2, n3, V2);
      }
      function Qr2(t2, n3) {
        return t2 && Zs2(t2, n3, V2);
      }
      function Je(t2, n3) {
        return en2(n3, function(e2) {
          return Qt(t2[e2]);
        });
      }
      function wn2(t2, n3) {
        n3 = fn2(n3, t2);
        for (var e2 = 0, r2 = n3.length; t2 != null && e2 < r2; ) t2 = t2[Ft2(n3[e2++])];
        return e2 && e2 == r2 ? t2 : i4;
      }
      function Xs2(t2, n3, e2) {
        var r2 = n3(t2);
        return b2(t2) ? r2 : rn(r2, e2(t2));
      }
      function rt(t2) {
        return t2 == null ? t2 === i4 ? to : ka2 : gn && gn in M2(t2) ? fh(t2) : Ah(t2);
      }
      function Vr(t2, n3) {
        return t2 > n3;
      }
      function Oc(t2, n3) {
        return t2 != null && W.call(t2, n3);
      }
      function Rc(t2, n3) {
        return t2 != null && n3 in M2(t2);
      }
      function bc(t2, n3, e2) {
        return t2 >= nt(n3, e2) && t2 < Q2(n3, e2);
      }
      function kr2(t2, n3, e2) {
        for (var r2 = e2 ? Dr2 : Se, u2 = t2[0].length, o2 = t2.length, f2 = o2, c2 = d3(o2), l2 = 1 / 0, v2 = []; f2--; ) {
          var _2 = t2[f2];
          f2 && n3 && (_2 = z3(_2, ht(n3))), l2 = nt(_2.length, l2), c2[f2] = !e2 && (n3 || u2 >= 120 && _2.length >= 120) ? new _n(f2 && _2) : i4;
        }
        _2 = t2[0];
        var m3 = -1, C2 = c2[0];
        t: for (; ++m3 < u2 && v2.length < l2; ) {
          var I2 = _2[m3], y3 = n3 ? n3(I2) : I2;
          if (I2 = e2 || I2 !== 0 ? I2 : 0, !(C2 ? ne2(C2, y3) : r2(v2, y3, e2))) {
            for (f2 = o2; --f2; ) {
              var L3 = c2[f2];
              if (!(L3 ? ne2(L3, y3) : r2(t2[f2], y3, e2))) continue t;
            }
            C2 && C2.push(y3), v2.push(I2);
          }
        }
        return v2;
      }
      function Tc(t2, n3, e2, r2) {
        return qt(t2, function(u2, o2, f2) {
          n3(r2, e2(u2), o2, f2);
        }), r2;
      }
      function fe2(t2, n3, e2) {
        n3 = fn2(n3, t2), t2 = $u(t2, n3);
        var r2 = t2 == null ? t2 : t2[Ft2(It(n3))];
        return r2 == null ? i4 : ct(r2, t2, e2);
      }
      function Qs2(t2) {
        return J(t2) && rt(t2) == Rn;
      }
      function Lc(t2) {
        return J(t2) && rt(t2) == te2;
      }
      function Hc(t2) {
        return J(t2) && rt(t2) == Xn2;
      }
      function ce2(t2, n3, e2, r2, u2) {
        return t2 === n3 ? true : t2 == null || n3 == null || !J(t2) && !J(n3) ? t2 !== t2 && n3 !== n3 : Dc(t2, n3, e2, r2, ce2, u2);
      }
      function Dc(t2, n3, e2, r2, u2, o2) {
        var f2 = b2(t2), c2 = b2(n3), l2 = f2 ? Pe : et(t2), v2 = c2 ? Pe : et(n3);
        l2 = l2 == Rn ? Gt2 : l2, v2 = v2 == Rn ? Gt2 : v2;
        var _2 = l2 == Gt2, m3 = v2 == Gt2, C2 = l2 == v2;
        if (C2 && hn(t2)) {
          if (!hn(n3)) return false;
          f2 = true, _2 = false;
        }
        if (C2 && !_2) return o2 || (o2 = new Ot2()), f2 || Gn2(t2) ? Ru(t2, n3, e2, r2, u2, o2) : ah(t2, n3, l2, e2, r2, u2, o2);
        if (!(e2 & yn)) {
          var I2 = _2 && W.call(t2, "__wrapped__"), y3 = m3 && W.call(n3, "__wrapped__");
          if (I2 || y3) {
            var L3 = I2 ? t2.value() : t2, S2 = y3 ? n3.value() : n3;
            return o2 || (o2 = new Ot2()), u2(L3, S2, e2, r2, o2);
          }
        }
        return C2 ? (o2 || (o2 = new Ot2()), oh(t2, n3, e2, r2, u2, o2)) : false;
      }
      function Nc(t2) {
        return J(t2) && et(t2) == Et;
      }
      function jr2(t2, n3, e2, r2) {
        var u2 = e2.length, o2 = u2, f2 = !r2;
        if (t2 == null) return !o2;
        for (t2 = M2(t2); u2--; ) {
          var c2 = e2[u2];
          if (f2 && c2[2] ? c2[1] !== t2[c2[0]] : !(c2[0] in t2)) return false;
        }
        for (; ++u2 < o2; ) {
          c2 = e2[u2];
          var l2 = c2[0], v2 = t2[l2], _2 = c2[1];
          if (f2 && c2[2]) {
            if (v2 === i4 && !(l2 in t2)) return false;
          } else {
            var m3 = new Ot2();
            if (r2) var C2 = r2(v2, _2, l2, t2, n3, m3);
            if (!(C2 === i4 ? ce2(_2, v2, yn | me, r2, m3) : C2)) return false;
          }
        }
        return true;
      }
      function Vs2(t2) {
        if (!K2(t2) || _h2(t2)) return false;
        var n3 = Qt(t2) ? Nf2 : xo;
        return n3.test(Cn(t2));
      }
      function $c(t2) {
        return J(t2) && rt(t2) == Vn2;
      }
      function qc(t2) {
        return J(t2) && et(t2) == yt;
      }
      function Uc(t2) {
        return J(t2) && fr2(t2.length) && !!G[rt(t2)];
      }
      function ks2(t2) {
        return typeof t2 == "function" ? t2 : t2 == null ? ft : typeof t2 == "object" ? b2(t2) ? nu(t2[0], t2[1]) : tu(t2) : Pa2(t2);
      }
      function ti(t2) {
        if (!pe2(t2)) return Mf2(t2);
        var n3 = [];
        for (var e2 in M2(t2)) W.call(t2, e2) && e2 != "constructor" && n3.push(e2);
        return n3;
      }
      function Fc(t2) {
        if (!K2(t2)) return Ch(t2);
        var n3 = pe2(t2), e2 = [];
        for (var r2 in t2) r2 == "constructor" && (n3 || !W.call(t2, r2)) || e2.push(r2);
        return e2;
      }
      function ni(t2, n3) {
        return t2 < n3;
      }
      function js2(t2, n3) {
        var e2 = -1, r2 = at(t2) ? d3(t2.length) : [];
        return an(t2, function(u2, o2, f2) {
          r2[++e2] = n3(u2, o2, f2);
        }), r2;
      }
      function tu(t2) {
        var n3 = vi(t2);
        return n3.length == 1 && n3[0][2] ? Du(n3[0][0], n3[0][1]) : function(e2) {
          return e2 === t2 || jr2(e2, t2, n3);
        };
      }
      function nu(t2, n3) {
        return mi2(t2) && Hu(n3) ? Du(Ft2(t2), n3) : function(e2) {
          var r2 = Oi2(e2, t2);
          return r2 === i4 && r2 === n3 ? Ri(e2, t2) : ce2(n3, r2, yn | me);
        };
      }
      function Ye(t2, n3, e2, r2, u2) {
        t2 !== n3 && Xr(n3, function(o2, f2) {
          if (u2 || (u2 = new Ot2()), K2(o2)) Wc(t2, n3, f2, e2, Ye, r2, u2);
          else {
            var c2 = r2 ? r2(Pi2(t2, f2), o2, f2 + "", t2, n3, u2) : i4;
            c2 === i4 && (c2 = o2), Yr(t2, f2, c2);
          }
        }, ot);
      }
      function Wc(t2, n3, e2, r2, u2, o2, f2) {
        var c2 = Pi2(t2, e2), l2 = Pi2(n3, e2), v2 = f2.get(l2);
        if (v2) {
          Yr(t2, e2, v2);
          return;
        }
        var _2 = o2 ? o2(c2, l2, e2 + "", t2, n3, f2) : i4, m3 = _2 === i4;
        if (m3) {
          var C2 = b2(l2), I2 = !C2 && hn(l2), y3 = !C2 && !I2 && Gn2(l2);
          _2 = l2, C2 || I2 || y3 ? b2(c2) ? _2 = c2 : Y(c2) ? _2 = ut(c2) : I2 ? (m3 = false, _2 = pu(l2, true)) : y3 ? (m3 = false, _2 = du(l2, true)) : _2 = [] : ge(l2) || An2(l2) ? (_2 = c2, An2(c2) ? _2 = ca2(c2) : (!K2(c2) || Qt(c2)) && (_2 = Lu(l2))) : m3 = false;
        }
        m3 && (f2.set(l2, _2), u2(_2, l2, r2, o2, f2), f2.delete(l2)), Yr(t2, e2, _2);
      }
      function eu(t2, n3) {
        var e2 = t2.length;
        if (e2) return n3 += n3 < 0 ? e2 : 0, Xt(n3, e2) ? t2[n3] : i4;
      }
      function ru(t2, n3, e2) {
        n3.length ? n3 = z3(n3, function(o2) {
          return b2(o2) ? function(f2) {
            return wn2(f2, o2.length === 1 ? o2[0] : o2);
          } : o2;
        }) : n3 = [ft];
        var r2 = -1;
        n3 = z3(n3, ht(E2()));
        var u2 = js2(t2, function(o2, f2, c2) {
          var l2 = z3(n3, function(v2) {
            return v2(o2);
          });
          return { criteria: l2, index: ++r2, value: o2 };
        });
        return pf2(u2, function(o2, f2) {
          return jc(o2, f2, e2);
        });
      }
      function Mc(t2, n3) {
        return iu(t2, n3, function(e2, r2) {
          return Ri(t2, r2);
        });
      }
      function iu(t2, n3, e2) {
        for (var r2 = -1, u2 = n3.length, o2 = {}; ++r2 < u2; ) {
          var f2 = n3[r2], c2 = wn2(t2, f2);
          e2(c2, f2) && he2(o2, fn2(f2, t2), c2);
        }
        return o2;
      }
      function Bc(t2) {
        return function(n3) {
          return wn2(n3, t2);
        };
      }
      function ei(t2, n3, e2, r2) {
        var u2 = r2 ? lf2 : Ln2, o2 = -1, f2 = n3.length, c2 = t2;
        for (t2 === n3 && (n3 = ut(n3)), e2 && (c2 = z3(t2, ht(e2))); ++o2 < f2; ) for (var l2 = 0, v2 = n3[o2], _2 = e2 ? e2(v2) : v2; (l2 = u2(c2, _2, l2, r2)) > -1; ) c2 !== t2 && qe.call(c2, l2, 1), qe.call(t2, l2, 1);
        return t2;
      }
      function su(t2, n3) {
        for (var e2 = t2 ? n3.length : 0, r2 = e2 - 1; e2--; ) {
          var u2 = n3[e2];
          if (e2 == r2 || u2 !== o2) {
            var o2 = u2;
            Xt(u2) ? qe.call(t2, u2, 1) : ui(t2, u2);
          }
        }
        return t2;
      }
      function ri(t2, n3) {
        return t2 + We(Fs2() * (n3 - t2 + 1));
      }
      function Gc(t2, n3, e2, r2) {
        for (var u2 = -1, o2 = Q2(Fe((n3 - t2) / (e2 || 1)), 0), f2 = d3(o2); o2--; ) f2[r2 ? o2 : ++u2] = t2, t2 += e2;
        return f2;
      }
      function ii(t2, n3) {
        var e2 = "";
        if (!t2 || n3 < 1 || n3 > nn) return e2;
        do
          n3 % 2 && (e2 += t2), n3 = We(n3 / 2), n3 && (t2 += t2);
        while (n3);
        return e2;
      }
      function H2(t2, n3) {
        return Ci2(Nu(t2, n3, ft), t2 + "");
      }
      function zc(t2) {
        return Bs(zn2(t2));
      }
      function Kc(t2, n3) {
        var e2 = zn2(t2);
        return rr(e2, mn(n3, 0, e2.length));
      }
      function he2(t2, n3, e2, r2) {
        if (!K2(t2)) return t2;
        n3 = fn2(n3, t2);
        for (var u2 = -1, o2 = n3.length, f2 = o2 - 1, c2 = t2; c2 != null && ++u2 < o2; ) {
          var l2 = Ft2(n3[u2]), v2 = e2;
          if (l2 === "__proto__" || l2 === "constructor" || l2 === "prototype") return t2;
          if (u2 != f2) {
            var _2 = c2[l2];
            v2 = r2 ? r2(_2, l2, c2) : i4, v2 === i4 && (v2 = K2(_2) ? _2 : Xt(n3[u2 + 1]) ? [] : {});
          }
          ae2(c2, l2, v2), c2 = c2[l2];
        }
        return t2;
      }
      var uu = Me ? function(t2, n3) {
        return Me.set(t2, n3), t2;
      } : ft, Jc = Ue ? function(t2, n3) {
        return Ue(t2, "toString", { configurable: true, enumerable: false, value: Ti2(n3), writable: true });
      } : ft;
      function Yc(t2) {
        return rr(zn2(t2));
      }
      function At(t2, n3, e2) {
        var r2 = -1, u2 = t2.length;
        n3 < 0 && (n3 = -n3 > u2 ? 0 : u2 + n3), e2 = e2 > u2 ? u2 : e2, e2 < 0 && (e2 += u2), u2 = n3 > e2 ? 0 : e2 - n3 >>> 0, n3 >>>= 0;
        for (var o2 = d3(u2); ++r2 < u2; ) o2[r2] = t2[r2 + n3];
        return o2;
      }
      function Zc(t2, n3) {
        var e2;
        return an(t2, function(r2, u2, o2) {
          return e2 = n3(r2, u2, o2), !e2;
        }), !!e2;
      }
      function Ze2(t2, n3, e2) {
        var r2 = 0, u2 = t2 == null ? r2 : t2.length;
        if (typeof n3 == "number" && n3 === n3 && u2 <= Za) {
          for (; r2 < u2; ) {
            var o2 = r2 + u2 >>> 1, f2 = t2[o2];
            f2 !== null && !pt(f2) && (e2 ? f2 <= n3 : f2 < n3) ? r2 = o2 + 1 : u2 = o2;
          }
          return u2;
        }
        return si(t2, n3, ft, e2);
      }
      function si(t2, n3, e2, r2) {
        var u2 = 0, o2 = t2 == null ? 0 : t2.length;
        if (o2 === 0) return 0;
        n3 = e2(n3);
        for (var f2 = n3 !== n3, c2 = n3 === null, l2 = pt(n3), v2 = n3 === i4; u2 < o2; ) {
          var _2 = We((u2 + o2) / 2), m3 = e2(t2[_2]), C2 = m3 !== i4, I2 = m3 === null, y3 = m3 === m3, L3 = pt(m3);
          if (f2) var S2 = r2 || y3;
          else v2 ? S2 = y3 && (r2 || C2) : c2 ? S2 = y3 && C2 && (r2 || !I2) : l2 ? S2 = y3 && C2 && !I2 && (r2 || !L3) : I2 || L3 ? S2 = false : S2 = r2 ? m3 <= n3 : m3 < n3;
          S2 ? u2 = _2 + 1 : o2 = _2;
        }
        return nt(o2, Ya2);
      }
      function au(t2, n3) {
        for (var e2 = -1, r2 = t2.length, u2 = 0, o2 = []; ++e2 < r2; ) {
          var f2 = t2[e2], c2 = n3 ? n3(f2) : f2;
          if (!e2 || !Rt(c2, l2)) {
            var l2 = c2;
            o2[u2++] = f2 === 0 ? 0 : f2;
          }
        }
        return o2;
      }
      function ou(t2) {
        return typeof t2 == "number" ? t2 : pt(t2) ? we2 : +t2;
      }
      function lt(t2) {
        if (typeof t2 == "string") return t2;
        if (b2(t2)) return z3(t2, lt) + "";
        if (pt(t2)) return Ws2 ? Ws2.call(t2) : "";
        var n3 = t2 + "";
        return n3 == "0" && 1 / t2 == -pn ? "-0" : n3;
      }
      function on(t2, n3, e2) {
        var r2 = -1, u2 = Se, o2 = t2.length, f2 = true, c2 = [], l2 = c2;
        if (e2) f2 = false, u2 = Dr2;
        else if (o2 >= w2) {
          var v2 = n3 ? null : sh(t2);
          if (v2) return Re2(v2);
          f2 = false, u2 = ne2, l2 = new _n();
        } else l2 = n3 ? [] : c2;
        t: for (; ++r2 < o2; ) {
          var _2 = t2[r2], m3 = n3 ? n3(_2) : _2;
          if (_2 = e2 || _2 !== 0 ? _2 : 0, f2 && m3 === m3) {
            for (var C2 = l2.length; C2--; ) if (l2[C2] === m3) continue t;
            n3 && l2.push(m3), c2.push(_2);
          } else u2(l2, m3, e2) || (l2 !== c2 && l2.push(m3), c2.push(_2));
        }
        return c2;
      }
      function ui(t2, n3) {
        return n3 = fn2(n3, t2), t2 = $u(t2, n3), t2 == null || delete t2[Ft2(It(n3))];
      }
      function fu(t2, n3, e2, r2) {
        return he2(t2, n3, e2(wn2(t2, n3)), r2);
      }
      function Xe2(t2, n3, e2, r2) {
        for (var u2 = t2.length, o2 = r2 ? u2 : -1; (r2 ? o2-- : ++o2 < u2) && n3(t2[o2], o2, t2); ) ;
        return e2 ? At(t2, r2 ? 0 : o2, r2 ? o2 + 1 : u2) : At(t2, r2 ? o2 + 1 : 0, r2 ? u2 : o2);
      }
      function cu(t2, n3) {
        var e2 = t2;
        return e2 instanceof N2 && (e2 = e2.value()), Nr(n3, function(r2, u2) {
          return u2.func.apply(u2.thisArg, rn([r2], u2.args));
        }, e2);
      }
      function ai(t2, n3, e2) {
        var r2 = t2.length;
        if (r2 < 2) return r2 ? on(t2[0]) : [];
        for (var u2 = -1, o2 = d3(r2); ++u2 < r2; ) for (var f2 = t2[u2], c2 = -1; ++c2 < r2; ) c2 != u2 && (o2[u2] = oe2(o2[u2] || f2, t2[c2], n3, e2));
        return on(tt(o2, 1), n3, e2);
      }
      function hu2(t2, n3, e2) {
        for (var r2 = -1, u2 = t2.length, o2 = n3.length, f2 = {}; ++r2 < u2; ) {
          var c2 = r2 < o2 ? n3[r2] : i4;
          e2(f2, t2[r2], c2);
        }
        return f2;
      }
      function oi(t2) {
        return Y(t2) ? t2 : [];
      }
      function fi(t2) {
        return typeof t2 == "function" ? t2 : ft;
      }
      function fn2(t2, n3) {
        return b2(t2) ? t2 : mi2(t2, n3) ? [t2] : Wu(U(t2));
      }
      var Xc = H2;
      function cn(t2, n3, e2) {
        var r2 = t2.length;
        return e2 = e2 === i4 ? r2 : e2, !n3 && e2 >= r2 ? t2 : At(t2, n3, e2);
      }
      var lu = $f || function(t2) {
        return j2.clearTimeout(t2);
      };
      function pu(t2, n3) {
        if (n3) return t2.slice();
        var e2 = t2.length, r2 = Ds2 ? Ds2(e2) : new t2.constructor(e2);
        return t2.copy(r2), r2;
      }
      function ci(t2) {
        var n3 = new t2.constructor(t2.byteLength);
        return new Ne(n3).set(new Ne(t2)), n3;
      }
      function Qc(t2, n3) {
        var e2 = n3 ? ci(t2.buffer) : t2.buffer;
        return new t2.constructor(e2, t2.byteOffset, t2.byteLength);
      }
      function Vc(t2) {
        var n3 = new t2.constructor(t2.source, Qi.exec(t2));
        return n3.lastIndex = t2.lastIndex, n3;
      }
      function kc(t2) {
        return ue2 ? M2(ue2.call(t2)) : {};
      }
      function du(t2, n3) {
        var e2 = n3 ? ci(t2.buffer) : t2.buffer;
        return new t2.constructor(e2, t2.byteOffset, t2.length);
      }
      function gu(t2, n3) {
        if (t2 !== n3) {
          var e2 = t2 !== i4, r2 = t2 === null, u2 = t2 === t2, o2 = pt(t2), f2 = n3 !== i4, c2 = n3 === null, l2 = n3 === n3, v2 = pt(n3);
          if (!c2 && !v2 && !o2 && t2 > n3 || o2 && f2 && l2 && !c2 && !v2 || r2 && f2 && l2 || !e2 && l2 || !u2) return 1;
          if (!r2 && !o2 && !v2 && t2 < n3 || v2 && e2 && u2 && !r2 && !o2 || c2 && e2 && u2 || !f2 && u2 || !l2) return -1;
        }
        return 0;
      }
      function jc(t2, n3, e2) {
        for (var r2 = -1, u2 = t2.criteria, o2 = n3.criteria, f2 = u2.length, c2 = e2.length; ++r2 < f2; ) {
          var l2 = gu(u2[r2], o2[r2]);
          if (l2) {
            if (r2 >= c2) return l2;
            var v2 = e2[r2];
            return l2 * (v2 == "desc" ? -1 : 1);
          }
        }
        return t2.index - n3.index;
      }
      function vu(t2, n3, e2, r2) {
        for (var u2 = -1, o2 = t2.length, f2 = e2.length, c2 = -1, l2 = n3.length, v2 = Q2(o2 - f2, 0), _2 = d3(l2 + v2), m3 = !r2; ++c2 < l2; ) _2[c2] = n3[c2];
        for (; ++u2 < f2; ) (m3 || u2 < o2) && (_2[e2[u2]] = t2[u2]);
        for (; v2--; ) _2[c2++] = t2[u2++];
        return _2;
      }
      function _u(t2, n3, e2, r2) {
        for (var u2 = -1, o2 = t2.length, f2 = -1, c2 = e2.length, l2 = -1, v2 = n3.length, _2 = Q2(o2 - c2, 0), m3 = d3(_2 + v2), C2 = !r2; ++u2 < _2; ) m3[u2] = t2[u2];
        for (var I2 = u2; ++l2 < v2; ) m3[I2 + l2] = n3[l2];
        for (; ++f2 < c2; ) (C2 || u2 < o2) && (m3[I2 + e2[f2]] = t2[u2++]);
        return m3;
      }
      function ut(t2, n3) {
        var e2 = -1, r2 = t2.length;
        for (n3 || (n3 = d3(r2)); ++e2 < r2; ) n3[e2] = t2[e2];
        return n3;
      }
      function Ut2(t2, n3, e2, r2) {
        var u2 = !e2;
        e2 || (e2 = {});
        for (var o2 = -1, f2 = n3.length; ++o2 < f2; ) {
          var c2 = n3[o2], l2 = r2 ? r2(e2[c2], t2[c2], c2, e2, t2) : i4;
          l2 === i4 && (l2 = t2[c2]), u2 ? Jt2(e2, c2, l2) : ae2(e2, c2, l2);
        }
        return e2;
      }
      function th(t2, n3) {
        return Ut2(t2, _i3(t2), n3);
      }
      function nh(t2, n3) {
        return Ut2(t2, bu(t2), n3);
      }
      function Qe(t2, n3) {
        return function(e2, r2) {
          var u2 = b2(e2) ? uf : Ic, o2 = n3 ? n3() : {};
          return u2(e2, t2, E2(r2, 2), o2);
        };
      }
      function Wn2(t2) {
        return H2(function(n3, e2) {
          var r2 = -1, u2 = e2.length, o2 = u2 > 1 ? e2[u2 - 1] : i4, f2 = u2 > 2 ? e2[2] : i4;
          for (o2 = t2.length > 3 && typeof o2 == "function" ? (u2--, o2) : i4, f2 && it(e2[0], e2[1], f2) && (o2 = u2 < 3 ? i4 : o2, u2 = 1), n3 = M2(n3); ++r2 < u2; ) {
            var c2 = e2[r2];
            c2 && t2(n3, c2, r2, o2);
          }
          return n3;
        });
      }
      function mu(t2, n3) {
        return function(e2, r2) {
          if (e2 == null) return e2;
          if (!at(e2)) return t2(e2, r2);
          for (var u2 = e2.length, o2 = n3 ? u2 : -1, f2 = M2(e2); (n3 ? o2-- : ++o2 < u2) && r2(f2[o2], o2, f2) !== false; ) ;
          return e2;
        };
      }
      function wu(t2) {
        return function(n3, e2, r2) {
          for (var u2 = -1, o2 = M2(n3), f2 = r2(n3), c2 = f2.length; c2--; ) {
            var l2 = f2[t2 ? c2 : ++u2];
            if (e2(o2[l2], l2, o2) === false) break;
          }
          return n3;
        };
      }
      function eh(t2, n3, e2) {
        var r2 = n3 & vt, u2 = le2(t2);
        function o2() {
          var f2 = this && this !== j2 && this instanceof o2 ? u2 : t2;
          return f2.apply(r2 ? e2 : this, arguments);
        }
        return o2;
      }
      function Pu(t2) {
        return function(n3) {
          n3 = U(n3);
          var e2 = Hn2(n3) ? St(n3) : i4, r2 = e2 ? e2[0] : n3.charAt(0), u2 = e2 ? cn(e2, 1).join("") : n3.slice(1);
          return r2[t2]() + u2;
        };
      }
      function Mn(t2) {
        return function(n3) {
          return Nr(ma2(_a3(n3).replace(Ko, "")), t2, "");
        };
      }
      function le2(t2) {
        return function() {
          var n3 = arguments;
          switch (n3.length) {
            case 0:
              return new t2();
            case 1:
              return new t2(n3[0]);
            case 2:
              return new t2(n3[0], n3[1]);
            case 3:
              return new t2(n3[0], n3[1], n3[2]);
            case 4:
              return new t2(n3[0], n3[1], n3[2], n3[3]);
            case 5:
              return new t2(n3[0], n3[1], n3[2], n3[3], n3[4]);
            case 6:
              return new t2(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5]);
            case 7:
              return new t2(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5], n3[6]);
          }
          var e2 = Fn(t2.prototype), r2 = t2.apply(e2, n3);
          return K2(r2) ? r2 : e2;
        };
      }
      function rh(t2, n3, e2) {
        var r2 = le2(t2);
        function u2() {
          for (var o2 = arguments.length, f2 = d3(o2), c2 = o2, l2 = Bn(u2); c2--; ) f2[c2] = arguments[c2];
          var v2 = o2 < 3 && f2[0] !== l2 && f2[o2 - 1] !== l2 ? [] : sn(f2, l2);
          if (o2 -= v2.length, o2 < e2) return Eu(t2, n3, Ve, u2.placeholder, i4, f2, v2, i4, i4, e2 - o2);
          var _2 = this && this !== j2 && this instanceof u2 ? r2 : t2;
          return ct(_2, this, f2);
        }
        return u2;
      }
      function Cu(t2) {
        return function(n3, e2, r2) {
          var u2 = M2(n3);
          if (!at(n3)) {
            var o2 = E2(e2, 3);
            n3 = V2(n3), e2 = function(c2) {
              return o2(u2[c2], c2, u2);
            };
          }
          var f2 = t2(n3, e2, r2);
          return f2 > -1 ? u2[o2 ? n3[f2] : f2] : i4;
        };
      }
      function Au(t2) {
        return Zt2(function(n3) {
          var e2 = n3.length, r2 = e2, u2 = Pt.prototype.thru;
          for (t2 && n3.reverse(); r2--; ) {
            var o2 = n3[r2];
            if (typeof o2 != "function") throw new wt(O2);
            if (u2 && !f2 && nr2(o2) == "wrapper") var f2 = new Pt([], true);
          }
          for (r2 = f2 ? r2 : e2; ++r2 < e2; ) {
            o2 = n3[r2];
            var c2 = nr2(o2), l2 = c2 == "wrapper" ? gi2(o2) : i4;
            l2 && wi(l2[0]) && l2[1] == (Bt | Dt2 | Nt2 | Yn2) && !l2[4].length && l2[9] == 1 ? f2 = f2[nr2(l2[0])].apply(f2, l2[3]) : f2 = o2.length == 1 && wi(o2) ? f2[c2]() : f2.thru(o2);
          }
          return function() {
            var v2 = arguments, _2 = v2[0];
            if (f2 && v2.length == 1 && b2(_2)) return f2.plant(_2).value();
            for (var m3 = 0, C2 = e2 ? n3[m3].apply(this, v2) : _2; ++m3 < e2; ) C2 = n3[m3].call(this, C2);
            return C2;
          };
        });
      }
      function Ve(t2, n3, e2, r2, u2, o2, f2, c2, l2, v2) {
        var _2 = n3 & Bt, m3 = n3 & vt, C2 = n3 & ln, I2 = n3 & (Dt2 | Sn), y3 = n3 & gr, L3 = C2 ? i4 : le2(t2);
        function S2() {
          for (var D = arguments.length, $2 = d3(D), dt = D; dt--; ) $2[dt] = arguments[dt];
          if (I2) var st = Bn(S2), gt = gf2($2, st);
          if (r2 && ($2 = vu($2, r2, u2, I2)), o2 && ($2 = _u($2, o2, f2, I2)), D -= gt, I2 && D < v2) {
            var Z = sn($2, st);
            return Eu(t2, n3, Ve, S2.placeholder, e2, $2, Z, c2, l2, v2 - D);
          }
          var bt = m3 ? e2 : this, kt2 = C2 ? bt[t2] : t2;
          return D = $2.length, c2 ? $2 = Ih($2, c2) : y3 && D > 1 && $2.reverse(), _2 && l2 < D && ($2.length = l2), this && this !== j2 && this instanceof S2 && (kt2 = L3 || le2(kt2)), kt2.apply(bt, $2);
        }
        return S2;
      }
      function Iu(t2, n3) {
        return function(e2, r2) {
          return Tc(e2, t2, n3(r2), {});
        };
      }
      function ke(t2, n3) {
        return function(e2, r2) {
          var u2;
          if (e2 === i4 && r2 === i4) return n3;
          if (e2 !== i4 && (u2 = e2), r2 !== i4) {
            if (u2 === i4) return r2;
            typeof e2 == "string" || typeof r2 == "string" ? (e2 = lt(e2), r2 = lt(r2)) : (e2 = ou(e2), r2 = ou(r2)), u2 = t2(e2, r2);
          }
          return u2;
        };
      }
      function hi(t2) {
        return Zt2(function(n3) {
          return n3 = z3(n3, ht(E2())), H2(function(e2) {
            var r2 = this;
            return t2(n3, function(u2) {
              return ct(u2, r2, e2);
            });
          });
        });
      }
      function je(t2, n3) {
        n3 = n3 === i4 ? " " : lt(n3);
        var e2 = n3.length;
        if (e2 < 2) return e2 ? ii(n3, t2) : n3;
        var r2 = ii(n3, Fe(t2 / Dn(n3)));
        return Hn2(n3) ? cn(St(r2), 0, t2).join("") : r2.slice(0, t2);
      }
      function ih(t2, n3, e2, r2) {
        var u2 = n3 & vt, o2 = le2(t2);
        function f2() {
          for (var c2 = -1, l2 = arguments.length, v2 = -1, _2 = r2.length, m3 = d3(_2 + l2), C2 = this && this !== j2 && this instanceof f2 ? o2 : t2; ++v2 < _2; ) m3[v2] = r2[v2];
          for (; l2--; ) m3[v2++] = arguments[++c2];
          return ct(C2, u2 ? e2 : this, m3);
        }
        return f2;
      }
      function xu(t2) {
        return function(n3, e2, r2) {
          return r2 && typeof r2 != "number" && it(n3, e2, r2) && (e2 = r2 = i4), n3 = Vt(n3), e2 === i4 ? (e2 = n3, n3 = 0) : e2 = Vt(e2), r2 = r2 === i4 ? n3 < e2 ? 1 : -1 : Vt(r2), Gc(n3, e2, r2, t2);
        };
      }
      function tr(t2) {
        return function(n3, e2) {
          return typeof n3 == "string" && typeof e2 == "string" || (n3 = xt(n3), e2 = xt(e2)), t2(n3, e2);
        };
      }
      function Eu(t2, n3, e2, r2, u2, o2, f2, c2, l2, v2) {
        var _2 = n3 & Dt2, m3 = _2 ? f2 : i4, C2 = _2 ? i4 : f2, I2 = _2 ? o2 : i4, y3 = _2 ? i4 : o2;
        n3 |= _2 ? Nt2 : On, n3 &= ~(_2 ? On : Nt2), n3 & Gi2 || (n3 &= -4);
        var L3 = [t2, n3, u2, I2, m3, y3, C2, c2, l2, v2], S2 = e2.apply(i4, L3);
        return wi(t2) && qu(S2, L3), S2.placeholder = r2, Uu(S2, t2, n3);
      }
      function li(t2) {
        var n3 = X[t2];
        return function(e2, r2) {
          if (e2 = xt(e2), r2 = r2 == null ? 0 : nt(T2(r2), 292), r2 && Us(e2)) {
            var u2 = (U(e2) + "e").split("e"), o2 = n3(u2[0] + "e" + (+u2[1] + r2));
            return u2 = (U(o2) + "e").split("e"), +(u2[0] + "e" + (+u2[1] - r2));
          }
          return n3(e2);
        };
      }
      var sh = qn2 && 1 / Re2(new qn2([, -0]))[1] == pn ? function(t2) {
        return new qn2(t2);
      } : Di2;
      function yu(t2) {
        return function(n3) {
          var e2 = et(n3);
          return e2 == Et ? Br(n3) : e2 == yt ? Af2(n3) : df2(n3, t2(n3));
        };
      }
      function Yt(t2, n3, e2, r2, u2, o2, f2, c2) {
        var l2 = n3 & ln;
        if (!l2 && typeof t2 != "function") throw new wt(O2);
        var v2 = r2 ? r2.length : 0;
        if (v2 || (n3 &= -97, r2 = u2 = i4), f2 = f2 === i4 ? f2 : Q2(T2(f2), 0), c2 = c2 === i4 ? c2 : T2(c2), v2 -= u2 ? u2.length : 0, n3 & On) {
          var _2 = r2, m3 = u2;
          r2 = u2 = i4;
        }
        var C2 = l2 ? i4 : gi2(t2), I2 = [t2, n3, e2, r2, u2, _2, m3, o2, f2, c2];
        if (C2 && Ph(I2, C2), t2 = I2[0], n3 = I2[1], e2 = I2[2], r2 = I2[3], u2 = I2[4], c2 = I2[9] = I2[9] === i4 ? l2 ? 0 : t2.length : Q2(I2[9] - v2, 0), !c2 && n3 & (Dt2 | Sn) && (n3 &= -25), !n3 || n3 == vt) var y3 = eh(t2, n3, e2);
        else n3 == Dt2 || n3 == Sn ? y3 = rh(t2, n3, c2) : (n3 == Nt2 || n3 == (vt | Nt2)) && !u2.length ? y3 = ih(t2, n3, e2, r2) : y3 = Ve.apply(i4, I2);
        var L3 = C2 ? uu : qu;
        return Uu(L3(y3, I2), t2, n3);
      }
      function Su(t2, n3, e2, r2) {
        return t2 === i4 || Rt(t2, $n2[e2]) && !W.call(r2, e2) ? n3 : t2;
      }
      function Ou(t2, n3, e2, r2, u2, o2) {
        return K2(t2) && K2(n3) && (o2.set(n3, t2), Ye(t2, n3, i4, Ou, o2), o2.delete(n3)), t2;
      }
      function uh(t2) {
        return ge(t2) ? i4 : t2;
      }
      function Ru(t2, n3, e2, r2, u2, o2) {
        var f2 = e2 & yn, c2 = t2.length, l2 = n3.length;
        if (c2 != l2 && !(f2 && l2 > c2)) return false;
        var v2 = o2.get(t2), _2 = o2.get(n3);
        if (v2 && _2) return v2 == n3 && _2 == t2;
        var m3 = -1, C2 = true, I2 = e2 & me ? new _n() : i4;
        for (o2.set(t2, n3), o2.set(n3, t2); ++m3 < c2; ) {
          var y3 = t2[m3], L3 = n3[m3];
          if (r2) var S2 = f2 ? r2(L3, y3, m3, n3, t2, o2) : r2(y3, L3, m3, t2, n3, o2);
          if (S2 !== i4) {
            if (S2) continue;
            C2 = false;
            break;
          }
          if (I2) {
            if (!$r(n3, function(D, $2) {
              if (!ne2(I2, $2) && (y3 === D || u2(y3, D, e2, r2, o2))) return I2.push($2);
            })) {
              C2 = false;
              break;
            }
          } else if (!(y3 === L3 || u2(y3, L3, e2, r2, o2))) {
            C2 = false;
            break;
          }
        }
        return o2.delete(t2), o2.delete(n3), C2;
      }
      function ah(t2, n3, e2, r2, u2, o2, f2) {
        switch (e2) {
          case bn2:
            if (t2.byteLength != n3.byteLength || t2.byteOffset != n3.byteOffset) return false;
            t2 = t2.buffer, n3 = n3.buffer;
          case te2:
            return !(t2.byteLength != n3.byteLength || !o2(new Ne(t2), new Ne(n3)));
          case Zn2:
          case Xn2:
          case Qn:
            return Rt(+t2, +n3);
          case Ce2:
            return t2.name == n3.name && t2.message == n3.message;
          case Vn2:
          case kn2:
            return t2 == n3 + "";
          case Et:
            var c2 = Br;
          case yt:
            var l2 = r2 & yn;
            if (c2 || (c2 = Re2), t2.size != n3.size && !l2) return false;
            var v2 = f2.get(t2);
            if (v2) return v2 == n3;
            r2 |= me, f2.set(t2, n3);
            var _2 = Ru(c2(t2), c2(n3), r2, u2, o2, f2);
            return f2.delete(t2), _2;
          case Ie:
            if (ue2) return ue2.call(t2) == ue2.call(n3);
        }
        return false;
      }
      function oh(t2, n3, e2, r2, u2, o2) {
        var f2 = e2 & yn, c2 = pi(t2), l2 = c2.length, v2 = pi(n3), _2 = v2.length;
        if (l2 != _2 && !f2) return false;
        for (var m3 = l2; m3--; ) {
          var C2 = c2[m3];
          if (!(f2 ? C2 in n3 : W.call(n3, C2))) return false;
        }
        var I2 = o2.get(t2), y3 = o2.get(n3);
        if (I2 && y3) return I2 == n3 && y3 == t2;
        var L3 = true;
        o2.set(t2, n3), o2.set(n3, t2);
        for (var S2 = f2; ++m3 < l2; ) {
          C2 = c2[m3];
          var D = t2[C2], $2 = n3[C2];
          if (r2) var dt = f2 ? r2($2, D, C2, n3, t2, o2) : r2(D, $2, C2, t2, n3, o2);
          if (!(dt === i4 ? D === $2 || u2(D, $2, e2, r2, o2) : dt)) {
            L3 = false;
            break;
          }
          S2 || (S2 = C2 == "constructor");
        }
        if (L3 && !S2) {
          var st = t2.constructor, gt = n3.constructor;
          st != gt && "constructor" in t2 && "constructor" in n3 && !(typeof st == "function" && st instanceof st && typeof gt == "function" && gt instanceof gt) && (L3 = false);
        }
        return o2.delete(t2), o2.delete(n3), L3;
      }
      function Zt2(t2) {
        return Ci2(Nu(t2, i4, zu), t2 + "");
      }
      function pi(t2) {
        return Xs2(t2, V2, _i3);
      }
      function di(t2) {
        return Xs2(t2, ot, bu);
      }
      var gi2 = Me ? function(t2) {
        return Me.get(t2);
      } : Di2;
      function nr2(t2) {
        for (var n3 = t2.name + "", e2 = Un2[n3], r2 = W.call(Un2, n3) ? e2.length : 0; r2--; ) {
          var u2 = e2[r2], o2 = u2.func;
          if (o2 == null || o2 == t2) return u2.name;
        }
        return n3;
      }
      function Bn(t2) {
        var n3 = W.call(a2, "placeholder") ? a2 : t2;
        return n3.placeholder;
      }
      function E2() {
        var t2 = a2.iteratee || Li2;
        return t2 = t2 === Li2 ? ks2 : t2, arguments.length ? t2(arguments[0], arguments[1]) : t2;
      }
      function er(t2, n3) {
        var e2 = t2.__data__;
        return vh(n3) ? e2[typeof n3 == "string" ? "string" : "hash"] : e2.map;
      }
      function vi(t2) {
        for (var n3 = V2(t2), e2 = n3.length; e2--; ) {
          var r2 = n3[e2], u2 = t2[r2];
          n3[e2] = [r2, u2, Hu(u2)];
        }
        return n3;
      }
      function Pn(t2, n3) {
        var e2 = wf2(t2, n3);
        return Vs2(e2) ? e2 : i4;
      }
      function fh(t2) {
        var n3 = W.call(t2, gn), e2 = t2[gn];
        try {
          t2[gn] = i4;
          var r2 = true;
        } catch {
        }
        var u2 = He.call(t2);
        return r2 && (n3 ? t2[gn] = e2 : delete t2[gn]), u2;
      }
      var _i3 = zr2 ? function(t2) {
        return t2 == null ? [] : (t2 = M2(t2), en2(zr2(t2), function(n3) {
          return $s2.call(t2, n3);
        }));
      } : Ni2, bu = zr2 ? function(t2) {
        for (var n3 = []; t2; ) rn(n3, _i3(t2)), t2 = $e(t2);
        return n3;
      } : Ni2, et = rt;
      (Kr2 && et(new Kr2(new ArrayBuffer(1))) != bn2 || re2 && et(new re2()) != Et || Jr2 && et(Jr2.resolve()) != Ji || qn2 && et(new qn2()) != yt || ie2 && et(new ie2()) != jn2) && (et = function(t2) {
        var n3 = rt(t2), e2 = n3 == Gt2 ? t2.constructor : i4, r2 = e2 ? Cn(e2) : "";
        if (r2) switch (r2) {
          case Kf:
            return bn2;
          case Jf:
            return Et;
          case Yf:
            return Ji;
          case Zf:
            return yt;
          case Xf:
            return jn2;
        }
        return n3;
      });
      function ch(t2, n3, e2) {
        for (var r2 = -1, u2 = e2.length; ++r2 < u2; ) {
          var o2 = e2[r2], f2 = o2.size;
          switch (o2.type) {
            case "drop":
              t2 += f2;
              break;
            case "dropRight":
              n3 -= f2;
              break;
            case "take":
              n3 = nt(n3, t2 + f2);
              break;
            case "takeRight":
              t2 = Q2(t2, n3 - f2);
              break;
          }
        }
        return { start: t2, end: n3 };
      }
      function hh(t2) {
        var n3 = t2.match(vo);
        return n3 ? n3[1].split(_o) : [];
      }
      function Tu(t2, n3, e2) {
        n3 = fn2(n3, t2);
        for (var r2 = -1, u2 = n3.length, o2 = false; ++r2 < u2; ) {
          var f2 = Ft2(n3[r2]);
          if (!(o2 = t2 != null && e2(t2, f2))) break;
          t2 = t2[f2];
        }
        return o2 || ++r2 != u2 ? o2 : (u2 = t2 == null ? 0 : t2.length, !!u2 && fr2(u2) && Xt(f2, u2) && (b2(t2) || An2(t2)));
      }
      function lh(t2) {
        var n3 = t2.length, e2 = new t2.constructor(n3);
        return n3 && typeof t2[0] == "string" && W.call(t2, "index") && (e2.index = t2.index, e2.input = t2.input), e2;
      }
      function Lu(t2) {
        return typeof t2.constructor == "function" && !pe2(t2) ? Fn($e(t2)) : {};
      }
      function ph(t2, n3, e2) {
        var r2 = t2.constructor;
        switch (n3) {
          case te2:
            return ci(t2);
          case Zn2:
          case Xn2:
            return new r2(+t2);
          case bn2:
            return Qc(t2, e2);
          case vr2:
          case _r:
          case mr2:
          case wr:
          case Pr:
          case Cr:
          case Ar2:
          case Ir:
          case xr2:
            return du(t2, e2);
          case Et:
            return new r2();
          case Qn:
          case kn2:
            return new r2(t2);
          case Vn2:
            return Vc(t2);
          case yt:
            return new r2();
          case Ie:
            return kc(t2);
        }
      }
      function dh(t2, n3) {
        var e2 = n3.length;
        if (!e2) return t2;
        var r2 = e2 - 1;
        return n3[r2] = (e2 > 1 ? "& " : "") + n3[r2], n3 = n3.join(e2 > 2 ? ", " : " "), t2.replace(go, `{
/* [wrapped with ` + n3 + `] */
`);
      }
      function gh(t2) {
        return b2(t2) || An2(t2) || !!(qs && t2 && t2[qs]);
      }
      function Xt(t2, n3) {
        var e2 = typeof t2;
        return n3 = n3 ?? nn, !!n3 && (e2 == "number" || e2 != "symbol" && yo.test(t2)) && t2 > -1 && t2 % 1 == 0 && t2 < n3;
      }
      function it(t2, n3, e2) {
        if (!K2(e2)) return false;
        var r2 = typeof n3;
        return (r2 == "number" ? at(e2) && Xt(n3, e2.length) : r2 == "string" && n3 in e2) ? Rt(e2[n3], t2) : false;
      }
      function mi2(t2, n3) {
        if (b2(t2)) return false;
        var e2 = typeof t2;
        return e2 == "number" || e2 == "symbol" || e2 == "boolean" || t2 == null || pt(t2) ? true : co.test(t2) || !fo.test(t2) || n3 != null && t2 in M2(n3);
      }
      function vh(t2) {
        var n3 = typeof t2;
        return n3 == "string" || n3 == "number" || n3 == "symbol" || n3 == "boolean" ? t2 !== "__proto__" : t2 === null;
      }
      function wi(t2) {
        var n3 = nr2(t2), e2 = a2[n3];
        if (typeof e2 != "function" || !(n3 in N2.prototype)) return false;
        if (t2 === e2) return true;
        var r2 = gi2(e2);
        return !!r2 && t2 === r2[0];
      }
      function _h2(t2) {
        return !!Hs && Hs in t2;
      }
      var mh = Te ? Qt : $i;
      function pe2(t2) {
        var n3 = t2 && t2.constructor, e2 = typeof n3 == "function" && n3.prototype || $n2;
        return t2 === e2;
      }
      function Hu(t2) {
        return t2 === t2 && !K2(t2);
      }
      function Du(t2, n3) {
        return function(e2) {
          return e2 == null ? false : e2[t2] === n3 && (n3 !== i4 || t2 in M2(e2));
        };
      }
      function wh(t2) {
        var n3 = ar2(t2, function(r2) {
          return e2.size === Jn && e2.clear(), r2;
        }), e2 = n3.cache;
        return n3;
      }
      function Ph(t2, n3) {
        var e2 = t2[1], r2 = n3[1], u2 = e2 | r2, o2 = u2 < (vt | ln | Bt), f2 = r2 == Bt && e2 == Dt2 || r2 == Bt && e2 == Yn2 && t2[7].length <= n3[8] || r2 == (Bt | Yn2) && n3[7].length <= n3[8] && e2 == Dt2;
        if (!(o2 || f2)) return t2;
        r2 & vt && (t2[2] = n3[2], u2 |= e2 & vt ? 0 : Gi2);
        var c2 = n3[3];
        if (c2) {
          var l2 = t2[3];
          t2[3] = l2 ? vu(l2, c2, n3[4]) : c2, t2[4] = l2 ? sn(t2[3], xn2) : n3[4];
        }
        return c2 = n3[5], c2 && (l2 = t2[5], t2[5] = l2 ? _u(l2, c2, n3[6]) : c2, t2[6] = l2 ? sn(t2[5], xn2) : n3[6]), c2 = n3[7], c2 && (t2[7] = c2), r2 & Bt && (t2[8] = t2[8] == null ? n3[8] : nt(t2[8], n3[8])), t2[9] == null && (t2[9] = n3[9]), t2[0] = n3[0], t2[1] = u2, t2;
      }
      function Ch(t2) {
        var n3 = [];
        if (t2 != null) for (var e2 in M2(t2)) n3.push(e2);
        return n3;
      }
      function Ah(t2) {
        return He.call(t2);
      }
      function Nu(t2, n3, e2) {
        return n3 = Q2(n3 === i4 ? t2.length - 1 : n3, 0), function() {
          for (var r2 = arguments, u2 = -1, o2 = Q2(r2.length - n3, 0), f2 = d3(o2); ++u2 < o2; ) f2[u2] = r2[n3 + u2];
          u2 = -1;
          for (var c2 = d3(n3 + 1); ++u2 < n3; ) c2[u2] = r2[u2];
          return c2[n3] = e2(f2), ct(t2, this, c2);
        };
      }
      function $u(t2, n3) {
        return n3.length < 2 ? t2 : wn2(t2, At(n3, 0, -1));
      }
      function Ih(t2, n3) {
        for (var e2 = t2.length, r2 = nt(n3.length, e2), u2 = ut(t2); r2--; ) {
          var o2 = n3[r2];
          t2[r2] = Xt(o2, e2) ? u2[o2] : i4;
        }
        return t2;
      }
      function Pi2(t2, n3) {
        if (!(n3 === "constructor" && typeof t2[n3] == "function") && n3 != "__proto__") return t2[n3];
      }
      var qu = Fu(uu), de2 = Uf2 || function(t2, n3) {
        return j2.setTimeout(t2, n3);
      }, Ci2 = Fu(Jc);
      function Uu(t2, n3, e2) {
        var r2 = n3 + "";
        return Ci2(t2, dh(r2, xh(hh(r2), e2)));
      }
      function Fu(t2) {
        var n3 = 0, e2 = 0;
        return function() {
          var r2 = Bf2(), u2 = Ga2 - (r2 - e2);
          if (e2 = r2, u2 > 0) {
            if (++n3 >= Ba2) return arguments[0];
          } else n3 = 0;
          return t2.apply(i4, arguments);
        };
      }
      function rr(t2, n3) {
        var e2 = -1, r2 = t2.length, u2 = r2 - 1;
        for (n3 = n3 === i4 ? r2 : n3; ++e2 < n3; ) {
          var o2 = ri(e2, u2), f2 = t2[o2];
          t2[o2] = t2[e2], t2[e2] = f2;
        }
        return t2.length = n3, t2;
      }
      var Wu = wh(function(t2) {
        var n3 = [];
        return t2.charCodeAt(0) === 46 && n3.push(""), t2.replace(ho, function(e2, r2, u2, o2) {
          n3.push(u2 ? o2.replace(Po, "$1") : r2 || e2);
        }), n3;
      });
      function Ft2(t2) {
        if (typeof t2 == "string" || pt(t2)) return t2;
        var n3 = t2 + "";
        return n3 == "0" && 1 / t2 == -pn ? "-0" : n3;
      }
      function Cn(t2) {
        if (t2 != null) {
          try {
            return Le.call(t2);
          } catch {
          }
          try {
            return t2 + "";
          } catch {
          }
        }
        return "";
      }
      function xh(t2, n3) {
        return mt(Xa, function(e2) {
          var r2 = "_." + e2[0];
          n3 & e2[1] && !Se(t2, r2) && t2.push(r2);
        }), t2.sort();
      }
      function Mu(t2) {
        if (t2 instanceof N2) return t2.clone();
        var n3 = new Pt(t2.__wrapped__, t2.__chain__);
        return n3.__actions__ = ut(t2.__actions__), n3.__index__ = t2.__index__, n3.__values__ = t2.__values__, n3;
      }
      function Eh(t2, n3, e2) {
        (e2 ? it(t2, n3, e2) : n3 === i4) ? n3 = 1 : n3 = Q2(T2(n3), 0);
        var r2 = t2 == null ? 0 : t2.length;
        if (!r2 || n3 < 1) return [];
        for (var u2 = 0, o2 = 0, f2 = d3(Fe(r2 / n3)); u2 < r2; ) f2[o2++] = At(t2, u2, u2 += n3);
        return f2;
      }
      function yh(t2) {
        for (var n3 = -1, e2 = t2 == null ? 0 : t2.length, r2 = 0, u2 = []; ++n3 < e2; ) {
          var o2 = t2[n3];
          o2 && (u2[r2++] = o2);
        }
        return u2;
      }
      function Sh() {
        var t2 = arguments.length;
        if (!t2) return [];
        for (var n3 = d3(t2 - 1), e2 = arguments[0], r2 = t2; r2--; ) n3[r2 - 1] = arguments[r2];
        return rn(b2(e2) ? ut(e2) : [e2], tt(n3, 1));
      }
      var Oh = H2(function(t2, n3) {
        return Y(t2) ? oe2(t2, tt(n3, 1, Y, true)) : [];
      }), Rh = H2(function(t2, n3) {
        var e2 = It(n3);
        return Y(e2) && (e2 = i4), Y(t2) ? oe2(t2, tt(n3, 1, Y, true), E2(e2, 2)) : [];
      }), bh = H2(function(t2, n3) {
        var e2 = It(n3);
        return Y(e2) && (e2 = i4), Y(t2) ? oe2(t2, tt(n3, 1, Y, true), i4, e2) : [];
      });
      function Th(t2, n3, e2) {
        var r2 = t2 == null ? 0 : t2.length;
        return r2 ? (n3 = e2 || n3 === i4 ? 1 : T2(n3), At(t2, n3 < 0 ? 0 : n3, r2)) : [];
      }
      function Lh(t2, n3, e2) {
        var r2 = t2 == null ? 0 : t2.length;
        return r2 ? (n3 = e2 || n3 === i4 ? 1 : T2(n3), n3 = r2 - n3, At(t2, 0, n3 < 0 ? 0 : n3)) : [];
      }
      function Hh(t2, n3) {
        return t2 && t2.length ? Xe2(t2, E2(n3, 3), true, true) : [];
      }
      function Dh(t2, n3) {
        return t2 && t2.length ? Xe2(t2, E2(n3, 3), true) : [];
      }
      function Nh(t2, n3, e2, r2) {
        var u2 = t2 == null ? 0 : t2.length;
        return u2 ? (e2 && typeof e2 != "number" && it(t2, n3, e2) && (e2 = 0, r2 = u2), Sc(t2, n3, e2, r2)) : [];
      }
      function Bu(t2, n3, e2) {
        var r2 = t2 == null ? 0 : t2.length;
        if (!r2) return -1;
        var u2 = e2 == null ? 0 : T2(e2);
        return u2 < 0 && (u2 = Q2(r2 + u2, 0)), Oe(t2, E2(n3, 3), u2);
      }
      function Gu(t2, n3, e2) {
        var r2 = t2 == null ? 0 : t2.length;
        if (!r2) return -1;
        var u2 = r2 - 1;
        return e2 !== i4 && (u2 = T2(e2), u2 = e2 < 0 ? Q2(r2 + u2, 0) : nt(u2, r2 - 1)), Oe(t2, E2(n3, 3), u2, true);
      }
      function zu(t2) {
        var n3 = t2 == null ? 0 : t2.length;
        return n3 ? tt(t2, 1) : [];
      }
      function $h(t2) {
        var n3 = t2 == null ? 0 : t2.length;
        return n3 ? tt(t2, pn) : [];
      }
      function qh(t2, n3) {
        var e2 = t2 == null ? 0 : t2.length;
        return e2 ? (n3 = n3 === i4 ? 1 : T2(n3), tt(t2, n3)) : [];
      }
      function Uh(t2) {
        for (var n3 = -1, e2 = t2 == null ? 0 : t2.length, r2 = {}; ++n3 < e2; ) {
          var u2 = t2[n3];
          r2[u2[0]] = u2[1];
        }
        return r2;
      }
      function Ku(t2) {
        return t2 && t2.length ? t2[0] : i4;
      }
      function Fh(t2, n3, e2) {
        var r2 = t2 == null ? 0 : t2.length;
        if (!r2) return -1;
        var u2 = e2 == null ? 0 : T2(e2);
        return u2 < 0 && (u2 = Q2(r2 + u2, 0)), Ln2(t2, n3, u2);
      }
      function Wh(t2) {
        var n3 = t2 == null ? 0 : t2.length;
        return n3 ? At(t2, 0, -1) : [];
      }
      var Mh = H2(function(t2) {
        var n3 = z3(t2, oi);
        return n3.length && n3[0] === t2[0] ? kr2(n3) : [];
      }), Bh = H2(function(t2) {
        var n3 = It(t2), e2 = z3(t2, oi);
        return n3 === It(e2) ? n3 = i4 : e2.pop(), e2.length && e2[0] === t2[0] ? kr2(e2, E2(n3, 2)) : [];
      }), Gh = H2(function(t2) {
        var n3 = It(t2), e2 = z3(t2, oi);
        return n3 = typeof n3 == "function" ? n3 : i4, n3 && e2.pop(), e2.length && e2[0] === t2[0] ? kr2(e2, i4, n3) : [];
      });
      function zh(t2, n3) {
        return t2 == null ? "" : Wf.call(t2, n3);
      }
      function It(t2) {
        var n3 = t2 == null ? 0 : t2.length;
        return n3 ? t2[n3 - 1] : i4;
      }
      function Kh(t2, n3, e2) {
        var r2 = t2 == null ? 0 : t2.length;
        if (!r2) return -1;
        var u2 = r2;
        return e2 !== i4 && (u2 = T2(e2), u2 = u2 < 0 ? Q2(r2 + u2, 0) : nt(u2, r2 - 1)), n3 === n3 ? xf2(t2, n3, u2) : Oe(t2, Es2, u2, true);
      }
      function Jh(t2, n3) {
        return t2 && t2.length ? eu(t2, T2(n3)) : i4;
      }
      var Yh = H2(Ju);
      function Ju(t2, n3) {
        return t2 && t2.length && n3 && n3.length ? ei(t2, n3) : t2;
      }
      function Zh(t2, n3, e2) {
        return t2 && t2.length && n3 && n3.length ? ei(t2, n3, E2(e2, 2)) : t2;
      }
      function Xh(t2, n3, e2) {
        return t2 && t2.length && n3 && n3.length ? ei(t2, n3, i4, e2) : t2;
      }
      var Qh = Zt2(function(t2, n3) {
        var e2 = t2 == null ? 0 : t2.length, r2 = Zr(t2, n3);
        return su(t2, z3(n3, function(u2) {
          return Xt(u2, e2) ? +u2 : u2;
        }).sort(gu)), r2;
      });
      function Vh(t2, n3) {
        var e2 = [];
        if (!(t2 && t2.length)) return e2;
        var r2 = -1, u2 = [], o2 = t2.length;
        for (n3 = E2(n3, 3); ++r2 < o2; ) {
          var f2 = t2[r2];
          n3(f2, r2, t2) && (e2.push(f2), u2.push(r2));
        }
        return su(t2, u2), e2;
      }
      function Ai(t2) {
        return t2 == null ? t2 : zf.call(t2);
      }
      function kh(t2, n3, e2) {
        var r2 = t2 == null ? 0 : t2.length;
        return r2 ? (e2 && typeof e2 != "number" && it(t2, n3, e2) ? (n3 = 0, e2 = r2) : (n3 = n3 == null ? 0 : T2(n3), e2 = e2 === i4 ? r2 : T2(e2)), At(t2, n3, e2)) : [];
      }
      function jh(t2, n3) {
        return Ze2(t2, n3);
      }
      function tl(t2, n3, e2) {
        return si(t2, n3, E2(e2, 2));
      }
      function nl(t2, n3) {
        var e2 = t2 == null ? 0 : t2.length;
        if (e2) {
          var r2 = Ze2(t2, n3);
          if (r2 < e2 && Rt(t2[r2], n3)) return r2;
        }
        return -1;
      }
      function el(t2, n3) {
        return Ze2(t2, n3, true);
      }
      function rl(t2, n3, e2) {
        return si(t2, n3, E2(e2, 2), true);
      }
      function il(t2, n3) {
        var e2 = t2 == null ? 0 : t2.length;
        if (e2) {
          var r2 = Ze2(t2, n3, true) - 1;
          if (Rt(t2[r2], n3)) return r2;
        }
        return -1;
      }
      function sl(t2) {
        return t2 && t2.length ? au(t2) : [];
      }
      function ul(t2, n3) {
        return t2 && t2.length ? au(t2, E2(n3, 2)) : [];
      }
      function al(t2) {
        var n3 = t2 == null ? 0 : t2.length;
        return n3 ? At(t2, 1, n3) : [];
      }
      function ol(t2, n3, e2) {
        return t2 && t2.length ? (n3 = e2 || n3 === i4 ? 1 : T2(n3), At(t2, 0, n3 < 0 ? 0 : n3)) : [];
      }
      function fl(t2, n3, e2) {
        var r2 = t2 == null ? 0 : t2.length;
        return r2 ? (n3 = e2 || n3 === i4 ? 1 : T2(n3), n3 = r2 - n3, At(t2, n3 < 0 ? 0 : n3, r2)) : [];
      }
      function cl(t2, n3) {
        return t2 && t2.length ? Xe2(t2, E2(n3, 3), false, true) : [];
      }
      function hl(t2, n3) {
        return t2 && t2.length ? Xe2(t2, E2(n3, 3)) : [];
      }
      var ll = H2(function(t2) {
        return on(tt(t2, 1, Y, true));
      }), pl = H2(function(t2) {
        var n3 = It(t2);
        return Y(n3) && (n3 = i4), on(tt(t2, 1, Y, true), E2(n3, 2));
      }), dl = H2(function(t2) {
        var n3 = It(t2);
        return n3 = typeof n3 == "function" ? n3 : i4, on(tt(t2, 1, Y, true), i4, n3);
      });
      function gl(t2) {
        return t2 && t2.length ? on(t2) : [];
      }
      function vl(t2, n3) {
        return t2 && t2.length ? on(t2, E2(n3, 2)) : [];
      }
      function _l(t2, n3) {
        return n3 = typeof n3 == "function" ? n3 : i4, t2 && t2.length ? on(t2, i4, n3) : [];
      }
      function Ii2(t2) {
        if (!(t2 && t2.length)) return [];
        var n3 = 0;
        return t2 = en2(t2, function(e2) {
          if (Y(e2)) return n3 = Q2(e2.length, n3), true;
        }), Wr(n3, function(e2) {
          return z3(t2, qr2(e2));
        });
      }
      function Yu(t2, n3) {
        if (!(t2 && t2.length)) return [];
        var e2 = Ii2(t2);
        return n3 == null ? e2 : z3(e2, function(r2) {
          return ct(n3, i4, r2);
        });
      }
      var ml = H2(function(t2, n3) {
        return Y(t2) ? oe2(t2, n3) : [];
      }), wl = H2(function(t2) {
        return ai(en2(t2, Y));
      }), Pl = H2(function(t2) {
        var n3 = It(t2);
        return Y(n3) && (n3 = i4), ai(en2(t2, Y), E2(n3, 2));
      }), Cl = H2(function(t2) {
        var n3 = It(t2);
        return n3 = typeof n3 == "function" ? n3 : i4, ai(en2(t2, Y), i4, n3);
      }), Al = H2(Ii2);
      function Il(t2, n3) {
        return hu2(t2 || [], n3 || [], ae2);
      }
      function xl(t2, n3) {
        return hu2(t2 || [], n3 || [], he2);
      }
      var El = H2(function(t2) {
        var n3 = t2.length, e2 = n3 > 1 ? t2[n3 - 1] : i4;
        return e2 = typeof e2 == "function" ? (t2.pop(), e2) : i4, Yu(t2, e2);
      });
      function Zu(t2) {
        var n3 = a2(t2);
        return n3.__chain__ = true, n3;
      }
      function yl(t2, n3) {
        return n3(t2), t2;
      }
      function ir2(t2, n3) {
        return n3(t2);
      }
      var Sl = Zt2(function(t2) {
        var n3 = t2.length, e2 = n3 ? t2[0] : 0, r2 = this.__wrapped__, u2 = function(o2) {
          return Zr(o2, t2);
        };
        return n3 > 1 || this.__actions__.length || !(r2 instanceof N2) || !Xt(e2) ? this.thru(u2) : (r2 = r2.slice(e2, +e2 + (n3 ? 1 : 0)), r2.__actions__.push({ func: ir2, args: [u2], thisArg: i4 }), new Pt(r2, this.__chain__).thru(function(o2) {
          return n3 && !o2.length && o2.push(i4), o2;
        }));
      });
      function Ol() {
        return Zu(this);
      }
      function Rl() {
        return new Pt(this.value(), this.__chain__);
      }
      function bl() {
        this.__values__ === i4 && (this.__values__ = oa2(this.value()));
        var t2 = this.__index__ >= this.__values__.length, n3 = t2 ? i4 : this.__values__[this.__index__++];
        return { done: t2, value: n3 };
      }
      function Tl() {
        return this;
      }
      function Ll(t2) {
        for (var n3, e2 = this; e2 instanceof Ge; ) {
          var r2 = Mu(e2);
          r2.__index__ = 0, r2.__values__ = i4, n3 ? u2.__wrapped__ = r2 : n3 = r2;
          var u2 = r2;
          e2 = e2.__wrapped__;
        }
        return u2.__wrapped__ = t2, n3;
      }
      function Hl() {
        var t2 = this.__wrapped__;
        if (t2 instanceof N2) {
          var n3 = t2;
          return this.__actions__.length && (n3 = new N2(this)), n3 = n3.reverse(), n3.__actions__.push({ func: ir2, args: [Ai], thisArg: i4 }), new Pt(n3, this.__chain__);
        }
        return this.thru(Ai);
      }
      function Dl() {
        return cu(this.__wrapped__, this.__actions__);
      }
      var Nl = Qe(function(t2, n3, e2) {
        W.call(t2, e2) ? ++t2[e2] : Jt2(t2, e2, 1);
      });
      function $l(t2, n3, e2) {
        var r2 = b2(t2) ? Is2 : yc;
        return e2 && it(t2, n3, e2) && (n3 = i4), r2(t2, E2(n3, 3));
      }
      function ql(t2, n3) {
        var e2 = b2(t2) ? en2 : Ys2;
        return e2(t2, E2(n3, 3));
      }
      var Ul = Cu(Bu), Fl = Cu(Gu);
      function Wl(t2, n3) {
        return tt(sr2(t2, n3), 1);
      }
      function Ml(t2, n3) {
        return tt(sr2(t2, n3), pn);
      }
      function Bl(t2, n3, e2) {
        return e2 = e2 === i4 ? 1 : T2(e2), tt(sr2(t2, n3), e2);
      }
      function Xu(t2, n3) {
        var e2 = b2(t2) ? mt : an;
        return e2(t2, E2(n3, 3));
      }
      function Qu(t2, n3) {
        var e2 = b2(t2) ? af2 : Js2;
        return e2(t2, E2(n3, 3));
      }
      var Gl = Qe(function(t2, n3, e2) {
        W.call(t2, e2) ? t2[e2].push(n3) : Jt2(t2, e2, [n3]);
      });
      function zl(t2, n3, e2, r2) {
        t2 = at(t2) ? t2 : zn2(t2), e2 = e2 && !r2 ? T2(e2) : 0;
        var u2 = t2.length;
        return e2 < 0 && (e2 = Q2(u2 + e2, 0)), cr2(t2) ? e2 <= u2 && t2.indexOf(n3, e2) > -1 : !!u2 && Ln2(t2, n3, e2) > -1;
      }
      var Kl = H2(function(t2, n3, e2) {
        var r2 = -1, u2 = typeof n3 == "function", o2 = at(t2) ? d3(t2.length) : [];
        return an(t2, function(f2) {
          o2[++r2] = u2 ? ct(n3, f2, e2) : fe2(f2, n3, e2);
        }), o2;
      }), Jl = Qe(function(t2, n3, e2) {
        Jt2(t2, e2, n3);
      });
      function sr2(t2, n3) {
        var e2 = b2(t2) ? z3 : js2;
        return e2(t2, E2(n3, 3));
      }
      function Yl(t2, n3, e2, r2) {
        return t2 == null ? [] : (b2(n3) || (n3 = n3 == null ? [] : [n3]), e2 = r2 ? i4 : e2, b2(e2) || (e2 = e2 == null ? [] : [e2]), ru(t2, n3, e2));
      }
      var Zl = Qe(function(t2, n3, e2) {
        t2[e2 ? 0 : 1].push(n3);
      }, function() {
        return [[], []];
      });
      function Xl(t2, n3, e2) {
        var r2 = b2(t2) ? Nr : Ss, u2 = arguments.length < 3;
        return r2(t2, E2(n3, 4), e2, u2, an);
      }
      function Ql(t2, n3, e2) {
        var r2 = b2(t2) ? of2 : Ss, u2 = arguments.length < 3;
        return r2(t2, E2(n3, 4), e2, u2, Js2);
      }
      function Vl(t2, n3) {
        var e2 = b2(t2) ? en2 : Ys2;
        return e2(t2, or2(E2(n3, 3)));
      }
      function kl(t2) {
        var n3 = b2(t2) ? Bs : zc;
        return n3(t2);
      }
      function jl(t2, n3, e2) {
        (e2 ? it(t2, n3, e2) : n3 === i4) ? n3 = 1 : n3 = T2(n3);
        var r2 = b2(t2) ? Cc : Kc;
        return r2(t2, n3);
      }
      function tp(t2) {
        var n3 = b2(t2) ? Ac : Yc;
        return n3(t2);
      }
      function np(t2) {
        if (t2 == null) return 0;
        if (at(t2)) return cr2(t2) ? Dn(t2) : t2.length;
        var n3 = et(t2);
        return n3 == Et || n3 == yt ? t2.size : ti(t2).length;
      }
      function ep(t2, n3, e2) {
        var r2 = b2(t2) ? $r : Zc;
        return e2 && it(t2, n3, e2) && (n3 = i4), r2(t2, E2(n3, 3));
      }
      var rp = H2(function(t2, n3) {
        if (t2 == null) return [];
        var e2 = n3.length;
        return e2 > 1 && it(t2, n3[0], n3[1]) ? n3 = [] : e2 > 2 && it(n3[0], n3[1], n3[2]) && (n3 = [n3[0]]), ru(t2, tt(n3, 1), []);
      }), ur2 = qf2 || function() {
        return j2.Date.now();
      };
      function ip(t2, n3) {
        if (typeof n3 != "function") throw new wt(O2);
        return t2 = T2(t2), function() {
          if (--t2 < 1) return n3.apply(this, arguments);
        };
      }
      function Vu(t2, n3, e2) {
        return n3 = e2 ? i4 : n3, n3 = t2 && n3 == null ? t2.length : n3, Yt(t2, Bt, i4, i4, i4, i4, n3);
      }
      function ku(t2, n3) {
        var e2;
        if (typeof n3 != "function") throw new wt(O2);
        return t2 = T2(t2), function() {
          return --t2 > 0 && (e2 = n3.apply(this, arguments)), t2 <= 1 && (n3 = i4), e2;
        };
      }
      var xi2 = H2(function(t2, n3, e2) {
        var r2 = vt;
        if (e2.length) {
          var u2 = sn(e2, Bn(xi2));
          r2 |= Nt2;
        }
        return Yt(t2, r2, n3, e2, u2);
      }), ju = H2(function(t2, n3, e2) {
        var r2 = vt | ln;
        if (e2.length) {
          var u2 = sn(e2, Bn(ju));
          r2 |= Nt2;
        }
        return Yt(n3, r2, t2, e2, u2);
      });
      function ta2(t2, n3, e2) {
        n3 = e2 ? i4 : n3;
        var r2 = Yt(t2, Dt2, i4, i4, i4, i4, i4, n3);
        return r2.placeholder = ta2.placeholder, r2;
      }
      function na2(t2, n3, e2) {
        n3 = e2 ? i4 : n3;
        var r2 = Yt(t2, Sn, i4, i4, i4, i4, i4, n3);
        return r2.placeholder = na2.placeholder, r2;
      }
      function ea2(t2, n3, e2) {
        var r2, u2, o2, f2, c2, l2, v2 = 0, _2 = false, m3 = false, C2 = true;
        if (typeof t2 != "function") throw new wt(O2);
        n3 = xt(n3) || 0, K2(e2) && (_2 = !!e2.leading, m3 = "maxWait" in e2, o2 = m3 ? Q2(xt(e2.maxWait) || 0, n3) : o2, C2 = "trailing" in e2 ? !!e2.trailing : C2);
        function I2(Z) {
          var bt = r2, kt2 = u2;
          return r2 = u2 = i4, v2 = Z, f2 = t2.apply(kt2, bt), f2;
        }
        function y3(Z) {
          return v2 = Z, c2 = de2(D, n3), _2 ? I2(Z) : f2;
        }
        function L3(Z) {
          var bt = Z - l2, kt2 = Z - v2, Ca2 = n3 - bt;
          return m3 ? nt(Ca2, o2 - kt2) : Ca2;
        }
        function S2(Z) {
          var bt = Z - l2, kt2 = Z - v2;
          return l2 === i4 || bt >= n3 || bt < 0 || m3 && kt2 >= o2;
        }
        function D() {
          var Z = ur2();
          if (S2(Z)) return $2(Z);
          c2 = de2(D, L3(Z));
        }
        function $2(Z) {
          return c2 = i4, C2 && r2 ? I2(Z) : (r2 = u2 = i4, f2);
        }
        function dt() {
          c2 !== i4 && lu(c2), v2 = 0, r2 = l2 = u2 = c2 = i4;
        }
        function st() {
          return c2 === i4 ? f2 : $2(ur2());
        }
        function gt() {
          var Z = ur2(), bt = S2(Z);
          if (r2 = arguments, u2 = this, l2 = Z, bt) {
            if (c2 === i4) return y3(l2);
            if (m3) return lu(c2), c2 = de2(D, n3), I2(l2);
          }
          return c2 === i4 && (c2 = de2(D, n3)), f2;
        }
        return gt.cancel = dt, gt.flush = st, gt;
      }
      var sp = H2(function(t2, n3) {
        return Ks(t2, 1, n3);
      }), up = H2(function(t2, n3, e2) {
        return Ks(t2, xt(n3) || 0, e2);
      });
      function ap(t2) {
        return Yt(t2, gr);
      }
      function ar2(t2, n3) {
        if (typeof t2 != "function" || n3 != null && typeof n3 != "function") throw new wt(O2);
        var e2 = function() {
          var r2 = arguments, u2 = n3 ? n3.apply(this, r2) : r2[0], o2 = e2.cache;
          if (o2.has(u2)) return o2.get(u2);
          var f2 = t2.apply(this, r2);
          return e2.cache = o2.set(u2, f2) || o2, f2;
        };
        return e2.cache = new (ar2.Cache || Kt2)(), e2;
      }
      ar2.Cache = Kt2;
      function or2(t2) {
        if (typeof t2 != "function") throw new wt(O2);
        return function() {
          var n3 = arguments;
          switch (n3.length) {
            case 0:
              return !t2.call(this);
            case 1:
              return !t2.call(this, n3[0]);
            case 2:
              return !t2.call(this, n3[0], n3[1]);
            case 3:
              return !t2.call(this, n3[0], n3[1], n3[2]);
          }
          return !t2.apply(this, n3);
        };
      }
      function op(t2) {
        return ku(2, t2);
      }
      var fp = Xc(function(t2, n3) {
        n3 = n3.length == 1 && b2(n3[0]) ? z3(n3[0], ht(E2())) : z3(tt(n3, 1), ht(E2()));
        var e2 = n3.length;
        return H2(function(r2) {
          for (var u2 = -1, o2 = nt(r2.length, e2); ++u2 < o2; ) r2[u2] = n3[u2].call(this, r2[u2]);
          return ct(t2, this, r2);
        });
      }), Ei2 = H2(function(t2, n3) {
        var e2 = sn(n3, Bn(Ei2));
        return Yt(t2, Nt2, i4, n3, e2);
      }), ra2 = H2(function(t2, n3) {
        var e2 = sn(n3, Bn(ra2));
        return Yt(t2, On, i4, n3, e2);
      }), cp = Zt2(function(t2, n3) {
        return Yt(t2, Yn2, i4, i4, i4, n3);
      });
      function hp(t2, n3) {
        if (typeof t2 != "function") throw new wt(O2);
        return n3 = n3 === i4 ? n3 : T2(n3), H2(t2, n3);
      }
      function lp(t2, n3) {
        if (typeof t2 != "function") throw new wt(O2);
        return n3 = n3 == null ? 0 : Q2(T2(n3), 0), H2(function(e2) {
          var r2 = e2[n3], u2 = cn(e2, 0, n3);
          return r2 && rn(u2, r2), ct(t2, this, u2);
        });
      }
      function pp(t2, n3, e2) {
        var r2 = true, u2 = true;
        if (typeof t2 != "function") throw new wt(O2);
        return K2(e2) && (r2 = "leading" in e2 ? !!e2.leading : r2, u2 = "trailing" in e2 ? !!e2.trailing : u2), ea2(t2, n3, { leading: r2, maxWait: n3, trailing: u2 });
      }
      function dp(t2) {
        return Vu(t2, 1);
      }
      function gp(t2, n3) {
        return Ei2(fi(n3), t2);
      }
      function vp() {
        if (!arguments.length) return [];
        var t2 = arguments[0];
        return b2(t2) ? t2 : [t2];
      }
      function _p(t2) {
        return Ct(t2, En);
      }
      function mp(t2, n3) {
        return n3 = typeof n3 == "function" ? n3 : i4, Ct(t2, En, n3);
      }
      function wp(t2) {
        return Ct(t2, Ht2 | En);
      }
      function Pp(t2, n3) {
        return n3 = typeof n3 == "function" ? n3 : i4, Ct(t2, Ht2 | En, n3);
      }
      function Cp(t2, n3) {
        return n3 == null || zs2(t2, n3, V2(n3));
      }
      function Rt(t2, n3) {
        return t2 === n3 || t2 !== t2 && n3 !== n3;
      }
      var Ap = tr(Vr), Ip = tr(function(t2, n3) {
        return t2 >= n3;
      }), An2 = Qs2(/* @__PURE__ */ (function() {
        return arguments;
      })()) ? Qs2 : function(t2) {
        return J(t2) && W.call(t2, "callee") && !$s2.call(t2, "callee");
      }, b2 = d3.isArray, xp = _s2 ? ht(_s2) : Lc;
      function at(t2) {
        return t2 != null && fr2(t2.length) && !Qt(t2);
      }
      function Y(t2) {
        return J(t2) && at(t2);
      }
      function Ep(t2) {
        return t2 === true || t2 === false || J(t2) && rt(t2) == Zn2;
      }
      var hn = Ff2 || $i, yp = ms ? ht(ms) : Hc;
      function Sp(t2) {
        return J(t2) && t2.nodeType === 1 && !ge(t2);
      }
      function Op(t2) {
        if (t2 == null) return true;
        if (at(t2) && (b2(t2) || typeof t2 == "string" || typeof t2.splice == "function" || hn(t2) || Gn2(t2) || An2(t2))) return !t2.length;
        var n3 = et(t2);
        if (n3 == Et || n3 == yt) return !t2.size;
        if (pe2(t2)) return !ti(t2).length;
        for (var e2 in t2) if (W.call(t2, e2)) return false;
        return true;
      }
      function Rp(t2, n3) {
        return ce2(t2, n3);
      }
      function bp(t2, n3, e2) {
        e2 = typeof e2 == "function" ? e2 : i4;
        var r2 = e2 ? e2(t2, n3) : i4;
        return r2 === i4 ? ce2(t2, n3, i4, e2) : !!r2;
      }
      function yi(t2) {
        if (!J(t2)) return false;
        var n3 = rt(t2);
        return n3 == Ce2 || n3 == Va2 || typeof t2.message == "string" && typeof t2.name == "string" && !ge(t2);
      }
      function Tp(t2) {
        return typeof t2 == "number" && Us(t2);
      }
      function Qt(t2) {
        if (!K2(t2)) return false;
        var n3 = rt(t2);
        return n3 == Ae2 || n3 == Ki2 || n3 == Qa2 || n3 == ja2;
      }
      function ia2(t2) {
        return typeof t2 == "number" && t2 == T2(t2);
      }
      function fr2(t2) {
        return typeof t2 == "number" && t2 > -1 && t2 % 1 == 0 && t2 <= nn;
      }
      function K2(t2) {
        var n3 = typeof t2;
        return t2 != null && (n3 == "object" || n3 == "function");
      }
      function J(t2) {
        return t2 != null && typeof t2 == "object";
      }
      var sa2 = ws ? ht(ws) : Nc;
      function Lp(t2, n3) {
        return t2 === n3 || jr2(t2, n3, vi(n3));
      }
      function Hp(t2, n3, e2) {
        return e2 = typeof e2 == "function" ? e2 : i4, jr2(t2, n3, vi(n3), e2);
      }
      function Dp(t2) {
        return ua2(t2) && t2 != +t2;
      }
      function Np(t2) {
        if (mh(t2)) throw new R2(x2);
        return Vs2(t2);
      }
      function $p(t2) {
        return t2 === null;
      }
      function qp(t2) {
        return t2 == null;
      }
      function ua2(t2) {
        return typeof t2 == "number" || J(t2) && rt(t2) == Qn;
      }
      function ge(t2) {
        if (!J(t2) || rt(t2) != Gt2) return false;
        var n3 = $e(t2);
        if (n3 === null) return true;
        var e2 = W.call(n3, "constructor") && n3.constructor;
        return typeof e2 == "function" && e2 instanceof e2 && Le.call(e2) == Hf;
      }
      var Si = Ps2 ? ht(Ps2) : $c;
      function Up(t2) {
        return ia2(t2) && t2 >= -nn && t2 <= nn;
      }
      var aa2 = Cs ? ht(Cs) : qc;
      function cr2(t2) {
        return typeof t2 == "string" || !b2(t2) && J(t2) && rt(t2) == kn2;
      }
      function pt(t2) {
        return typeof t2 == "symbol" || J(t2) && rt(t2) == Ie;
      }
      var Gn2 = As ? ht(As) : Uc;
      function Fp(t2) {
        return t2 === i4;
      }
      function Wp(t2) {
        return J(t2) && et(t2) == jn2;
      }
      function Mp(t2) {
        return J(t2) && rt(t2) == no;
      }
      var Bp = tr(ni), Gp = tr(function(t2, n3) {
        return t2 <= n3;
      });
      function oa2(t2) {
        if (!t2) return [];
        if (at(t2)) return cr2(t2) ? St(t2) : ut(t2);
        if (ee2 && t2[ee2]) return Cf2(t2[ee2]());
        var n3 = et(t2), e2 = n3 == Et ? Br : n3 == yt ? Re2 : zn2;
        return e2(t2);
      }
      function Vt(t2) {
        if (!t2) return t2 === 0 ? t2 : 0;
        if (t2 = xt(t2), t2 === pn || t2 === -pn) {
          var n3 = t2 < 0 ? -1 : 1;
          return n3 * Ja2;
        }
        return t2 === t2 ? t2 : 0;
      }
      function T2(t2) {
        var n3 = Vt(t2), e2 = n3 % 1;
        return n3 === n3 ? e2 ? n3 - e2 : n3 : 0;
      }
      function fa2(t2) {
        return t2 ? mn(T2(t2), 0, $t2) : 0;
      }
      function xt(t2) {
        if (typeof t2 == "number") return t2;
        if (pt(t2)) return we2;
        if (K2(t2)) {
          var n3 = typeof t2.valueOf == "function" ? t2.valueOf() : t2;
          t2 = K2(n3) ? n3 + "" : n3;
        }
        if (typeof t2 != "string") return t2 === 0 ? t2 : +t2;
        t2 = Os(t2);
        var e2 = Io.test(t2);
        return e2 || Eo.test(t2) ? rf(t2.slice(2), e2 ? 2 : 8) : Ao.test(t2) ? we2 : +t2;
      }
      function ca2(t2) {
        return Ut2(t2, ot(t2));
      }
      function zp(t2) {
        return t2 ? mn(T2(t2), -nn, nn) : t2 === 0 ? t2 : 0;
      }
      function U(t2) {
        return t2 == null ? "" : lt(t2);
      }
      var Kp = Wn2(function(t2, n3) {
        if (pe2(n3) || at(n3)) {
          Ut2(n3, V2(n3), t2);
          return;
        }
        for (var e2 in n3) W.call(n3, e2) && ae2(t2, e2, n3[e2]);
      }), ha2 = Wn2(function(t2, n3) {
        Ut2(n3, ot(n3), t2);
      }), hr2 = Wn2(function(t2, n3, e2, r2) {
        Ut2(n3, ot(n3), t2, r2);
      }), Jp = Wn2(function(t2, n3, e2, r2) {
        Ut2(n3, V2(n3), t2, r2);
      }), Yp = Zt2(Zr);
      function Zp(t2, n3) {
        var e2 = Fn(t2);
        return n3 == null ? e2 : Gs2(e2, n3);
      }
      var Xp = H2(function(t2, n3) {
        t2 = M2(t2);
        var e2 = -1, r2 = n3.length, u2 = r2 > 2 ? n3[2] : i4;
        for (u2 && it(n3[0], n3[1], u2) && (r2 = 1); ++e2 < r2; ) for (var o2 = n3[e2], f2 = ot(o2), c2 = -1, l2 = f2.length; ++c2 < l2; ) {
          var v2 = f2[c2], _2 = t2[v2];
          (_2 === i4 || Rt(_2, $n2[v2]) && !W.call(t2, v2)) && (t2[v2] = o2[v2]);
        }
        return t2;
      }), Qp = H2(function(t2) {
        return t2.push(i4, Ou), ct(la2, i4, t2);
      });
      function Vp(t2, n3) {
        return xs(t2, E2(n3, 3), qt);
      }
      function kp(t2, n3) {
        return xs(t2, E2(n3, 3), Qr2);
      }
      function jp(t2, n3) {
        return t2 == null ? t2 : Xr(t2, E2(n3, 3), ot);
      }
      function td(t2, n3) {
        return t2 == null ? t2 : Zs2(t2, E2(n3, 3), ot);
      }
      function nd(t2, n3) {
        return t2 && qt(t2, E2(n3, 3));
      }
      function ed(t2, n3) {
        return t2 && Qr2(t2, E2(n3, 3));
      }
      function rd(t2) {
        return t2 == null ? [] : Je(t2, V2(t2));
      }
      function id(t2) {
        return t2 == null ? [] : Je(t2, ot(t2));
      }
      function Oi2(t2, n3, e2) {
        var r2 = t2 == null ? i4 : wn2(t2, n3);
        return r2 === i4 ? e2 : r2;
      }
      function sd(t2, n3) {
        return t2 != null && Tu(t2, n3, Oc);
      }
      function Ri(t2, n3) {
        return t2 != null && Tu(t2, n3, Rc);
      }
      var ud = Iu(function(t2, n3, e2) {
        n3 != null && typeof n3.toString != "function" && (n3 = He.call(n3)), t2[n3] = e2;
      }, Ti2(ft)), ad = Iu(function(t2, n3, e2) {
        n3 != null && typeof n3.toString != "function" && (n3 = He.call(n3)), W.call(t2, n3) ? t2[n3].push(e2) : t2[n3] = [e2];
      }, E2), od = H2(fe2);
      function V2(t2) {
        return at(t2) ? Ms(t2) : ti(t2);
      }
      function ot(t2) {
        return at(t2) ? Ms(t2, true) : Fc(t2);
      }
      function fd(t2, n3) {
        var e2 = {};
        return n3 = E2(n3, 3), qt(t2, function(r2, u2, o2) {
          Jt2(e2, n3(r2, u2, o2), r2);
        }), e2;
      }
      function cd(t2, n3) {
        var e2 = {};
        return n3 = E2(n3, 3), qt(t2, function(r2, u2, o2) {
          Jt2(e2, u2, n3(r2, u2, o2));
        }), e2;
      }
      var hd = Wn2(function(t2, n3, e2) {
        Ye(t2, n3, e2);
      }), la2 = Wn2(function(t2, n3, e2, r2) {
        Ye(t2, n3, e2, r2);
      }), ld = Zt2(function(t2, n3) {
        var e2 = {};
        if (t2 == null) return e2;
        var r2 = false;
        n3 = z3(n3, function(o2) {
          return o2 = fn2(o2, t2), r2 || (r2 = o2.length > 1), o2;
        }), Ut2(t2, di(t2), e2), r2 && (e2 = Ct(e2, Ht2 | Mt | En, uh));
        for (var u2 = n3.length; u2--; ) ui(e2, n3[u2]);
        return e2;
      });
      function pd(t2, n3) {
        return pa2(t2, or2(E2(n3)));
      }
      var dd = Zt2(function(t2, n3) {
        return t2 == null ? {} : Mc(t2, n3);
      });
      function pa2(t2, n3) {
        if (t2 == null) return {};
        var e2 = z3(di(t2), function(r2) {
          return [r2];
        });
        return n3 = E2(n3), iu(t2, e2, function(r2, u2) {
          return n3(r2, u2[0]);
        });
      }
      function gd(t2, n3, e2) {
        n3 = fn2(n3, t2);
        var r2 = -1, u2 = n3.length;
        for (u2 || (u2 = 1, t2 = i4); ++r2 < u2; ) {
          var o2 = t2 == null ? i4 : t2[Ft2(n3[r2])];
          o2 === i4 && (r2 = u2, o2 = e2), t2 = Qt(o2) ? o2.call(t2) : o2;
        }
        return t2;
      }
      function vd(t2, n3, e2) {
        return t2 == null ? t2 : he2(t2, n3, e2);
      }
      function _d2(t2, n3, e2, r2) {
        return r2 = typeof r2 == "function" ? r2 : i4, t2 == null ? t2 : he2(t2, n3, e2, r2);
      }
      var da2 = yu(V2), ga2 = yu(ot);
      function md(t2, n3, e2) {
        var r2 = b2(t2), u2 = r2 || hn(t2) || Gn2(t2);
        if (n3 = E2(n3, 4), e2 == null) {
          var o2 = t2 && t2.constructor;
          u2 ? e2 = r2 ? new o2() : [] : K2(t2) ? e2 = Qt(o2) ? Fn($e(t2)) : {} : e2 = {};
        }
        return (u2 ? mt : qt)(t2, function(f2, c2, l2) {
          return n3(e2, f2, c2, l2);
        }), e2;
      }
      function wd(t2, n3) {
        return t2 == null ? true : ui(t2, n3);
      }
      function Pd(t2, n3, e2) {
        return t2 == null ? t2 : fu(t2, n3, fi(e2));
      }
      function Cd(t2, n3, e2, r2) {
        return r2 = typeof r2 == "function" ? r2 : i4, t2 == null ? t2 : fu(t2, n3, fi(e2), r2);
      }
      function zn2(t2) {
        return t2 == null ? [] : Mr2(t2, V2(t2));
      }
      function Ad(t2) {
        return t2 == null ? [] : Mr2(t2, ot(t2));
      }
      function Id(t2, n3, e2) {
        return e2 === i4 && (e2 = n3, n3 = i4), e2 !== i4 && (e2 = xt(e2), e2 = e2 === e2 ? e2 : 0), n3 !== i4 && (n3 = xt(n3), n3 = n3 === n3 ? n3 : 0), mn(xt(t2), n3, e2);
      }
      function xd(t2, n3, e2) {
        return n3 = Vt(n3), e2 === i4 ? (e2 = n3, n3 = 0) : e2 = Vt(e2), t2 = xt(t2), bc(t2, n3, e2);
      }
      function Ed(t2, n3, e2) {
        if (e2 && typeof e2 != "boolean" && it(t2, n3, e2) && (n3 = e2 = i4), e2 === i4 && (typeof n3 == "boolean" ? (e2 = n3, n3 = i4) : typeof t2 == "boolean" && (e2 = t2, t2 = i4)), t2 === i4 && n3 === i4 ? (t2 = 0, n3 = 1) : (t2 = Vt(t2), n3 === i4 ? (n3 = t2, t2 = 0) : n3 = Vt(n3)), t2 > n3) {
          var r2 = t2;
          t2 = n3, n3 = r2;
        }
        if (e2 || t2 % 1 || n3 % 1) {
          var u2 = Fs2();
          return nt(t2 + u2 * (n3 - t2 + ef("1e-" + ((u2 + "").length - 1))), n3);
        }
        return ri(t2, n3);
      }
      var yd = Mn(function(t2, n3, e2) {
        return n3 = n3.toLowerCase(), t2 + (e2 ? va2(n3) : n3);
      });
      function va2(t2) {
        return bi(U(t2).toLowerCase());
      }
      function _a3(t2) {
        return t2 = U(t2), t2 && t2.replace(So, vf2).replace(Jo, "");
      }
      function Sd(t2, n3, e2) {
        t2 = U(t2), n3 = lt(n3);
        var r2 = t2.length;
        e2 = e2 === i4 ? r2 : mn(T2(e2), 0, r2);
        var u2 = e2;
        return e2 -= n3.length, e2 >= 0 && t2.slice(e2, u2) == n3;
      }
      function Od(t2) {
        return t2 = U(t2), t2 && uo.test(t2) ? t2.replace(Zi, _f3) : t2;
      }
      function Rd(t2) {
        return t2 = U(t2), t2 && lo.test(t2) ? t2.replace(Er2, "\\$&") : t2;
      }
      var bd = Mn(function(t2, n3, e2) {
        return t2 + (e2 ? "-" : "") + n3.toLowerCase();
      }), Td = Mn(function(t2, n3, e2) {
        return t2 + (e2 ? " " : "") + n3.toLowerCase();
      }), Ld = Pu("toLowerCase");
      function Hd(t2, n3, e2) {
        t2 = U(t2), n3 = T2(n3);
        var r2 = n3 ? Dn(t2) : 0;
        if (!n3 || r2 >= n3) return t2;
        var u2 = (n3 - r2) / 2;
        return je(We(u2), e2) + t2 + je(Fe(u2), e2);
      }
      function Dd(t2, n3, e2) {
        t2 = U(t2), n3 = T2(n3);
        var r2 = n3 ? Dn(t2) : 0;
        return n3 && r2 < n3 ? t2 + je(n3 - r2, e2) : t2;
      }
      function Nd(t2, n3, e2) {
        t2 = U(t2), n3 = T2(n3);
        var r2 = n3 ? Dn(t2) : 0;
        return n3 && r2 < n3 ? je(n3 - r2, e2) + t2 : t2;
      }
      function $d(t2, n3, e2) {
        return e2 || n3 == null ? n3 = 0 : n3 && (n3 = +n3), Gf(U(t2).replace(yr, ""), n3 || 0);
      }
      function qd(t2, n3, e2) {
        return (e2 ? it(t2, n3, e2) : n3 === i4) ? n3 = 1 : n3 = T2(n3), ii(U(t2), n3);
      }
      function Ud() {
        var t2 = arguments, n3 = U(t2[0]);
        return t2.length < 3 ? n3 : n3.replace(t2[1], t2[2]);
      }
      var Fd = Mn(function(t2, n3, e2) {
        return t2 + (e2 ? "_" : "") + n3.toLowerCase();
      });
      function Wd(t2, n3, e2) {
        return e2 && typeof e2 != "number" && it(t2, n3, e2) && (n3 = e2 = i4), e2 = e2 === i4 ? $t2 : e2 >>> 0, e2 ? (t2 = U(t2), t2 && (typeof n3 == "string" || n3 != null && !Si(n3)) && (n3 = lt(n3), !n3 && Hn2(t2)) ? cn(St(t2), 0, e2) : t2.split(n3, e2)) : [];
      }
      var Md = Mn(function(t2, n3, e2) {
        return t2 + (e2 ? " " : "") + bi(n3);
      });
      function Bd(t2, n3, e2) {
        return t2 = U(t2), e2 = e2 == null ? 0 : mn(T2(e2), 0, t2.length), n3 = lt(n3), t2.slice(e2, e2 + n3.length) == n3;
      }
      function Gd(t2, n3, e2) {
        var r2 = a2.templateSettings;
        e2 && it(t2, n3, e2) && (n3 = i4), t2 = U(t2), n3 = hr2({}, n3, r2, Su);
        var u2 = hr2({}, n3.imports, r2.imports, Su), o2 = V2(u2), f2 = Mr2(u2, o2), c2, l2, v2 = 0, _2 = n3.interpolate || xe, m3 = "__p += '", C2 = Gr2((n3.escape || xe).source + "|" + _2.source + "|" + (_2 === Xi ? Co : xe).source + "|" + (n3.evaluate || xe).source + "|$", "g"), I2 = "//# sourceURL=" + (W.call(n3, "sourceURL") ? (n3.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Vo + "]") + `
`;
        t2.replace(C2, function(S2, D, $2, dt, st, gt) {
          return $2 || ($2 = dt), m3 += t2.slice(v2, gt).replace(Oo, mf2), D && (c2 = true, m3 += `' +
__e(` + D + `) +
'`), st && (l2 = true, m3 += `';
` + st + `;
__p += '`), $2 && (m3 += `' +
((__t = (` + $2 + `)) == null ? '' : __t) +
'`), v2 = gt + S2.length, S2;
        }), m3 += `';
`;
        var y3 = W.call(n3, "variable") && n3.variable;
        if (!y3) m3 = `with (obj) {
` + m3 + `
}
`;
        else if (wo.test(y3)) throw new R2(k2);
        m3 = (l2 ? m3.replace(eo, "") : m3).replace(ro, "$1").replace(io, "$1;"), m3 = "function(" + (y3 || "obj") + `) {
` + (y3 ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (c2 ? ", __e = _.escape" : "") + (l2 ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + m3 + `return __p
}`;
        var L3 = wa2(function() {
          return q(o2, I2 + "return " + m3).apply(i4, f2);
        });
        if (L3.source = m3, yi(L3)) throw L3;
        return L3;
      }
      function zd(t2) {
        return U(t2).toLowerCase();
      }
      function Kd(t2) {
        return U(t2).toUpperCase();
      }
      function Jd(t2, n3, e2) {
        if (t2 = U(t2), t2 && (e2 || n3 === i4)) return Os(t2);
        if (!t2 || !(n3 = lt(n3))) return t2;
        var r2 = St(t2), u2 = St(n3), o2 = Rs(r2, u2), f2 = bs(r2, u2) + 1;
        return cn(r2, o2, f2).join("");
      }
      function Yd(t2, n3, e2) {
        if (t2 = U(t2), t2 && (e2 || n3 === i4)) return t2.slice(0, Ls2(t2) + 1);
        if (!t2 || !(n3 = lt(n3))) return t2;
        var r2 = St(t2), u2 = bs(r2, St(n3)) + 1;
        return cn(r2, 0, u2).join("");
      }
      function Zd(t2, n3, e2) {
        if (t2 = U(t2), t2 && (e2 || n3 === i4)) return t2.replace(yr, "");
        if (!t2 || !(n3 = lt(n3))) return t2;
        var r2 = St(t2), u2 = Rs(r2, St(n3));
        return cn(r2, u2).join("");
      }
      function Xd(t2, n3) {
        var e2 = Wa, r2 = Ma2;
        if (K2(n3)) {
          var u2 = "separator" in n3 ? n3.separator : u2;
          e2 = "length" in n3 ? T2(n3.length) : e2, r2 = "omission" in n3 ? lt(n3.omission) : r2;
        }
        t2 = U(t2);
        var o2 = t2.length;
        if (Hn2(t2)) {
          var f2 = St(t2);
          o2 = f2.length;
        }
        if (e2 >= o2) return t2;
        var c2 = e2 - Dn(r2);
        if (c2 < 1) return r2;
        var l2 = f2 ? cn(f2, 0, c2).join("") : t2.slice(0, c2);
        if (u2 === i4) return l2 + r2;
        if (f2 && (c2 += l2.length - c2), Si(u2)) {
          if (t2.slice(c2).search(u2)) {
            var v2, _2 = l2;
            for (u2.global || (u2 = Gr2(u2.source, U(Qi.exec(u2)) + "g")), u2.lastIndex = 0; v2 = u2.exec(_2); ) var m3 = v2.index;
            l2 = l2.slice(0, m3 === i4 ? c2 : m3);
          }
        } else if (t2.indexOf(lt(u2), c2) != c2) {
          var C2 = l2.lastIndexOf(u2);
          C2 > -1 && (l2 = l2.slice(0, C2));
        }
        return l2 + r2;
      }
      function Qd(t2) {
        return t2 = U(t2), t2 && so.test(t2) ? t2.replace(Yi2, Ef2) : t2;
      }
      var Vd = Mn(function(t2, n3, e2) {
        return t2 + (e2 ? " " : "") + n3.toUpperCase();
      }), bi = Pu("toUpperCase");
      function ma2(t2, n3, e2) {
        return t2 = U(t2), n3 = e2 ? i4 : n3, n3 === i4 ? Pf2(t2) ? Of2(t2) : hf(t2) : t2.match(n3) || [];
      }
      var wa2 = H2(function(t2, n3) {
        try {
          return ct(t2, i4, n3);
        } catch (e2) {
          return yi(e2) ? e2 : new R2(e2);
        }
      }), kd = Zt2(function(t2, n3) {
        return mt(n3, function(e2) {
          e2 = Ft2(e2), Jt2(t2, e2, xi2(t2[e2], t2));
        }), t2;
      });
      function jd(t2) {
        var n3 = t2 == null ? 0 : t2.length, e2 = E2();
        return t2 = n3 ? z3(t2, function(r2) {
          if (typeof r2[1] != "function") throw new wt(O2);
          return [e2(r2[0]), r2[1]];
        }) : [], H2(function(r2) {
          for (var u2 = -1; ++u2 < n3; ) {
            var o2 = t2[u2];
            if (ct(o2[0], this, r2)) return ct(o2[1], this, r2);
          }
        });
      }
      function tg(t2) {
        return Ec(Ct(t2, Ht2));
      }
      function Ti2(t2) {
        return function() {
          return t2;
        };
      }
      function ng(t2, n3) {
        return t2 == null || t2 !== t2 ? n3 : t2;
      }
      var eg = Au(), rg = Au(true);
      function ft(t2) {
        return t2;
      }
      function Li2(t2) {
        return ks2(typeof t2 == "function" ? t2 : Ct(t2, Ht2));
      }
      function ig(t2) {
        return tu(Ct(t2, Ht2));
      }
      function sg(t2, n3) {
        return nu(t2, Ct(n3, Ht2));
      }
      var ug = H2(function(t2, n3) {
        return function(e2) {
          return fe2(e2, t2, n3);
        };
      }), ag = H2(function(t2, n3) {
        return function(e2) {
          return fe2(t2, e2, n3);
        };
      });
      function Hi2(t2, n3, e2) {
        var r2 = V2(n3), u2 = Je(n3, r2);
        e2 == null && !(K2(n3) && (u2.length || !r2.length)) && (e2 = n3, n3 = t2, t2 = this, u2 = Je(n3, V2(n3)));
        var o2 = !(K2(e2) && "chain" in e2) || !!e2.chain, f2 = Qt(t2);
        return mt(u2, function(c2) {
          var l2 = n3[c2];
          t2[c2] = l2, f2 && (t2.prototype[c2] = function() {
            var v2 = this.__chain__;
            if (o2 || v2) {
              var _2 = t2(this.__wrapped__), m3 = _2.__actions__ = ut(this.__actions__);
              return m3.push({ func: l2, args: arguments, thisArg: t2 }), _2.__chain__ = v2, _2;
            }
            return l2.apply(t2, rn([this.value()], arguments));
          });
        }), t2;
      }
      function og() {
        return j2._ === this && (j2._ = Df2), this;
      }
      function Di2() {
      }
      function fg(t2) {
        return t2 = T2(t2), H2(function(n3) {
          return eu(n3, t2);
        });
      }
      var cg = hi(z3), hg = hi(Is2), lg = hi($r);
      function Pa2(t2) {
        return mi2(t2) ? qr2(Ft2(t2)) : Bc(t2);
      }
      function pg(t2) {
        return function(n3) {
          return t2 == null ? i4 : wn2(t2, n3);
        };
      }
      var dg = xu(), gg = xu(true);
      function Ni2() {
        return [];
      }
      function $i() {
        return false;
      }
      function vg() {
        return {};
      }
      function _g2() {
        return "";
      }
      function mg() {
        return true;
      }
      function wg(t2, n3) {
        if (t2 = T2(t2), t2 < 1 || t2 > nn) return [];
        var e2 = $t2, r2 = nt(t2, $t2);
        n3 = E2(n3), t2 -= $t2;
        for (var u2 = Wr(r2, n3); ++e2 < t2; ) n3(e2);
        return u2;
      }
      function Pg(t2) {
        return b2(t2) ? z3(t2, Ft2) : pt(t2) ? [t2] : ut(Wu(U(t2)));
      }
      function Cg(t2) {
        var n3 = ++Lf;
        return U(t2) + n3;
      }
      var Ag = ke(function(t2, n3) {
        return t2 + n3;
      }, 0), Ig = li("ceil"), xg = ke(function(t2, n3) {
        return t2 / n3;
      }, 1), Eg = li("floor");
      function yg(t2) {
        return t2 && t2.length ? Ke(t2, ft, Vr) : i4;
      }
      function Sg(t2, n3) {
        return t2 && t2.length ? Ke(t2, E2(n3, 2), Vr) : i4;
      }
      function Og(t2) {
        return ys(t2, ft);
      }
      function Rg(t2, n3) {
        return ys(t2, E2(n3, 2));
      }
      function bg(t2) {
        return t2 && t2.length ? Ke(t2, ft, ni) : i4;
      }
      function Tg(t2, n3) {
        return t2 && t2.length ? Ke(t2, E2(n3, 2), ni) : i4;
      }
      var Lg = ke(function(t2, n3) {
        return t2 * n3;
      }, 1), Hg = li("round"), Dg = ke(function(t2, n3) {
        return t2 - n3;
      }, 0);
      function Ng(t2) {
        return t2 && t2.length ? Fr2(t2, ft) : 0;
      }
      function $g(t2, n3) {
        return t2 && t2.length ? Fr2(t2, E2(n3, 2)) : 0;
      }
      return a2.after = ip, a2.ary = Vu, a2.assign = Kp, a2.assignIn = ha2, a2.assignInWith = hr2, a2.assignWith = Jp, a2.at = Yp, a2.before = ku, a2.bind = xi2, a2.bindAll = kd, a2.bindKey = ju, a2.castArray = vp, a2.chain = Zu, a2.chunk = Eh, a2.compact = yh, a2.concat = Sh, a2.cond = jd, a2.conforms = tg, a2.constant = Ti2, a2.countBy = Nl, a2.create = Zp, a2.curry = ta2, a2.curryRight = na2, a2.debounce = ea2, a2.defaults = Xp, a2.defaultsDeep = Qp, a2.defer = sp, a2.delay = up, a2.difference = Oh, a2.differenceBy = Rh, a2.differenceWith = bh, a2.drop = Th, a2.dropRight = Lh, a2.dropRightWhile = Hh, a2.dropWhile = Dh, a2.fill = Nh, a2.filter = ql, a2.flatMap = Wl, a2.flatMapDeep = Ml, a2.flatMapDepth = Bl, a2.flatten = zu, a2.flattenDeep = $h, a2.flattenDepth = qh, a2.flip = ap, a2.flow = eg, a2.flowRight = rg, a2.fromPairs = Uh, a2.functions = rd, a2.functionsIn = id, a2.groupBy = Gl, a2.initial = Wh, a2.intersection = Mh, a2.intersectionBy = Bh, a2.intersectionWith = Gh, a2.invert = ud, a2.invertBy = ad, a2.invokeMap = Kl, a2.iteratee = Li2, a2.keyBy = Jl, a2.keys = V2, a2.keysIn = ot, a2.map = sr2, a2.mapKeys = fd, a2.mapValues = cd, a2.matches = ig, a2.matchesProperty = sg, a2.memoize = ar2, a2.merge = hd, a2.mergeWith = la2, a2.method = ug, a2.methodOf = ag, a2.mixin = Hi2, a2.negate = or2, a2.nthArg = fg, a2.omit = ld, a2.omitBy = pd, a2.once = op, a2.orderBy = Yl, a2.over = cg, a2.overArgs = fp, a2.overEvery = hg, a2.overSome = lg, a2.partial = Ei2, a2.partialRight = ra2, a2.partition = Zl, a2.pick = dd, a2.pickBy = pa2, a2.property = Pa2, a2.propertyOf = pg, a2.pull = Yh, a2.pullAll = Ju, a2.pullAllBy = Zh, a2.pullAllWith = Xh, a2.pullAt = Qh, a2.range = dg, a2.rangeRight = gg, a2.rearg = cp, a2.reject = Vl, a2.remove = Vh, a2.rest = hp, a2.reverse = Ai, a2.sampleSize = jl, a2.set = vd, a2.setWith = _d2, a2.shuffle = tp, a2.slice = kh, a2.sortBy = rp, a2.sortedUniq = sl, a2.sortedUniqBy = ul, a2.split = Wd, a2.spread = lp, a2.tail = al, a2.take = ol, a2.takeRight = fl, a2.takeRightWhile = cl, a2.takeWhile = hl, a2.tap = yl, a2.throttle = pp, a2.thru = ir2, a2.toArray = oa2, a2.toPairs = da2, a2.toPairsIn = ga2, a2.toPath = Pg, a2.toPlainObject = ca2, a2.transform = md, a2.unary = dp, a2.union = ll, a2.unionBy = pl, a2.unionWith = dl, a2.uniq = gl, a2.uniqBy = vl, a2.uniqWith = _l, a2.unset = wd, a2.unzip = Ii2, a2.unzipWith = Yu, a2.update = Pd, a2.updateWith = Cd, a2.values = zn2, a2.valuesIn = Ad, a2.without = ml, a2.words = ma2, a2.wrap = gp, a2.xor = wl, a2.xorBy = Pl, a2.xorWith = Cl, a2.zip = Al, a2.zipObject = Il, a2.zipObjectDeep = xl, a2.zipWith = El, a2.entries = da2, a2.entriesIn = ga2, a2.extend = ha2, a2.extendWith = hr2, Hi2(a2, a2), a2.add = Ag, a2.attempt = wa2, a2.camelCase = yd, a2.capitalize = va2, a2.ceil = Ig, a2.clamp = Id, a2.clone = _p, a2.cloneDeep = wp, a2.cloneDeepWith = Pp, a2.cloneWith = mp, a2.conformsTo = Cp, a2.deburr = _a3, a2.defaultTo = ng, a2.divide = xg, a2.endsWith = Sd, a2.eq = Rt, a2.escape = Od, a2.escapeRegExp = Rd, a2.every = $l, a2.find = Ul, a2.findIndex = Bu, a2.findKey = Vp, a2.findLast = Fl, a2.findLastIndex = Gu, a2.findLastKey = kp, a2.floor = Eg, a2.forEach = Xu, a2.forEachRight = Qu, a2.forIn = jp, a2.forInRight = td, a2.forOwn = nd, a2.forOwnRight = ed, a2.get = Oi2, a2.gt = Ap, a2.gte = Ip, a2.has = sd, a2.hasIn = Ri, a2.head = Ku, a2.identity = ft, a2.includes = zl, a2.indexOf = Fh, a2.inRange = xd, a2.invoke = od, a2.isArguments = An2, a2.isArray = b2, a2.isArrayBuffer = xp, a2.isArrayLike = at, a2.isArrayLikeObject = Y, a2.isBoolean = Ep, a2.isBuffer = hn, a2.isDate = yp, a2.isElement = Sp, a2.isEmpty = Op, a2.isEqual = Rp, a2.isEqualWith = bp, a2.isError = yi, a2.isFinite = Tp, a2.isFunction = Qt, a2.isInteger = ia2, a2.isLength = fr2, a2.isMap = sa2, a2.isMatch = Lp, a2.isMatchWith = Hp, a2.isNaN = Dp, a2.isNative = Np, a2.isNil = qp, a2.isNull = $p, a2.isNumber = ua2, a2.isObject = K2, a2.isObjectLike = J, a2.isPlainObject = ge, a2.isRegExp = Si, a2.isSafeInteger = Up, a2.isSet = aa2, a2.isString = cr2, a2.isSymbol = pt, a2.isTypedArray = Gn2, a2.isUndefined = Fp, a2.isWeakMap = Wp, a2.isWeakSet = Mp, a2.join = zh, a2.kebabCase = bd, a2.last = It, a2.lastIndexOf = Kh, a2.lowerCase = Td, a2.lowerFirst = Ld, a2.lt = Bp, a2.lte = Gp, a2.max = yg, a2.maxBy = Sg, a2.mean = Og, a2.meanBy = Rg, a2.min = bg, a2.minBy = Tg, a2.stubArray = Ni2, a2.stubFalse = $i, a2.stubObject = vg, a2.stubString = _g2, a2.stubTrue = mg, a2.multiply = Lg, a2.nth = Jh, a2.noConflict = og, a2.noop = Di2, a2.now = ur2, a2.pad = Hd, a2.padEnd = Dd, a2.padStart = Nd, a2.parseInt = $d, a2.random = Ed, a2.reduce = Xl, a2.reduceRight = Ql, a2.repeat = qd, a2.replace = Ud, a2.result = gd, a2.round = Hg, a2.runInContext = h2, a2.sample = kl, a2.size = np, a2.snakeCase = Fd, a2.some = ep, a2.sortedIndex = jh, a2.sortedIndexBy = tl, a2.sortedIndexOf = nl, a2.sortedLastIndex = el, a2.sortedLastIndexBy = rl, a2.sortedLastIndexOf = il, a2.startCase = Md, a2.startsWith = Bd, a2.subtract = Dg, a2.sum = Ng, a2.sumBy = $g, a2.template = Gd, a2.times = wg, a2.toFinite = Vt, a2.toInteger = T2, a2.toLength = fa2, a2.toLower = zd, a2.toNumber = xt, a2.toSafeInteger = zp, a2.toString = U, a2.toUpper = Kd, a2.trim = Jd, a2.trimEnd = Yd, a2.trimStart = Zd, a2.truncate = Xd, a2.unescape = Qd, a2.uniqueId = Cg, a2.upperCase = Vd, a2.upperFirst = bi, a2.each = Xu, a2.eachRight = Qu, a2.first = Ku, Hi2(a2, (function() {
        var t2 = {};
        return qt(a2, function(n3, e2) {
          W.call(a2.prototype, e2) || (t2[e2] = n3);
        }), t2;
      })(), { chain: false }), a2.VERSION = p2, mt(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(t2) {
        a2[t2].placeholder = a2;
      }), mt(["drop", "take"], function(t2, n3) {
        N2.prototype[t2] = function(e2) {
          e2 = e2 === i4 ? 1 : Q2(T2(e2), 0);
          var r2 = this.__filtered__ && !n3 ? new N2(this) : this.clone();
          return r2.__filtered__ ? r2.__takeCount__ = nt(e2, r2.__takeCount__) : r2.__views__.push({ size: nt(e2, $t2), type: t2 + (r2.__dir__ < 0 ? "Right" : "") }), r2;
        }, N2.prototype[t2 + "Right"] = function(e2) {
          return this.reverse()[t2](e2).reverse();
        };
      }), mt(["filter", "map", "takeWhile"], function(t2, n3) {
        var e2 = n3 + 1, r2 = e2 == zi2 || e2 == Ka2;
        N2.prototype[t2] = function(u2) {
          var o2 = this.clone();
          return o2.__iteratees__.push({ iteratee: E2(u2, 3), type: e2 }), o2.__filtered__ = o2.__filtered__ || r2, o2;
        };
      }), mt(["head", "last"], function(t2, n3) {
        var e2 = "take" + (n3 ? "Right" : "");
        N2.prototype[t2] = function() {
          return this[e2](1).value()[0];
        };
      }), mt(["initial", "tail"], function(t2, n3) {
        var e2 = "drop" + (n3 ? "" : "Right");
        N2.prototype[t2] = function() {
          return this.__filtered__ ? new N2(this) : this[e2](1);
        };
      }), N2.prototype.compact = function() {
        return this.filter(ft);
      }, N2.prototype.find = function(t2) {
        return this.filter(t2).head();
      }, N2.prototype.findLast = function(t2) {
        return this.reverse().find(t2);
      }, N2.prototype.invokeMap = H2(function(t2, n3) {
        return typeof t2 == "function" ? new N2(this) : this.map(function(e2) {
          return fe2(e2, t2, n3);
        });
      }), N2.prototype.reject = function(t2) {
        return this.filter(or2(E2(t2)));
      }, N2.prototype.slice = function(t2, n3) {
        t2 = T2(t2);
        var e2 = this;
        return e2.__filtered__ && (t2 > 0 || n3 < 0) ? new N2(e2) : (t2 < 0 ? e2 = e2.takeRight(-t2) : t2 && (e2 = e2.drop(t2)), n3 !== i4 && (n3 = T2(n3), e2 = n3 < 0 ? e2.dropRight(-n3) : e2.take(n3 - t2)), e2);
      }, N2.prototype.takeRightWhile = function(t2) {
        return this.reverse().takeWhile(t2).reverse();
      }, N2.prototype.toArray = function() {
        return this.take($t2);
      }, qt(N2.prototype, function(t2, n3) {
        var e2 = /^(?:filter|find|map|reject)|While$/.test(n3), r2 = /^(?:head|last)$/.test(n3), u2 = a2[r2 ? "take" + (n3 == "last" ? "Right" : "") : n3], o2 = r2 || /^find/.test(n3);
        u2 && (a2.prototype[n3] = function() {
          var f2 = this.__wrapped__, c2 = r2 ? [1] : arguments, l2 = f2 instanceof N2, v2 = c2[0], _2 = l2 || b2(f2), m3 = function(D) {
            var $2 = u2.apply(a2, rn([D], c2));
            return r2 && C2 ? $2[0] : $2;
          };
          _2 && e2 && typeof v2 == "function" && v2.length != 1 && (l2 = _2 = false);
          var C2 = this.__chain__, I2 = !!this.__actions__.length, y3 = o2 && !C2, L3 = l2 && !I2;
          if (!o2 && _2) {
            f2 = L3 ? f2 : new N2(this);
            var S2 = t2.apply(f2, c2);
            return S2.__actions__.push({ func: ir2, args: [m3], thisArg: i4 }), new Pt(S2, C2);
          }
          return y3 && L3 ? t2.apply(this, c2) : (S2 = this.thru(m3), y3 ? r2 ? S2.value()[0] : S2.value() : S2);
        });
      }), mt(["pop", "push", "shift", "sort", "splice", "unshift"], function(t2) {
        var n3 = be2[t2], e2 = /^(?:push|sort|unshift)$/.test(t2) ? "tap" : "thru", r2 = /^(?:pop|shift)$/.test(t2);
        a2.prototype[t2] = function() {
          var u2 = arguments;
          if (r2 && !this.__chain__) {
            var o2 = this.value();
            return n3.apply(b2(o2) ? o2 : [], u2);
          }
          return this[e2](function(f2) {
            return n3.apply(b2(f2) ? f2 : [], u2);
          });
        };
      }), qt(N2.prototype, function(t2, n3) {
        var e2 = a2[n3];
        if (e2) {
          var r2 = e2.name + "";
          W.call(Un2, r2) || (Un2[r2] = []), Un2[r2].push({ name: n3, func: e2 });
        }
      }), Un2[Ve(i4, ln).name] = [{ name: "wrapper", func: i4 }], N2.prototype.clone = Qf, N2.prototype.reverse = Vf, N2.prototype.value = kf, a2.prototype.at = Sl, a2.prototype.chain = Ol, a2.prototype.commit = Rl, a2.prototype.next = bl, a2.prototype.plant = Ll, a2.prototype.reverse = Hl, a2.prototype.toJSON = a2.prototype.valueOf = a2.prototype.value = Dl, a2.prototype.first = a2.prototype.head, ee2 && (a2.prototype[ee2] = Tl), a2;
    }, Nn = Rf2();
    dn ? ((dn.exports = Nn)._ = Nn, Lr2._ = Nn) : j2._ = Nn;
  }).call(_e);
})(Ui, Ui.exports);
const y2 = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode", "wallet_sendCalls", "wallet_getCapabilities", "wallet_getCallsStatus", "wallet_showCallsStatus"];
const bsc = /* @__PURE__ */ defineChain({
  id: 56,
  name: "BNB Smart Chain",
  blockTime: 750,
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://56.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
});
const bscTestnet = /* @__PURE__ */ defineChain({
  id: 97,
  name: "BNB Smart Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://testnet.bscscan.com",
      apiUrl: "https://api-testnet.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 17422483
    }
  },
  testnet: true
});
const mainnet = /* @__PURE__ */ defineChain({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  blockTime: 12e3,
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensUniversalResolver: {
      address: "0xeeeeeeee14d718c2b47d9923deab1335e144eeee",
      blockCreated: 23085558
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});
function getCaipDefaultChain(chain) {
  if (!chain) {
    return void 0;
  }
  return {
    id: `${ConstantsUtil$3.EIP155}:${chain.id}`,
    name: chain.name,
    imageId: PresetsUtil.EIP155NetworkImageIds[chain.id],
    chain: ConstantsUtil$2.CHAIN.EVM
  };
}
async function getWalletConnectCaipNetworks(connector) {
  if (!connector) {
    throw new Error("networkControllerClient:getApprovedCaipNetworks - connector is undefined");
  }
  const provider = await connector?.getProvider();
  const ns = provider?.signer?.session?.namespaces;
  const nsMethods = ns?.[ConstantsUtil$3.EIP155]?.methods;
  const nsChains = xn(ns?.[ConstantsUtil$3.EIP155]?.accounts || []);
  return {
    supportsAllNetworks: Boolean(nsMethods?.includes(ConstantsUtil$3.ADD_CHAIN_METHOD)),
    approvedCaipNetworkIds: nsChains
  };
}
function getEmailCaipNetworks() {
  return {
    supportsAllNetworks: false,
    approvedCaipNetworkIds: PresetsUtil.WalletConnectRpcChainIds.map((id) => `${ConstantsUtil$3.EIP155}:${id}`)
  };
}
function getTransport({ chain, projectId: projectId2 }) {
  const RPC_URL = CoreHelperUtil.getBlockchainApiUrl();
  const chainDefaultUrl = chain.rpcUrls[0]?.http?.[0];
  if (!PresetsUtil.WalletConnectRpcChainIds.includes(chain.id)) {
    return http(chainDefaultUrl);
  }
  return fallback([
    http(`${RPC_URL}/v1/?chainId=${ConstantsUtil$3.EIP155}:${chain.id}&projectId=${projectId2}`, {
      fetchOptions: {
        headers: {
          "Content-Type": "text/plain"
        }
      }
    }),
    http(chainDefaultUrl)
  ]);
}
function requireCaipAddress(caipAddress) {
  if (!caipAddress) {
    throw new Error("No CAIP address provided");
  }
  const account = caipAddress.split(":")[2];
  if (!account) {
    throw new Error("Invalid CAIP address");
  }
  return account;
}
var COMPRESSED$1 = "AEkU4AngDVgB0QKRAQYBOwDqATEAnwDbAIUApABsAOAAbwCRAEYAiQBPAHYAPgA+ACsANwAlAGMAHwAvACsAJQAWAC8AGwAiACIALwAUACsAEQAiAAsAGwARABcAGAA6ACkALAAsADUAFgAsABEAHQAhAA8AGwAdABUAFgAZAA0ADQAXABAAGQAUABIEqgYJAR4UFjfDBdMAsQCuPwFnAKUBA10jAK5/Ly8vLwE/pwUJ6/0HPwbkMQVXBVgAPSs5APa2EQbIwQuUCkEDyJ4zAsUKLwKOoQKG2D+Ob4kCxcsCg/IBH98JAPKtAUECLY0KP48A4wDiChUAF9S5yAwLPZ0EG3cA/QI5GL0P6wkGKekFBIFnDRsHLQCrAGmR76WcfwBbBpMjBukAGwA7DJMAWxVbqfu75wzbIM8IuykDsRQ7APcta6MAoX0YABcEJdcWAR0AuRnNBPoJIEw3CZcJiB4bVllM44NCABMADAAVAA5rVAAhAA4AR+4V2D3zOVjKleYuChAdX01YPewAEwAMABUADmsgXECXAMPrABsAOQzFABsVW6n7Adq4HB0FWwXiAtCfAsSwCkwcpGUUcxptTPUAuw1nAuEACy00iRfJkQKBewETGwC9DWcC4QALLQFIUCWRTAoDLfsFMgnXaRetAddDAEkrEncCMRYhAusnuTdrADnhAfUlAMcOy7UBG2OBALEFAAUAitNJBRvDHwcXAKgn0QGhKy0DmwBnAQoZPu03dAQYFwCqAccCIQDTKxJzOvNQsAWQOncnNUgF+icFWQVYr7gFaTtdQhI6WEGXe5NmX6H4CxMDxQcl8XcjBKNLAlNTAnUbqycBj6OlNVsDRRcEg2EJANEGqz8vIwcpAjldAGsBYR9xAIMdGQCVAUm3ACdpFwGvxQM3LSFDUwFvWQZlAmUA8UkXAykBBQBJQQCrAF0AcwArtQYH8+8ZjX8ACSEAKQCzG0cB0QHbBwsxl3iB6AAKABEANAA9ADgzd3nTwBBfEFwBTQlMbDoVCwKsD6YL5REVDNEqy9PYADSpB+sDUwfrA1MDUwfrB+sDUwfrA1MDUwNTA1McCvAa08AQXw9IBG0FjgWLBNYIgyZJEYEHKAjSVA10HhxHA0UA/CMlSRw7kzMLJUJMDE0DB/w2QmynfTgDRzGrVPWQogPLMk85bAEecRKgACoPcxw1tU5+ekdxoApLT661f0liTmcCvjqoP/gKIQmTb7t3TgY9EBcnoRDzDC8BsQE3DelL1ATtBjcExR95GRUPyZWYCKEt2QzpJt8unYBWI/EqfwXpS/A82QtJUWQPVQthCd86X4FKAx0BCSKHCtkNNQhpEO8KxWcN4RFBBzUD0UmWAKEG/QsNHTEVsSYMYqgLBTlzBvca8guLJqsTJXr4Bc8aHQZJASUa+wDLLuOFrFotXBhPWwX/CyEjwxSkUBwNIUCzeEQaFwcRJaUCjUNsSoNRMh6PIfI8OQ1iLg9ReAfxPAEZSwt9PJpGp0UKEc4+iT1EIkVMKAQxeywrJ4cJyw+BDLV8bgFVCR0JrQxtEy0REzfBCDUHFSmXICcRCB1GkWCWBPObA+8TzQMHBTsJPQcPA7EcKRMqFSUFCYEg0wLvNtEurwKLVnwBEwXHDyEf2xBMR9wO5QiXAmEDfyXnACkVHQATIpcIP18AW4/UUwEuxwjDamgjcANjFONdEW8HjQ5TB6McLxW7HN1wxF4HhgQon6sJVwFxCZUBWwTfCAU1V4ycID1nT4tUGJcgXUE7XfgCLQxhFZtEuYd0AocPZxIXATEBbwc1DP0CcxHpEWcQkQjnhgA1sTP0OiEESyF/IA0KIwNLbMoLIyb1DPRlAZ8SXgMINDl36menYLIgF/kHFTLBQVwh7QuOT8kMmBq9GD5UKhngB7sD7xrvJ+ZBUwX7A58POkkz6gS5C2UIhwk7AEUOnxMH0xhmCm2MzAEthwGzlQNTjX8Ca4sGMwcHAGMHgwV14QAZAqMInwABAMsDUwA1AqkHmQAVAIE9ATkDIysBHeECiwOPCC3HAZErAe8lBBe/DBEA8zNuRgLDrQKAZmaeBdlUAooCRTEBSSEEAUpDTQOrbd0A1wBHBg/bQwERp0bHFt8/AdtrJwDDAPcAATEHAT0ByQHvaQCzAVsLLQmer7EBSeUlAH8AEWcB0wKFANkAMQB77QFPAEkFVfUFzwJLRQENLRQnU10BtwMbAS8BCQB1BseJocUDGwRpB88CEBcV3QLvKgexAyLbE8lCwQK92lEAMhIKNAq1CrQfX/NcLwItbj1MAAofpD7DP0oFTTtPO1Q7TztUO087VDtPO1Q7TztUA5O73rveCmhfQWHnDKIN0ETEOkUT12BNYC4TxC2zFL0VyiVSGTkauCcBJeBVBQ8ALc9mLAgoNHEXuAA7KWSDPWOCHiwKRxzjU41U9C0XAK1LnjOrDagbEUQ8BUN16WImFgoKHgJkfQJiPldJq1c3HAKh8wJolAJmBQKfgDgXBwJmNwJmIgRqBHsDfw8Dfo45AjlzEzl+Oh8fAmwZAjIyOAYCbcMCbarrhi9jQScBYwDaAN0ARgEHlAyJAPoHvgAJsQJ3KwJ2njsCeUc/Ani2GVjXRapG0wJ8OwJ6xAJ9BQJ87AVVBRxH/Eh5XyAAJxFJVEpXERNKyALQ/QLQyEsjA4hLA4fiRMGRLgLynVz/AwOqS8pMKSHLTUhNqwKLOwKK1L0XAxk/YwGzAo4zAo5YPJN9Ao7VAo5YdFGwUzEGUtBUgQKT9wKTCADlABhVGlWrVcwCLBcpkYIy3XhiRTc1ApebAu+uWB2kAFUhApaLApZ4mAClWahaBX1JADcClrEClkpcQFzNApnHAplgXMZdAxUCnJc5vjqZApwSAp+XAp60hgAZCy0mCwKd7QKejgCxOWEwYesCns8CoGoBpQKemxsCnkqhY8RkIyEnAierAiZ6AqD3AqBIAqLZAqHAAqYrAqXKAqf7AHkCp+5oeGit/0VqGGrNAqzfAqyqAq1jAqz+AlcZAlXYArHd0wMfSmyTArK5CQKy5BNs3G1fbURbAyXJArZYNztujAMpQQK4WgK5QxECuSZzcDJw3QK9FQK71nCSAzINAr6Ecf4DM20CvhZzHnNLAsPHAsMAc350RzFBdNwDPKMDPJYDPbsCxXgCxkMCxgyFAshlTQLIQALJSwLJKgJkmQLdznh1XXiqeSFLzAMYn2b+AmHwGe+VIHsHXo5etw0Cz2cCz2grR0/O7w+bAMKpAs9vASXmA04OfkcBAtwjAtuGAtJLA1JYA1NbAP0DVYiAhTvHEulcQYIYgs+CyoOJAtrDAtnahAyERac4A4ahACsDZAqGbVX1AFEC32EC3rRvcwLiK+0QAfMsIwH0lwHyzoMC6+8C6Wx1Aur1AurgAPVDAbUC7oUC65iWppb/Au47A4XcmHVw3HGdAvL/AGUDjhKZjwL3DwORagOSgwL3lAL51QL4YpoYmqe3M5saA51/Av72ARcANZ8Yn68DBYkDpmYDptUAzcEDBmahhKIBBQMMRQELARsHaQZdtWMBALcEZ7sNhx6vCQATcTUAHwMvEkkDhXsBXyMdAIzrAB0A5p8Dm40IswYbn8EApwURu+kdPT4WeAVoNz5AK0IhQrRfcRFfvACWxQUyAJBMGZu5OyZgMhG6zw4vGMYYicn2BVcFWAVXBVgFYwVYBVcFWAVXBVgFVwVYBVcFWEYVCNeFZwICAgpkXukrBMkDsQYvu7sAuwSnuwDnQCkWsgVGPmk+cEI/QrZfdTdf6ABYETOrAIz+zGvL/KbnRno9JiMEKxYnNjV+bd9qwfEZwixpAWvXbjAXBV8FasnBybgIz0lbAAAACnxefYu+ADM/gQADFtEG5a0jBQCMwwsDAQ0A5WUdPSQfSkKxQrxBOCNfJ2A2JzgjCcE9CkQ/Qz54PoE+cD5xAolCvElCO1/LTk9qTQosa1QvagtuH1/gMzobCWebCmIjKzwdJkKrQrwrzAHL/F/JDh8uCQgJIn6d32o6LUoXyavJrAllwcvMCmBBXw/lEKMRAJONHUVCJRupbTnOOAozP0M+cEI/HAcKHUxHbFssLVrhvBIKfe0dK0I/HF0ISgkOM1RDQjcEO0OcLAqBGy1CPxv1CFMiIxgwMQAFj2HwXgpxZMlgC2AtI25DYBk5AhseYLMGAmsQZU5gTREBZOdgFWCVYH1gs2BLYJFoFhcGtQ7cVam8WgtDFqsBuyvNwQIfFQAcAx4BeQJsLzCVUoABigq4RxoA5CN0jgrKDaZN6gGbAoecTwVAXwD39wkANBZXDAulDCQfuq9HAE8MNAAVE58rggh6AtILS2URGwDYTgZ1BAoeWgAxALa4AZonCxZvqyQ4nxkBWwGGCfwD2e0PBqoGSga5AB3LValaCbthE4kLLT8OuwG7ASICR1ooKCggHh8hLBImBiEMjQBUAm5XkEmVAW4fD3FHAdN1D85RIBmpsE3qBxEFTF8A9/cKAHoGJGwKKwulODAtx69WDQsAX7wLAGNAlQh6AOpN7yIbvwAxALa4AZonLTsOzgKQGHtQu1jIdHKO16WbDvWZFT0b7AEpEFwSBg8bAccJOhCTBRArDDYLABEAs84BAgCkAOEAmIIABWtXLwAUAFsbxi5sdioNwRACOyQz0+EcHgsbfQJ7Ls6hHATBCqrxbAA3OS0Opge7CQAQOi7OERkAfavaHA+7GkcczaF3HgE9Kl8cAuugCAHCAULz5B9lAb4Jtwz6CDwKPgAFwAs9AksNuwi8DTwKvC7OoSoJPA67BZgBG2sKD4sa4QHDARELuxY7AKALOxC7BBige9wAO2sMPAACpgm8BRvQ9QUBvgH6bsoGewAHuwG7D00RErwBAQDqAQAAdBVbBhbLFPxvF7sYOwAuuwLrDlaouwAeuwJVICp/AAG7AALjAAg7FTwVuwAbuwG9KOClWw6/xAD0AGj7L7ZtvgNIo7vIqDsDAbuVJ0sAAlsACrsEAOfdGbsIGnsIoQUK/3AA37unuxjbGruji3lyBvupm4MAErsGGwsBvAAAhgBtuwYAC7unOwEaO7oIoZzKAbsL7QfAqTsA4XsBvwAA5QAVuwAG+wAJuwBpiwAauwAOuwIYu45pFfsAAVsADmsALkseAAa7ABe7CCEADUoBwgC3ryYBwAAAtAAOmwG+J+QAsloAHBsBv/7hCqEABcYLFRXbAAebAEK7AQIAabsAC3sAHbsACLsJoQAFygBunxnVAJEIIQAFygABOwAH2wAdmwghAAaaAAl7ABsrAG0bAOa7gAAIWwAUuwkhAAbKAOOLAAk7C6EOxPtfAAc7AG6cQEgARwADOwAJrQM3AAcbABl7Abv/Aab7AAobAAo7AAn7p+sGuwAJGwADCwAQOwAAFDsAEWsAD4sADesADbsAGQsGFhsAFTsAbpsWswG7ALoAEzsDAGkrCgDhSwACOwAEUgAXewUbAAbQABi7AAv7AF+7AGv7AOSLAbsAF3YBvAABcguhAAVKHgF7KFIAOUUA/gcNDHIAKCpwAaQFCF4BvF4jDAkHb0tsXyqJHzwUYi02A6EKtAHYABYC0QNuAXZyR1IUIQNPAhU+ASwGA3NGvHtSekAAKQAxAfsAUwrbAHuQLAErAHblDREyRgFKAFcFAAFQAQeKzAB4OwQgpQBaANYVAJVoNx+LAM1rsQDP1BYIwnVzGxhWHQnRAYiQqyJTU01IEjzCifkAfxw3QCkr4BGXTwByASksMClCGQ8DMFUE98XuAEtl3ABqAnECPxF6Osd4LjXVBgUAEBsdCggMKgQfHSlOU04IuboAChLNACYAARoAhgCJAI41AO4AtADgAJ08ALsAqwCmAKEA8gCfANMAnADrAQwBBwDAAHkAWgDLAM0BBwDXAOsAiACiATUA4wDYANUDAQcqM9TU1NS2wNzN0M5DMhcBTQFXL0cBVQFkAWMBVgFHS0NFaA0BThUHCAMyNgwHACINJCYpLDg6Oj09PT4/DkAeUVFRUVNTUlMpVFVXVlYcXWFhYGJhI2ZocG9ycnJycnJ0dHR0dHR0dHR0dHZ2d3Z1WwBA7ABFAJYAdAAuAGLyAIoAUwBTADMCc+kAh//y8gBgAI/sAJsASwBeAGD5+aoAgQCBAGUAUgCtAB4AsgB/AjwCPwD4AOMA+gD6AOQA+wDlAOUA5ADiACkCdwFNATwBOgFQAToBOgE6ATUBNAE0ATQBGAFUDwArCAAATRcKFgMVFg4AigCSAKIASwBkGAItAHAAaQCRAxIDJCoDHkE+RykAiwJLAMMCUwKgALoCkgKSApICkgKSApIChwKSApICkgKSApICkgKRApEClAKcApMCkgKSApACkAKQApACjgKRAnEB0AKTApsCkgKSApEWeQsA+gUDpwJdAjYXAVAQNQLeEQorEwFKNxNNkQF3pDwBZVkA/wM9RwEAAJMpHhiPagApYABpAC4AiQOUzIvwroRaBborDsIRAZ3VdCoLBCMxbAEzWmwBsgDdfoB/foB+gYKCfoOGhH6FiIaAh4KIgol+in6LfoyKjX6Ofo+CkH6RfpJ+k36Ug5WIloKXftoC2WzhAtdsAIJsJGygAINsbARCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAlmZsAKMDh2wAtGYBBWwAyVFsbADPbAIMbAD2WmwA9gEZAPYA9AD0APUA9AN8XmzUhCNlvwD2APQA9AD1APQcbGwAiVpsAPYAiQEZAPYAiQLsAPYAiQN8XmzUhCNlvxxsAPdabAEZAPYA9gD0APQA9QD0APcA9AD0APUA9AN8XmzUhCNlvxxsbACJWmwBGQD2AIkA9gCJAuwA9gCJA3xebNSEI2W/HGwCQwE2bAJKATlsAkvBbGwCV2xsA54C7AOeA54DnwOfA58DnwN8XmzUhCNlvxxsbACJWmwBGQOeAIkDngCJAuwDngCJA3xebNSEI2W/HGwEN2wAiQQ4AIkGjTFtIC9s1m4DJmwA/QDGWgJsbABVWv4UMgJsbACJAmwAVAEAuV5sAmxebGwAiV5sAmxebD3YAEls1gJsbEZFNiJ9FGVAe8xvEZKvxVfKZszAVTBzYBH2d1iyUXEHH7twNw7eZF5JJRHI5EgaRr5D20/3dfONrFLSq5qSrrgd2CEUq722WBQ/LzpA+bx1oREI5xy4BDSZNun0ZWORUJqInZSyMaioyvfSI0l5uFDzbWaQ28/zdB0hwR4OQZ0/jn9ALSLNikjFYGfqR389qtFlhD3a6KdIh97rhZYpywuLc7o8ql5/X8KCbPU3L/QlmCowhRXhsGDvg6wUNprA9bM/49uxlAj7ZVy3ouEY/BgFXBNyK0TLrSjZWeJm/T4nz6QGLT3cJNtWRZVZTvIdtaxMMJRHgig9+S11LjBh7Inr06ykoch1U097Rw0hvgmOrydQyaWcEQDg0RavuMuT0zYabUZl1e33HNSK1oNUCS03eh+9C2EvF3fq9h+XBaAMFuoWeZf+mfZgL4HzyiKDIUtfNU4oFu0aE9qt3VA3U4D3fOSrAcYVnjG3cSkp1vhXZnp3JQm4JknKdBitO2NVnGCYQwU3YMWHWB87NEd+4AHuOKI8BSIH92reW0pfs+kWCTJxDCbRjFv8Cfc4/DSBYJScJYTeAEgg9wTEvcwd/QuHRHqGzAQ4fXf5FUI1lPrO+fvEcPl4JInM1z9AtBT2bL4QYEREe7KiSnnxTwtmAFjn8lqT3mND8qTktX2F16Ae9cakqJ6/pEQsHURqyqWlRMCzKXRKfCHT7sYHWx9/T/ugYTFY6iVN3Btm58ATJR5alYZybKMWojwOw3HbFn23NFyeLl7+Er82RchyYuBoGQ3j7SAWNxiYvp5U+Fq/DEzB9cG5DlJWsqkosRze92OVlCtQEYo1S1lF72Z8xWc4ld/+fFcfTEDTFb9d8tJGQ75dpJEvcWyGmGBiTbiWDdGOcw93Dmxq5ISUrmasygONfHLvhgo83HQZenbdBtSzBkvYrCEQ/xEDMhMZsN6gqplx5jGG9mSQLhM81UEdEeJ59sdNJDAFy/gPyJoKlwPZgB/MkC/kICLiCB8va+nCdO2ry4aDfkmPFpF/H/SGQ3LJ6aAv9dtJ8DniHtLOckZix0BVb0iR5V3LAp521LBSIi6AtV7r2ZB/hQEvAw54EFNOQcFnl1xGUIc67tqK1INNwD2n/RbwgzO9h45LM6VMuN8V1ZNIQ6t+Xy3lTqyVCD5kqLy/t3/b8MLbgDg8JIWDkSZ+LrGhhr+gYpH+pr1TnCUnZPjpUdw6bSL6MWVXoDDciQDWECwU2e6VEpfrcOBbrSOijqGkEIoJPbpmeJLkcwbvA0yWIixQVjo0HnYh7fji+Dfdq1mtV1lG2Zz9R7eFMHS+FK7nybutu2fwzDpFldO2pZBshsHJWaltn3PWOoGJpCT2jE8EHOuC6FkejNWcfsWCqNqMLP9xTwcWArj2EiiI7D+EaDi7/2cqHL1gPiF6C/J7aUo7RQqogPZ11WqbyP97nsoMxPOC78wZMF7B1Y0g7JNXJV/nN1m4xx8hbqWz07KSaqr5hE4icB326DMR/vUKX9LoNjle/ZWtbUhrTAcsdgrLlG5Ne8aiR0bS/2ZhpNOVVxavWIZsEM/rd68EB4vjbbD13NkMK1qvMk74vGbSkL7ULO0sZ9R6APSCo6KH+Xn98wEdw1bCPAnDTaBsD6sidAGN58uiH4a3ovG1KyZAu2XtyGgF/vgWKGxw9R1lfAVcfuYE71DHuxtTzfGZnHaDpDGWmfEq0N4GawE7yIkaoz8jcmVmzJe1ydM8q0p08YIxFcY1YcqQc1djWBEoNETDFcgk5waRftEJasPREkrV++N/TOKkERF1fCLrXS8DFGYGRBeECMQRNEs0ES3FzUtXCcNxpYEM3Uei6XodZruXUIRnn+UXf2b/r7n1vQutoi6WoIbW7svDNWBbUWcDUc7F9SJK3bvSy9KIqhgyJHoW2Kpvv0J4ob14HFXGWWVsYXJzjwxS+SADShTgCRjhoDgjAYRGxwJ1Vonw+cpnCKhz8NQPrb0SFxHIRbmG95Q2hlC4mDxvPBRbkFa60cvWakd7f0kVBxxktzZ9agPJEWyA63RSHYVqt8cPrs2uFJ3rS3k9ETGKn5+A6F9IOrdZHfT1biEyUJKEvwzuscwshGCBJvd16TrefW03xVnJf4xvs72PdxrMidjJO8EiWyN/VWyB3fv9kc34YIuZTFtXGo9DuG3H1Uka5FgBMwDPEvRcSabi3WakNQkXFecJlFk6buLVk5YHpuKWTw6oF632FPPSVIVl5hgUAeHhj0t/sw/PEEvThLQDDFE34eCg/rLOyXT3r+L98oRKrlTO0MdALYQ3rRQqC7d822dJPGxF1K4J2TtfPSMFaCAg0n0NGk9yiaKKOJD1v2aBX9HUOIawjjfvwCmjHZJTR62R9c9x33JnBjWrN4QYEOmehy0oZMP9XM9Zyi6TYoe07PaLceRXcCWZiY/imRUWW6+mci7+wMxSdwMdbXckXtvhJH8sc4iQcTwm7yp+3f7CaesTTQB2qkgeXh+wFiSMXfMlH7Yil0OoZ2QTtRLTip2O0cLZ4SstqWHZ6H+8A2kZXhpm0kPbL9dUanTOvziqIUh6Ambwa3WrCb2eWbuCN3L1hgWUmjRC3JoL3dBhR3imSQI8xuCMfsszlji7cSShNSYdqCXPxEVwbqO9i5B6hf93YI7aeyI8jxgcVXK0I/klbvhSXjkjOIwZgPdVwmsFW7HGPLUAvDRuKm+itybRg7c8+Yqqjg824Qf+/NxsBSUNAK9KCoJpauFqK0XQULrWYj4FnxeKDuvr54iokpi+D57e6Y1zxRJJdsHnDR3JyraCUufHBRTKODWBVzthjm4k3/Hv+Q990XDVR+KW+TcJX045LW86EKhz/97aqj89A8ZvTk1//tczosU90loIPVaHuWegJU3wP//7XHcO7c0yQM2jM/IhQKrf8hiObHWiWDZManF8Uf/HzbmDfC2wT//aiZ4hGTv/xzgKwdb1sD6cGEkceow0s3b89/zg+3plyRm0HlZi886j5wUwFhdHiDTaBidZRo5cx/tMeLyguOATbzq17ydhzbrpxunuHx6lbFGiO97gsd4dk//7iCIo+Ew+hG2so5kvv+ITG4c1fzHPtu1Xn5QfUnqY3/uByVmB7gmnE/E+5zdm+6nDmoews5fr+NzThdSHzK4bBQOL9c4O8OI0xLSqjJ4lbniLJg1aFpQRLwaSMZmpkC9e/j6FOVrTQ6a/a4alGgfrl2ZL1sbHUQ3DOI7ntq9diHFfm3t1mul3rdJEJCHnlW/hlQntipMrpeMs7fUr6wK370D7VbXH0DUHzdYfRg/6Z11Ult1sffJS+heHbco15Sxy3+rDnPesqH1lajk0yu02hPUvEUqvcUXWXL7Ad0wNGMx5gOle4XJxq/r/YY0xdco2wRSEGwcT7YADlBrHc9ZbvzOL0QwyWCWWChB9Obg800v7tyBWaNvdwz+fL7Ph9i2irEeJkRgOzeEDw+JiD/V93vH9FgMEoFIJMoIuogmicZohf94SBuPn6hXaV9jP4VVVA/bu+Wg8S88GLtmEPSNRLdtlXx2XL/nuM8nKkhnlnjaropiKKLIH94pLIASci0pDBfj9Hi5BfaTSXQg5+PMjQX91Ktk4MOqK1K99l4BRPv5+vNovGZ3IxQv8ICvjV4/diThpoaM8uvd3D9d/DE477w3yAbW3IDm2i73pZ9aEj38JqS6h/s8/xgmUIVcuq2JTgefAyuoafzQxAuRASeg3NtG3ach/JEkyuX+JDt2PnDZTShUhyHHG3ttBg/6lhAchGjLJBtopj4e01MlCp2yqQRTr4sBBXru+lKaoanwYX8y2aWCJiR3KnhCOkYVFSvsO0oDRujUFOEptiNDTYrJoUbvOyvl4AhC9h3wORiTXK1MrpMfnvdnndnR/HRVSusMBgIxwrLdn3vq1VcncPiD0SquTx/kNmxeFyCT4uXVUd9AL+rSGmuq7OOCzDKeVPjiNWVaoP5KOFqYq5Xcuf/xW9S+u9eIq9GAtZWtQlgkRecjRtvG1NR4WXXpn+pwsTBTIy079Ikg8rSef1aVapIFcXCd6C2wHVjLXR+N0tw4Taw6x6H90BFRgNrtlq2up6hHKuV3inM5RJaQWZHd84e6RsKkk9po3dk9by54tpPw7cBkFas/G+GbHwuG+AwP55BZyXILTHCIVrPpXHEaUPYfL6nphJP1Rc10xG4UaCeY4IHCwuur8xmSQDgY4aVwhzWhjbtSHG8JO6P2i2nC9/0Bfx0zk6dYQq3aw7k5vIObD7SEKrxhz0fQ0+YTOfHW23CBNeZci1qNsUDhoeqmfyP6PvjoEjHk8QbrFyQVZPHVWijnb8YCM65iYNoEbvnchStZ/9cKg5Vd45j8KnB6UjzXl/bkyZx7VoD47ocUUi117WwgySSb4rXgLJ52Mv5XJbp3I+uBP81BUvOjy4Cacgi+GWWlC/8dwgqwiojjUBDnEOxyRyowwLQfytFra1OZS4XvRYr4uoamAfG3I/p2bA7G90yqKThH8Ke00Tqd+3l3dmJpaCZelBMYjGqNLVa3SM4+LQeL56gY6Bymy2LQPVOxjWfj5tq4o74swcxhyGJPynkS5xAjOXZP1/FAYcBT3u6qLoIkEfErwo4gozmyI1YCvM0oyI3ghjGPQSsof2sKUhq91WsKy9cYWN+4A2v4pG/Mxpdc6w6kI/HX7Xb0TuihmsiOy2wQIsrZbUmr3OBSUo6oDJNgQp+YqYkgTgYcWZDgawJw3DFfdzT//PhVUidgB2qa8uw/j9ToHBAS33iT8YLhhAfyXG0bQUFp7QmH7oQ3i6Flf4OTZLvJdh8pfuflmWu2ohm5pTiSg1pl3vq9uluTJwqXfh1hqy8e2iHoD+Y35gCIViTo6VOtK5dD8HYClucJucXASzwe2kPj4S4eYQtmkYHagXhAzp/F541xE8YFYqSPszDuz3soWzHy0p3E2jwZNQaIcGU9FNQwQxeDw0ZlK9dxXrj9IUHGUPTOyib8CqXmbZ7Ex54bn1rLx3qqAavu/gh6XjV0GmN1p+yyMK9HN5uYEvxgbAk43tsheREhyI+Q5WLIneKTGPmYiM/lxOp8fvqHy8YgXK0TlMiX0tliLI2JtfmWZP8eVV732sdYm+pcWzDzEmKLJZyeelyaZKkjPnnUO9keDwtgiLnmd5+t+Sr5y8brRnlvxcWEWfCqIALQYHvaXx6jTg4dAlye469uGwwOZVZCILLfGjaMg4LUCNMTtMSp1aC2y/3wR2t1v3w/iNBRQ+bNbtDqL2NAr7K4rUcyqbSpNrXZgAWXvjxBBtfYLK1uRYt3q2pfXJOAL0HtWcEwJLddOSJKV1SwvcvEuzg/4MPnA8MIUJOLqm3qI6wFyN99Ck6zYaV/zGSAzF/PGsaNa4vPLe5QnyuqVUnVQ6xELA6gbe53aGgeke+R/ycb2LJVyc7BhuzI90zA+c6wUDTb7NH//gdDSl2u/aW7lRJm8m1fLtPxcNuEM5JbkOCZKPM88HUsLRoC1pmKKlvWyeAXuxILbu0snpSxf8N+RgtLUSe5n2gdjOjoSTaN7mMZ7bF+cWk/MS8mFD4pcyl5UN7CbpFZH2a+Pm1VAnUTVfbw8qrmz1G9m5aKmRzY1SMhhPrlCn2t4uNUXNA3IFe6NOjSC1DEaAFZAfDlEkQCsbNhsZPj6NQPDSB3tLiTo0ZYoEbIeEIaKtU3Wk60rEszawTFuyHVd365LA/c/uarABN5M5rGq/dqTG3Ilye/5EKiYisisuzqNaZjmWv0z9TORc0CKbaTea214oNM9u2sXUZub/eqM3Pi/PjRSyQiOSwPWif2asTgu6hS6fb5UGosCWxdedMqdViIUUSSdIJx+qQ4KShfTT39VAWZbi+mB+iKICNwpt6cflY57Rcbs6d1kA26Iru73cuxYVlSvuJdcR5VfDYZRk8X0AXePROyw3Le6LaUdmTLzYsoNhhgQpd67xVNiHgk3pakmndeIAtTC4DCXy9oS6eU4CWxDdVmY53pKNbdAKmQsP37lrJZC6iDXMELGKcHjNuuZgcDyY8W/yv6ha3DX7OWm/35fpvhw55oitf4V+GULlcPWYyGGuVBdro19c8u0RDddDun40W7G5cSIzHLh/qZxb59R+EPY+wZ2XerkUim92hhXpKyW6WtAh6zQS97DrPyjCvKi3pCw96LeKynOpyjtsMQc2RmI/20zFOZcSa2AK++PoRcT6zeJyxlBZ7kk5mhqXGkLlM2hFKc+/T544xXP0Ua38Q6xdPTLTeG1PHnLMaOvksUQMrEFTB/lizCirmFQL8zYVU+OTeYQEFaITsBSMMYexS9HkajO2gGIf2micvntCZJsZQEwIH3/4JGJQGflBuH5rNXmnRRYXDQs3ZoEQoMtYDr1kFKUS/siiQSUxcTH9XYeBZiKDDFQoExREO9dddKQLO3BwMHvymCSTFyY+vxn3D27NDx6OlU092D5EDUwilttqVHpjJQDUceJYCLsK2swfXeNUVrBJT/w/sk+7si8rPtiMFis+oxvGdGQxirMBID700T39mULuNHzOyN+xBfcFACZcyngF1aSpv0JPkNUrAZTqfplv509cGXFUiEEm5dZb+OsP/blizqdK45/dSsIrufYTrCPY2lgJD6k6QljTfXVlHfYKSq+MsagyUcaMintyr95bD8kdTAeYNLNsMmo/Wdd8a2nStBP49ARIjqqpUHWY4q4mvO5Cq/CgCP+4/B+5zutGwX5pssgVLr1+fIM7WWLfiUQDk4c6ZdHZOWv5hG3g2dgQ5NXnpIY+BWwJpaouf25bXnjDzbHnQNofH/c6m+dEAS9Gs2h7pFRPKOBDnqswZ8KZjhId1ytHUTs533KwBoSiImoxKQUgZ7z6pA9QB3sZ8Cq0vwutJTTkfbX8AzCpm2cFXx/P22niUMHauU8IGc+78R6TsutoonoqFuoNA3l80t387YHMoL5KGAT1JO4zmx+vJ0LbLHlicHraSVYvJjnO9p++qnWgKw9OwFVVUagvZuf9qfiuum+hIicxP1q4zDnzkHsCNriLxBpxY9N+UOmqzdY1MunLMDgkMyi3uvnN3UBXJeZ8YLs5xr8QrOhimYoKuGBebZHAiBIkViv3DG8k2oNpp5OIgX6ulqaRN8V62QUPjn5tl1kPXhT9bcd8qIm8gi4or/FGbvQ6pgGSHmnayrugmf5E0upGxPRf/3xOtitGMaHLKJVm5zhglmVfI91o0yxhJZVS/5wQ8zfxK8Ylw0WmHXoGfRkoBRx9Hsnl/6sgTjAVwpmNuSeZtBwlX4qB8Bh8lxjqBDIuFGJ4I1wxN0XRlAAslzqMKwQfyA7OkuivCXfv+i+3XmhcBFM2n4jdT+NyUmBnQJPV3F2sZfKvJhUlXzSosFR4VevVVcOkFnnjdiRWc0TeSYxj41sJGYMbZTeLI3GvyZ8/gAAudQ1+4oFX+enX5V49MczGCYVBuoC4kHjp7ZVxj+clBwPr9k+v05SsezQK3enxLs1Nt/N7c7AImVUysjGou4iOohHo83Zs9/MI/OWB+OyXzOBD93NbApGHXrv8CVRHp2bwH+xB55cfNrdqFD35HSMx4iVmtzYAmSCIV8kXsHoq3DIb93riTWbubnjxbBW5zConVtbxLRStXHkIyAByaozME952Gc9aAdAbBpZSVCH88Uwb/4bPTVOVl+WoMYD7JIvK8VcMrJ8zHV4bbG0Dg7Kx17A4ej/ZcZ2Z5pVuVLUH1E/AccUTKm81SE+LQ6STTUDscUk0x2OWIbEORhg69tdoTGNkA1RfkGIRZHr5mCXOpLC55WWzCZoGPFUVtZRHwh0nq039CDdjEPo+JyaxSQAvDgR6Iqvxy0frrtEG1A385N81l05SSzN+IDm9bypF9m92EUqblnauZ5sjc37wRykOdl7w4o8WMgQsjii3EE/aJYDfHs1cH6DNBEujjcCc8qAefYFyIAURDcDnzun5UmkbBQsU4eu/W8I9nBE0qJKTdg2hwjq0+XV7a3TJ7R+alvJZCRia9lJ+grNB9dbrOmWEvUotMjvDhq4wV/kq4fvIBkzUGpDeYH74rne8uU3dgoNZdR9pUL6q9YDNRfOiF6Dyk+SYXQIghTjm9qR4tBHh0gnmF/9q3Qv22EzaLhSvDlDOxMrrCNRmLCl1jApzLrBCPn2mjn5zqK7OYK7VxOfQ5GfBfoPdyQwqFEgCVHkJ9oTnagRM3R0+rsuN5jQv9icCav/p1WqiEXSzCdLd/WEA6z6dDP7tPqPbeDYKAkVcz1lLGbFOC9b7cBd3MV0Ve8dZ89oR7OnxGS7uVpSry8banVZwpJg+nkH1jRBYa2BvBMY2xITH9ERXCjHzdZxs+ipdXP2DY7X+eWiBhtT2L0RRGTLPeazn5tpl4tu8iE2rWig731iuJDRbCHHy+g/Mb9+miAyVqfIpXT/iZeOxOxODO0hEpLM78I1+G2Z45yi3lS1K3m4WMQ559Lp4UML5vZUjYGJuxl+OPpUH5klpyBujkjprhei0TmUik10gjvNUp8mDkWlNKikmYspaVTqewbnOzJrmz8FLIpsT67EJLHIIfeDcWEfiP+DJrZ1jfxpoAb2abeMqLx+9RuZGzQoYtYVGgAWwEM9Kek2vPIeBNAKD6ao7nw6sgvfeLZPoXkbYO/tStHJdKzk+WFSFEU2NcALJAEP6S8pcnqqBBt57dwTrzQNCIdk2SocK4dLRbD/pu/VryKnm65ZYXiJCfHJk3mx9MRSl+nSK6OqEBSoGjz0/LADddwF/HqcfK3K3O+6YUGQcmj8pZL4PhZ6KrGkb8B38FmDvvLd3XQXbvS/FQmrXFTvJNkaN/FGo83KuS43BK1UfVnIqigGkCoP5fBda2MwAGTGNKX9K9t4Bx83pMFc5KSORmWKv+8VoVggWxoaBz3/9IBh6RwLd1tebwy89xvE5z6EEpXpDfrXWfRsMs6+ekUHH6idVosno55+xQ8Zqzelh0bxtJTgCcH3Z3/Cxlx9eNIS4JIFKOAVrDqbrXRszmY55a5+niJGHtkO3b6mnIDxLa1WXc7BAe33mt2KyM4Fbc3R6/WVTQN8QhlqAtave2WsQTqzWeSlKuGUVIJRqtObpv294rS0kDN1RKzdstZTXJebR2HlzsQ4P3NbMHUqFZMZw+/IKXnh4t+lY8qocp/B1oMszR03EFs3bPeND8QkItMvllObeCz3SZAjqZrobmLcrpFyQV7mwBjg3C3C8/bc5goQhv8j/IXMLGnt4mF7tybRDG5G0polxoUScQkPvmnga2/K+aapKeqSL0BTmo1Cm5g+booNOtdyKva2KoefRURaBk7113QKo3y+WTuFKtgETIK8HRluYS9DvlcciCDvnG8UaJRfZE2siZsiTHvRmN80xkUIInHeRZl5Re/+ATL6VhKFi8CZ/n/jbFV6T5pZ+Uoppvsi3qjacVFOJgWWfdlwVHKPW/TJO3na9hRM9bS2yo2rEsC6IBzRReVO6IesJU7PItzOamr+ROFfwGZmZ7ue8HNxAgLJKb7P3p8dMqk6Be5PJaT/5Rdc1deYVihWH9cjVKc9uz5EnfHqxLUkOO8iJUENBNVf5LyNy8zjLu/78k5WNTywiPfYeX3CPk7yc6CI3lum/CEZwfUaNpcI3KsPqfn2lmz3kd/acQjKA1ebkJaiuLD+epQ/Fc1llHXXMzofWzz/Kd29SNmOhcjMWw1jq1g3YfrXZ9rzXDYW4ZttfgfMi6oCUtBs0PkMVuxmq5lxEoCaSXPSqCJJ7MlKdRDidVt0AFlxk5cTdX++sBF2+E35mjwfm8ERVxH0FvuAQtsfA4V2G0TKTUxeyRGVjd/u6F1SvuAiU2/WaQjcNCU4Ep7VunXCYSbZj3U3wzu/LWM5MPlYuyQ3FOOCD/zt7K295hY2JhwF+ODDIZ676vGQFKveEQYkWj7lkK7rVmD7MhU0Y/tF8EcTTpo4/yqOufbd/zWIpMajnbDuWK2vn6OPPtz2rc9MIBNlPd8tt+yf+7SC4wqEPbozKMCwY5Bygx4JmoIEDsixWRDcdHd6S3/dZMHXOJAAv7+NIstl00crgSqHZKAEe4g3G4dzIV51EeZB01r7p8GNlfUnG/GjZgNGsqXZdYMBVtAtFNv3hJWPve4GvqZ2XxuiNkHTz5kxWgr0PjQdJlVywJ9Zf2ZvqeeTbolKtvK54re2Lq5BoyzfsRtvDfyao3kmyFzDQ88nM+qx83w74RDlkngtYiArI05Epre3GgBeSlMig0pE6RGQaFznKkGeb0SozLCyiOtxh7hgwZlbKbClzUUfC8ntMiHUOZE375RhTy9c4DA+oMLkUDkztSybZbdmP1xpaIbjUpPAHBq3cIq+CBFzbMlMMCCkUQ6d9LGV6GYCsYiEWZIy3nBnuxOYXeU4YTGDSin9e4/pCjPtQSHlg5LMEvIlF0ElthqrF129iK2RPBEWd3XWOl3SWV5uz5VUyZYp5kEFmz7QfP/B1W1BBzQ2iTGbSVT79lUHzcGXz3PJceSgz4uknETUwo0xffpr2KUvZF0i/r2sL3IFIClYx8CbIZE6Qt7MDJbOPB3xMScwaOcWG66IJfCnDkb0D2Mb+PHzX+oiCbxeTIogtyN+s2NJirNACk/OACSOTtV6vscwbzW4M168xqaI+RzR47S1nlV/rOoZnid87n/Ima2XYa3un3BuGAisNjb8eLMT9OnMtazQROFCuO1HiZXaOc0oUDbNC4eKLToOx8DzVhMgGA8XIAQ2x3b6I0uEyLssQjJX3QphcUMx4KsMgJ+72km4N2aqkBF2coKmUEt1eqIMGn+5txMT4kYVGd3ALO+y9Z4PP3d3l48JQK8s9ZZ/Qx/+NBKgBEJFlQ32psoJiihGO7FSYM5L81q72kaAYcilEFMG+ZK1BcMqELkflyCV7v8JEXLO4Rf/oZYNZHZVjJhfL6fnpP9Tio3Euue5uS7FMkfGOeRCTrBZ06Caev7tgufeTrX34Ur/Vvc+b8ksiIShNJtuF9WmYxOZ4xg8y6zTdy3KAB2y5kYkcRnXsptWwAFyKZ2I/QGySNeoQLkINUMloC+5L3WuMMx297Q1xUYLKqZ9XHavaobo6QQv4auMm+i84IhxRpPt9nUmcav9NcjCcP+TcMmxsQZ/F3mgeoA0fQgwvTsyXuuTaM3Sqtv2jaaajmaFQpK9W6uIbeqwvSDo34ZrY6elDUHwSCjHRRmlwmyy+eOra64Ssq0XSXYljMHtKY+FShcMkHsEUY/4Bw63dJ6KpwDaxmthlDdbdE+TvYF3v33cGSKqO+1H1pKYhJMvZD5ckQcHyNF8zrtiR5b0ko6NPGoRexUZTYP6VbUdn3zzxGBOi8Z0OqHjGqYxRXwN3mYi0GYEEZYq+Q3QvdKcEHILLLj8S+VFepSfErtmfZCdvxbfIifFSpEzKi+7VJsLMT+zEFeyp1OdwRC1VZrfTLIyR7xTPUcZFYPD9qI7D70uTb4hdpqPXsJIRNYbZtNwch1OI3trh3u2ScoQyM9POnInsUa+OovcwkUP1UfIzPb95n4BaF2ev57NHAej0+BVMF9/Cj9663HN2/JN3SQgslL914bKfiTTDFAz9PlQEL/dSv1H8xl3mtWxh1McFO9EJXlRDaKQDsyKO4vOJW90NFE6yw2tjbc2GeF95sbs0I9enAa6QwQVf/kJQhAD2BzUDKggOyjy1TEhED6sfk+418lQy3c/uj8aw8UEzZ6hIMCd8RohAkumMtIj9m73l2yPWoGHVTPaywkC7Yj9tBM1NxMgcrDwRtk4RO2WHT7Ql5kQCKdJj6kNuOTeyEBYBjLMhGz+O5/YGa84HEiTYEpZ6fFzy26GG2hWtTyteuYrhSyG56BjsT/wQeLRytpTY3D7sIMqZnJ9z1FDrfyjFlGl2TNw9BQysbaxOuwYYZs/7I6BANgkqCknWZC7/BBXvaeKwAmC959I+G39BUE9bExkNlbRoFRyEtNzv+NJ91FuisG3JCS6uYBeRnfv8AkAfKTeg9EYamqnsGfAV7d0f9DghHEQ5IsPGDIUhgoSj7obM4Bu5uhQ3/CYEDTHc92AsFvDK4XGrwUeGBWBHPlS+f4x+CxmmHz2sAGmSFNt65kwZC64mnaoWlu2310laYn8r62AqsR5dfjyK18MEdurdagldzfJtjFXlZs7St4QhdPiye6TPh2/ZAQLU/Fip5s7TDEM16KtRWrK9hmxnQ7bmfa/+7pa10Z8WDPK3NuJ+NN/RAbQ5vHx2uX0Lm7/w7cAEH/hvZA+mt7J7zGw7YtQYwnNN6dpgwkGjjrS3yQoeoYt1EnczmtmJfQZWzUlP3Hlg9Wzlr9IH23q3thGth+QNEANFettxKfskkGOlLk8AqoKJwDqOxAa6UzAx07plSSyNBJSGco9zjnC5gGbDoKvsMDuBR6bGRlGzJ+hFsGa/Izt78aI+WZ6dJlZKp4pGISuv9rV0sAS0MWEwCmfauO7oQZMiakHU35LBxiyJoOMddhUWgcZuC8r4Ksvn75TTcQXLJ7kWtYhGuGqPd9dZuFjBWQHNwosXY5snbHFQq72CvHXhIg+shQxycuLOuWYErwCLZeF24b7F78pO7xw4X6lIAR02hUOf5087Rl0nOaeb6CK4i/KA/EZv76ftOWZtjwxslNr0E/u8rWUmnf3amfg6UZmBAluuoj3Dd7UV+9IAJ6iYcDfSJlgmIImohjfIUMJ27z+opj50Ak9af2LCNrWrBJvMovA1OeNO+MF/MwZvnaCxTgG7Cw4QfSPF6AYCGFt21M8PySZFeV3t2Rqqs5JMzMYzGRgq4o+UaKRgBf9GHi/9X9HXA3wxkCsd/UhnHSh2zUVDiraio/6nP4y3XJqs8ABfALAtCYU7DHPMPRjgcM6Ad/HiSXDAbOdSMkvGZPAkHs8wuQTy6X2Ov/JFvcPuKfV3/r9Q28";
const FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
const NSM_MAX = 4;
function decode_arithmetic(bytes) {
  let pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i4 = 1; i4 < symbol_count; i4++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = 2 ** N2;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i4 = 0; i4 < N2; i4++) register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start2 = 0;
    let end2 = symbol_count;
    while (end2 - start2 > 1) {
      let mid = start2 + end2 >>> 1;
      if (value < acc[mid]) {
        end2 = mid;
      } else {
        start2 = mid;
      }
    }
    if (start2 == 0) break;
    symbols.push(start2);
    let a2 = low + Math.floor(range * acc[start2] / total);
    let b2 = low + Math.floor(range * acc[start2 + 1] / total) - 1;
    while (((a2 ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a2 = a2 << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a2 & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a2 = a2 << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a2;
    range = 1 + b2 - a2;
  }
  let offset2 = symbol_count - 4;
  return symbols.map((x2) => {
    switch (x2 - offset2) {
      case 3:
        return offset2 + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset2 + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset2 + bytes[pos_payload++];
      default:
        return x2 - 1;
    }
  });
}
function read_payload(v2) {
  let pos = 0;
  return () => v2[pos++];
}
function read_compressed_payload(s2) {
  return read_payload(decode_arithmetic(unsafe_atob(s2)));
}
function unsafe_atob(s2) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c2, i4) => lookup[c2.charCodeAt(0)] = i4);
  let n3 = s2.length;
  let ret = new Uint8Array(6 * n3 >> 3);
  for (let i4 = 0, pos = 0, width2 = 0, carry = 0; i4 < n3; i4++) {
    carry = carry << 6 | lookup[s2.charCodeAt(i4)];
    width2 += 6;
    if (width2 >= 8) {
      ret[pos++] = carry >> (width2 -= 8);
    }
  }
  return ret;
}
function signed(i4) {
  return i4 & 1 ? ~i4 >> 1 : i4 >> 1;
}
function read_deltas(n3, next2) {
  let v2 = Array(n3);
  for (let i4 = 0, x2 = 0; i4 < n3; i4++) v2[i4] = x2 += signed(next2());
  return v2;
}
function read_sorted(next2, prev2 = 0) {
  let ret = [];
  while (true) {
    let x2 = next2();
    let n3 = next2();
    if (!n3) break;
    prev2 += x2;
    for (let i4 = 0; i4 < n3; i4++) {
      ret.push(prev2 + i4);
    }
    prev2 += n3 + 1;
  }
  return ret;
}
function read_sorted_arrays(next2) {
  return read_array_while(() => {
    let v2 = read_sorted(next2);
    if (v2.length) return v2;
  });
}
function read_mapped(next2) {
  let ret = [];
  while (true) {
    let w2 = next2();
    if (w2 == 0) break;
    ret.push(read_linear_table(w2, next2));
  }
  while (true) {
    let w2 = next2() - 1;
    if (w2 < 0) break;
    ret.push(read_replacement_table(w2, next2));
  }
  return ret.flat();
}
function read_array_while(next2) {
  let v2 = [];
  while (true) {
    let x2 = next2(v2.length);
    if (!x2) break;
    v2.push(x2);
  }
  return v2;
}
function read_transposed(n3, w2, next2) {
  let m3 = Array(n3).fill().map(() => []);
  for (let i4 = 0; i4 < w2; i4++) {
    read_deltas(n3, next2).forEach((x2, j2) => m3[j2].push(x2));
  }
  return m3;
}
function read_linear_table(w2, next2) {
  let dx = 1 + next2();
  let dy = next2();
  let vN = read_array_while(next2);
  let m3 = read_transposed(vN.length, 1 + w2, next2);
  return m3.flatMap((v2, i4) => {
    let [x2, ...ys] = v2;
    return Array(vN[i4]).fill().map((_2, j2) => {
      let j_dy = j2 * dy;
      return [x2 + j2 * dx, ys.map((y3) => y3 + j_dy)];
    });
  });
}
function read_replacement_table(w2, next2) {
  let n3 = 1 + next2();
  let m3 = read_transposed(n3, 1 + w2, next2);
  return m3.map((v2) => [v2[0], v2.slice(1)]);
}
function read_trie(next2) {
  let ret = [];
  let sorted = read_sorted(next2);
  expand(decode2([]), []);
  return ret;
  function decode2(Q2) {
    let S2 = next2();
    let B3 = read_array_while(() => {
      let cps = read_sorted(next2).map((i4) => sorted[i4]);
      if (cps.length) return decode2(cps);
    });
    return { S: S2, B: B3, Q: Q2 };
  }
  function expand({ S: S2, B: B3 }, cps, saved) {
    if (S2 & 4 && saved === cps[cps.length - 1]) return;
    if (S2 & 2) saved = cps[cps.length - 1];
    if (S2 & 1) ret.push(cps);
    for (let br2 of B3) {
      for (let cp of br2.Q) {
        expand(br2, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s2) {
  let cps = [];
  for (let pos = 0, len = s2.length; pos < len; ) {
    let cp = s2.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk) return String.fromCodePoint(...cps);
  let buf = [];
  for (let i4 = 0; i4 < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i4, i4 += chunk)));
  }
  return buf.join("");
}
function compare_arrays(a2, b2) {
  let n3 = a2.length;
  let c2 = n3 - b2.length;
  for (let i4 = 0; c2 == 0 && i4 < n3; i4++) c2 = a2[i4] - b2[i4];
  return c2;
}
var COMPRESSED = "AEUDVgHLCGMATwDUADIAdAAhADQAFAAtABQAIQAPACcADQASAAoAGAAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAeYDMwCxCl8B8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobWgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vAITAdQZWxDzALN9AhsZVwIcGSkCBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rlr3JG9m8w9lIAXltp/v8kfWaIaaR9OwpAES/I3ZVamDXSgB/UsOgAG6D0tq+5CIqE15FiAhV3yA2VhCQ7tj+m6xXaF53FIfGi/IAZIskMGAi2MU7MDVJNCbMzERyHZi+osdPtnFVbvq653O8rwaCy4IAf9OOok65AqJUtUriUfYsGPPVbe6jm0s9lbKlPCUKjdkHsFsEhvX4kT39ZCtAAbwQdn/h4TpO5hTByWAmr5n+Wuwhdegv6bmvX4LyOes3z2+cuHv2JFYwVMNuq2gzn8YHTjlUQd39osyWei4NKl3LAdfxlO876hh5ENp/cOvpuI9bF55guEthLLPOXjD4dktTH04P5TvZrWTM0e4+BHJxj7MLApXIFOs0sWKhNkG8iwuM5wR83my6V3wW06abhDzTXYfOr/ZpFXgXzmv4d12FFyP00/dPGbIVGV5ao8UufGzUwp/IHx6v/wDWJr9iaoCulhWwlZ7A8q/NMoD12+mBdNRgJYnThRLtMx1Bgwttn8/4Qn2CDfOSup9GVXEvA21ILgp0owHYxNOkpwLWz0G7K+WREIDjIzUzSn8I99CuJSmSpPyH0Ke6/NERYiNx+3dncSebPnOUnnWD61AhJ1n/tSLZmU5wYO5GfgzyAYJm6VL91LxZ8hL1lfximQxIDMRhIecQZBmeE5R0XlrpvwplVrJwpa8BBCdp93GPP9lyBeZ2zkRr920CR3cYbKpKHfogvm0nV7XdDz6EbjzlxADCMjSLXuXpIpyuizy39yY+I+H9rmpoIF3YwEjlH9MgGgWcCNTjHEWMqAbprn2Ox7rOHupaVE3lNyg3nt5XaZID6Y+uml5Ja+aOPu+BI+DZbiJVfaspUadakWUX6TA4dETkIqdJJHYnU4Z4yKpt5y8rVIahoMUf8A8kWtAQNCTbjp71gx3/zVdqNz1Sutkw0gFIMVm2BF4Xdv/0olw+NaDIR9Bb3DPweZA2K/cw+/b+AwyWl9ZOP67A9nexmeTNjfdzPGf9J6E6BMPKa5lJh+qNsdUz3HBUevU71eQFCqOcxiIYhacAhh/8PX0J5DdSViZ6WazDDx7cukJNpMfEkYLJ5Ao4vLoVd3d25Pg4qaVa2p2D2L3WvYPJ5Yf/A/MSxptjlgXL/KJtP2U0cRv2I09ATAiWCJYuRwiapeKFsqmi18yMMulDp3HdcIldq+7jkwsJUOHLHCzzzBw5XFvL0CAmo1ub456z7zb7shk3KPGCLZzr47oT1k/j06XNnJvG3Udv6XrP+wsqTBlZ5MaNPt9FOs/4Bt/ja/vbVhTNpBFl9Gq7MqINvGlWKOAwQzwOZy+EzSdjAqKJVV2YcskTuM94aIK+kc/AZaXiZLPREUDpkXIV947IFfj+85TrqPqLfkGcxgboMQjosf+az+odLNXdyp1mDNGsqSdK/pJ2Ca04mt/4d6s1X+lncOEYaGBBeW4pApGcjf7/XJCFbj3N3mFb+BtlIcw8ZiDKoClFX9Rf0bxCqtLpicObKJzBVVHr/6u4siH2hK75RNv7w9GfTbhJOQBYiFUZAByY4rn37tZBHT//kqKsNi3ryL9AqXJRzqiMIJMhILjoi/i8LVEsbu+Ih9bsyW16sgQqjYLO0qda6KaCPKj3DQcu6CfV5lKtjS3ZCdqLAZkOey9MR+QutJBGiz/r15GVD6rCVwJR4UUKC4GNJkfDf00OMW8aQtLSAGLXV8MIi9mbbl/qQEpxCm2L5hutFX4ekeLH4QgBWUFKs/2VVMKy46WtFE6AbwgmYm/Z0yHk5veDIrcl2HpVqb/rSE0PC9EbDzJEWqeaPhh7vF369Umq2kSiB3s5rBI6c/7N9bkRu4h2n+/h5nSwy+7n+/I+6oXQVANo2Jb5zDwtiBPf1ySCzHdT6yJShMzqSRZfnykX49CaFaxhoVF4PBhEuECJ1PrFYSpmHuyYsl14DTAV9ZxRms1XiR/kBrjhZjidOt0UNe+GSml7XNgpVw8YsUTmZXLTK+6iYnyW/wYR1W4UXwOi14xpFROHb6HcZzksgF5DbL2AFXzKNwHU2adjdAY+KCyM/cwRTBkkq/a227NI0q6DR2MkMCRu620t79bGcYUmACtqN3mk/0uNwd3JSXHqE1kzf6Yyj0W2083JNDRnIXDlgBxJ6uf58NN1f6FQiRCWB4egF8QDx74AixV8oTyw7PluIjr3/rj/WzgwPSq4xPojaF7V0xqG2u5ti2L1h6yYHv73Isrukr0kURDIEjClBsBx7kdcXUxaYMS0syT3ymLzDzslNDWQOT1Tao1YNmJHARUenhCkmV9tqCPGI5GqZaRpkiPxyjoncWjyOHYGqvbvRX+Bn1pn7EhRNXa1lqJPmoeN5VqdqIDPhEVhFsyG0d4iQEIYX0wZUbY2XbZWYlpZ/l66IrDDY0q1C1YzBDpHC4h05YqHQLqS9anyl22JQ6lEvjvdBwMHfE7z0luCXD34/rFeDa2TmSeEAykSpYO5j1G/nsgpR3qn0qaQEmLjnnLfcz+veoYqPnRqmRGwCJ6FJ3Gm/Z1/aVX5PSb03MMnjAf41ww54sD5k8FrkfBP+K0b1MrYpapWjtpZfve2HVf4ickX3LKSOhu7qI1Vd4c1kNrn2ajy1t4y93JhV4fnWCKq7OmFpcr7FjdJCXPTql0Drr14Ho3Z87+GPQ4Z/DcTiGqtvZxlRYi8cNuhXABveZIwNl/BX1huhVLaFax5OqypUrQRyb9OE3SSkPlDdy5uo5XGg2EIGEjLY1MO5cr1ibfiFWV7zspcTgkBKkwo5jPyAin04LqizZXb2tDRgwKJjGx4cVk3ngAQixwcxjYAg2Q7vmUR/hpwInMdw7OhC2qyf41vTPkudQAORS0DdLtOGQxb4fH2VYGsvJCkeWPeUwtf1/tuIhzXEThoCZzzSJqqjUtbaPI3ntHm3T5uf849hGUA0zU8ni5W+EEn3/0Y6oUhQFw9z0aGjkljBbAlFXc0y82G2wkd7VdgWa5KTgJJNjNwZMfmdnUIUn1JU5LiWX5UZEZbVlKSN76mlmjUR2ku+fucTNlO4IAAahnLjBhlvQNR9pe9swGBgq0YR7P3VCyI/seYwQ4QBzy9X+HPePgoF8WfKaJ4MBOhLCGHae6Z8xkNXwni9QAKvTNtVA56x8YJflZ/VvONRSlsSLmiSyNMnTjTaE1ko81zkzGEnVwEhjCzlwIqpxmpDAqwsEmtpdr3xpc7i/ZX3f2TzT3M0FdxIEQvO1jgmmiN+D1YpMduAzEhBtj2OBkMN/rv6p7Th4pSH6f5aH3aTvwFTl7EOSgGASI7ttyMehzpm4AVyK+bFEaFg9gnZsSUPpsbAe/0RFhrH+EXZ12Z7thf4dzN1+Sn+G8QrDA1VKaN4IFxD1rQz9Xq9Coii9S9/hPbTGjyBwFH3H1UdQuz5KsgPDEHua4/kPg2Gp/IIItsaLWBqiT9XH45MiQxSosGJ56H/0F2cjcCFd72l1665RNHURdC3lspI77esfJsl+rXXabkAy7vxDXG/XGGcKpwiKDPFfvMEgjkAHil4Za1F36RnyxxvdIAzvgfH8knukYDck07tc++DP4TdWeI7HXuq5Yl6VVFrUQtf64/dkXewlKZSHQo6YvCSpREB0GDrz+Ys2GfO8nw2SwrYwaf88AifzlPvP17bf1mI3AuccJvAjZIpBmqvharKFAebEjVKfGAwpQjWoXlm9LROsq9bCk1UeQ3CJxJqprzssS/Q04JeS1ReCCubL3J7sx86spkP4eNpp95UF+8K748icIs8vdILFklk9skQqi1So6cx3X906pvy1vz+KipTJ8fiVJxsV5MmT0XwA";
const S0 = 44032;
const L0 = 4352;
const V0 = 4449;
const T0 = 4519;
const L_COUNT = 19;
const V_COUNT = 21;
const T_COUNT = 28;
const N_COUNT = V_COUNT * T_COUNT;
const S_COUNT = L_COUNT * N_COUNT;
const S1 = S0 + S_COUNT;
const L1 = L0 + L_COUNT;
const V1 = V0 + V_COUNT;
const T1 = T0 + T_COUNT;
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
let SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;
function init$1() {
  let r2 = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r2).flatMap((v2, i4) => v2.map((x2) => [x2, i4 + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r2));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp, cps] of read_mapped(r2)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a2, b2] = cps;
      let bucket = RECOMP.get(a2);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a2, bucket);
      }
      bucket.set(b2, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a2, b2) {
  if (a2 >= L0 && a2 < L1 && b2 >= V0 && b2 < V1) {
    return S0 + (a2 - L0) * N_COUNT + (b2 - V0) * T_COUNT;
  } else if (is_hangul(a2) && b2 > T0 && b2 < T1 && (a2 - S0) % T_COUNT == 0) {
    return a2 + (b2 - T0);
  } else {
    let recomp = RECOMP.get(a2);
    if (recomp) {
      recomp = recomp.get(b2);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK) init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add2(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add2(L0 + l_index);
        add2(V0 + v_index);
        if (t_index > 0) add2(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add2(cp);
        }
      }
      if (!buf.length) break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i4 = 1; i4 < ret.length; i4++) {
      let cc = unpack_cc(ret[i4]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j2 = i4 - 1;
      while (true) {
        let tmp = ret[j2 + 1];
        ret[j2 + 1] = ret[j2];
        ret[j2] = tmp;
        if (!j2) break;
        prev_cc = unpack_cc(ret[--j2]);
        if (prev_cc <= cc) break;
      }
      prev_cc = unpack_cc(ret[i4]);
    }
  }
  return ret;
}
function composed_from_decomposed(v2) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v2) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
const HYPHEN = 45;
const STOP_CH = ".";
const FE0F = 65039;
const UNIQUE_PH = 1;
const Array_from = (x2) => Array.from(x2);
function group_has_cp(g2, cp) {
  return g2.P.has(cp) || g2.Q.has(cp);
}
class Emoji extends Array {
  get is_emoji() {
    return true;
  }
  // free tagging system
}
let MAPPED, IGNORED, CM, NSM, ESCAPE, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;
function init() {
  if (MAPPED) return;
  let r2 = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r2);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set, v2) => v2.forEach((x2) => set.add(x2));
  MAPPED = new Map(read_mapped(r2));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i4) => CM[i4]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  read_sorted_set();
  let chunks = read_sorted_arrays(r2);
  let unrestricted = r2();
  const read_chunked = () => {
    let set = /* @__PURE__ */ new Set();
    read_sorted_array().forEach((i4) => set_add_many(set, chunks[i4]));
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS = read_array_while((i4) => {
    let N2 = read_array_while(r2).map((x2) => x2 + 96);
    if (N2.length) {
      let R2 = i4 >= unrestricted;
      N2[0] -= 32;
      N2 = str_from_cps(N2);
      if (R2) N2 = `Restricted[${N2}]`;
      let P2 = read_chunked();
      let Q2 = read_chunked();
      let M2 = !r2();
      return { N: N2, P: P2, Q: Q2, M: M2, R: R2 };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a2, b2) => a2 - b2);
  wholes.forEach((cp, i4) => {
    let d3 = r2();
    let w2 = wholes[i4] = d3 ? wholes[i4 - d3] : { V: [], M: /* @__PURE__ */ new Map() };
    w2.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w2);
    }
  });
  for (let { V: V2, M: M2 } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V2) {
      let gs = GROUPS.filter((g2) => group_has_cp(g2, cp));
      let rec = recs.find(({ G }) => gs.some((g2) => G.has(g2)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs);
    }
    let union = recs.flatMap((x2) => Array_from(x2.G));
    for (let { G, V: V3 } of recs) {
      let complement = new Set(union.filter((g2) => !G.has(g2)));
      for (let cp of V3) {
        M2.set(cp, complement);
      }
    }
  }
  VALID = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g2 of GROUPS) {
    for (let cp of g2.P) add_to_union(cp);
    for (let cp of g2.Q) add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r2).map((v2) => Emoji.from(v2)).sort(compare_arrays);
  EMOJI_ROOT = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev2 = [EMOJI_ROOT];
    for (let cp of cps) {
      let next2 = prev2.map((node2) => {
        let child = node2.get(cp);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node2.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev2.push(...next2);
      } else {
        prev2 = next2;
      }
    }
    for (let x2 of prev2) {
      x2.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s2) {
  return `"${s2}"`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i4 = cps.lastIndexOf(UNDERSCORE); i4 > 0; ) {
    if (cps[--i4] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev2 = FENCED.get(cp);
  if (prev2) throw error_placement(`leading ${prev2}`);
  let n3 = cps.length;
  let last = -1;
  for (let i4 = 1; i4 < n3; i4++) {
    cp = cps[i4];
    let match2 = FENCED.get(cp);
    if (match2) {
      if (last == i4) throw error_placement(`${prev2} + ${match2}`);
      last = i4 + 1;
      prev2 = match2;
    }
  }
  if (last == n3) throw error_placement(`trailing ${prev2}`);
}
function safe_str_from_cps(cps, max2 = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0])) buf.push("");
  if (cps.length > max2) {
    max2 >>= 1;
    cps = [...cps.slice(0, max2), 8230, ...cps.slice(-max2)];
  }
  let prev2 = 0;
  let n3 = cps.length;
  for (let i4 = 0; i4 < n3; i4++) {
    let cp = cps[i4];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev2, i4)));
      buf.push(quoter(cp));
      prev2 = i4 + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev2, n3)));
  return buf.join("");
}
function is_combining_mark(cp, only_nsm) {
  init();
  return CM.has(cp);
}
function should_escape(cp) {
  init();
  return ESCAPE.has(cp);
}
function ens_normalize(name) {
  return flatten(split(name, nfc, filter_fe0f));
}
function split(name, nf2, ef) {
  if (!name) return [];
  init();
  let offset2 = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset: offset2
      // codepoint, not substring!
    };
    offset2 += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf2, ef);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type = "ASCII";
      } else {
        let chars = tokens.flatMap((x2) => x2.is_emoji ? [] : x2);
        if (!chars.length) {
          type = "Emoji";
        } else {
          if (CM.has(norm[0])) throw error_placement("leading combining mark");
          for (let i4 = 1; i4 < token_count; i4++) {
            let cps = tokens[i4];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i4 - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g2] = determine_group(unique);
          check_group(g2, chars);
          check_whole(g2, unique);
          type = g2.N;
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH) return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g2) => set.has(g2)) : Array_from(set);
      if (!maker.length) return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g2 of maker) {
      if (shared.every((cp) => group_has_cp(g2, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g2.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g2) => group_has_cp(g2, cp));
    if (!gs.length) {
      if (!GROUPS.some((g2) => group_has_cp(g2, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1) break;
  }
  return groups;
}
function flatten(split2) {
  return split2.map(({ input, error, output }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split2.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
    }
    return str_from_cps(output);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g2, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g3) => g3.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g2.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g2, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g2, cp)) {
      throw error_group_member(g2, cp);
    }
  }
  if (g2.M) {
    let decomposed2 = nfd(cps);
    for (let i4 = 1, e2 = decomposed2.length; i4 < e2; i4++) {
      if (NSM.has(decomposed2[i4])) {
        let j2 = i4 + 1;
        for (let cp; j2 < e2 && NSM.has(cp = decomposed2[j2]); j2++) {
          for (let k2 = i4; k2 < j2; k2++) {
            if (decomposed2[k2] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j2 - i4 > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i4 - 1, j2)))} (${j2 - i4}/${NSM_MAX})`);
        }
        i4 = j2;
      }
    }
  }
}
function tokens_from_str(input, nf2, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf2(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf2(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node2 = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node2 = node2.get(cps[--pos]);
    if (!node2) break;
    let { V: V2 } = node2;
    if (V2) {
      emoji = V2;
      cps.length = pos;
    }
  }
  return emoji;
}
function normalize$1(name) {
  return ens_normalize(name);
}
function normalize(name) {
  return normalize$1(name);
}
class EVMWagmiClient {
  constructor(options) {
    this.appKit = void 0;
    this.options = void 0;
    this.chain = ConstantsUtil$2.CHAIN.EVM;
    this.defaultChain = void 0;
    this.tokens = HelpersUtil.getCaipTokens(this.options?.tokens);
    this.getCaipDefaultChain = this.options?.defaultChain;
    this.siweControllerClient = this.options?.siweConfig;
    const { wagmiConfig, defaultChain } = options;
    if (!wagmiConfig) {
      throw new Error("wagmiConfig is undefined");
    }
    this.wagmiConfig = wagmiConfig;
    this.defaultChain = getCaipDefaultChain(defaultChain);
    this.siweControllerClient = options.siweConfig;
    this.networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => {
        const chainId = NetworkUtil$1.caipNetworkIdToNumber(caipNetwork?.id);
        if (chainId) {
          await switchChain(this.wagmiConfig, { chainId });
        }
      },
      getApprovedCaipNetworksData: async () => new Promise((resolve) => {
        const connections = new Map(this.wagmiConfig.state.connections);
        const connection = connections.get(this.wagmiConfig.state.current || "");
        if (connection?.connector?.id === ConstantsUtil$3.AUTH_CONNECTOR_ID) {
          resolve(getEmailCaipNetworks());
        } else if (connection?.connector?.id === ConstantsUtil$3.WALLET_CONNECT_CONNECTOR_ID) {
          const connector = this.wagmiConfig.connectors.find((c2) => c2.id === ConstantsUtil$3.WALLET_CONNECT_CONNECTOR_ID);
          resolve(getWalletConnectCaipNetworks(connector));
        }
        resolve({ approvedCaipNetworkIds: void 0, supportsAllNetworks: true });
      })
    };
    this.connectionControllerClient = {
      connectWalletConnect: async (onUri) => {
        const siweConfig = this.options?.siweConfig;
        const connector = this.wagmiConfig.connectors.find((c2) => c2.id === ConstantsUtil$3.WALLET_CONNECT_CONNECTOR_ID);
        if (!connector) {
          throw new Error("connectionControllerClient:getWalletConnectUri - connector is undefined");
        }
        const provider = await connector.getProvider();
        provider.on("display_uri", (data2) => {
          onUri(data2);
        });
        const clientId = await provider.signer?.client?.core?.crypto?.getClientId();
        if (clientId) {
          this.appKit?.setClientId(clientId);
        }
        const chainId = NetworkUtil$1.caipNetworkIdToNumber(this.appKit?.getCaipNetwork()?.id);
        const siweParams = await siweConfig?.getMessageParams?.();
        if (siweConfig?.options?.enabled && typeof provider?.authenticate === "function" && siweParams && Object.keys(siweParams || {}).length > 0) {
          const { SIWEController, getDidChainId, getDidAddress } = await __vitePreload(async () => {
            const { SIWEController: SIWEController2, getDidChainId: getDidChainId2, getDidAddress: getDidAddress2 } = await import("./index-BPfKs9-b.js");
            return { SIWEController: SIWEController2, getDidChainId: getDidChainId2, getDidAddress: getDidAddress2 };
          }, true ? [] : void 0);
          await connector.setRequestedChainsIds(siweParams.chains);
          let reorderedChains = siweParams.chains;
          if (chainId) {
            reorderedChains = [chainId, ...siweParams.chains.filter((c2) => c2 !== chainId)];
          }
          const result = await provider.authenticate({
            nonce: await siweConfig.getNonce(),
            methods: [...y2],
            ...siweParams,
            chains: reorderedChains
          });
          const signedCacao = result?.auths?.[0];
          if (signedCacao) {
            const { p: p2, s: s2 } = signedCacao;
            const cacaoChainId = getDidChainId(p2.iss) || "";
            const address = getDidAddress(p2.iss);
            if (address && cacaoChainId) {
              SIWEController.setSession({
                address,
                chainId: parseInt(cacaoChainId, 10)
              });
            }
            try {
              const message = provider.signer.client.formatAuthMessage({
                request: p2,
                iss: p2.iss
              });
              await SIWEController.verifyMessage({
                message,
                signature: s2.s,
                cacao: signedCacao
              });
            } catch (error) {
              console.error("Error verifying message", error);
              await provider.disconnect().catch(console.error);
              await SIWEController.signOut().catch(console.error);
              throw error;
            }
          }
          this.wagmiConfig.state.current = "";
        }
        await connect(this.wagmiConfig, { connector, chainId });
      },
      connectExternal: async ({ id, provider, info }) => {
        const connector = this.wagmiConfig.connectors.find((c2) => c2.id === id);
        if (!connector) {
          throw new Error("connectionControllerClient:connectExternal - connector is undefined");
        }
        this.appKit?.setClientId(null);
        if (provider && info && connector.id === ConstantsUtil$3.EIP6963_CONNECTOR_ID) {
          connector.setEip6963Wallet?.({ provider, info });
        }
        const chainId = NetworkUtil$1.caipNetworkIdToNumber(this.appKit?.getCaipNetwork()?.id);
        await connect(this.wagmiConfig, { connector, chainId });
      },
      checkInstalled: (ids) => {
        const injectedConnector = this.appKit?.getConnectors().find((c2) => c2.type === "INJECTED");
        if (!ids) {
          return Boolean(window.ethereum);
        }
        if (injectedConnector) {
          if (!window?.ethereum) {
            return false;
          }
          return ids.some((id) => Boolean(window.ethereum?.[String(id)]));
        }
        return false;
      },
      disconnect: async () => {
        await disconnect(this.wagmiConfig);
        this.appKit?.setClientId(null);
        if (this.options?.siweConfig?.options?.signOutOnDisconnect) {
          const { SIWEController } = await __vitePreload(async () => {
            const { SIWEController: SIWEController2 } = await import("./index-BPfKs9-b.js");
            return { SIWEController: SIWEController2 };
          }, true ? [] : void 0);
          await SIWEController.signOut();
        }
      },
      signMessage: async (message) => {
        const caipAddress = this.appKit?.getCaipAddress() || "";
        const account = requireCaipAddress(caipAddress);
        return signMessage(this.wagmiConfig, { message, account });
      },
      estimateGas: async (args) => {
        if (args.chainNamespace && args.chainNamespace !== "eip155") {
          throw new Error("connectionControllerClient:estimateGas - invalid chain namespace");
        }
        try {
          return await estimateGas(this.wagmiConfig, {
            account: args.address,
            to: args.to,
            data: args.data,
            type: "legacy"
          });
        } catch (error) {
          return 0n;
        }
      },
      sendTransaction: async (data2) => {
        if (data2.chainNamespace && data2.chainNamespace !== "eip155") {
          throw new Error("connectionControllerClient:sendTransaction - invalid chain namespace");
        }
        const { chainId } = getAccount(this.wagmiConfig);
        const txParams = {
          account: data2.address,
          to: data2.to,
          value: data2.value,
          gas: data2.gas,
          gasPrice: data2.gasPrice,
          data: data2.data,
          chainId,
          type: "legacy"
        };
        await prepareTransactionRequest(this.wagmiConfig, txParams);
        const tx = await sendTransaction(this.wagmiConfig, txParams);
        await waitForTransactionReceipt(this.wagmiConfig, { hash: tx, timeout: 25e3 });
        return tx;
      },
      writeContract: async (data2) => {
        const caipAddress = this.appKit?.getCaipAddress() || "";
        const account = requireCaipAddress(caipAddress);
        const chainId = NetworkUtil$1.caipNetworkIdToNumber(this.appKit?.getCaipNetwork()?.id);
        const tx = await writeContract(this.wagmiConfig, {
          chainId,
          address: data2.tokenAddress,
          account,
          abi: data2.abi,
          functionName: data2.method,
          args: [data2.receiverAddress, data2.tokenAmount]
        });
        return tx;
      },
      getEnsAddress: async (value) => {
        try {
          const chainId = NetworkUtil$1.caipNetworkIdToNumber(this.appKit?.getCaipNetwork()?.id);
          let ensName = false;
          let wcName = false;
          if (value?.endsWith(ConstantsUtil$2.WC_NAME_SUFFIX)) {
            wcName = await this.appKit?.resolveWalletConnectName(value) || false;
          }
          if (chainId === mainnet.id) {
            ensName = await getEnsAddress(this.wagmiConfig, {
              name: normalize(value),
              chainId
            });
          }
          return ensName || wcName || false;
        } catch {
          return false;
        }
      },
      getEnsAvatar: async (value) => {
        const chainId = NetworkUtil$1.caipNetworkIdToNumber(this.appKit?.getCaipNetwork()?.id);
        if (chainId !== mainnet.id) {
          return false;
        }
        const avatar = await getEnsAvatar(this.wagmiConfig, {
          name: normalize(value),
          chainId
        });
        return avatar || false;
      },
      parseUnits,
      formatUnits
    };
  }
  construct(appKit, options) {
    if (!options.projectId) {
      throw new Error("projectId is undefined");
    }
    this.appKit = appKit;
    this.options = options;
    this.tokens = HelpersUtil.getCaipTokens(options.tokens);
    this.syncRequestedNetworks([...this.wagmiConfig.chains]);
    this.syncConnectors(this.wagmiConfig.connectors);
    this.initAuthConnectorListeners([...this.wagmiConfig.connectors]);
    watchConnectors(this.wagmiConfig, {
      onChange: (connectors) => this.syncConnectors(connectors)
    });
    watchAccount(this.wagmiConfig, {
      onChange: (accountData) => this.syncAccount({ ...accountData })
    });
    this.appKit?.setEIP6963Enabled(options.enableEIP6963 !== false);
    this.appKit?.subscribeShouldUpdateToAddress((newAddress) => {
      if (newAddress) {
        const connections = getConnections(this.wagmiConfig);
        const connector = connections[0]?.connector;
        if (connector) {
          switchAccount(this.wagmiConfig, {
            connector
          }).then((response) => this.syncAccount({
            address: newAddress,
            isConnected: true,
            addresses: response.accounts,
            connector,
            chainId: response.chainId
          }));
        }
      }
    });
  }
  subscribeState(callback) {
    return this.appKit?.subscribeState((state2) => callback({
      ...state2,
      selectedNetworkId: NetworkUtil$1.caipNetworkIdToNumber(state2.selectedNetworkId)
    }));
  }
  syncRequestedNetworks(chains2) {
    const requestedCaipNetworks = chains2?.map((chain) => ({
      id: `${ConstantsUtil$3.EIP155}:${chain.id}`,
      name: chain.name,
      imageId: PresetsUtil.EIP155NetworkImageIds[chain.id],
      imageUrl: this.options?.chainImages?.[chain.id],
      chain: this.chain
    }));
    this.appKit?.setRequestedCaipNetworks(requestedCaipNetworks ?? [], this.chain);
  }
  async syncAccount({ address, chainId, connector, addresses, status }) {
    const caipAddress = `${ConstantsUtil$3.EIP155}:${chainId}:${address}`;
    if (this.appKit?.getCaipAddress() === caipAddress) {
      return;
    }
    if (status === "connected" && address && chainId) {
      this.syncNetwork(address, chainId, true);
      this.appKit?.setIsConnected(true, this.chain);
      this.appKit?.setCaipAddress(caipAddress, this.chain);
      await Promise.all([
        this.syncProfile(address, chainId),
        this.syncBalance(address, chainId),
        this.syncConnectedWalletInfo(connector),
        this.appKit?.setApprovedCaipNetworksData(this.chain)
      ]);
      if (connector) {
        this.syncConnectedWalletInfo(connector);
      }
      const isAuthConnector = connector?.id === ConstantsUtil$3.AUTH_CONNECTOR_ID;
      if (!isAuthConnector && addresses?.length) {
        this.appKit?.setAllAccounts(addresses.map((addr) => ({ address: addr, type: "eoa" })), this.chain);
      }
    } else if (status === "disconnected") {
      this.appKit?.resetAccount(this.chain);
      this.appKit?.resetWcConnection();
      this.appKit?.resetNetwork();
      this.appKit?.setAllAccounts([], this.chain);
      this.appKit?.setIsConnected(false, this.chain);
    }
  }
  async syncNetwork(address, chainId, isConnected) {
    const chain = this.wagmiConfig.chains.find((c2) => c2.id === chainId);
    if (chain || chainId) {
      const name = chain?.name ?? chainId?.toString();
      const id = Number(chain?.id ?? chainId);
      const caipChainId = `${ConstantsUtil$3.EIP155}:${id}`;
      this.appKit?.setCaipNetwork({
        id: caipChainId,
        name,
        imageId: PresetsUtil.EIP155NetworkImageIds[id],
        imageUrl: this.options?.chainImages?.[id],
        chain: this.chain
      });
      if (isConnected && address && chainId) {
        const caipAddress = `${ConstantsUtil$3.EIP155}:${id}:${address}`;
        this.appKit?.setCaipAddress(caipAddress, this.chain);
        if (chain?.blockExplorers?.default?.url) {
          const url = `${chain.blockExplorers.default.url}/address/${address}`;
          this.appKit?.setAddressExplorerUrl(url, this.chain);
        } else {
          this.appKit?.setAddressExplorerUrl(void 0, this.chain);
        }
        await this.syncBalance(address, chainId);
      }
    }
  }
  async syncWalletConnectName(address) {
    if (!this.appKit) {
      throw new Error("syncWalletConnectName - appKit is undefined");
    }
    try {
      const registeredWcNames = await this.appKit.getWalletConnectName(address);
      if (registeredWcNames[0]) {
        const wcName = registeredWcNames[0];
        this.appKit?.setProfileName(wcName.name, this.chain);
      } else {
        this.appKit?.setProfileName(null, this.chain);
      }
    } catch {
      this.appKit?.setProfileName(null, this.chain);
    }
  }
  async syncProfile(address, chainId) {
    if (!this.appKit) {
      throw new Error("syncProfile - appKit is undefined");
    }
    try {
      const { name, avatar } = await this.appKit.fetchIdentity({
        address
      });
      this.appKit?.setProfileName(name, this.chain);
      this.appKit?.setProfileImage(avatar, this.chain);
      if (!name) {
        await this.syncWalletConnectName(address);
      }
    } catch {
      if (chainId === mainnet.id) {
        const profileName = await getEnsName(this.wagmiConfig, { address, chainId });
        if (profileName) {
          this.appKit?.setProfileName(profileName, this.chain);
          const profileImage = await getEnsAvatar(this.wagmiConfig, {
            name: profileName,
            chainId
          });
          if (profileImage) {
            this.appKit?.setProfileImage(profileImage, this.chain);
          }
        } else {
          await this.syncWalletConnectName(address);
          this.appKit?.setProfileImage(null, this.chain);
        }
      } else {
        await this.syncWalletConnectName(address);
        this.appKit?.setProfileImage(null, this.chain);
      }
    }
  }
  async syncBalance(address, chainId) {
    const chain = this.wagmiConfig.chains.find((c2) => c2.id === chainId);
    if (chain) {
      const balance = await getBalance(this.wagmiConfig, {
        address,
        chainId: chain.id,
        token: this.options?.tokens?.[chain.id]?.address
      });
      this.appKit?.setBalance(balance.formatted, balance.symbol, this.chain);
      return;
    }
    this.appKit?.setBalance(void 0, void 0, this.chain);
  }
  async syncConnectedWalletInfo(connector) {
    if (!connector) {
      throw Error("syncConnectedWalletInfo - connector is undefined");
    }
    if (connector.id === ConstantsUtil$3.WALLET_CONNECT_CONNECTOR_ID && connector.getProvider) {
      const walletConnectProvider = await connector.getProvider();
      if (walletConnectProvider.session) {
        this.appKit?.setConnectedWalletInfo({
          ...walletConnectProvider.session.peer.metadata,
          name: walletConnectProvider.session.peer.metadata.name,
          icon: walletConnectProvider.session.peer.metadata.icons?.[0]
        }, this.chain);
      }
    } else {
      const wagmiConnector = this.appKit?.getConnectors().find((c2) => c2.id === connector.id);
      this.appKit?.setConnectedWalletInfo({
        name: connector.name,
        icon: connector.icon || this.appKit.getConnectorImage(wagmiConnector)
      }, this.chain);
    }
  }
  syncConnectors(connectors) {
    const uniqueIds = /* @__PURE__ */ new Set();
    const filteredConnectors = connectors.filter((item) => !uniqueIds.has(item.id) && uniqueIds.add(item.id));
    const w3mConnectors = [];
    filteredConnectors.forEach(({ id, name, type, icon }) => {
      const shouldSkip = ConstantsUtil$3.AUTH_CONNECTOR_ID === id;
      if (!shouldSkip) {
        w3mConnectors.push({
          id,
          explorerId: PresetsUtil.ConnectorExplorerIds[id],
          imageUrl: this.options?.connectorImages?.[id] ?? icon,
          name: PresetsUtil.ConnectorNamesMap[id] ?? name,
          imageId: PresetsUtil.ConnectorImageIds[id],
          type: PresetsUtil.ConnectorTypesMap[type] ?? "EXTERNAL",
          info: {
            rdns: id
          },
          chain: this.chain
        });
      }
    });
    this.appKit?.setConnectors(w3mConnectors);
    this.syncAuthConnector(filteredConnectors);
  }
  async syncAuthConnector(connectors) {
    const authConnector2 = connectors.find(({ id }) => id === ConstantsUtil$3.AUTH_CONNECTOR_ID);
    if (authConnector2) {
      const provider = await authConnector2.getProvider();
      this.appKit?.addConnector({
        id: ConstantsUtil$3.AUTH_CONNECTOR_ID,
        type: "AUTH",
        name: "Auth",
        provider,
        email: authConnector2.email,
        socials: authConnector2.socials,
        showWallets: authConnector2.showWallets,
        chain: this.chain,
        walletFeatures: authConnector2.walletFeatures
      });
    }
  }
  async initAuthConnectorListeners(connectors) {
    const authConnector2 = connectors.find(({ id }) => id === ConstantsUtil$3.AUTH_CONNECTOR_ID);
    if (authConnector2) {
      await this.listenAuthConnector(authConnector2);
      await this.listenModal(authConnector2);
    }
  }
  async listenAuthConnector(connector) {
    if (typeof window !== "undefined" && connector) {
      this.appKit?.setLoading(true);
      const provider = await connector.getProvider();
      const isLoginEmailUsed = provider.getLoginEmailUsed();
      this.appKit?.setLoading(isLoginEmailUsed);
      if (isLoginEmailUsed) {
        this.appKit?.setIsConnected(false, this.chain);
      }
      provider.onRpcRequest((request) => {
        if (W3mFrameHelpers.checkIfRequestExists(request)) {
          if (!W3mFrameHelpers.checkIfRequestIsSafe(request)) {
            this.appKit?.handleUnsafeRPCRequest();
          }
        } else {
          this.appKit?.open();
          console.error(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_MESSAGE, {
            method: request.method
          });
          setTimeout(() => {
            this.appKit?.showErrorMessage(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
          }, 300);
          provider.rejectRpcRequests();
        }
      });
      provider.onRpcError(() => {
        const isModalOpen = this.appKit?.isOpen();
        if (isModalOpen) {
          if (this.appKit?.isTransactionStackEmpty()) {
            this.appKit?.close();
          } else {
            this.appKit?.popTransactionStack(true);
          }
        }
      });
      provider.onRpcSuccess((_2, request) => {
        const isSafeRequest = W3mFrameHelpers.checkIfRequestIsSafe(request);
        if (isSafeRequest) {
          return;
        }
        if (this.appKit?.isTransactionStackEmpty()) {
          this.appKit?.close();
        } else {
          this.appKit?.popTransactionStack();
        }
      });
      provider.onNotConnected(() => {
        const isConnected = this.appKit?.getIsConnectedState();
        if (!isConnected) {
          this.appKit?.setIsConnected(false, this.chain);
          this.appKit?.setLoading(false);
        }
      });
      provider.onIsConnected((req) => {
        this.appKit?.setIsConnected(true, this.chain);
        this.appKit?.setSmartAccountDeployed(Boolean(req.smartAccountDeployed), this.chain);
        this.appKit?.setPreferredAccountType(req.preferredAccountType, this.chain);
        this.appKit?.setLoading(false);
        this.appKit?.setAllAccounts(req.accounts || [
          {
            address: req.address,
            type: req.preferredAccountType || "eoa"
          }
        ], this.chain);
      });
      provider.onGetSmartAccountEnabledNetworks((networks) => {
        this.appKit?.setSmartAccountEnabledNetworks(networks, this.chain);
      });
      provider.onSetPreferredAccount(({ address, type }) => {
        if (!address) {
          return;
        }
        this.appKit?.setPreferredAccountType(type, this.chain);
        reconnect(this.wagmiConfig, { connectors: [connector] });
      });
    }
  }
  async listenModal(connector) {
    const provider = await connector.getProvider();
    this.subscribeState((val) => {
      if (!val.open) {
        provider.rejectRpcRequests();
      }
    });
  }
}
coinbaseWallet.type = "coinbaseWallet";
function coinbaseWallet(parameters = {}) {
  if (parameters.version === "3" || parameters.headlessMode)
    return version3(parameters);
  return version4(parameters);
}
function version4(parameters) {
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect2;
  return createConnector((config2) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    rdns: "com.coinbase.wallet",
    type: coinbaseWallet.type,
    async connect({ chainId, ...rest } = {}) {
      try {
        const provider = await this.getProvider();
        const accounts = (await provider.request({
          method: "eth_requestAccounts",
          params: "instantOnboarding" in rest && rest.instantOnboarding ? [{ onboarding: "instant" }] : []
        })).map((x2) => getAddress(x2));
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = chain?.id ?? currentChainId;
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      provider.disconnect();
      provider.close?.();
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return (await provider.request({
        method: "eth_accounts"
      })).map((x2) => getAddress(x2));
    },
    async getChainId() {
      const provider = await this.getProvider();
      const chainId = await provider.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      if (!walletProvider) {
        const preference = (() => {
          if (typeof parameters.preference === "string")
            return { options: parameters.preference };
          return {
            ...parameters.preference,
            options: parameters.preference?.options ?? "all"
          };
        })();
        const { createCoinbaseWalletSDK } = await __vitePreload(async () => {
          const { createCoinbaseWalletSDK: createCoinbaseWalletSDK2 } = await import("./index-DydxHIo5.js");
          return { createCoinbaseWalletSDK: createCoinbaseWalletSDK2 };
        }, true ? __vite__mapDeps([2,3,1,4]) : void 0);
        const sdk = createCoinbaseWalletSDK({
          ...parameters,
          appChainIds: config2.chains.map((x2) => x2.id),
          preference
        });
        walletProvider = sdk.getProvider();
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const chain = config2.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider = await this.getProvider();
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain.id) }]
        });
        return chain;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter?.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = chain.blockExplorers?.default.url ? [chain.blockExplorers?.default.url] : [];
            let rpcUrls;
            if (addEthereumChainParameter?.rpcUrls?.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [chain.rpcUrls.default?.http[0] ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: addEthereumChainParameter?.chainName ?? chain.name,
              iconUrls: addEthereumChainParameter?.iconUrls,
              nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config2.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config2.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
    }
  }));
}
function version3(parameters) {
  const reloadOnDisconnect = false;
  let sdk;
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect2;
  return createConnector((config2) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    rdns: "com.coinbase.wallet",
    type: coinbaseWallet.type,
    async connect({ chainId } = {}) {
      try {
        const provider = await this.getProvider();
        const accounts = (await provider.request({
          method: "eth_requestAccounts"
        })).map((x2) => getAddress(x2));
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = chain?.id ?? currentChainId;
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      provider.disconnect();
      provider.close();
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return (await provider.request({
        method: "eth_accounts"
      })).map((x2) => getAddress(x2));
    },
    async getChainId() {
      const provider = await this.getProvider();
      const chainId = await provider.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      if (!walletProvider) {
        const CoinbaseWalletSDK = await (async () => {
          const { default: SDK } = await __vitePreload(async () => {
            const { default: SDK2 } = await import("./index-CZ19Q9_0.js").then((n3) => n3.i);
            return { default: SDK2 };
          }, true ? __vite__mapDeps([5,3]) : void 0);
          if (typeof SDK !== "function" && typeof SDK.default === "function")
            return SDK.default;
          return SDK;
        })();
        sdk = new CoinbaseWalletSDK({ ...parameters, reloadOnDisconnect });
        const walletExtensionChainId = sdk.walletExtension?.getChainId();
        const chain = config2.chains.find((chain2) => parameters.chainId ? chain2.id === parameters.chainId : chain2.id === walletExtensionChainId) || config2.chains[0];
        const chainId = parameters.chainId || chain?.id;
        const jsonRpcUrl = parameters.jsonRpcUrl || chain?.rpcUrls.default.http[0];
        walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId);
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const chain = config2.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider = await this.getProvider();
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain.id) }]
        });
        return chain;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter?.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = chain.blockExplorers?.default.url ? [chain.blockExplorers?.default.url] : [];
            let rpcUrls;
            if (addEthereumChainParameter?.rpcUrls?.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [chain.rpcUrls.default?.http[0] ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: addEthereumChainParameter?.chainName ?? chain.name,
              iconUrls: addEthereumChainParameter?.iconUrls,
              nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,
              rpcUrls
            };
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config2.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config2.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
    }
  }));
}
walletConnect.type = "walletConnect";
function walletConnect(parameters) {
  const isNewChainsStale = parameters.isNewChainsStale ?? true;
  let provider_;
  let providerPromise;
  const NAMESPACE = "eip155";
  let accountsChanged;
  let chainChanged;
  let connect2;
  let displayUri;
  let sessionDelete;
  let disconnect2;
  return createConnector((config2) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: walletConnect.type,
    async setup() {
      const provider = await this.getProvider().catch(() => null);
      if (!provider)
        return;
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
      if (!sessionDelete) {
        sessionDelete = this.onSessionDelete.bind(this);
        provider.on("session_delete", sessionDelete);
      }
    },
    async connect({ chainId, ...rest } = {}) {
      try {
        const provider = await this.getProvider();
        if (!provider)
          throw new ProviderNotFoundError();
        if (!displayUri) {
          displayUri = this.onDisplayUri;
          provider.on("display_uri", displayUri);
        }
        let targetChainId = chainId;
        if (!targetChainId) {
          const state2 = await config2.storage?.getItem("state") ?? {};
          const isChainSupported = config2.chains.some((x2) => x2.id === state2.chainId);
          if (isChainSupported)
            targetChainId = state2.chainId;
          else
            targetChainId = config2.chains[0]?.id;
        }
        if (!targetChainId)
          throw new Error("No chains found on connector.");
        const isChainsStale = await this.isChainsStale();
        if (provider.session && isChainsStale)
          await provider.disconnect();
        if (!provider.session || isChainsStale) {
          const optionalChains = config2.chains.filter((chain) => chain.id !== targetChainId).map((optionalChain) => optionalChain.id);
          await provider.connect({
            optionalChains: [targetChainId, ...optionalChains],
            ..."pairingTopic" in rest ? { pairingTopic: rest.pairingTopic } : {}
          });
          this.setRequestedChainsIds(config2.chains.map((x2) => x2.id));
        }
        const accounts = (await provider.enable()).map((x2) => getAddress(x2));
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code && error.cause?.message !== "Missing or invalid. request() method: wallet_addEthereumChain")
              throw error;
            return { id: currentChainId };
          });
          currentChainId = chain?.id ?? currentChainId;
        }
        if (displayUri) {
          provider.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (connect2) {
          provider.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        if (!sessionDelete) {
          sessionDelete = this.onSessionDelete.bind(this);
          provider.on("session_delete", sessionDelete);
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user rejected|connection request reset)/i.test(error?.message)) {
          throw new UserRejectedRequestError(error);
        }
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      try {
        await provider?.disconnect();
      } catch (error) {
        if (!/No matching key/i.test(error.message))
          throw error;
      } finally {
        if (chainChanged) {
          provider?.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider?.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider?.on("connect", connect2);
        }
        if (accountsChanged) {
          provider?.removeListener("accountsChanged", accountsChanged);
          accountsChanged = void 0;
        }
        if (sessionDelete) {
          provider?.removeListener("session_delete", sessionDelete);
          sessionDelete = void 0;
        }
        this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return provider.accounts.map((x2) => getAddress(x2));
    },
    async getProvider() {
      async function initProvider() {
        const optionalChains = config2.chains.map((x2) => x2.id);
        if (!optionalChains.length)
          return;
        const { EthereumProvider } = await __vitePreload(async () => {
          const { EthereumProvider: EthereumProvider2 } = await import("./index.es-DcHRjKpf.js").then((n3) => n3.K);
          return { EthereumProvider: EthereumProvider2 };
        }, true ? [] : void 0);
        return await EthereumProvider.init({
          ...parameters,
          disableProviderPing: true,
          optionalChains,
          projectId: parameters.projectId,
          rpcMap: Object.fromEntries(config2.chains.map((chain) => {
            const [url] = extractRpcUrls({
              chain,
              transports: config2.transports
            });
            return [chain.id, url];
          })),
          showQrModal: parameters.showQrModal ?? true
        });
      }
      if (!provider_) {
        if (!providerPromise)
          providerPromise = initProvider();
        provider_ = await providerPromise;
        provider_?.events.setMaxListeners(Number.POSITIVE_INFINITY);
      }
      return provider_;
    },
    async getChainId() {
      const provider = await this.getProvider();
      return provider.chainId;
    },
    async isAuthorized() {
      try {
        const [accounts, provider] = await Promise.all([
          this.getAccounts(),
          this.getProvider()
        ]);
        if (!accounts.length)
          return false;
        const isChainsStale = await this.isChainsStale();
        if (isChainsStale && provider.session) {
          await provider.disconnect().catch(() => {
          });
          return false;
        }
        return true;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const chain = config2.chains.find((x2) => x2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new ChainNotConfiguredError());
      try {
        await Promise.all([
          new Promise((resolve) => {
            const listener = ({ chainId: currentChainId }) => {
              if (currentChainId === chainId) {
                config2.emitter.off("change", listener);
                resolve();
              }
            };
            config2.emitter.on("change", listener);
          }),
          provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          })
        ]);
        const requestedChains = await this.getRequestedChainsIds();
        this.setRequestedChainsIds([...requestedChains, chainId]);
        return chain;
      } catch (err) {
        const error = err;
        if (/(user rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        try {
          let blockExplorerUrls;
          if (addEthereumChainParameter?.blockExplorerUrls)
            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
          else
            blockExplorerUrls = chain.blockExplorers?.default.url ? [chain.blockExplorers?.default.url] : [];
          let rpcUrls;
          if (addEthereumChainParameter?.rpcUrls?.length)
            rpcUrls = addEthereumChainParameter.rpcUrls;
          else
            rpcUrls = [...chain.rpcUrls.default.http];
          const addEthereumChain = {
            blockExplorerUrls,
            chainId: numberToHex(chainId),
            chainName: addEthereumChainParameter?.chainName ?? chain.name,
            iconUrls: addEthereumChainParameter?.iconUrls,
            nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,
            rpcUrls
          };
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [addEthereumChain]
          });
          const requestedChains = await this.getRequestedChainsIds();
          this.setRequestedChainsIds([...requestedChains, chainId]);
          return chain;
        } catch (error2) {
          throw new UserRejectedRequestError(error2);
        }
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config2.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress(x2))
        });
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const chainId = Number(connectInfo.chainId);
      const accounts = await this.getAccounts();
      config2.emitter.emit("connect", { accounts, chainId });
    },
    async onDisconnect(_error) {
      this.setRequestedChainsIds([]);
      config2.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (sessionDelete) {
        provider.removeListener("session_delete", sessionDelete);
        sessionDelete = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
    },
    onDisplayUri(uri) {
      config2.emitter.emit("message", { type: "display_uri", data: uri });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      if (!provider_)
        return [];
      const chainIds = provider_.session?.namespaces[NAMESPACE]?.accounts?.map((account) => Number.parseInt(account.split(":")[1] || ""));
      return chainIds ?? [];
    },
    async getRequestedChainsIds() {
      return await config2.storage?.getItem(this.requestedChainsStorageKey) ?? [];
    },
    /**
     * Checks if the target chains match the chains that were
     * initially requested by the connector for the WalletConnect session.
     * If there is a mismatch, this means that the chains on the connector
     * are considered stale, and need to be revalidated at a later point (via
     * connection).
     *
     * There may be a scenario where a dapp adds a chain to the
     * connector later on, however, this chain will not have been approved or rejected
     * by the wallet. In this case, the chain is considered stale.
     */
    async isChainsStale() {
      if (!isNewChainsStale)
        return false;
      const connectorChains = config2.chains.map((x2) => x2.id);
      const namespaceChains = this.getNamespaceChainsIds();
      if (namespaceChains.length && !namespaceChains.some((id) => connectorChains.includes(id)))
        return false;
      const requestedChains = await this.getRequestedChainsIds();
      return !connectorChains.every((id) => requestedChains.includes(id));
    },
    async setRequestedChainsIds(chains2) {
      await config2.storage?.setItem(this.requestedChainsStorageKey, chains2);
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  }));
}
function authConnector(parameters) {
  function parseChainId(chainId) {
    return NetworkUtil$1.parseEvmChainId(chainId) || 1;
  }
  return createConnector((config2) => ({
    id: ConstantsUtil$3.AUTH_CONNECTOR_ID,
    name: "Web3Modal Auth",
    type: "w3mAuth",
    socials: parameters.socials,
    email: parameters.email,
    showWallets: parameters.showWallets,
    walletFeatures: parameters.walletFeatures,
    chain: ConstantsUtil$2.CHAIN.EVM,
    async connect(options = {}) {
      const provider = await this.getProvider();
      const { address, chainId } = await provider.connect({
        chainId: options.chainId
      });
      await provider.getSmartAccountEnabledNetworks();
      const parsedChainId = parseChainId(chainId);
      return {
        accounts: [address],
        account: address,
        chainId: parsedChainId,
        chain: {
          id: parsedChainId,
          unsuported: false
        }
      };
    },
    async disconnect() {
      const provider = await this.getProvider();
      await provider.disconnect();
    },
    async getAccounts() {
      const provider = await this.getProvider();
      const { address } = await provider.connect();
      config2.emitter.emit("change", { accounts: [address] });
      return [address];
    },
    async getProvider() {
      if (!this.provider) {
        this.provider = new W3mFrameProvider(parameters.options.projectId);
      }
      return Promise.resolve(this.provider);
    },
    async getChainId() {
      const provider = await this.getProvider();
      const { chainId } = await provider.getChainId();
      return parseChainId(chainId);
    },
    async isAuthorized() {
      const provider = await this.getProvider();
      const { isConnected } = await provider.isConnected();
      return isConnected;
    },
    async switchChain({ chainId }) {
      try {
        const chain = config2.chains.find((c2) => c2.id === chainId);
        if (!chain) {
          throw new SwitchChainError(new Error("chain not found on connector."));
        }
        const provider = await this.getProvider();
        const response = await provider.connect({ chainId });
        config2.emitter.emit("change", {
          chainId: Number(chainId),
          accounts: [response.address]
        });
        return chain;
      } catch (error) {
        if (error instanceof Error) {
          throw new SwitchChainError(error);
        }
        throw error;
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.onDisconnect();
      } else {
        config2.emitter.emit("change", { accounts: accounts.map(getAddress) });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config2.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const chainId = Number(connectInfo.chainId);
      const accounts = await this.getAccounts();
      config2.emitter.emit("connect", { accounts, chainId });
    },
    async onDisconnect(_error) {
      const provider = await this.getProvider();
      await provider.disconnect();
    }
  }));
}
function defaultConfig({ projectId: projectId2, chains: chains2, metadata: metadata2, enableCoinbase, enableInjected, auth = {}, enableWalletConnect, enableEIP6963, ...wagmiConfig }) {
  const connectors = wagmiConfig?.connectors ?? [];
  const transportsArr = chains2.map((chain) => [chain.id, getTransport({ chain, projectId: projectId2 })]);
  const transports = Object.fromEntries(transportsArr);
  const defaultAuth = {
    email: true,
    showWallets: true,
    walletFeatures: true,
    socials: [
      "google",
      "x",
      "discord",
      "farcaster",
      "github",
      "apple",
      "facebook"
    ]
  };
  if (enableWalletConnect !== false) {
    connectors.push(walletConnect({ projectId: projectId2, metadata: metadata2, showQrModal: false }));
  }
  if (enableInjected !== false) {
    connectors.push(injected({ shimDisconnect: true }));
  }
  if (enableCoinbase !== false) {
    connectors.push(coinbaseWallet({
      version: "4",
      appName: metadata2?.name ?? "Unknown",
      appLogoUrl: metadata2?.icons[0] ?? "Unknown",
      preference: wagmiConfig.coinbasePreference || "all"
    }));
  }
  const mergedAuth = {
    ...defaultAuth,
    ...auth
  };
  if (mergedAuth.email || mergedAuth.socials?.length) {
    connectors.push(authConnector({
      chains: [...chains2],
      options: { projectId: projectId2 },
      socials: mergedAuth.socials,
      email: mergedAuth.email,
      showWallets: mergedAuth.showWallets,
      walletFeatures: mergedAuth.walletFeatures
    }));
  }
  return createConfig({
    chains: chains2,
    multiInjectedProviderDiscovery: enableEIP6963 !== false,
    transports,
    ...wagmiConfig,
    connectors
  });
}
let modal = void 0;
function getWeb3Modal(appKit) {
  if (appKit) {
    modal = appKit;
  }
}
function useWeb3Modal() {
  if (!modal) {
    throw new Error('Please call "createWeb3Modal" before using "useWeb3Modal" hook');
  }
  async function open(options) {
    await modal?.open(options);
  }
  async function close() {
    await modal?.close();
  }
  return { open, close };
}
let appkit = void 0;
let wagmiAdapter = void 0;
function createWeb3Modal(options) {
  wagmiAdapter = new EVMWagmiClient({
    wagmiConfig: options.wagmiConfig,
    siweConfig: options.siweConfig,
    defaultChain: options.defaultChain
  });
  appkit = new AppKit({
    ...options,
    defaultChain: wagmiAdapter.defaultChain,
    adapters: [wagmiAdapter],
    sdkType: "w3m",
    sdkVersion: `react-wagmi-${ConstantsUtil$3.VERSION}`
  });
  getWeb3Modal(appkit);
  return appkit;
}
const projectId = "b0cebcda95846f0aabc833a9f05dca99";
const metadata = {
  name: "safemint ",
  description: "safemint",
  url: "https://safemint.live/",
  icons: ["https://safemin.io/favicon.ico"]
};
const chains = [bsc];
const config = defaultConfig({ chains, projectId, metadata });
createWeb3Modal({
  wagmiConfig: config,
  projectId,
  metadata,
  // Mobile-optimized configuration
  featuredWalletIds: [
    "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
    // Trust Wallet
    "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
    // MetaMask
    "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa"
    // Coinbase Wallet
  ],
  // Disable problematic features for mobile
  enableAnalytics: false,
  enableOnramp: false,
  enableEmail: false,
  enableSocials: false,
  themeMode: "dark",
  themeVariables: {
    "--w3m-accent": "#FFA000",
    "--w3m-border-radius-master": "12px"
  },
  // Default to BSC Mainnet
  defaultChain: bsc
});
const USDC_CONTRACT_ADDRESS = "0x55d398326f99059fF775485246999027B3197955";
const BSC_TESTNET_CHAIN_ID$1 = 56;
const USDC_ABI = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_recipient",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "allowance",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
      }
    ],
    name: "ERC20InsufficientAllowance",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256"
      }
    ],
    name: "ERC20InsufficientBalance",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address"
      }
    ],
    name: "ERC20InvalidApprover",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "ERC20InvalidReceiver",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "ERC20InvalidSender",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "ERC20InvalidSpender",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
const usdcContractInteractions = {
  /**
   * Approve USDC spending for a specified address
   * @param spender - Address allowed to spend USDC
   * @param amount - Amount to approve (in wei)
   * @param account - Wallet address to send the transaction from
   * @returns Transaction hash
   */
  async approveUSDC(spender, amount, account) {
    try {
      console.log(`Approving ${amount} USDC for ${spender}`);
      const txHash = await writeContract(config, {
        abi: USDC_ABI,
        address: USDC_CONTRACT_ADDRESS,
        functionName: "approve",
        args: [spender, amount],
        chain: bscTestnet,
        account
      });
      console.log("USDC approval transaction hash:", txHash);
      return txHash;
    } catch (error) {
      console.error(`Error approving USDC: ${error.message || error}`);
      throw new Error(
        `Failed to approve USDC: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get USDC balance for an address
   * @param account - Wallet address
   * @returns USDC balance in wei
   */
  async getUSDCBalance(account) {
    try {
      return await readContract(config, {
        abi: USDC_ABI,
        address: USDC_CONTRACT_ADDRESS,
        functionName: "balanceOf",
        args: [account],
        chainId: BSC_TESTNET_CHAIN_ID$1
      });
    } catch (error) {
      console.error(`Error fetching USDC balance: ${error.message || error}`);
      throw new Error(
        `Failed to fetch USDC balance: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Transfer USDC to another address
   * @param to - Recipient address
   * @param amount - Amount to transfer (in wei)
   * @param account - Wallet address to send the transaction from
   * @returns Transaction hash
   */
  async transferUSDC(to, amount, account) {
    try {
      console.log(`Transferring ${amount} USDC to ${to}`);
      const txHash = await writeContract(config, {
        abi: USDC_ABI,
        address: USDC_CONTRACT_ADDRESS,
        functionName: "transfer",
        args: [to, amount],
        chain: bscTestnet,
        account
      });
      console.log("USDC transfer transaction hash:", txHash);
      return txHash;
    } catch (error) {
      console.error(`Error transferring USDC: ${error.message || error}`);
      throw new Error(
        `Failed to transfer USDC: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Transfer USDC from one address to another using allowance
   * @param from - Source address
   * @param to - Recipient address
   * @param amount - Amount to transfer (in wei)
   * @param account - Wallet address to send the transaction from
   * @returns Transaction hash
   */
  async transferFromUSDC(from2, to, amount, account) {
    try {
      console.log(`Transferring ${amount} USDC from ${from2} to ${to}`);
      const txHash = await writeContract(config, {
        abi: USDC_ABI,
        address: USDC_CONTRACT_ADDRESS,
        functionName: "transferFrom",
        args: [from2, to, amount],
        chain: bscTestnet,
        account
      });
      console.log("USDC transferFrom transaction hash:", txHash);
      return txHash;
    } catch (error) {
      console.error(`Error in transferFrom USDC: ${error.message || error}`);
      throw new Error(
        `Failed to transferFrom USDC: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get allowance of a spender for an owner's USDC
   * @param owner - Owner address
   * @param spender - Spender address
   * @returns Allowance amount in wei
   */
  async getAllowance(owner, spender) {
    try {
      return await readContract(config, {
        abi: USDC_ABI,
        address: USDC_CONTRACT_ADDRESS,
        functionName: "allowance",
        args: [owner, spender],
        chainId: BSC_TESTNET_CHAIN_ID$1
      });
    } catch (error) {
      console.error(`Error fetching allowance: ${error.message || error}`);
      throw new Error(
        `Failed to fetch allowance: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get total supply of USDC
   * @returns Total supply in wei
   */
  async getTotalSupply() {
    try {
      return await readContract(config, {
        abi: USDC_ABI,
        address: USDC_CONTRACT_ADDRESS,
        functionName: "totalSupply",
        chainId: BSC_TESTNET_CHAIN_ID$1
      });
    } catch (error) {
      console.error(`Error fetching total supply: ${error.message || error}`);
      throw new Error(
        `Failed to fetch total supply: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get token name
   * @returns Token name (USDC)
   */
  async getName() {
    try {
      return await readContract(config, {
        abi: USDC_ABI,
        address: USDC_CONTRACT_ADDRESS,
        functionName: "name",
        chainId: BSC_TESTNET_CHAIN_ID$1
      });
    } catch (error) {
      console.error(`Error fetching token name: ${error.message || error}`);
      throw new Error(
        `Failed to fetch token name: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get token symbol
   * @returns Token symbol (USDC)
   */
  async getSymbol() {
    try {
      return await readContract(config, {
        abi: USDC_ABI,
        address: USDC_CONTRACT_ADDRESS,
        functionName: "symbol",
        chainId: BSC_TESTNET_CHAIN_ID$1
      });
    } catch (error) {
      console.error(`Error fetching token symbol: ${error.message || error}`);
      throw new Error(
        `Failed to fetch token symbol: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get token decimals
   * @returns Number of decimals (18)
   */
  async getDecimals() {
    try {
      return await readContract(config, {
        abi: USDC_ABI,
        address: USDC_CONTRACT_ADDRESS,
        functionName: "decimals",
        chainId: BSC_TESTNET_CHAIN_ID$1
      });
    } catch (error) {
      console.error(`Error fetching decimals: ${error.message || error}`);
      throw new Error(
        `Failed to fetch decimals: ${error.message || "Unknown error"}`
      );
    }
  }
};
const USDT_ADDRESS = USDC_CONTRACT_ADDRESS;
const USDT_ABI = USDC_ABI;
const STAKING_CONTRACT_ADDRESS = "0xd5017C72215F927F8e9386006f3fede65aeBa405";
const BSC_TESTNET_CHAIN_ID = 56;
const TOKEN_ADDRESS = "0xC0746bd0380190B899440bC33C647cE2426C8cCb";
const USDC_ADDRESS = USDC_CONTRACT_ADDRESS;
const SAFEMINT_TOKEN_ABI$1 = [
  {
    "inputs": [],
    "name": "rateInUSDT",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getReserves",
    "outputs": [
      { "internalType": "uint256", "name": "_reserve0", "type": "uint256" },
      { "internalType": "uint256", "name": "_reserve1", "type": "uint256" },
      { "internalType": "uint256", "name": "_blockTimestampLast", "type": "uint256" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "account", "type": "address" }],
    "name": "balanceOf",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "pure",
    "type": "function"
  }
];
const STAKING_ABI = [
  {
    inputs: [{ internalType: "address", name: "_owner", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "stacke_Id",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "growthRate",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "timeStamp",
        type: "uint256"
      }
    ],
    name: "deposit_Satke",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "stacke_Id",
        type: "uint256"
      }
    ],
    name: "forfeit_Ev",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "from_user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "to_user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "level",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "payAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "types",
        type: "uint256"
      }
    ],
    name: "income_Ev",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "_user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "referralAddress",
        type: "address"
      }
    ],
    name: "regUserEv",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "_user",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "withdrwal_Stacking",
    type: "event"
  },
  {
    inputs: [],
    name: "DAO_Count",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DAO_TotalApprovals",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DAO_VoteIsOn",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DAO_Voting",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "VotingIsOn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_user", type: "address" }],
    name: "activeUser",
    outputs: [{ internalType: "bool", name: "active", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "allStake",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "user", type: "address" }],
    name: "avUnStake",
    outputs: [{ internalType: "uint256", name: "avGh", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "bonusInfos",
    outputs: [
      { internalType: "uint256", name: "referralGains", type: "uint256" },
      { internalType: "uint256", name: "levelGains", type: "uint256" },
      { internalType: "uint256", name: "growthGains", type: "uint256" },
      { internalType: "uint256", name: "teamGrowthGains", type: "uint256" },
      { internalType: "uint256", name: "leaderGains", type: "uint256" },
      { internalType: "uint256", name: "developmentGains", type: "uint256" },
      { internalType: "uint256", name: "teamLevelStake", type: "uint256" },
      { internalType: "uint256", name: "lapsTeamStake", type: "uint256" },
      { internalType: "uint256", name: "totalStake", type: "uint256" },
      { internalType: "uint256", name: "totalUnStake", type: "uint256" },
      { internalType: "uint256", name: "totalWithdrwan", type: "uint256" },
      { internalType: "uint256", name: "inOutBuy", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "boostLevel",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "usdAmount", type: "uint256" }],
    name: "buyToken",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "userAddress", type: "address" }],
    name: "directUser",
    outputs: [
      { internalType: "address[]", name: "referrals", type: "address[]" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "distShare",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "contractAdd", type: "address" },
      { internalType: "uint256", name: "runTime", type: "uint256" },
      { internalType: "bool", name: "looprun", type: "bool" }
    ],
    name: "fetchOldData",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "userAddress", type: "address" }],
    name: "findLeaderUser",
    outputs: [
      { internalType: "address[6]", name: "ledAdd", type: "address[6]" },
      { internalType: "address[3]", name: "devAdd", type: "address[3]" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
    name: "getPrice",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "levelDist",
    outputs: [
      { internalType: "uint8[21]", name: "levelPer", type: "uint8[21]" }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "userAddress", type: "address" },
      { internalType: "uint256", name: "Level", type: "uint256" }
    ],
    name: "makeLeader",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "userAddress", type: "address" }
    ],
    name: "makeStake",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    name: "makeUnstake",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_user", type: "address" }],
    name: "matureOrder",
    outputs: [
      { internalType: "uint256", name: "activeOrder", type: "uint256" },
      { internalType: "uint256", name: "lastOrder", type: "uint256" },
      { internalType: "uint256", name: "unlock_Order", type: "uint256" },
      { internalType: "uint256", name: "mature_Order", type: "uint256" },
      { internalType: "uint256", name: "activeLimit", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "user", type: "address" }],
    name: "rankQualify",
    outputs: [
      { internalType: "uint256", name: "directs", type: "uint256" },
      { internalType: "uint256", name: "level", type: "uint256" },
      { internalType: "uint256", name: "strongTeam", type: "uint256" },
      { internalType: "uint256", name: "totalTeam", type: "uint256" },
      { internalType: "uint256", name: "fLevel", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "redeemRate",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "referral", type: "address" }],
    name: "regUser",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "releaseContract",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256[2]", name: "_growthRate", type: "uint256[2]" }
    ],
    name: "setGrowths",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256[]", name: "_levelSatke", type: "uint256[]" }
    ],
    name: "setLevelStakes",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_teamDepth", type: "uint256" },
      { internalType: "uint256", name: "_redeemRate", type: "uint256" },
      { internalType: "bool", name: "_boostLevel", type: "bool" }
    ],
    name: "setPrams",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "_shareAddress", type: "address" }
    ],
    name: "setShareAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "shareAddress",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "stake_Order", type: "uint256" }],
    name: "stakeGrowth",
    outputs: [
      { internalType: "uint256", name: "orderGrowth", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "stakeInfos",
    outputs: [
      { internalType: "address", name: "ownerAddress", type: "address" },
      { internalType: "uint256", name: "orderValue", type: "uint256" },
      { internalType: "uint256", name: "orderGrowth", type: "uint256" },
      { internalType: "uint256", name: "orderID", type: "uint256" },
      { internalType: "uint256", name: "orderTime", type: "uint256" },
      { internalType: "uint256", name: "isMature", type: "uint256" },
      { internalType: "bool", name: "isComplete", type: "bool" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "teamDepth",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "user", type: "address" },
      { internalType: "uint256", name: "totalTPR", type: "uint256" }
    ],
    name: "teamGrowthTime",
    outputs: [{ internalType: "uint256", name: "growthTime", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenAddress",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_user", type: "address" }],
    name: "totalGains",
    outputs: [{ internalType: "uint256", name: "total", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalReg",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "userAddress", type: "address" },
      { internalType: "bool", name: "isMatureOrd", type: "bool" }
    ],
    name: "totalRemainTPR",
    outputs: [
      { internalType: "uint256", name: "totalTPR", type: "uint256" },
      { internalType: "uint256", name: "growthTPR", type: "uint256" },
      { internalType: "uint256", name: "forfietOrder", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_user", type: "address" }],
    name: "unStakePotential",
    outputs: [
      { internalType: "uint256", name: "remainLimit", type: "uint256" },
      { internalType: "uint256", name: "growthLimit", type: "uint256" },
      { internalType: "uint256", name: "active_Order", type: "uint256" },
      { internalType: "uint256", name: "lastOrder", type: "uint256" },
      { internalType: "uint256", name: "unlock_Order", type: "uint256" },
      { internalType: "uint256", name: "mature_Order", type: "uint256" },
      { internalType: "uint256", name: "totGain", type: "uint256" },
      { internalType: "uint256", name: "OrderValue", type: "uint256" },
      { internalType: "uint256", name: "orderGrowth", type: "uint256" },
      { internalType: "uint256", name: "teamGrowth", type: "uint256" },
      { internalType: "uint256", name: "teamLaps", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "usdAddress",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "userInfos",
    outputs: [
      { internalType: "address", name: "referral", type: "address" },
      { internalType: "uint256", name: "totalTeam", type: "uint256" },
      { internalType: "uint256", name: "strongTeam", type: "uint256" },
      { internalType: "uint256", name: "userLevel", type: "uint256" },
      { internalType: "uint256", name: "lastStake", type: "uint256" },
      { internalType: "uint256", name: "forfeitStake", type: "uint256" },
      { internalType: "uint256", name: "harvestTime", type: "uint256" },
      { internalType: "bool", name: "isNewStake", type: "bool" },
      { internalType: "bool", name: "isDAO", type: "bool" },
      { internalType: "bool", name: "joined", type: "bool" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "user", type: "address" }],
    name: "userLiveStatus",
    outputs: [
      { internalType: "uint256", name: "directs", type: "uint256" },
      { internalType: "uint256", name: "level", type: "uint256" },
      { internalType: "uint256", name: "strongLeg", type: "uint256" },
      { internalType: "uint256", name: "totalTeam", type: "uint256" },
      { internalType: "uint256", name: "growthVol", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "user", type: "address" }],
    name: "userSelfUpdate",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "user", type: "address" },
      { internalType: "uint256", name: "stakeCount", type: "uint256" }
    ],
    name: "userStakeView",
    outputs: [
      { internalType: "uint256", name: "totalCount", type: "uint256" },
      {
        components: [
          { internalType: "address", name: "ownerAddress", type: "address" },
          { internalType: "uint256", name: "orderValue", type: "uint256" },
          { internalType: "uint256", name: "orderGrowth", type: "uint256" },
          { internalType: "uint256", name: "orderID", type: "uint256" },
          { internalType: "uint256", name: "orderTime", type: "uint256" },
          { internalType: "uint256", name: "isMature", type: "uint256" },
          { internalType: "bool", name: "isComplete", type: "bool" }
        ],
        internalType: "struct SELFMINT_STAKING.order",
        name: "stakeInfo",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
const stakingInteractions = {
  /**
   * Approve USDC spending for the staking contract
   * @param amount - Amount to approve (in wei)
   * @param account - Wallet address to send the transaction from
   * @returns Transaction hash
   */
  async approveUSDC(amount, account) {
    try {
      console.log(
        `Approving ${formatEther(
          amount
        )} USDC for staking contract ${STAKING_CONTRACT_ADDRESS}`
      );
      const txHash = await usdcContractInteractions.approveUSDC(
        STAKING_CONTRACT_ADDRESS,
        amount,
        account
      );
      console.log(`Approval transaction submitted: ${txHash}`);
      return txHash;
    } catch (error) {
      console.error(`Error approving USDC:`, error);
      if (error.message?.includes("gasLimit") || error.message?.includes("Cannot destructure")) {
        throw new Error(
          "Network configuration error. Please ensure you are connected to BSC Testnet and try again."
        );
      }
      throw new Error(
        `Failed to approve USDC: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get USDC balance for an address
   * @param account - Wallet address
   * @returns USDC balance in wei
   */
  async getUSDCBalance(account) {
    try {
      const balance = await readContract(config, {
        abi: USDC_ABI,
        address: USDC_ADDRESS,
        functionName: "balanceOf",
        args: [account],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      console.log(`USDC balance for ${account}: ${formatEther(balance)} USDC`);
      return balance;
    } catch (error) {
      console.error(`Error fetching USDC balance: ${error.message || error}`);
      throw new Error(
        `Failed to fetch USDC balance: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get USDT balance for an address (BSC Mainnet)
   * @param account - Wallet address
   * @returns USDT balance in wei
   */
  async getUSDTBalance(account) {
    try {
      const balance = await readContract(config, {
        abi: USDT_ABI,
        address: USDT_ADDRESS,
        functionName: "balanceOf",
        args: [account],
        chainId: 56
        // BSC Mainnet
      });
      console.log(`USDT balance for ${account}: ${formatUnits(balance, 6)} USDT`);
      return balance;
    } catch (error) {
      console.error(`Error fetching USDT balance: ${error.message || error}`);
      throw new Error(
        `Failed to fetch USDT balance: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get the USD token address configured in the staking contract
   * @returns USD token address
   */
  async getUSDAddress() {
    try {
      const usdAddress = await readContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "usdAddress",
        chainId: BSC_TESTNET_CHAIN_ID
      });
      console.log(`Contract USD address: ${usdAddress}`);
      return usdAddress;
    } catch (error) {
      console.error(`Error fetching USD address: ${error.message || error}`);
      throw new Error(
        `Failed to fetch USD address: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Register a user with a referral
   * @param referral - Referral address
   * @returns Transaction hash
   */
  async regUser(referral, account) {
    try {
      console.log(`Attempting to register user with referrer: ${referral}`);
      if (referral === "0x0000000000000000000000000000000000000000") {
        throw new Error(
          "Invalid referrer address: zero address is not allowed"
        );
      }
      const ethAddressRegex = /^0x[a-fA-F0-9]{40}$/;
      if (!ethAddressRegex.test(referral)) {
        throw new Error("Invalid referrer address format");
      }
      const txHash = await writeContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "regUser",
        args: [referral],
        chain: bscTestnet,
        account,
        gas: void 0
      });
      console.log(
        `Registration transaction submitted successfully. Hash: ${txHash}`
      );
      return txHash;
    } catch (error) {
      console.error("Error registering user:", error);
      if (error.message?.includes("user rejected")) {
        throw new Error("Transaction rejected by user");
      } else if (error.message?.includes("insufficient funds")) {
        throw new Error("Insufficient funds for gas fees");
      } else if (error.message?.includes("already registered") || error.message?.includes("already exists")) {
        throw new Error("Address is already registered");
      } else if (error.message?.includes("invalid address")) {
        throw new Error("Invalid referrer address");
      } else if (error.message?.includes("gas")) {
        throw new Error("Network congestion. Please try again later");
      } else {
        throw new Error(
          `Registration failed: ${error.message || "Unknown error occurred"}`
        );
      }
    }
  },
  /**
   * Swap USDT for tokens
   * @param usdAmount - Amount of USDT to spend (plain amount, e.g., 1.5 for 1.5 USDT)
   * @param account - Wallet address to send the transaction from
   * @returns Transaction hash
   */
  async buyToken(usdAmount, account) {
    try {
      console.log(` [buyToken] Swapping ${usdAmount} USDT for tokens (plain amount)`);
      const decimals = await readContract(config, {
        abi: USDT_ABI,
        address: USDT_ADDRESS,
        functionName: "decimals",
        chainId: 56
      });
      console.log(" [buyToken] USDT Decimals:", decimals);
      const amountInWei = parseUnits(usdAmount.toString(), Number(decimals));
      console.log(" [buyToken] Amount in wei (for allowance check):", amountInWei.toString());
      console.log(` [buyToken] Swapping ${usdAmount} USDT for tokens`);
      const allowance = await readContract(config, {
        abi: USDT_ABI,
        address: USDT_ADDRESS,
        functionName: "allowance",
        args: [account, STAKING_CONTRACT_ADDRESS],
        chainId: 56
      });
      console.log(" [buyToken] Current allowance:", formatUnits(allowance, Number(decimals)), "USDT");
      if (allowance < amountInWei) {
        throw new Error(
          `Insufficient allowance. Approved: ${formatUnits(
            allowance,
            Number(decimals)
          )} USDT, Required: ${usdAmount} USDT`
        );
      }
      console.log(" [buyToken] Executing swap transaction...");
      console.log(" [buyToken] Contract address:", STAKING_CONTRACT_ADDRESS);
      console.log(" [buyToken] Plain amount for swap:", usdAmount);
      console.log(" [buyToken] Amount type:", typeof usdAmount);
      const txHash = await writeContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "buyToken",
        args: [usdAmount],
        // Pass plain amount directly
        chain: bsc,
        account,
        gas: BigInt(5e5)
        // Manual gas limit to avoid estimation issues
      });
      console.log(`Buy token transaction successful: ${txHash}`);
      return txHash;
    } catch (error) {
      console.error("Error buying tokens:", error);
      if (error.cause?.data) {
        const decodedError = decodeErrorResult({
          abi: STAKING_ABI,
          data: error.cause.data
        });
        throw new Error(
          `Buy token failed: ${decodedError.errorName || "Unknown error"} - ${decodedError.args?.join(", ") || ""}`
        );
      }
      throw new Error(
        `Failed to buy tokens: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Stake tokens
   * @param amount - Amount to stake (in wei)
   * @param userAddress - Address to stake for
   * @returns Transaction hash
   */
  // async makeStake(amount: bigint, userAddress: Address): Promise<string> {
  //   try {
  //     console.log(`Staking ${formatEther(amount)} DAI for ${userAddress}`);
  //     // Verify allowance
  //     const allowance = await readContract(config, {
  //       abi: USDC_ABI,
  //       address: USDC_ADDRESS,
  //       functionName: 'allowance',
  //       args: [userAddress, STAKING_CONTRACT_ADDRESS],
  //       chainId: BSC_TESTNET_CHAIN_ID,
  //     }) as bigint;
  //     if (allowance < amount) {
  //       throw new Error(`Insufficient allowance. Approved: ${formatEther(allowance)} USDC, Required: ${formatEther(amount)} USDC`);
  //     }
  //     const txHash = await writeContract(config, {
  //       abi: STAKING_ABI,
  //       address: STAKING_CONTRACT_ADDRESS,
  //       functionName: 'makeStake',
  //       args: [amount, userAddress],
  //       chain: bscTestnet,
  //       account: userAddress,
  //       gas: undefined,
  //     });
  //     console.log(`Stake transaction successful: ${txHash}`);
  //     return txHash;
  //   } catch (error: any) {
  //     console.error(`Error staking tokens:`, error);
  //     throw new Error(`Failed to stake tokens: ${error.message || 'Unknown error'}`);
  //   }
  // },
  async makeStake(amount, userAddress) {
    try {
      console.log(`Staking ${amount} USDC for ${userAddress}`);
      const decimals = await readContract(config, {
        abi: USDC_ABI,
        address: USDC_ADDRESS,
        functionName: "decimals",
        chainId: BSC_TESTNET_CHAIN_ID
      });
      console.log("USDC Decimals:", decimals);
      const amountInWei = parseUnits(amount, Number(decimals));
      console.log(`Converted Amount: ${amountInWei.toString()} wei`);
      const allowance = await readContract(config, {
        abi: USDC_ABI,
        address: USDC_ADDRESS,
        functionName: "allowance",
        args: [userAddress, STAKING_CONTRACT_ADDRESS],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      console.log("Allowance:", formatUnits(allowance, Number(decimals)));
      if (allowance < amountInWei) {
        throw new Error(
          `Insufficient allowance. Approved: ${formatUnits(
            allowance,
            Number(decimals)
          )} USDC, Required: ${amount} USDC`
        );
      }
      console.log("Simulating makeStake transaction...");
      console.log("Executing makeStake transaction...");
      const txHash = await writeContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "makeStake",
        args: [amount, userAddress],
        chain: bscTestnet,
        account: userAddress
        // gas: BigInt(500000), // Manual gas limit
      });
      console.log(`Stake transaction successful: ${txHash}`);
      return txHash;
    } catch (error) {
      console.error("Error staking tokens:", error);
      if (error.cause?.data) {
        const decodedError = decodeErrorResult({
          abi: STAKING_ABI,
          data: error.cause.data
        });
        throw new Error(
          `Stake failed: ${decodedError.errorName || "Unknown error"} - ${decodedError.args?.join(", ") || ""}`
        );
      }
      throw new Error(
        `Failed to stake tokens: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Unstake tokens
   * @param amount - Amount to unstake (in wei)
   * @param account - Wallet address
   * @returns Transaction hash
   */
  async makeUnstake(amount, account) {
    try {
      console.log(`Unstaking ${formatEther(amount)} USDT for ${account}`);
      const txHash = await writeContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "makeUnstake",
        args: [amount],
        chain: bsc,
        account,
        gas: BigInt(5e5)
        // Manual gas limit to avoid estimation issues
      });
      console.log(`Unstake transaction successful: ${txHash}`);
      return txHash;
    } catch (error) {
      console.error(`Error unstaking tokens:`, error);
      if (error.cause?.data) {
        const decodedError = decodeErrorResult({
          abi: STAKING_ABI,
          data: error.cause.data
        });
        throw new Error(
          `Unstake failed: ${decodedError.errorName || "Unknown error"} - ${decodedError.args?.join(", ") || ""}`
        );
      }
      throw new Error(
        `Failed to unstake tokens: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Sell tokens back to USDT (alias for makeUnstake for swap functionality)
   * @param tokenAmount - Amount of tokens to sell (in USDT equivalent wei)
   * @param account - Wallet address
   * @returns Transaction hash
   */
  async sellToken(tokenAmount, account) {
    try {
      console.log(`Selling tokens worth ${formatUnits(tokenAmount, 6)} USDT for ${account}`);
      return await this.makeUnstake(tokenAmount, account);
    } catch (error) {
      console.error(`Error selling tokens:`, error);
      throw new Error(
        `Failed to sell tokens: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get user stake information
   * @param user - User address
   * @param stakeCount - Stake index to view
   * @returns Total count and stake info
   */
  async userStakeView(user, stakeCount) {
    try {
      const [totalCount, stakeInfo] = await readContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "userStakeView",
        args: [user, stakeCount],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      return {
        totalCount,
        stakeInfo
      };
    } catch (error) {
      console.error(`Error fetching stake info: ${error.message || error}`);
      throw new Error(
        `Failed to fetch stake info: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get bonus information for a user
   * @param user - User address
   * @returns Bonus information
   */
  async getBonusInfo(user) {
    try {
      const result = await readContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "bonusInfos",
        args: [user],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      return {
        referralGains: result[0],
        levelGains: result[1],
        growthGains: result[2],
        teamGrowthGains: result[3],
        leaderGains: result[4],
        developmentGains: result[5],
        teamLevelStake: result[6],
        lapsTeamStake: result[7],
        totalStake: result[8],
        totalUnStake: result[9],
        totalWithdrwan: result[10],
        inOutBuy: result[11]
      };
    } catch (error) {
      console.error(`Error fetching bonus info: ${error.message || error}`);
      throw new Error(
        `Failed to fetch bonus info: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get user information
   * @param user - User address
   * @returns User information
   */
  async getUserInfo(user) {
    try {
      const result = await readContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "userInfos",
        args: [user],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      return {
        referral: result[0],
        totalTeam: result[1],
        strongTeam: result[2],
        userLevel: result[3],
        lastStake: result[4],
        forfeitStake: result[5],
        harvestTime: result[6],
        isNewStake: result[7],
        isDAO: result[8],
        joined: result[9]
      };
    } catch (error) {
      console.error(`Error fetching user info: ${error.message || error}`);
      throw new Error(
        `Failed to fetch user info: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get mature order information
   * @param user - User address
   * @returns Mature order details
   */
  async getMatureOrder(user) {
    try {
      const [activeOrder, lastOrder, unlock_Order, mature_Order, activeLimit] = await readContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "matureOrder",
        args: [user],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      return {
        activeOrder,
        lastOrder,
        unlock_Order,
        mature_Order,
        activeLimit
      };
    } catch (error) {
      console.error(`Error fetching mature order: ${error.message || error}`);
      throw new Error(
        `Failed to fetch mature order: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get rank qualification details
   * @param user - User address
   * @returns Rank qualification details
   */
  async getRankQualify(user) {
    try {
      const [directs, level, strongTeam, totalTeam, fLevel] = await readContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "rankQualify",
        args: [user],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      return { directs, level, strongTeam, totalTeam, fLevel };
    } catch (error) {
      console.error(
        `Error fetching rank qualification: ${error.message || error}`
      );
      throw new Error(
        `Failed to fetch rank qualification: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get unstake potential
   * @param user - User address
   * @returns Unstake potential details
   */
  async getUnStakePotential(user) {
    try {
      const result = await readContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "unStakePotential",
        args: [user],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      return {
        remainLimit: result[0],
        growthLimit: result[1],
        active_Order: result[2],
        lastOrder: result[3],
        unlock_Order: result[4],
        mature_Order: result[5],
        totGain: result[6],
        OrderValue: result[7],
        orderGrowth: result[8],
        teamGrowth: result[9],
        teamLaps: result[10]
      };
    } catch (error) {
      console.error(
        `Error fetching unstake potential: ${error.message || error}`
      );
      throw new Error(
        `Failed to fetch unstake potential: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get total remaining TPR
   * @param userAddress - User address
   * @param isMatureOrd - Whether to consider mature orders
   * @returns Total remaining TPR details
   */
  async getTotalRemainTPR(userAddress, isMatureOrd) {
    try {
      const [totalTPR, growthTPR, forfietOrder] = await readContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "totalRemainTPR",
        args: [userAddress, isMatureOrd],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      return { totalTPR, growthTPR, forfietOrder };
    } catch (error) {
      console.error(
        `Error fetching total remaining TPR: ${error.message || error}`
      );
      throw new Error(
        `Failed to fetch total remaining TPR: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get token price for a given amount
   * @param amount - Amount in wei
   * @returns Price in wei
   */
  async getPrice(amount) {
    try {
      const price = await readContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "getPrice",
        args: [amount],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      console.log(
        `Price for ${formatEther(amount)} DAI: ${formatEther(price)} INOUT`
      );
      return price;
    } catch (error) {
      console.error(`Error fetching price: ${error.message || error}`);
      throw new Error(
        `Failed to fetch price: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Check if a user is active
   * @param user - User address
   * @returns Active status
   */
  async activeUser(user) {
    try {
      const isActive = await readContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "activeUser",
        args: [user],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      console.log(`User ${user} active status: ${isActive}`);
      return isActive;
    } catch (error) {
      console.error(`Error checking active user: ${error.message || error}`);
      throw new Error(
        `Failed to check active user: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Update user status
   * @param user - User address
   * @returns Transaction hash
   */
  async userSelfUpdate(user) {
    try {
      console.log(`Updating status for user: ${user}`);
      const txHash = await writeContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "userSelfUpdate",
        args: [user],
        chain: bscTestnet,
        account: user,
        gas: void 0
      });
      console.log(`User update transaction successful: ${txHash}`);
      return txHash;
    } catch (error) {
      console.error(`Error updating user status:`, error);
      throw new Error(
        `Failed to update user status: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get SafeMint token rate in USDT
   * @returns Rate in wei (18 decimals)
   */
  async getSafeMintRateInUSDT() {
    try {
      console.log("Fetching SafeMint token rate in USDT...");
      const rate = await readContract(config, {
        abi: SAFEMINT_TOKEN_ABI$1,
        address: TOKEN_ADDRESS,
        functionName: "rateInUSDT",
        chainId: BSC_TESTNET_CHAIN_ID
      });
      console.log(`SafeMint rate in USDT: ${formatEther(rate)}`);
      return rate;
    } catch (error) {
      console.error(`Error fetching SafeMint rate:`, error);
      throw new Error(
        `Failed to fetch SafeMint rate: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get SafeMint token reserves
   * @returns Reserves object with token supply, USDT balance, and timestamp
   */
  async getSafeMintReserves() {
    try {
      console.log("Fetching SafeMint token reserves...");
      const [reserve0, reserve1, blockTimestampLast] = await readContract(config, {
        abi: SAFEMINT_TOKEN_ABI$1,
        address: TOKEN_ADDRESS,
        functionName: "getReserves",
        chainId: BSC_TESTNET_CHAIN_ID
      });
      console.log(`SafeMint Reserves: Token Supply=${formatEther(reserve0)}, USDT Balance=${formatEther(reserve1)}, Timestamp=${blockTimestampLast}`);
      return {
        tokenSupply: reserve0,
        usdtBalance: reserve1,
        blockTimestampLast
      };
    } catch (error) {
      console.error(`Error fetching SafeMint reserves:`, error);
      throw new Error(
        `Failed to fetch SafeMint reserves: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get SafeMint token balance for an address
   * @param account - Wallet address
   * @returns Token balance in wei
   */
  async getSafeMintBalance(account) {
    try {
      console.log(`Fetching SafeMint balance for ${account}...`);
      const balance = await readContract(config, {
        abi: SAFEMINT_TOKEN_ABI$1,
        address: TOKEN_ADDRESS,
        functionName: "balanceOf",
        args: [account],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      console.log(`SafeMint balance for ${account}: ${formatEther(balance)} SELFMINT`);
      return balance;
    } catch (error) {
      console.error(`Error fetching SafeMint balance:`, error);
      throw new Error(
        `Failed to fetch SafeMint balance: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get direct referrals for a user
   * @param userAddress - User address
   * @returns Array of referral addresses
   */
  async getDirectUser(userAddress) {
    try {
      const referrals = await readContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "directUser",
        args: [userAddress],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      console.log(`Direct referrals for ${userAddress}:`, referrals);
      return referrals;
    } catch (error) {
      console.error(
        `Error fetching direct referrals: ${error.message || error}`
      );
      throw new Error(
        `Failed to fetch direct referrals: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Find leader and developer addresses
   * @param userAddress - User address
   * @returns Leader and developer addresses
   */
  async findLeaderUser(userAddress) {
    try {
      const [ledAdd, devAdd] = await readContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "findLeaderUser",
        args: [userAddress],
        chainId: BSC_TESTNET_CHAIN_ID
      });
      console.log(`Leader addresses for ${userAddress}:`, ledAdd);
      console.log(`Developer addresses for ${userAddress}:`, devAdd);
      return { ledAdd, devAdd };
    } catch (error) {
      console.error(`Error fetching leader user: ${error.message || error}`);
      throw new Error(
        `Failed to fetch leader user: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Approve USDT spending for the staking contract (BSC Mainnet)
   * @param amount - Amount to approve (in wei)
   * @param account - Wallet address to send the transaction from
   * @returns Transaction hash
   */
  async approveUSDT(amount, account) {
    try {
      console.log(`Approving ${formatUnits(amount, 6)} USDT for staking contract ${STAKING_CONTRACT_ADDRESS}`);
      const txHash = await writeContract(config, {
        abi: USDT_ABI,
        address: USDT_ADDRESS,
        functionName: "approve",
        args: [STAKING_CONTRACT_ADDRESS, amount],
        chain: bsc,
        account
      });
      console.log(`USDT approval transaction submitted: ${txHash}`);
      return txHash;
    } catch (error) {
      console.error(`Error approving USDT:`, error);
      if (error.message?.includes("gasLimit") || error.message?.includes("Cannot destructure")) {
        throw new Error(
          "Network configuration error. Please ensure you are connected to BSC Mainnet and try again."
        );
      }
      throw new Error(
        `Failed to approve USDT: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get complete user history including stakes and referrals
   * @param userAddress - User address
   * @returns Complete history data
   */
  async getCompleteUserHistory(userAddress) {
    try {
      console.log(`Fetching complete history for user: ${userAddress}`);
      const [directReferrals, bonusInfo, userInfo, rankQualify] = await Promise.all([
        this.getDirectUser(userAddress).catch((err) => {
          console.error("Error fetching direct referrals:", err);
          return [];
        }),
        this.getBonusInfo(userAddress).catch((err) => {
          console.error("Error fetching bonus info:", err);
          return {};
        }),
        this.getUserInfo(userAddress).catch((err) => {
          console.error("Error fetching user info:", err);
          return {};
        }),
        this.getRankQualify(userAddress).catch((err) => {
          console.error("Error fetching rank qualify:", err);
          return {};
        })
      ]);
      const stakeHistory = [];
      const stakeViewResponse = await this.userStakeView(userAddress, BigInt(0));
      const totalCount = Number(stakeViewResponse?.totalCount || 0);
      for (let i4 = 0; i4 < totalCount; i4++) {
        try {
          const orderResponse = await this.userStakeView(userAddress, BigInt(i4));
          const stakeInfo = orderResponse?.stakeInfo || {};
          const orderValue = stakeInfo?.orderValue || BigInt(0);
          const orderTime = stakeInfo?.orderTime || 0;
          const orderGrowth = stakeInfo?.orderGrowth || BigInt(0);
          const isMature = stakeInfo?.isMature || 0;
          const isComplete = stakeInfo?.isComplete || false;
          const formattedAmount = Number(orderValue);
          const timestamp = Number(orderTime) * 1e3;
          const growthRate = Number(orderGrowth);
          const maturityStatus = Number(isMature);
          const orderDate = new Date(timestamp);
          const formattedDate = orderDate.toLocaleDateString("en-US", {
            year: "numeric",
            month: "short",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit",
            hour12: true
          });
          const maturityPeriodDays = 15;
          const stakeDate = new Date(timestamp);
          const currentTime = /* @__PURE__ */ new Date();
          const timeElapsed = currentTime.getTime() - stakeDate.getTime();
          const daysElapsed = Math.floor(timeElapsed / (1e3 * 60 * 60 * 24));
          const totalMaturityTime = maturityPeriodDays * 24 * 60 * 60 * 1e3;
          const remainingTime = totalMaturityTime - timeElapsed;
          let remainingTimeText = "";
          if (isComplete) {
            remainingTimeText = "Completed";
          } else if (daysElapsed >= 15 || maturityStatus > 0) {
            remainingTimeText = "Matured";
          } else if (remainingTime > 0) {
            const remainingDays = Math.floor(remainingTime / (1e3 * 60 * 60 * 24));
            const remainingHours = Math.floor(remainingTime % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60));
            const remainingMinutes = Math.floor(remainingTime % (1e3 * 60 * 60) / (1e3 * 60));
            remainingTimeText = `${remainingDays}d ${remainingHours}h ${remainingMinutes}m`;
          } else {
            remainingTimeText = "Matured";
          }
          const processedOrder = {
            ...stakeInfo,
            amount: formattedAmount,
            timestamp,
            date: formattedDate,
            growthRate,
            maturityStatus,
            remainingTime: remainingTimeText,
            isStake: !isComplete,
            isComplete,
            orderValue,
            orderTime,
            orderGrowth,
            isMature
          };
          stakeHistory.push(processedOrder);
        } catch (error) {
          console.error(`Error fetching stake ${i4}:`, error);
        }
      }
      console.log(`Fetched complete history: ${stakeHistory.length} stakes, ${directReferrals.length} referrals`);
      const teamDetails = await this.getTeamDetails(userAddress);
      const earningsDetails = await this.getEarningsDetails(userAddress);
      return {
        stakeHistory,
        directReferrals,
        bonusInfo,
        userInfo,
        rankQualify,
        teamDetails,
        earningsDetails
      };
    } catch (error) {
      console.error(`Error fetching complete user history: ${error.message || error}`);
      throw new Error(
        `Failed to fetch complete user history: ${error.message || "Unknown error"}`
      );
    }
  },
  // Get detailed team information
  async getTeamDetails(userAddress) {
    try {
      console.log(`Fetching team details for: ${userAddress}`);
      const teamMembers = [];
      const directReferrals = await this.getDirectUser(userAddress);
      for (let i4 = 0; i4 < directReferrals.length; i4++) {
        const memberAddress = directReferrals[i4];
        try {
          const memberInfo = await this.getUserInfo(memberAddress);
          const memberReferrals = await this.getDirectUser(memberAddress);
          const stakeViewResponse = await this.userStakeView(memberAddress, BigInt(0));
          const latestStake = stakeViewResponse?.stakeInfo || {};
          const recentAmount = Number(latestStake.orderValue || 0);
          const joinTimestamp = Date.now() / 1e3 - i4 * 24 * 60 * 60;
          teamMembers.push({
            date: new Date(joinTimestamp * 1e3).toLocaleDateString("en-US", {
              year: "numeric",
              month: "2-digit",
              day: "2-digit"
            }),
            address: memberAddress,
            sponsor: userAddress,
            // Current user is sponsor
            level: 1,
            // Direct referral is level 1
            directs: memberReferrals.length,
            recentDeposited: recentAmount,
            tagName: `Member${i4 + 1}`,
            // Generate tag name
            userStatus: recentAmount > 0 ? "Active" : "Inactive",
            joinTimestamp
          });
        } catch (err) {
          console.error(`Error fetching details for member ${memberAddress}:`, err);
          teamMembers.push({
            date: (/* @__PURE__ */ new Date()).toLocaleDateString("en-US", {
              year: "numeric",
              month: "2-digit",
              day: "2-digit"
            }),
            address: memberAddress,
            sponsor: userAddress,
            level: 1,
            directs: 0,
            recentDeposited: 0,
            tagName: `Member${i4 + 1}`,
            userStatus: "Unknown",
            joinTimestamp: Date.now() / 1e3
          });
        }
      }
      return teamMembers.sort((a2, b2) => b2.joinTimestamp - a2.joinTimestamp);
    } catch (error) {
      console.error("Error fetching team details:", error);
      return [];
    }
  },
  // Get detailed earnings information
  async getEarningsDetails(userAddress) {
    try {
      console.log(`Fetching earnings details for: ${userAddress}`);
      const earningsHistory = [];
      const bonusInfo = await this.getBonusInfo(userAddress);
      const directReferrals = await this.getDirectUser(userAddress);
      const earningsTypes = [
        { type: "Referral Bonus", amount: Number(bonusInfo.referralGains || 0), level: 1 },
        { type: "Level Bonus", amount: Number(bonusInfo.levelGains || 0), level: 2 },
        { type: "Growth Bonus", amount: Number(bonusInfo.growthGains || 0), level: 0 },
        { type: "Team Growth", amount: Number(bonusInfo.teamGrowthGains || 0), level: 1 },
        { type: "Leader Bonus", amount: Number(bonusInfo.leaderGains || 0), level: 3 },
        { type: "Development", amount: Number(bonusInfo.developmentGains || 0), level: 0 }
      ];
      earningsTypes.forEach((earning, index2) => {
        if (earning.amount > 0) {
          const timestamp = Date.now() / 1e3 - index2 * 12 * 60 * 60;
          earningsHistory.push({
            date: new Date(timestamp * 1e3).toLocaleDateString("en-US", {
              year: "numeric",
              month: "2-digit",
              day: "2-digit"
            }),
            amount: earning.amount,
            fromUser: directReferrals[index2 % directReferrals.length] || userAddress,
            level: earning.level,
            rewardType: earning.type,
            timestamp
          });
        }
      });
      return earningsHistory.sort((a2, b2) => b2.timestamp - a2.timestamp);
    } catch (error) {
      console.error("Error fetching earnings details:", error);
      return [];
    }
  }
};
const WalletContext = reactExports.createContext({
  account: null,
  isConnected: false,
  isRegistered: false,
  isCorrectNetwork: false,
  connectWallet: async () => {
  },
  disconnectWallet: () => {
  },
  switchToCorrectNetwork: async () => false,
  refreshRegistrationStatus: async () => false,
  loading: false
});
const useWallet = () => reactExports.useContext(WalletContext);
const WalletProvider = ({ children }) => {
  const { address, isConnected, chain } = useAccount();
  const { open, close } = useWeb3Modal();
  const { disconnect: disconnect2 } = useDisconnect();
  const { switchChainAsync } = useSwitchChain();
  const [isRegistered, setIsRegistered] = reactExports.useState(false);
  const [loading, setLoading] = reactExports.useState(false);
  const isCorrectNetwork = chain?.id === 137;
  const connectWallet = async () => {
    try {
      console.log("Opening wallet connection...");
      if (/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        console.log("Mobile device detected, optimizing connection...");
        setTimeout(() => {
          open();
        }, 100);
      } else {
        open();
      }
    } catch (error) {
      console.error("Error opening wallet modal:", error);
    }
  };
  const disconnectWallet = () => {
    try {
      console.log("Disconnecting wallet...");
      disconnect2();
      close();
      setIsRegistered(false);
      setLoading(false);
      localStorage.removeItem("wagmi.store");
      localStorage.removeItem("wagmi.cache");
      setTimeout(() => {
        console.log("Wallet disconnected successfully");
      }, 100);
    } catch (error) {
      console.error("Error disconnecting wallet:", error);
    }
  };
  const switchToCorrectNetwork = async () => {
    if (!isCorrectNetwork && switchChainAsync) {
      try {
        await switchChainAsync({ chainId: 137 });
        return true;
      } catch (error) {
        console.error("Error switching network:", error);
        return false;
      }
    }
    return isCorrectNetwork;
  };
  const refreshRegistrationStatus = async () => {
    if (!address) return false;
    setLoading(true);
    try {
      const userInfo = await stakingInteractions.getUserInfo(address);
      const registered = userInfo?.joined ?? false;
      setIsRegistered(registered);
      return registered;
    } catch (error) {
      console.error("Error refreshing registration status:", error);
      setIsRegistered(false);
      return false;
    } finally {
      setLoading(false);
    }
  };
  reactExports.useEffect(() => {
    if (isConnected && address) {
      refreshRegistrationStatus();
    } else {
      setIsRegistered(false);
    }
  }, [isConnected, address]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    WalletContext.Provider,
    {
      value: {
        account: address ?? null,
        isConnected,
        isRegistered,
        isCorrectNetwork,
        connectWallet,
        disconnectWallet,
        switchToCorrectNetwork,
        refreshRegistrationStatus,
        loading
      },
      children
    }
  );
};
const MLMContext = reactExports.createContext(void 0);
const MLMProvider = ({ children }) => {
  const { address, isConnected, chain } = useAccount();
  const [isMLMRegistered, setIsMLMRegistered] = reactExports.useState(false);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const isCorrectNetwork = chain?.id === 56;
  const checkMLMRegistration = async () => {
    if (!address || !isCorrectNetwork) return false;
    try {
      setIsLoading(true);
      const registered = await stakingInteractions.activeUser(address);
      setIsMLMRegistered(registered);
      return registered;
    } catch (error) {
      console.error("Error checking MLM registration:", error);
      setIsMLMRegistered(false);
      return false;
    } finally {
      setIsLoading(false);
    }
  };
  const handleRegisterMLM = async (referrerAddress) => {
    if (!address || !isCorrectNetwork) {
      throw new Error("Wallet not connected or wrong network. Please connect your wallet and switch to Polygon network.");
    }
    const refAddress = referrerAddress || "0x3FBF4C71e8b3Fbb16808C2fb66A19f414B250297";
    const ethAddressRegex = /^0x[a-fA-F0-9]{40}$/;
    if (!ethAddressRegex.test(refAddress)) {
      throw new Error("Invalid referrer address format. Please provide a valid Ethereum address.");
    }
    try {
      setIsLoading(true);
      console.log("Starting registration process with referrer:", refAddress);
      const approveAmount = parseEther("1");
      console.log(`Approving ${approveAmount} USDTfor contract ${STAKING_CONTRACT_ADDRESS}`);
      const usdcBalance = await stakingInteractions.getUSDCBalance(address);
      if (usdcBalance < approveAmount) {
        throw new Error(`Insufficient USDTbalance. You have ${parseFloat(formatEther(usdcBalance)).toFixed(2)} USDTbut need 1 USDC.`);
      }
      const approvalTx = await stakingInteractions.approveUSDC(approveAmount, address);
      console.log("USDTapproval transaction successful:", approvalTx);
      const hash2 = await stakingInteractions.regUser(refAddress, address);
      console.log("Registration transaction submitted. Hash:", hash2);
      setTimeout(async () => {
        try {
          await checkMLMRegistration();
          console.log("Registration status checked after transaction");
        } catch (checkError) {
          console.error("Error checking registration status after transaction:", checkError);
        }
      }, 5e3);
      return true;
    } catch (error) {
      console.error("Error registering MLM:", error);
      console.error("Error details:", {
        name: error.name,
        message: error.message,
        code: error.code,
        data: error.data,
        shortMessage: error.shortMessage,
        details: error.details
      });
      if (error.message?.includes("user rejected")) {
        throw new Error("Transaction was rejected by user. Please approve the transaction to complete registration.");
      } else if (error.message?.includes("insufficient")) {
        throw new Error("Insufficient USDTbalance or POL for gas fees. Ensure you have ~1 USDTand ~0.2 POL.");
      } else if (error.message?.includes("already registered")) {
        throw new Error("This wallet address is already registered in the system.");
      } else {
        throw new Error(`Registration failed: ${error.message || "Unknown error occurred. Please try again."}`);
      }
    } finally {
      setIsLoading(false);
    }
  };
  const handleGetDirectReferrals = async () => {
    if (!address || !isCorrectNetwork) return [];
    try {
      return await stakingInteractions.getDirectUser(address);
    } catch (error) {
      console.error("Error getting direct referrals:", error);
      return [];
    }
  };
  const handleGetDirectReferralCount = async () => {
    if (!address || !isCorrectNetwork) return 0;
    try {
      const referrals = await stakingInteractions.getDirectUser(address);
      return referrals.length;
    } catch (error) {
      console.error("Error getting direct referral count:", error);
      return 0;
    }
  };
  const handleGetReferrer = async () => {
    if (!address || !isCorrectNetwork) return "";
    try {
      const userInfo = await stakingInteractions.getUserInfo(address);
      return userInfo.referral || "";
    } catch (error) {
      console.error("Error getting referrer:", error);
      return "";
    }
  };
  const handleGetTotalRegistered = async () => {
    try {
      const total = await readContract(config, {
        abi: STAKING_ABI,
        address: STAKING_CONTRACT_ADDRESS,
        functionName: "totalReg",
        chainId: 56
      });
      return Number(total);
    } catch (error) {
      console.error("Error getting total registered:", error);
      return 0;
    }
  };
  reactExports.useEffect(() => {
    if (isConnected && address && isCorrectNetwork) {
      checkMLMRegistration();
    } else {
      setIsMLMRegistered(false);
    }
  }, [isConnected, address, isCorrectNetwork]);
  const value = {
    address: address ?? null,
    isConnected,
    isMLMRegistered,
    isLoading,
    isCorrectNetwork,
    registerMLM: handleRegisterMLM,
    checkMLMRegistration,
    getDirectReferrals: handleGetDirectReferrals,
    getDirectReferralCount: handleGetDirectReferralCount,
    getReferrer: handleGetReferrer,
    getTotalRegistered: handleGetTotalRegistered
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MLMContext.Provider, { value, children });
};
const TransactionHistoryContext = reactExports.createContext(void 0);
const TransactionHistoryProvider = ({ children }) => {
  const wallet = useWallet();
  const address = wallet.account;
  const [transactions, setTransactions] = reactExports.useState([]);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (address) {
      const storageKey = `transaction_history_${address}`;
      const storedHistory = localStorage.getItem(storageKey);
      if (storedHistory) {
        try {
          const parsedHistory = JSON.parse(storedHistory);
          setTransactions(parsedHistory);
        } catch (error) {
          console.error("Error loading transaction history:", error);
          setTransactions([]);
        }
      }
    }
  }, [address]);
  reactExports.useEffect(() => {
    if (address && transactions.length > 0) {
      const storageKey = `transaction_history_${address}`;
      localStorage.setItem(storageKey, JSON.stringify(transactions));
    }
  }, [address, transactions]);
  const addTransaction = (transaction) => {
    setIsLoading(true);
    const newTransaction = {
      ...transaction,
      id: `TXN-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
      timestamp: Date.now()
    };
    setTransactions((prev2) => [newTransaction, ...prev2]);
    setIsLoading(false);
  };
  const getWithdrawalHistory = () => {
    return transactions.filter((tx) => tx.type === "withdrawal");
  };
  const getInvestmentHistory = () => {
    return transactions.filter((tx) => tx.type === "investment");
  };
  const getTotalWithdrawals = () => {
    const withdrawals = getWithdrawalHistory();
    const totalAmount = withdrawals.reduce((sum, tx) => sum + parseFloat(tx.amount), 0);
    const totalFees = withdrawals.reduce((sum, tx) => sum + parseFloat(tx.fee), 0);
    return {
      count: withdrawals.length,
      amount: totalAmount,
      fees: totalFees
    };
  };
  const clearHistory = () => {
    setTransactions([]);
    if (address) {
      const storageKey = `transaction_history_${address}`;
      localStorage.removeItem(storageKey);
    }
  };
  const value = {
    transactions,
    addTransaction,
    getWithdrawalHistory,
    getInvestmentHistory,
    getTotalWithdrawals,
    clearHistory,
    isLoading
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransactionHistoryContext.Provider, { value, children });
};
const ToastContext = reactExports.createContext(void 0);
function SlideTransition(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Slide, { ...props, direction: "up" });
}
const ToastProvider = ({ children }) => {
  const [toasts, setToasts] = reactExports.useState([]);
  const showToast = (message, type = "info", duration2 = 6e3) => {
    const id = Date.now().toString();
    const newToast = {
      id,
      message,
      type,
      duration: duration2
    };
    setToasts((prev2) => [...prev2, newToast]);
    setTimeout(() => {
      setToasts((prev2) => prev2.filter((toast) => toast.id !== id));
    }, duration2);
  };
  const showSuccess = (message, duration2 = 6e3) => {
    showToast(message, "success", duration2);
  };
  const showError = (message, duration2 = 8e3) => {
    showToast(message, "error", duration2);
  };
  const showWarning = (message, duration2 = 6e3) => {
    showToast(message, "warning", duration2);
  };
  const showInfo = (message, duration2 = 6e3) => {
    showToast(message, "info", duration2);
  };
  const handleClose = (id) => {
    setToasts((prev2) => prev2.filter((toast) => toast.id !== id));
  };
  const value = {
    showToast,
    showSuccess,
    showError,
    showWarning,
    showInfo
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ToastContext.Provider, { value, children: [
    children,
    toasts.map((toast, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Snackbar,
      {
        open: true,
        autoHideDuration: toast.duration,
        onClose: () => handleClose(toast.id),
        TransitionComponent: SlideTransition,
        anchorOrigin: { vertical: "top", horizontal: "right" },
        sx: {
          mt: index2 * 7
          // Stack multiple toasts
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Alert,
          {
            onClose: () => handleClose(toast.id),
            severity: toast.type,
            variant: "filled",
            sx: {
              width: "100%",
              minWidth: 300,
              boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)"
            },
            children: toast.message
          }
        )
      },
      toast.id
    ))
  ] });
};
const getBasePath = () => {
  const base3 = "/";
  return base3.endsWith("/") ? base3 : base3 + "/";
};
const LOGO_CONFIG = {
  // Main logo image (public folder path)
  image: `${getBasePath()}safemint-logo.png`,
  // Alternative fallback (same path for consistency)
  fallback: `${getBasePath()}safemint-logo.png`,
  // Logo dimensions for different use cases
  sizes: {
    navbar: {
      width: 100,
      height: 100
    },
    sidebar: {
      width: 32,
      height: 32
    },
    large: {
      width: 80,
      height: 80
    }
  },
  // Alt text
  alt: "SafeMint Logo",
  // Common styles
  styles: {
    borderRadius: "8px",
    objectFit: "contain"
  }
};
const Logo = ({
  size: size2 = "medium",
  fallbackText = "SM",
  sx,
  ...props
}) => {
  const [imageError, setImageError] = reactExports.useState(false);
  const [fallbackError, setFallbackError] = reactExports.useState(false);
  const getSizeConfig = () => {
    switch (size2) {
      case "small":
        return { width: 24, height: 24 };
      case "navbar":
        return LOGO_CONFIG.sizes.navbar;
      case "sidebar":
        return LOGO_CONFIG.sizes.sidebar;
      case "large":
        return LOGO_CONFIG.sizes.large;
      default:
        return { width: 48, height: 48 };
    }
  };
  const sizeConfig = getSizeConfig();
  const handleImageError = () => {
    if (!imageError) {
      setImageError(true);
    } else if (!fallbackError) {
      setFallbackError(true);
    }
  };
  const getImageSrc = () => {
    if (!imageError) {
      return LOGO_CONFIG.image;
    } else if (!fallbackError) {
      return LOGO_CONFIG.fallback;
    }
    return null;
  };
  const imageSrc = getImageSrc();
  if (!imageSrc || imageError && fallbackError) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        sx: {
          width: sizeConfig.width,
          height: sizeConfig.height,
          borderRadius: LOGO_CONFIG.styles.borderRadius,
          background: "linear-gradient(45deg, #FFA000 30%, #FF8F00 90%)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          color: "#ffffff",
          fontWeight: "bold",
          fontSize: sizeConfig.width * 0.35,
          boxShadow: "0 4px 15px rgba(255, 160, 0, 0.4)",
          border: "2px solid rgba(255, 255, 255, 0.3)",
          textShadow: "0 2px 4px rgba(0, 0, 0, 0.3)",
          // Add enhanced styling for navbar fallback
          ...size2 === "navbar" && {
            transition: "all 0.3s ease",
            border: "none",
            borderRadius: "0",
            "&:hover": {
              transform: "scale(1.05)"
            }
          },
          ...sx
        },
        ...props,
        children: fallbackText
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      component: "img",
      src: imageSrc,
      alt: LOGO_CONFIG.alt,
      onError: handleImageError,
      sx: {
        width: sizeConfig.width,
        height: sizeConfig.height,
        borderRadius: LOGO_CONFIG.styles.borderRadius,
        objectFit: LOGO_CONFIG.styles.objectFit,
        // Add enhanced styling for navbar
        ...size2 === "navbar" && {
          transition: "all 0.3s ease",
          border: "none",
          borderRadius: "0",
          "&:hover": {
            transform: "scale(1.05)"
          }
        },
        ...sx
      },
      ...props
    }
  );
};
const SafeMintTextSvg = ({
  size: size2 = "medium",
  animated = true,
  sx,
  ...props
}) => {
  const getSizeConfig = () => {
    switch (size2) {
      case "small":
        return { width: 80, height: 24, fontSize: 16 };
      case "navbar":
        return { width: 100, height: 28, fontSize: 18 };
      case "large":
        return { width: 140, height: 36, fontSize: 24 };
      default:
        return { width: 120, height: 32, fontSize: 20 };
    }
  };
  const sizeConfig = getSizeConfig();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box,
    {
      sx: {
        display: "flex",
        alignItems: "center",
        ...sx
      },
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          width: sizeConfig.width,
          height: sizeConfig.height,
          viewBox: "0 0 120 32",
          xmlns: "http://www.w3.org/2000/svg",
          style: {
            filter: "drop-shadow(0 1px 3px rgba(255, 160, 0, 0.3))"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "safeMintTextGradient", x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#FFA000", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "stop-color", values: "#FFA000;#FFD54F;#FFEB3B;#FFA000", dur: "4s", repeatCount: "indefinite" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "50%", stopColor: "#FF8F00", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "stop-color", values: "#FF8F00;#FFC107;#FF9800;#FF8F00", dur: "4s", repeatCount: "indefinite" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#FF6F00", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "stop-color", values: "#FF6F00;#FF9800;#F57C00;#FF6F00", dur: "4s", repeatCount: "indefinite" }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "glowGradient", x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#FFD54F", stopOpacity: "0.8" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "50%", stopColor: "#FFC107", stopOpacity: "1" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#FF9800", stopOpacity: "0.8" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", { id: "textShadow", x: "-50%", y: "-50%", width: "200%", height: "200%", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("feDropShadow", { dx: "0", dy: "2", stdDeviation: "2", floodColor: "rgba(0,0,0,0.4)" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("feGaussianBlur", { stdDeviation: "1", result: "glow" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("feMerge", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("feMergeNode", { in: "glow" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("feMergeNode", { in: "SourceGraphic" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", { id: "sparkle", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("feGaussianBlur", { stdDeviation: "0.5", result: "coloredBlur" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("feMerge", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("feMergeNode", { in: "coloredBlur" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("feMergeNode", { in: "SourceGraphic" })
                ] })
              ] })
            ] }),
            animated && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "circle",
              {
                cx: "60",
                cy: "16",
                r: "45",
                fill: "url(#glowGradient)",
                opacity: "0.1",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "animate",
                    {
                      attributeName: "r",
                      values: "40;50;40",
                      dur: "3s",
                      repeatCount: "indefinite"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "animate",
                    {
                      attributeName: "opacity",
                      values: "0.05;0.15;0.05",
                      dur: "2s",
                      repeatCount: "indefinite"
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "text",
                {
                  x: "35",
                  y: "20",
                  fontFamily: "'Inter', 'Roboto', sans-serif",
                  fontSize: sizeConfig.fontSize,
                  fontWeight: "700",
                  fill: "url(#safeMintTextGradient)",
                  textAnchor: "middle",
                  letterSpacing: "0.8px",
                  filter: "url(#textShadow)",
                  children: [
                    "Safe",
                    animated && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animateTransform",
                        {
                          attributeName: "transform",
                          type: "translate",
                          values: "0,0; 0,-2; 0,0; 0,-1; 0,0",
                          dur: "3s",
                          repeatCount: "indefinite"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animateTransform",
                        {
                          attributeName: "transform",
                          type: "scale",
                          values: "1;1.05;1",
                          dur: "4s",
                          repeatCount: "indefinite",
                          additive: "sum"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animate",
                        {
                          attributeName: "opacity",
                          values: "0.9;1;0.9",
                          dur: "2.5s",
                          repeatCount: "indefinite"
                        }
                      )
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "text",
                {
                  x: "85",
                  y: "20",
                  fontFamily: "'Inter', 'Roboto', sans-serif",
                  fontSize: sizeConfig.fontSize,
                  fontWeight: "800",
                  fill: "#FF6F00",
                  textAnchor: "middle",
                  letterSpacing: "0.8px",
                  filter: "url(#sparkle)",
                  children: [
                    "Mint",
                    animated && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animateTransform",
                        {
                          attributeName: "transform",
                          type: "translate",
                          values: "0,0; 0,-2; 0,0; 0,-1; 0,0",
                          dur: "3s",
                          begin: "0.5s",
                          repeatCount: "indefinite"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animateTransform",
                        {
                          attributeName: "transform",
                          type: "scale",
                          values: "1;1.08;1",
                          dur: "3.5s",
                          repeatCount: "indefinite",
                          additive: "sum"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animate",
                        {
                          attributeName: "fill",
                          values: "#FF6F00;#FF9800;#F57C00;#FF6F00",
                          dur: "3s",
                          repeatCount: "indefinite"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animate",
                        {
                          attributeName: "opacity",
                          values: "0.85;1;0.85",
                          dur: "2s",
                          repeatCount: "indefinite"
                        }
                      )
                    ] })
                  ]
                }
              )
            ] }),
            animated && /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { opacity: "0.7", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("circle", { cx: "15", cy: "8", r: "1", fill: "#FFD54F", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animate",
                  {
                    attributeName: "opacity",
                    values: "0;1;0",
                    dur: "2s",
                    repeatCount: "indefinite"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animateTransform",
                  {
                    attributeName: "transform",
                    type: "scale",
                    values: "0;1;0",
                    dur: "2s",
                    repeatCount: "indefinite"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("circle", { cx: "105", cy: "10", r: "1.5", fill: "#FFC107", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animate",
                  {
                    attributeName: "opacity",
                    values: "0;1;0",
                    dur: "2.5s",
                    begin: "1s",
                    repeatCount: "indefinite"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animateTransform",
                  {
                    attributeName: "transform",
                    type: "scale",
                    values: "0;1;0",
                    dur: "2.5s",
                    begin: "1s",
                    repeatCount: "indefinite"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("circle", { cx: "25", cy: "28", r: "0.8", fill: "#FF9800", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animate",
                  {
                    attributeName: "opacity",
                    values: "0;1;0",
                    dur: "1.8s",
                    begin: "1.5s",
                    repeatCount: "indefinite"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animateTransform",
                  {
                    attributeName: "transform",
                    type: "scale",
                    values: "0;1;0",
                    dur: "1.8s",
                    begin: "1.5s",
                    repeatCount: "indefinite"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("circle", { cx: "95", cy: "30", r: "1", fill: "#FFD54F", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animate",
                  {
                    attributeName: "opacity",
                    values: "0;1;0",
                    dur: "2.2s",
                    begin: "0.8s",
                    repeatCount: "indefinite"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animateTransform",
                  {
                    attributeName: "transform",
                    type: "scale",
                    values: "0;1;0",
                    dur: "2.2s",
                    begin: "0.8s",
                    repeatCount: "indefinite"
                  }
                )
              ] })
            ] })
          ]
        }
      )
    }
  );
};
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const toCamelCase = (string) => string.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (match2, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
);
const toPascalCase = (string) => {
  const camelCase = toCamelCase(string);
  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
};
const mergeClasses = (...classes) => classes.filter((className, index2, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index2;
}).join(" ").trim();
const hasA11yProp = (props) => {
  for (const prop in props) {
    if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
      return true;
    }
  }
};
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = reactExports.forwardRef(
  ({
    color: color2 = "currentColor",
    size: size2 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref2) => reactExports.createElement(
    "svg",
    {
      ref: ref2,
      ...defaultAttributes,
      width: size2,
      height: size2,
      stroke: color2,
      strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
      className: mergeClasses("lucide", className),
      ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
      ...rest
    },
    [
      ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
      ...Array.isArray(children) ? children : [children]
    ]
  )
);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => {
  const Component = reactExports.forwardRef(
    ({ className, ...props }, ref2) => reactExports.createElement(Icon, {
      ref: ref2,
      iconNode,
      className: mergeClasses(
        `lucide-${toKebabCase(toPascalCase(iconName))}`,
        `lucide-${iconName}`,
        className
      ),
      ...props
    })
  );
  Component.displayName = toPascalCase(iconName);
  return Component;
};
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$m = [
  ["path", { d: "M8 3 4 7l4 4", key: "9rb6wj" }],
  ["path", { d: "M4 7h16", key: "6tx8e3" }],
  ["path", { d: "m16 21 4-4-4-4", key: "siv7j2" }],
  ["path", { d: "M20 17H4", key: "h6l3hr" }]
];
const ArrowLeftRight = createLucideIcon("arrow-left-right", __iconNode$m);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$l = [
  ["path", { d: "M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z", key: "1b4qmf" }],
  ["path", { d: "M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2", key: "i71pzd" }],
  ["path", { d: "M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2", key: "10jefs" }],
  ["path", { d: "M10 6h4", key: "1itunk" }],
  ["path", { d: "M10 10h4", key: "tcdvrf" }],
  ["path", { d: "M10 14h4", key: "kelpxr" }],
  ["path", { d: "M10 18h4", key: "1ulq68" }]
];
const Building2 = createLucideIcon("building-2", __iconNode$l);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$k = [
  ["line", { x1: "12", x2: "12", y1: "20", y2: "10", key: "1vz5eb" }],
  ["line", { x1: "18", x2: "18", y1: "20", y2: "4", key: "cun8e5" }],
  ["line", { x1: "6", x2: "6", y1: "20", y2: "16", key: "hq0ia6" }]
];
const ChartNoAxesColumnIncreasing = createLucideIcon("chart-no-axes-column-increasing", __iconNode$k);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$j = [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
];
const CircleCheckBig = createLucideIcon("circle-check-big", __iconNode$j);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$i = [
  ["path", { d: "M12 6v6h4", key: "135r8i" }],
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
];
const Clock3 = createLucideIcon("clock-3", __iconNode$i);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$h = [
  ["path", { d: "M12 6v6l4 2", key: "mmk7yg" }],
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
];
const Clock = createLucideIcon("clock", __iconNode$h);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$g = [
  ["circle", { cx: "8", cy: "8", r: "6", key: "3yglwk" }],
  ["path", { d: "M18.09 10.37A6 6 0 1 1 10.34 18", key: "t5s6rm" }],
  ["path", { d: "M7 6h1v4", key: "1obek4" }],
  ["path", { d: "m16.71 13.88.7.71-2.82 2.82", key: "1rbuyh" }]
];
const Coins = createLucideIcon("coins", __iconNode$g);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$f = [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
];
const Copy = createLucideIcon("copy", __iconNode$f);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$e = [
  [
    "path",
    {
      d: "M11.562 3.266a.5.5 0 0 1 .876 0L15.39 8.87a1 1 0 0 0 1.516.294L21.183 5.5a.5.5 0 0 1 .798.519l-2.834 10.246a1 1 0 0 1-.956.734H5.81a1 1 0 0 1-.957-.734L2.02 6.02a.5.5 0 0 1 .798-.519l4.276 3.664a1 1 0 0 0 1.516-.294z",
      key: "1vdc57"
    }
  ],
  ["path", { d: "M5 21h14", key: "11awu3" }]
];
const Crown = createLucideIcon("crown", __iconNode$e);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$d = [
  ["line", { x1: "12", x2: "12", y1: "2", y2: "22", key: "7eqyqh" }],
  ["path", { d: "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6", key: "1b0p4s" }]
];
const DollarSign = createLucideIcon("dollar-sign", __iconNode$d);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$c = [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
];
const ExternalLink = createLucideIcon("external-link", __iconNode$c);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$b = [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
  ["path", { d: "M12 7v5l4 2", key: "1fdv2h" }]
];
const History = createLucideIcon("history", __iconNode$b);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$a = [
  ["path", { d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8", key: "5wwlr5" }],
  [
    "path",
    {
      d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",
      key: "1d0kgt"
    }
  ]
];
const House = createLucideIcon("house", __iconNode$a);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$9 = [
  ["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }],
  ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]
];
const Link = createLucideIcon("link", __iconNode$9);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$8 = [
  ["path", { d: "m16 17 5-5-5-5", key: "1bji2h" }],
  ["path", { d: "M21 12H9", key: "dn1m92" }],
  ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }]
];
const LogOut = createLucideIcon("log-out", __iconNode$8);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$7 = [
  ["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }],
  ["path", { d: "M21 3v5h-5", key: "1q7to0" }],
  ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }],
  ["path", { d: "M8 16H3v5", key: "1cv678" }]
];
const RefreshCw = createLucideIcon("refresh-cw", __iconNode$7);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$6 = [
  ["path", { d: "M12 2v13", key: "1km8f5" }],
  ["path", { d: "m16 6-4-4-4 4", key: "13yo43" }],
  ["path", { d: "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8", key: "1b2hhj" }]
];
const Share = createLucideIcon("share", __iconNode$6);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$5 = [
  ["path", { d: "M16 17h6v-6", key: "t6n2it" }],
  ["path", { d: "m22 17-8.5-8.5-5 5L2 7", key: "x473p" }]
];
const TrendingDown = createLucideIcon("trending-down", __iconNode$5);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$4 = [
  ["path", { d: "M16 7h6v6", key: "box55l" }],
  ["path", { d: "m22 7-8.5 8.5-5-5L2 17", key: "1t1m79" }]
];
const TrendingUp = createLucideIcon("trending-up", __iconNode$4);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$3 = [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["line", { x1: "19", x2: "19", y1: "8", y2: "14", key: "1bvyxn" }],
  ["line", { x1: "22", x2: "16", y1: "11", y2: "11", key: "1shjgl" }]
];
const UserPlus = createLucideIcon("user-plus", __iconNode$3);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$2 = [
  ["path", { d: "M18 21a8 8 0 0 0-16 0", key: "3ypg7q" }],
  ["circle", { cx: "10", cy: "8", r: "5", key: "o932ke" }],
  ["path", { d: "M22 20c0-3.37-2-6.5-4-8a5 5 0 0 0-.45-8.3", key: "10s06x" }]
];
const UsersRound = createLucideIcon("users-round", __iconNode$2);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$1 = [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["path", { d: "M16 3.128a4 4 0 0 1 0 7.744", key: "16gr8j" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
];
const Users = createLucideIcon("users", __iconNode$1);
/**
 * @license lucide-react v0.542.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode = [
  [
    "path",
    {
      d: "M19 7V4a1 1 0 0 0-1-1H5a2 2 0 0 0 0 4h15a1 1 0 0 1 1 1v4h-3a2 2 0 0 0 0 4h3a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1",
      key: "18etb6"
    }
  ],
  ["path", { d: "M3 5v14a2 2 0 0 0 2 2h15a1 1 0 0 0 1-1v-4", key: "xoc0q4" }]
];
const Wallet = createLucideIcon("wallet", __iconNode);
const Navbar = () => {
  const wallet = useWallet();
  const { open } = useWeb3Modal();
  const navigate = useNavigate();
  const theme2 = useTheme();
  const isMobile = useMediaQuery(theme2.breakpoints.down("md"));
  const location2 = useLocation();
  const isActive = (path) => {
    return location2.pathname === path;
  };
  const appBarStyle = {
    background: "linear-gradient(90deg, #1e3a8a 0%, #1e40af 100%)",
    // Royal dark blue gradient
    boxShadow: "0 4px 20px rgba(0, 0, 0, 0.15)"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AppBar, { position: "sticky", sx: appBarStyle, elevation: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Toolbar, { disableGutters: true, sx: { minHeight: { xs: 41, sm: 45 } }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Typography,
        {
          variant: "h6",
          component: Link$1,
          to: "/",
          sx: {
            flexGrow: 1,
            fontWeight: 700,
            textDecoration: "none",
            color: "white",
            display: "flex",
            alignItems: "center",
            fontSize: { xs: "1.1rem", sm: "1.35rem" },
            transition: "all 0.3s ease",
            "&:hover": {
              transform: "translateY(-1px)",
              textShadow: "0 2px 8px rgba(0, 0, 0, 0.3)"
            }
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Logo,
              {
                size: "navbar",
                sx: {
                  mr: 0,
                  ml: 0,
                  m: 0,
                  p: 0,
                  flexShrink: 0
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SafeMintTextSvg,
              {
                size: "navbar",
                animated: true,
                sx: {
                  ml: 1,
                  flexShrink: 0
                }
              }
            )
          ]
        }
      ),
      !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", gap: 2, alignItems: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            color: "inherit",
            component: Link$1,
            to: "/",
            sx: {
              borderRadius: "20px",
              px: 2,
              backgroundColor: isActive("/") ? "rgba(255, 255, 255, 0.15)" : "transparent"
            },
            startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(House, { size: 18 }),
            children: "Dashboard"
          }
        ),
        wallet.isConnected && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              color: "inherit",
              component: Link$1,
              to: "/history",
              sx: {
                borderRadius: "20px",
                px: 2,
                backgroundColor: isActive("/history") ? "rgba(255, 255, 255, 0.15)" : "transparent"
              },
              startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(History, { size: 18 }),
              children: "History"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              color: "inherit",
              component: Link$1,
              to: "/swap",
              sx: {
                borderRadius: "20px",
                px: 2,
                backgroundColor: isActive("/swap") ? "rgba(255, 255, 255, 0.15)" : "transparent"
              },
              startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeftRight, { size: 18 }),
              children: "Swap"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", gap: 1, ml: 2 }, children: [
        wallet.isConnected && !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Chip,
          {
            avatar: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { sx: { bgcolor: theme2.palette.success.main, width: 32, height: 32 }, children: "U" }),
            label: `${wallet.account?.substring(0, 6)}...${wallet.account?.substring(wallet.account.length - 4)}`,
            sx: {
              borderColor: "white",
              color: "white",
              fontSize: "0.875rem"
            },
            variant: "outlined"
          }
        ),
        wallet.isConnected ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            color: "inherit",
            variant: "outlined",
            onClick: wallet.disconnectWallet,
            sx: {
              borderColor: "rgba(255, 255, 255, 0.5)",
              "&:hover": { borderColor: "white", backgroundColor: "rgba(255, 255, 255, 0.1)" },
              px: { xs: 1, sm: 2 },
              fontSize: { xs: "0.75rem", sm: "0.875rem" }
            },
            startIcon: !isMobile ? /* @__PURE__ */ jsxRuntimeExports.jsx(LogOut, { size: 18 }) : void 0,
            children: isMobile ? "Exit" : "Disconnect"
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "contained",
            onClick: () => open(),
            sx: {
              backgroundColor: "#3b82f6",
              "&:hover": { backgroundColor: "#2563eb" },
              px: { xs: 1, sm: 2 },
              fontSize: { xs: "0.75rem", sm: "0.875rem" }
            },
            startIcon: !isMobile ? /* @__PURE__ */ jsxRuntimeExports.jsx(Wallet, { size: 18 }) : void 0,
            children: isMobile ? "Connect" : "Connect Wallet"
          }
        )
      ] })
    ] }) }) }),
    isMobile && wallet.isConnected && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Paper,
      {
        sx: {
          position: "fixed",
          bottom: 0,
          left: 0,
          right: 0,
          zIndex: 1e3,
          borderTop: "1px solid #333"
        },
        elevation: 3,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          BottomNavigation,
          {
            value: location2.pathname,
            sx: {
              bgcolor: "#1e3a8a",
              // Royal dark blue to match navbar
              "& .MuiBottomNavigationAction-root": {
                color: "rgba(255, 255, 255, 0.7)",
                fontSize: "0.7rem",
                minWidth: "auto",
                padding: "6px 8px",
                "&.Mui-selected": {
                  color: "#ffffff",
                  fontSize: "0.75rem"
                }
              }
            },
            showLabels: true,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                BottomNavigationAction,
                {
                  label: "Dashboard",
                  value: "/",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(House, { size: 18 }),
                  onClick: () => navigate("/")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                BottomNavigationAction,
                {
                  label: "History",
                  value: "/history",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(History, { size: 18 }),
                  onClick: () => navigate("/history")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                BottomNavigationAction,
                {
                  label: "Swap",
                  value: "/swap",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeftRight, { size: 18 }),
                  onClick: () => navigate("/swap")
                }
              )
            ]
          }
        )
      }
    )
  ] });
};
const MLMDashboard = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
};
const getReferrerFromUrl = () => {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.get("referrer") || urlParams.get("ref") || "";
};
const generateReferralLink = (referrerAddress) => {
  const currentDomain = window.location.origin;
  const currentPath = window.location.pathname;
  return `${currentDomain}${currentPath}?ref=${referrerAddress}`;
};
const generateReferralMessage = (referrerAddress, appName = "SafeMint") => {
  const referralLink = generateReferralLink(referrerAddress);
  return ` Join me on ${appName}!

 Use my referral link to get started: ${referralLink}

 Or use my referral code: ${referrerAddress}

Start earning with crypto staking and MLM rewards! `;
};
const hasReferralInUrl = () => {
  const referrer = getReferrerFromUrl();
  return referrer.length > 0;
};
const clearReferralFromUrl = () => {
  const url = new URL(window.location.href);
  url.searchParams.delete("referrer");
  url.searchParams.delete("ref");
  window.history.replaceState({}, document.title, url.toString());
};
const StatCard = ({ icon, title, value, subtitle, color: color2, gradient }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
    width: "100%",
    maxWidth: "100%",
    height: "100%",
    backgroundColor: "white",
    borderRadius: { xs: 4, sm: 5 },
    boxShadow: { xs: 3, sm: 6, md: 10 },
    transition: "all 0.4s cubic-bezier(0.4, 0, 0.2, 1)",
    border: `2px solid ${color2}15`,
    margin: 0,
    position: "relative",
    overflow: "hidden",
    background: gradient || `linear-gradient(145deg, #ffffff 0%, #fafafa 100%)`,
    "&:hover": {
      boxShadow: { xs: 6, sm: 12, md: 20 },
      transform: "translateY(-8px) scale(1.03)",
      borderColor: `${color2}40`,
      background: `linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%)`,
      "&::before": {
        opacity: 1,
        height: "4px"
      },
      "&::after": {
        opacity: 0.1
      }
    },
    "&::before": {
      content: '""',
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      height: "3px",
      background: `linear-gradient(90deg, ${color2} 0%, ${color2}60 25%, ${color2}80 50%, ${color2}60 75%, ${color2} 100%)`,
      backgroundSize: "200% 100%",
      opacity: 0.8,
      transition: "all 0.4s ease",
      animation: "shimmer 3s ease-in-out infinite",
      "@keyframes shimmer": {
        "0%": { backgroundPosition: "-200% 0" },
        "100%": { backgroundPosition: "200% 0" }
      }
    },
    "&::after": {
      content: '""',
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      background: `radial-gradient(circle at 50% 0%, ${color2}05 0%, transparent 50%)`,
      opacity: 0,
      transition: "opacity 0.4s ease"
    }
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { sx: {
    width: "100%",
    maxWidth: "100%",
    p: { xs: 2, sm: 3, md: 4 },
    "&:last-child": { pb: { xs: 2, sm: 3, md: 4 } },
    display: "flex",
    flexDirection: "column",
    height: "100%",
    minHeight: { xs: "160px", sm: "200px", md: "240px" },
    boxSizing: "border-box",
    margin: 0,
    justifyContent: "center",
    alignItems: "stretch",
    overflow: "hidden"
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "flex-start",
    gap: { xs: 2, sm: 3, md: 4 },
    width: "100%",
    height: "100%",
    position: "relative"
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
      flex: "0 0 auto",
      width: { xs: "80px", sm: "100px", md: "120px" },
      height: { xs: "80px", sm: "100px", md: "120px" },
      borderRadius: { xs: 3, sm: 4, md: 5 },
      backgroundColor: `${color2}08`,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      border: `3px solid ${color2}20`,
      transition: "all 0.5s cubic-bezier(0.4, 0, 0.2, 1)",
      position: "relative",
      overflow: "hidden",
      background: `
              radial-gradient(circle at 30% 30%, ${color2}15 0%, transparent 50%),
              linear-gradient(135deg, ${color2}05 0%, ${color2}15 50%, ${color2}05 100%)
            `,
      boxShadow: `
              0 8px 25px ${color2}25,
              inset 0 1px 0 rgba(255,255,255,0.4),
              inset 0 -1px 0 ${color2}10
            `,
      "&::before": {
        content: '""',
        position: "absolute",
        top: 0,
        left: "-100%",
        width: "100%",
        height: "100%",
        background: `linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent)`,
        transition: "left 0.8s ease"
      },
      "&::after": {
        content: '""',
        position: "absolute",
        top: "50%",
        left: "50%",
        width: "120%",
        height: "120%",
        background: `radial-gradient(circle, ${color2}05 0%, transparent 70%)`,
        transform: "translate(-50%, -50%)",
        opacity: 0,
        transition: "opacity 0.5s ease"
      },
      "&:hover": {
        backgroundColor: `${color2}15`,
        transform: "scale(1.05) translateY(-4px)",
        borderColor: `${color2}40`,
        boxShadow: `
                0 15px 40px ${color2}35,
                inset 0 1px 0 rgba(255,255,255,0.5),
                inset 0 -1px 0 ${color2}20
              `,
        "&::before": {
          left: "100%"
        },
        "&::after": {
          opacity: 1
        },
        "& .icon-wrapper": {
          transform: "scale(1.1) rotate(5deg)"
        }
      }
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        className: "icon-wrapper",
        sx: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          transition: "all 0.5s cubic-bezier(0.4, 0, 0.2, 1)",
          filter: `drop-shadow(0 4px 12px ${color2}40)`,
          position: "relative",
          zIndex: 2,
          "&:hover": {
            filter: `drop-shadow(0 6px 16px ${color2}60)`
          }
        },
        children: icon
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
      flex: 1,
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "flex-start",
      height: "100%",
      minHeight: { xs: "80px", sm: "100px", md: "120px" },
      gap: { xs: 1, sm: 1.5, md: 2 },
      position: "relative",
      pl: { xs: 1, sm: 2, md: 3 },
      overflow: "hidden",
      maxWidth: "100%"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
        width: "100%",
        display: "flex",
        alignItems: "center",
        justifyContent: "flex-start",
        minHeight: { xs: "24px", sm: "32px", md: "40px" },
        maxWidth: "100%",
        overflow: "hidden"
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "h6",
          sx: {
            fontWeight: 700,
            color: "text.primary",
            fontSize: { xs: "1.1rem", sm: "1.3rem", md: "1.5rem" },
            lineHeight: 1.2,
            textAlign: "left",
            letterSpacing: "-0.01em",
            whiteSpace: "nowrap",
            overflow: "hidden",
            textOverflow: "ellipsis",
            maxWidth: "100%",
            textShadow: "0 1px 2px rgba(0,0,0,0.1)"
          },
          title,
          children: title
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
        width: "100%",
        display: "flex",
        alignItems: "baseline",
        justifyContent: "flex-start",
        minHeight: { xs: "32px", sm: "40px", md: "50px" },
        maxWidth: "100%",
        overflow: "hidden"
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "h3",
          sx: {
            fontWeight: 800,
            color: color2,
            fontSize: { xs: "1.8rem", sm: "2.4rem", md: "3rem" },
            lineHeight: 1,
            letterSpacing: "-0.02em",
            textAlign: "left",
            textShadow: `0 2px 8px ${color2}20`,
            whiteSpace: "nowrap",
            overflow: "hidden",
            textOverflow: "ellipsis",
            maxWidth: "100%"
          },
          title: value?.toString(),
          children: value
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
        width: "100%",
        display: "flex",
        alignItems: "center",
        justifyContent: "flex-start",
        minHeight: { xs: "20px", sm: "24px", md: "28px" },
        maxWidth: "100%",
        overflow: "hidden"
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "body2",
          sx: {
            fontSize: { xs: "0.9rem", sm: "1rem", md: "1.1rem" },
            lineHeight: 1.3,
            color: "text.secondary",
            fontWeight: 500,
            textAlign: "left",
            letterSpacing: "0.01em",
            whiteSpace: "nowrap",
            overflow: "hidden",
            textOverflow: "ellipsis",
            maxWidth: "100%",
            opacity: 0.8
          },
          title: subtitle,
          children: subtitle
        }
      ) })
    ] })
  ] }) }) });
};
const TradingSection = ({
  buyAmount,
  setBuyAmount,
  sellAmount,
  setSellAmount,
  buyTokenAmount,
  setBuyTokenAmount,
  onBuy,
  onSell,
  onBuyToken,
  orderLoading
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
    mb: { xs: 2, sm: 3, md: 4 },
    display: "flex",
    flexDirection: "column",
    gap: { xs: 1.5, sm: 2 }
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
      p: { xs: 1.5, sm: 2 },
      border: "1px solid rgba(0, 0, 0, 0.05)",
      borderRadius: { xs: 2, sm: 3 },
      backgroundColor: "white",
      boxShadow: { xs: 1, sm: 2 }
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "subtitle1",
          sx: {
            mb: { xs: 1, sm: 1.5 },
            color: "primary.main",
            fontSize: { xs: "0.85rem", sm: "1rem" },
            fontWeight: "medium"
          },
          children: "Stake"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          fullWidth: true,
          label: "Stake Amount (USDT)",
          type: "number",
          value: buyAmount,
          onChange: (e2) => {
            const value = e2.target.value;
            if (value === "" || /^\d*\.?\d*$/.test(value) && parseFloat(value) >= 0) {
              setBuyAmount(value);
            }
          },
          size: window.innerWidth < 600 ? "small" : "medium",
          placeholder: "Enter amount to stake",
          sx: {
            "& .MuiInputBase-input": {
              fontSize: { xs: "0.8rem", sm: "0.875rem", md: "1rem" }
            },
            mb: { xs: 1, sm: 1.5 },
            "& .MuiOutlinedInput-root": {
              borderRadius: { xs: 1.5, sm: 2 }
            }
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          fullWidth: true,
          variant: "contained",
          onClick: onBuy,
          disabled: orderLoading,
          size: window.innerWidth < 600 ? "small" : "medium",
          sx: {
            fontSize: { xs: "0.8rem", sm: "0.875rem", md: "1rem" },
            py: { xs: 1, sm: 1.5 },
            borderRadius: { xs: 1.5, sm: 2 },
            fontWeight: "bold"
          },
          children: "Stake USDT"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
      p: { xs: 1.5, sm: 2 },
      border: "1px solid rgba(0, 0, 0, 0.05)",
      borderRadius: { xs: 2, sm: 3 },
      backgroundColor: "white",
      boxShadow: { xs: 1, sm: 2 }
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "subtitle1",
          sx: {
            mb: { xs: 1, sm: 1.5 },
            color: "success.main",
            fontSize: { xs: "0.85rem", sm: "1rem" },
            fontWeight: "medium"
          },
          children: "Buy Tokens"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          fullWidth: true,
          label: "Buy Token Amount (USDT)",
          type: "number",
          value: buyTokenAmount,
          onChange: (e2) => {
            const value = e2.target.value;
            if (value === "" || /^\d*\.?\d*$/.test(value) && parseFloat(value) >= 0) {
              setBuyTokenAmount(value);
            }
          },
          size: window.innerWidth < 600 ? "small" : "medium",
          placeholder: "Enter USDT amount to buy tokens",
          sx: {
            "& .MuiInputBase-input": {
              fontSize: { xs: "0.8rem", sm: "0.875rem", md: "1rem" }
            },
            mb: { xs: 1, sm: 1.5 },
            "& .MuiOutlinedInput-root": {
              borderRadius: { xs: 1.5, sm: 2 }
            }
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          fullWidth: true,
          variant: "contained",
          color: "success",
          onClick: onBuyToken,
          disabled: orderLoading,
          size: window.innerWidth < 600 ? "small" : "medium",
          sx: {
            fontSize: { xs: "0.8rem", sm: "0.875rem", md: "1rem" },
            py: { xs: 1, sm: 1.5 },
            borderRadius: { xs: 1.5, sm: 2 },
            fontWeight: "bold"
          },
          children: "Buy Tokens"
        }
      )
    ] })
  ] });
};
const ReferralSection = ({ account, onCopy, onShare }) => {
  const [copySuccess, setCopySuccess] = reactExports.useState("");
  const referralLink = account ? generateReferralLink(account) : "";
  const referralMessage = account ? generateReferralMessage(account) : "";
  const handleCopyCode = async () => {
    if (!account) return;
    try {
      await navigator.clipboard.writeText(account);
      setCopySuccess("Referral code copied!");
      setTimeout(() => setCopySuccess(""), 3e3);
      onCopy?.();
    } catch (err) {
      console.error("Failed to copy referral code:", err);
    }
  };
  const handleCopyLink = async () => {
    if (!referralLink) return;
    try {
      await navigator.clipboard.writeText(referralLink);
      setCopySuccess("Referral link copied!");
      setTimeout(() => setCopySuccess(""), 3e3);
    } catch (err) {
      console.error("Failed to copy referral link:", err);
    }
  };
  const handleShare = async () => {
    if (!account) return;
    try {
      if (navigator.share) {
        await navigator.share({
          title: "SafeMint Referral",
          text: referralMessage,
          url: referralLink
        });
      } else {
        await navigator.clipboard.writeText(referralMessage);
        setCopySuccess("Referral message copied!");
        setTimeout(() => setCopySuccess(""), 3e3);
      }
      onShare?.();
    } catch (err) {
      console.error("Failed to share:", err);
      try {
        await navigator.clipboard.writeText(referralMessage);
        setCopySuccess("Referral message copied!");
        setTimeout(() => setCopySuccess(""), 3e3);
      } catch (copyErr) {
        console.error("Failed to copy as fallback:", copyErr);
      }
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: { xs: 3, sm: 4 }, display: "flex", flexDirection: "column", gap: 2 }, children: [
    copySuccess && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "success", sx: { mb: 1 }, children: copySuccess }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { mb: 1, fontWeight: "medium" }, children: "Referral Code:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          fullWidth: true,
          value: account || "",
          InputProps: {
            readOnly: true,
            endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                size: "small",
                startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { size: 16 }),
                onClick: handleCopyCode,
                disabled: !account,
                sx: { ml: 1 },
                children: "Copy"
              }
            )
          },
          sx: { "& .MuiInputBase-input": { fontSize: { xs: "0.875rem", sm: "1rem" } } }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { mb: 1, fontWeight: "medium" }, children: "Referral Link:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField,
        {
          fullWidth: true,
          value: referralLink,
          InputProps: {
            readOnly: true,
            endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                size: "small",
                startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { size: 16 }),
                onClick: handleCopyLink,
                disabled: !account,
                sx: { ml: 1 },
                children: "Copy"
              }
            )
          },
          sx: { "& .MuiInputBase-input": { fontSize: { xs: "0.75rem", sm: "0.875rem" } } }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", gap: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        variant: "contained",
        startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Share, { size: 16 }),
        onClick: handleShare,
        disabled: !account,
        sx: { flex: 1, fontSize: { xs: "0.75rem", sm: "0.875rem" } },
        children: "Share Complete Message"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 2 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "body2",
          color: "text.secondary",
          sx: { fontSize: { xs: "0.75rem", sm: "0.875rem" }, mb: 1 },
          children: " How it works:"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { pl: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", sx: { fontSize: { xs: "0.7rem", sm: "0.8rem" } }, children: " Share your referral link or code with friends" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", sx: { fontSize: { xs: "0.7rem", sm: "0.8rem" } }, children: " When they register using your link, you become their referrer" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", sx: { fontSize: { xs: "0.7rem", sm: "0.8rem" } }, children: " Earn bonuses from their investments and activities" })
      ] })
    ] })
  ] });
};
const OrderHistoryTable = ({
  orderHistory,
  orderLoading,
  formatDate: formatDate2
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { flexGrow: 1, display: "flex", flexDirection: "column" }, children: orderLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", p: 3, flexGrow: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {}) }) : orderHistory.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    Typography,
    {
      variant: "body2",
      color: "text.secondary",
      sx: {
        p: 2,
        textAlign: "center",
        fontSize: { xs: "0.75rem", sm: "0.875rem" },
        flexGrow: 1
      },
      children: "No orders yet"
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer, { component: Paper, sx: { flexGrow: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { size: "small", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { sx: { fontSize: { xs: "0.75rem", sm: "0.875rem" } }, children: "Type" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { sx: { fontSize: { xs: "0.75rem", sm: "0.875rem" } }, children: "Amount" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { sx: { fontSize: { xs: "0.75rem", sm: "0.875rem" } }, children: "Growth" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { sx: { fontSize: { xs: "0.75rem", sm: "0.875rem" } }, children: "Date" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { sx: { fontSize: { xs: "0.75rem", sm: "0.875rem" } }, children: "Remaining Time" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: orderHistory.map((order2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "body2",
          color: order2.isStake ? "success.main" : "error.main",
          sx: { fontSize: { xs: "0.75rem", sm: "0.875rem" } },
          children: order2.isStake ? "STAKE" : "UNSTAKE"
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { fontSize: { xs: "0.75rem", sm: "0.875rem" } }, children: [
        "$",
        order2.amount?.toFixed(2) || "N/A"
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "success.main", sx: { fontSize: { xs: "0.75rem", sm: "0.875rem" } }, children: [
        order2.growthRate || 0,
        "%"
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { fontSize: { xs: "0.75rem", sm: "0.875rem" } }, children: order2.date || formatDate2(order2.timestamp) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "body2",
          sx: {
            fontSize: { xs: "0.75rem", sm: "0.875rem" },
            color: order2.remainingTime === "Completed" ? "success.main" : order2.remainingTime === "Matured" ? "warning.main" : "primary.main",
            fontWeight: "medium"
          },
          children: order2.remainingTime || "Active"
        }
      ) })
    ] }, `order-${index2}`)) })
  ] }) }) });
};
const RegistrationForm = ({
  referralCode,
  setReferralCode,
  onRegister,
  isLoading,
  error,
  success,
  setError,
  setSuccess,
  isFromReferralLink = false
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "sm", sx: { py: { xs: 2, sm: 3 } }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: { p: { xs: 2, sm: 3 }, boxShadow: 3 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Typography,
      {
        variant: "h5",
        gutterBottom: true,
        sx: {
          color: "primary.main",
          fontWeight: "bold",
          mb: { xs: 2, sm: 3 },
          fontSize: { xs: "1.25rem", sm: "1.5rem" }
        },
        children: "Register"
      }
    ),
    isFromReferralLink && referralCode && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 2 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: { mb: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", gap: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { size: 16 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "You were invited! Referral code auto-detected from link." })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Chip,
        {
          label: `Referrer: ${referralCode.slice(0, 6)}...${referralCode.slice(-4)}`,
          color: "primary",
          variant: "outlined",
          size: "small"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Typography,
      {
        variant: "body1",
        color: "text.secondary",
        sx: { mb: { xs: 2, sm: 3 }, fontSize: { xs: "0.875rem", sm: "1rem" } },
        children: isFromReferralLink && referralCode ? "Your referral code has been automatically filled. You can change it if needed." : "Enter a referral code to get started."
      }
    ),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, onClose: () => setError(""), children: error }),
    success && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "success", sx: { mb: 2 }, onClose: () => setSuccess(""), children: success }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextField,
      {
        fullWidth: true,
        label: "Referral Code",
        value: referralCode,
        onChange: (e2) => setReferralCode(e2.target.value),
        placeholder: "0x...",
        helperText: isFromReferralLink ? "Auto-filled from referral link" : "Enter the wallet address of your referrer",
        sx: { mb: 2, "& .MuiInputBase-input": { fontSize: { xs: "0.875rem", sm: "1rem" } } }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        fullWidth: true,
        variant: "contained",
        startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserPlus, { size: 18 }),
        onClick: onRegister,
        disabled: isLoading || !referralCode,
        sx: { fontSize: { xs: "0.875rem", sm: "1rem" } },
        children: isLoading ? "Registering..." : "Register"
      }
    ),
    !referralCode && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Typography,
      {
        variant: "body2",
        color: "text.secondary",
        sx: { mt: 2, textAlign: "center", fontSize: { xs: "0.75rem", sm: "0.875rem" } },
        children: " Need a referral code? Ask a friend or find one in the community!"
      }
    )
  ] }) });
};
const SAFEMINT_TOKEN_ADDRESS = "0xC0746bd0380190B899440bC33C647cE2426C8cCb";
const BSC_MAINNET_CHAIN_ID = 56;
const SAFEMINT_TOKEN_ABI = [
  {
    "inputs": [],
    "name": "rateInUSDT",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getReserves",
    "outputs": [
      { "internalType": "uint256", "name": "_reserve0", "type": "uint256" },
      { "internalType": "uint256", "name": "_reserve1", "type": "uint256" },
      { "internalType": "uint256", "name": "_blockTimestampLast", "type": "uint256" }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [{ "internalType": "address", "name": "account", "type": "address" }],
    "name": "balanceOf",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [{ "internalType": "string", "name": "", "type": "string" }],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "owner", "type": "address" },
      { "internalType": "address", "name": "spender", "type": "address" }
    ],
    "name": "allowance",
    "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      { "internalType": "address", "name": "spender", "type": "address" },
      { "internalType": "uint256", "name": "amount", "type": "uint256" }
    ],
    "name": "approve",
    "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
    "stateMutability": "nonpayable",
    "type": "function"
  }
];
const safeMintTokenService = {
  /**
   * Get SafeMint token rate in USDT
   * @returns Rate in wei (18 decimals)
   */
  async getRateInUSDT() {
    try {
      console.log(" [SafeMintTokenService] Fetching SafeMint token rate in USDT...");
      const rate = await readContract(config, {
        abi: SAFEMINT_TOKEN_ABI,
        address: SAFEMINT_TOKEN_ADDRESS,
        functionName: "rateInUSDT",
        chainId: BSC_MAINNET_CHAIN_ID
      });
      console.log(` [SafeMintTokenService] SafeMint rate in USDT: ${formatEther(rate)}`);
      return rate;
    } catch (error) {
      console.error(` [SafeMintTokenService] Error fetching SafeMint rate:`, error);
      throw new Error(
        `Failed to fetch SafeMint rate: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get SafeMint token reserves
   * @returns Reserves object with token supply, USDT balance, and timestamp
   */
  async getReserves() {
    try {
      console.log(" [SafeMintTokenService] Fetching SafeMint token reserves...");
      const [reserve0, reserve1, blockTimestampLast] = await readContract(config, {
        abi: SAFEMINT_TOKEN_ABI,
        address: SAFEMINT_TOKEN_ADDRESS,
        functionName: "getReserves",
        chainId: BSC_MAINNET_CHAIN_ID
      });
      const reserves = {
        tokenSupply: reserve0,
        usdtBalance: reserve1,
        blockTimestampLast
      };
      console.log(` [SafeMintTokenService] SafeMint Reserves:`, {
        tokenSupply: formatEther(reserve0),
        usdtBalance: formatEther(reserve1),
        blockTimestampLast: blockTimestampLast.toString()
      });
      return reserves;
    } catch (error) {
      console.error(` [SafeMintTokenService] Error fetching SafeMint reserves:`, error);
      throw new Error(
        `Failed to fetch SafeMint reserves: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get SafeMint token balance for an address
   * @param account - Wallet address
   * @returns Token balance in wei
   */
  async getBalance(account) {
    try {
      console.log(` [SafeMintTokenService] Fetching SafeMint balance for ${account}...`);
      const balance = await readContract(config, {
        abi: SAFEMINT_TOKEN_ABI,
        address: SAFEMINT_TOKEN_ADDRESS,
        functionName: "balanceOf",
        args: [account],
        chainId: BSC_MAINNET_CHAIN_ID
      });
      console.log(` [SafeMintTokenService] SafeMint balance for ${account}: ${formatEther(balance)} SELFMINT`);
      return balance;
    } catch (error) {
      console.error(` [SafeMintTokenService] Error fetching SafeMint balance:`, error);
      throw new Error(
        `Failed to fetch SafeMint balance: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get SafeMint token allowance for a spender
   * @param owner - Token owner address
   * @param spender - Spender address (usually the staking contract)
   * @returns Allowance amount in wei
   */
  async getAllowance(owner, spender) {
    try {
      console.log(` [SafeMintTokenService] Fetching allowance for ${owner}  ${spender}...`);
      const allowance = await readContract(config, {
        abi: SAFEMINT_TOKEN_ABI,
        address: SAFEMINT_TOKEN_ADDRESS,
        functionName: "allowance",
        args: [owner, spender],
        chainId: BSC_MAINNET_CHAIN_ID
      });
      console.log(` [SafeMintTokenService] Allowance: ${formatEther(allowance)} SMT`);
      return allowance;
    } catch (error) {
      console.error(` [SafeMintTokenService] Error fetching allowance:`, error);
      throw new Error(
        `Failed to fetch allowance: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Approve SafeMint token spending for a spender
   * @param spender - Spender address (usually the staking contract)
   * @param amount - Amount to approve (in wei)
   * @param account - Wallet address to send the transaction from
   * @returns Transaction hash
   */
  async approve(spender, amount, account) {
    try {
      console.log(` [SafeMintTokenService] Approving ${formatEther(amount)} SMT for ${spender}...`);
      const txHash = await writeContract(config, {
        abi: SAFEMINT_TOKEN_ABI,
        address: SAFEMINT_TOKEN_ADDRESS,
        functionName: "approve",
        args: [spender, amount],
        chain: bsc,
        account
      });
      console.log(` [SafeMintTokenService] Approval transaction successful: ${txHash}`);
      return txHash;
    } catch (error) {
      console.error(` [SafeMintTokenService] Error approving tokens:`, error);
      throw new Error(
        `Failed to approve SafeMint tokens: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get SafeMint token total supply
   * @returns Total supply in wei
   */
  async getTotalSupply() {
    try {
      console.log(" [SafeMintTokenService] Fetching SafeMint total supply...");
      const totalSupply = await readContract(config, {
        abi: SAFEMINT_TOKEN_ABI,
        address: SAFEMINT_TOKEN_ADDRESS,
        functionName: "totalSupply",
        chainId: BSC_MAINNET_CHAIN_ID
      });
      console.log(` [SafeMintTokenService] SafeMint total supply: ${formatEther(totalSupply)} SELFMINT`);
      return totalSupply;
    } catch (error) {
      console.error(` [SafeMintTokenService] Error fetching SafeMint total supply:`, error);
      throw new Error(
        `Failed to fetch SafeMint total supply: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Get complete SafeMint token information
   * @returns Complete token info object
   */
  async getTokenInfo() {
    try {
      console.log(" [SafeMintTokenService] Fetching complete SafeMint token info...");
      const [name, symbol, decimals, totalSupply, rateInUSDT, reserves] = await Promise.all([
        readContract(config, {
          abi: SAFEMINT_TOKEN_ABI,
          address: SAFEMINT_TOKEN_ADDRESS,
          functionName: "name",
          chainId: BSC_MAINNET_CHAIN_ID
        }),
        readContract(config, {
          abi: SAFEMINT_TOKEN_ABI,
          address: SAFEMINT_TOKEN_ADDRESS,
          functionName: "symbol",
          chainId: BSC_MAINNET_CHAIN_ID
        }),
        readContract(config, {
          abi: SAFEMINT_TOKEN_ABI,
          address: SAFEMINT_TOKEN_ADDRESS,
          functionName: "decimals",
          chainId: BSC_MAINNET_CHAIN_ID
        }),
        this.getTotalSupply(),
        this.getRateInUSDT(),
        this.getReserves()
      ]);
      const tokenInfo = {
        name,
        symbol,
        decimals,
        totalSupply,
        rateInUSDT,
        reserves
      };
      console.log(" [SafeMintTokenService] Complete token info fetched:", {
        name,
        symbol,
        decimals,
        totalSupply: formatEther(totalSupply),
        rateInUSDT: formatEther(rateInUSDT),
        reserves: {
          tokenSupply: formatEther(reserves.tokenSupply),
          usdtBalance: formatEther(reserves.usdtBalance),
          blockTimestampLast: reserves.blockTimestampLast.toString()
        }
      });
      return tokenInfo;
    } catch (error) {
      console.error(` [SafeMintTokenService] Error fetching complete token info:`, error);
      throw new Error(
        `Failed to fetch complete token info: ${error.message || "Unknown error"}`
      );
    }
  },
  /**
   * Format token rate for display
   * @param rate - Rate in wei
   * @returns Formatted rate string
   */
  formatRate(rate) {
    const rateNumber = parseFloat(formatEther(rate));
    return rateNumber.toFixed(6);
  },
  /**
   * Format token balance for display
   * @param balance - Balance in wei
   * @returns Formatted balance string
   */
  formatBalance(balance) {
    const balanceNumber = parseFloat(formatEther(balance));
    return balanceNumber.toLocaleString(void 0, {
      minimumFractionDigits: 2,
      maximumFractionDigits: 6
    });
  }
};
const TokenPriceCard = ({
  autoRefresh = true,
  refreshInterval = 3e4
  // 30 seconds
}) => {
  const [tokenInfo, setTokenInfo] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState(null);
  const [lastUpdated, setLastUpdated] = reactExports.useState(null);
  const [previousRate, setPreviousRate] = reactExports.useState(null);
  const fetchTokenInfo = async () => {
    try {
      setError(null);
      console.log(" [TokenPriceCard] Fetching token info...");
      const info = await safeMintTokenService.getTokenInfo();
      if (tokenInfo?.rateInUSDT) {
        setPreviousRate(tokenInfo.rateInUSDT);
      }
      setTokenInfo(info);
      setLastUpdated(/* @__PURE__ */ new Date());
      console.log(" [TokenPriceCard] Token info updated successfully");
    } catch (err) {
      console.error(" [TokenPriceCard] Error fetching token info:", err);
      setError(err.message || "Failed to fetch token information");
    } finally {
      setLoading(false);
    }
  };
  const handleRefresh = () => {
    setLoading(true);
    fetchTokenInfo();
  };
  reactExports.useEffect(() => {
    fetchTokenInfo();
  }, []);
  reactExports.useEffect(() => {
    if (!autoRefresh) return;
    const interval = setInterval(() => {
      fetchTokenInfo();
    }, refreshInterval);
    return () => clearInterval(interval);
  }, [autoRefresh, refreshInterval]);
  const getRateTrend = () => {
    if (!tokenInfo || !previousRate) return null;
    const current = tokenInfo.rateInUSDT;
    const previous = previousRate;
    if (current > previous) return "up";
    if (current < previous) return "down";
    return "stable";
  };
  const getTrendIcon = () => {
    const trend = getRateTrend();
    if (trend === "up") return /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 16, style: { color: "#4caf50" } });
    if (trend === "down") return /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingDown, { size: 16, style: { color: "#f44336" } });
    return null;
  };
  const getTrendColor = () => {
    const trend = getRateTrend();
    if (trend === "up") return "success.main";
    if (trend === "down") return "error.main";
    return "text.primary";
  };
  if (loading && !tokenInfo) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { p: { xs: 1.5, sm: 2 }, boxShadow: 2, height: "100%", backgroundColor: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "center", minHeight: 120 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 40 }) }) }) });
  }
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { p: { xs: 1.5, sm: 2 }, boxShadow: 2, height: "100%", backgroundColor: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: handleRefresh, disabled: loading, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 20 }) }) })
    ] }) });
  }
  if (!tokenInfo) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { p: { xs: 1.5, sm: 2 }, boxShadow: 2, height: "100%", backgroundColor: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", align: "center", children: "No token data available" }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
    p: { xs: 1, sm: 1.5, md: 2 },
    boxShadow: { xs: 1, sm: 2 },
    height: "auto",
    minHeight: { xs: "160px", sm: "180px", md: "200px" },
    backgroundColor: "white",
    borderRadius: { xs: 2, sm: 3 },
    transition: "all 0.3s ease",
    "&:hover": {
      boxShadow: { xs: 2, sm: 4 },
      transform: "translateY(-2px)"
    }
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: {
    p: { xs: 1, sm: 1.5, md: 2 },
    "&:last-child": { pb: { xs: 1, sm: 1.5, md: 2 } },
    display: "flex",
    flexDirection: "column",
    height: "100%"
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      mb: { xs: 1, sm: 1.5 }
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", gap: { xs: 0.5, sm: 1 } }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Coins,
          {
            size: 24,
            style: {
              color: "#1976d2"
            }
          }
        ),
        getTrendIcon()
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          size: "small",
          onClick: handleRefresh,
          disabled: loading,
          sx: {
            p: { xs: 0.3, sm: 0.5 },
            minWidth: "auto",
            "& .MuiSvgIcon-root": {
              fontSize: { xs: "0.9rem", sm: "1rem" }
            }
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 16 })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { textAlign: "center", mb: { xs: 1, sm: 1.5 } }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Typography,
        {
          variant: "h4",
          sx: {
            fontWeight: "bold",
            color: getTrendColor(),
            fontSize: { xs: "1.3rem", sm: "1.5rem", md: "1.8rem" },
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            gap: 0.5,
            lineHeight: 1.2,
            mb: 0.5
          },
          children: [
            "$",
            safeMintTokenService.formatRate(tokenInfo.rateInUSDT),
            loading && /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 16 })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "body2",
          color: "text.secondary",
          sx: {
            fontSize: { xs: "0.7rem", sm: "0.75rem", md: "0.85rem" }
          },
          children: "SELFMINT Price"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { textAlign: "center", mb: { xs: 1, sm: 1.5 } }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Typography,
      {
        variant: "h6",
        sx: {
          fontSize: { xs: "0.85rem", sm: "0.95rem", md: "1.1rem" },
          fontWeight: "bold",
          color: "text.primary",
          lineHeight: 1.2
        },
        children: "SELFMINT TOKEN"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
      display: "flex",
      flexDirection: "column",
      gap: { xs: 0.8, sm: 1 },
      mb: { xs: 1, sm: 1.5 }
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        flexWrap: "wrap",
        gap: 0.5
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography,
          {
            variant: "body2",
            color: "text.secondary",
            sx: { fontSize: { xs: "0.7rem", sm: "0.75rem" } },
            children: "Total Supply:"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography,
          {
            variant: "body2",
            sx: {
              fontSize: { xs: "0.7rem", sm: "0.75rem" },
              fontWeight: "medium",
              textAlign: "right"
            },
            children: safeMintTokenService.formatBalance(tokenInfo.totalSupply)
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        flexWrap: "wrap",
        gap: 0.5
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography,
          {
            variant: "body2",
            color: "text.secondary",
            sx: { fontSize: { xs: "0.7rem", sm: "0.75rem" } },
            children: "USDT Pool:"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Typography,
          {
            variant: "body2",
            sx: {
              fontSize: { xs: "0.7rem", sm: "0.75rem" },
              fontWeight: "medium",
              textAlign: "right"
            },
            children: [
              "$",
              safeMintTokenService.formatBalance(tokenInfo.reserves.usdtBalance)
            ]
          }
        )
      ] })
    ] })
  ] }) });
};
const SafeMintTokenStats = ({
  autoRefresh = true,
  refreshInterval = 3e4
  // 30 seconds
}) => {
  const [tokenInfo, setTokenInfo] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [error, setError] = reactExports.useState(null);
  const [lastUpdated, setLastUpdated] = reactExports.useState(null);
  const fetchTokenInfo = async () => {
    try {
      setError(null);
      console.log(" [SafeMintTokenStats] Fetching token info...");
      const info = await safeMintTokenService.getTokenInfo();
      setTokenInfo(info);
      setLastUpdated(/* @__PURE__ */ new Date());
      console.log(" [SafeMintTokenStats] Token info updated successfully");
    } catch (err) {
      console.error(" [SafeMintTokenStats] Error fetching token info:", err);
      setError(err.message || "Failed to fetch token information");
    } finally {
      setLoading(false);
    }
  };
  const handleRefresh = () => {
    setLoading(true);
    fetchTokenInfo();
  };
  reactExports.useEffect(() => {
    fetchTokenInfo();
  }, []);
  reactExports.useEffect(() => {
    if (!autoRefresh) return;
    const interval = setInterval(() => {
      fetchTokenInfo();
    }, refreshInterval);
    return () => clearInterval(interval);
  }, [autoRefresh, refreshInterval]);
  const calculateMarketCap = () => {
    if (!tokenInfo) return "0";
    const marketCap = tokenInfo.totalSupply * tokenInfo.rateInUSDT / BigInt(10 ** 18);
    return safeMintTokenService.formatBalance(marketCap);
  };
  if (loading && !tokenInfo) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { p: { xs: 1.5, sm: 2 }, boxShadow: 2, height: "100%", backgroundColor: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "center", minHeight: 200 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 40 }) }) }) });
  }
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { p: { xs: 1.5, sm: 2 }, boxShadow: 2, height: "100%", backgroundColor: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { onClick: handleRefresh, disabled: loading, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 20 }) }) })
    ] }) });
  }
  if (!tokenInfo) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { p: { xs: 1.5, sm: 2 }, boxShadow: 2, height: "100%", backgroundColor: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", align: "center", children: "No token data available" }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
    display: "grid",
    gridTemplateColumns: {
      xs: "1fr",
      sm: "repeat(2, 1fr)",
      md: "repeat(4, 1fr)"
    },
    gap: { xs: 2, sm: 2, md: 3 },
    width: "100%",
    p: { xs: 1, sm: 2 }
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
      p: { xs: 1.5, sm: 2 },
      boxShadow: { xs: 2, sm: 3 },
      height: "100%",
      backgroundColor: "white",
      borderRadius: { xs: 2, sm: 3 },
      border: "2px solid rgba(255, 160, 0, 0.2)",
      background: "linear-gradient(135deg, rgba(255, 160, 0, 0.05) 0%, rgba(255, 143, 0, 0.05) 100%)",
      transition: "all 0.3s ease",
      "&:hover": {
        boxShadow: { xs: 3, sm: 6 },
        transform: "translateY(-4px)",
        border: "2px solid rgba(255, 160, 0, 0.4)"
      }
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: {
      p: { xs: 1, sm: 1.5 },
      "&:last-child": { pb: { xs: 1, sm: 1.5 } },
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center",
      height: "100%",
      justifyContent: "center"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Building2,
        {
          size: 48,
          style: {
            color: "#FFA000",
            marginBottom: 8,
            filter: "drop-shadow(0 2px 4px rgba(255, 160, 0, 0.3))"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Typography,
        {
          variant: "h4",
          sx: {
            fontWeight: 800,
            color: "#FFA000",
            fontSize: { xs: "1.2rem", sm: "1.4rem", md: "1.6rem" },
            mb: 0.5,
            textShadow: "0 2px 4px rgba(0,0,0,0.1)"
          },
          children: [
            "$",
            safeMintTokenService.formatBalance(tokenInfo.reserves.usdtBalance)
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "h6",
          sx: {
            fontWeight: 700,
            color: "text.primary",
            fontSize: { xs: "0.9rem", sm: "1rem", md: "1.1rem" },
            letterSpacing: "0.5px"
          },
          children: "USDT Pool"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "body2",
          color: "text.secondary",
          sx: {
            fontSize: { xs: "0.7rem", sm: "0.8rem" },
            mt: 0.5,
            fontWeight: 500
          },
          children: "Liquidity Reserve"
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
      p: { xs: 1.5, sm: 2 },
      boxShadow: { xs: 2, sm: 3 },
      height: "100%",
      backgroundColor: "white",
      borderRadius: { xs: 2, sm: 3 },
      border: "2px solid rgba(255, 160, 0, 0.2)",
      background: "linear-gradient(135deg, rgba(255, 160, 0, 0.05) 0%, rgba(255, 143, 0, 0.05) 100%)",
      transition: "all 0.3s ease",
      "&:hover": {
        boxShadow: { xs: 3, sm: 6 },
        transform: "translateY(-4px)",
        border: "2px solid rgba(255, 160, 0, 0.4)"
      }
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: {
      p: { xs: 1, sm: 1.5 },
      "&:last-child": { pb: { xs: 1, sm: 1.5 } },
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center",
      height: "100%",
      justifyContent: "center"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Coins,
        {
          size: 48,
          style: {
            color: "#FFA000",
            marginBottom: 8,
            filter: "drop-shadow(0 2px 4px rgba(255, 160, 0, 0.3))"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "h4",
          sx: {
            fontWeight: 800,
            color: "#FFA000",
            fontSize: { xs: "1.2rem", sm: "1.4rem", md: "1.6rem" },
            mb: 0.5,
            textShadow: "0 2px 4px rgba(0,0,0,0.1)"
          },
          children: safeMintTokenService.formatBalance(tokenInfo.totalSupply)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "h6",
          sx: {
            fontWeight: 700,
            color: "text.primary",
            fontSize: { xs: "0.9rem", sm: "1rem", md: "1.1rem" },
            letterSpacing: "0.5px"
          },
          children: "Total Supply"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "body2",
          color: "text.secondary",
          sx: {
            fontSize: { xs: "0.7rem", sm: "0.8rem" },
            mt: 0.5,
            fontWeight: 500
          },
          children: "Circulating Tokens"
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
      p: { xs: 1.5, sm: 2 },
      boxShadow: { xs: 2, sm: 3 },
      height: "100%",
      backgroundColor: "white",
      borderRadius: { xs: 2, sm: 3 },
      border: "2px solid rgba(255, 160, 0, 0.2)",
      background: "linear-gradient(135deg, rgba(255, 160, 0, 0.05) 0%, rgba(255, 143, 0, 0.05) 100%)",
      transition: "all 0.3s ease",
      "&:hover": {
        boxShadow: { xs: 3, sm: 6 },
        transform: "translateY(-4px)",
        border: "2px solid rgba(255, 160, 0, 0.4)"
      }
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: {
      p: { xs: 1, sm: 1.5 },
      "&:last-child": { pb: { xs: 1, sm: 1.5 } },
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center",
      height: "100%",
      justifyContent: "center"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TrendingUp,
        {
          size: 48,
          style: {
            color: "#FFA000",
            marginBottom: 8,
            filter: "drop-shadow(0 2px 4px rgba(255, 160, 0, 0.3))"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Typography,
        {
          variant: "h4",
          sx: {
            fontWeight: 800,
            color: "#FFA000",
            fontSize: { xs: "1.2rem", sm: "1.4rem", md: "1.6rem" },
            mb: 0.5,
            textShadow: "0 2px 4px rgba(0,0,0,0.1)"
          },
          children: [
            "$",
            calculateMarketCap()
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "h6",
          sx: {
            fontWeight: 700,
            color: "text.primary",
            fontSize: { xs: "0.9rem", sm: "1rem", md: "1.1rem" },
            letterSpacing: "0.5px"
          },
          children: "Market Cap"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "body2",
          color: "text.secondary",
          sx: {
            fontSize: { xs: "0.7rem", sm: "0.8rem" },
            mt: 0.5,
            fontWeight: 500
          },
          children: "Total Market Value"
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
      p: { xs: 1.5, sm: 2 },
      boxShadow: { xs: 2, sm: 3 },
      height: "100%",
      backgroundColor: "white",
      borderRadius: { xs: 2, sm: 3 },
      border: "2px solid rgba(255, 160, 0, 0.2)",
      background: "linear-gradient(135deg, rgba(255, 160, 0, 0.05) 0%, rgba(255, 143, 0, 0.05) 100%)",
      transition: "all 0.3s ease",
      "&:hover": {
        boxShadow: { xs: 3, sm: 6 },
        transform: "translateY(-4px)",
        border: "2px solid rgba(255, 160, 0, 0.4)"
      }
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: {
      p: { xs: 1, sm: 1.5 },
      "&:last-child": { pb: { xs: 1, sm: 1.5 } },
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center",
      height: "100%",
      justifyContent: "center"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TrendingUp,
        {
          size: 48,
          style: {
            color: "#FFA000",
            marginBottom: 8,
            filter: "drop-shadow(0 2px 4px rgba(255, 160, 0, 0.3))",
            transform: "rotate(45deg)"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Typography,
        {
          variant: "h4",
          sx: {
            fontWeight: 800,
            color: "#FFA000",
            fontSize: { xs: "1.2rem", sm: "1.4rem", md: "1.6rem" },
            mb: 0.5,
            textShadow: "0 2px 4px rgba(0,0,0,0.1)"
          },
          children: [
            "$",
            safeMintTokenService.formatBalance(tokenInfo.rateInUSDT)
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "h6",
          sx: {
            fontWeight: 700,
            color: "text.primary",
            fontSize: { xs: "0.9rem", sm: "1rem", md: "1.1rem" },
            letterSpacing: "0.5px"
          },
          children: "Token Price"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "body2",
          color: "text.secondary",
          sx: {
            fontSize: { xs: "0.7rem", sm: "0.8rem" },
            mt: 0.5,
            fontWeight: 500
          },
          children: "Current Rate"
        }
      )
    ] }) })
  ] });
};
const formatNumber = (value, maxDecimals = 2) => {
  const num = typeof value === "string" ? parseFloat(value) : value;
  if (isNaN(num)) {
    return "0";
  }
  return new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: maxDecimals
  }).format(num);
};
const formatCurrency = (value, maxDecimals = 2) => {
  const num = typeof value === "string" ? parseFloat(value) : value;
  if (isNaN(num)) {
    return "$0.00";
  }
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 0,
    maximumFractionDigits: maxDecimals
  }).format(num);
};
const formatTimeAgo = (timestamp) => {
  const now = Date.now();
  const diff = now - timestamp * 1e3;
  const seconds = Math.floor(diff / 1e3);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  if (days > 0) {
    return `${days} day${days > 1 ? "s" : ""} ago`;
  } else if (hours > 0) {
    return `${hours} hour${hours > 1 ? "s" : ""} ago`;
  } else if (minutes > 0) {
    return `${minutes} minute${minutes > 1 ? "s" : ""} ago`;
  } else {
    return "Just now";
  }
};
const formatDate = (timestamp) => {
  const date = new Date(timestamp * 1e3);
  return date.toLocaleDateString("en-US", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit"
  });
};
const CustomSVGIcons = {
  Users: ({ size: size2 = 24, color: color2 = "currentColor", animated = true }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: size2, height: size2, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "usersGradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#4F46E5" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#7C3AED" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", { id: "glow", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("feGaussianBlur", { stdDeviation: "2", result: "coloredBlur" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("feMerge", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("feMergeNode", { in: "coloredBlur" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feMergeNode", { in: "SourceGraphic" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "9", cy: "7", r: "4", fill: "url(#usersGradient)", opacity: "0.8", filter: "url(#glow)", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.6;1;0.6", dur: "2s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 21v-2a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v2", stroke: "url(#usersGradient)", strokeWidth: "2", fill: "none" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "16", cy: "6", r: "3", fill: "url(#usersGradient)", opacity: "0.6", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.4;0.8;0.4", dur: "2.5s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", stroke: "url(#usersGradient)", strokeWidth: "2", fill: "none" })
  ] }),
  Star: ({ size: size2 = 24, color: color2 = "currentColor", animated = true }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: size2, height: size2, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "starGradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#F59E0B" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "50%", stopColor: "#FCD34D" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#EF4444" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", { id: "starGlow", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("feGaussianBlur", { stdDeviation: "1.5", result: "coloredBlur" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("feMerge", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("feMergeNode", { in: "coloredBlur" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("feMergeNode", { in: "SourceGraphic" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z",
        fill: "url(#starGradient)",
        stroke: "url(#starGradient)",
        strokeWidth: "1",
        filter: "url(#starGlow)",
        children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animateTransform", { attributeName: "transform", type: "rotate", values: "0 12 12;360 12 12", dur: "8s", repeatCount: "indefinite" })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "2", fill: "white", opacity: "0.9", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.5;1;0.5", dur: "1.5s", repeatCount: "indefinite" }) })
  ] }),
  BarChart3: ({ size: size2 = 24, color: color2 = "currentColor", animated = true }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: size2, height: size2, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "chartGradient", x1: "0%", y1: "100%", x2: "0%", y2: "0%", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#10B981" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "50%", stopColor: "#34D399" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#6EE7B7" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("rect", { x: "3", y: "12", width: "4", height: "9", rx: "2", fill: "url(#chartGradient)", opacity: "0.8", children: [
      animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "height", values: "5;9;5", dur: "2s", repeatCount: "indefinite" }),
      animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "y", values: "16;12;16", dur: "2s", repeatCount: "indefinite" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("rect", { x: "10", y: "8", width: "4", height: "13", rx: "2", fill: "url(#chartGradient)", children: [
      animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "height", values: "9;13;9", dur: "2.5s", repeatCount: "indefinite" }),
      animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "y", values: "12;8;12", dur: "2.5s", repeatCount: "indefinite" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("rect", { x: "17", y: "4", width: "4", height: "17", rx: "2", fill: "url(#chartGradient)", opacity: "0.9", children: [
      animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "height", values: "13;17;13", dur: "3s", repeatCount: "indefinite" }),
      animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "y", values: "8;4;8", dur: "3s", repeatCount: "indefinite" })
    ] })
  ] }),
  CheckCircle: ({ size: size2 = 24, color: color2 = "currentColor", animated = true }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: size2, height: size2, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "checkGradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#10B981" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#065F46" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10", fill: "url(#checkGradient)", opacity: "0.9", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "r", values: "8;10;8", dur: "2s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 12l2 2 4-4", stroke: "white", strokeWidth: "2", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "stroke-dasharray", values: "0 10;10 0;0 10", dur: "3s", repeatCount: "indefinite" }) })
  ] }),
  TrendingUp: ({ size: size2 = 24, color: color2 = "currentColor", animated = true }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: size2, height: size2, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "trendGradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#10B981" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "50%", stopColor: "#34D399" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#6EE7B7" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 17l6-6 4 4 8-8", stroke: "url(#trendGradient)", strokeWidth: "3", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "stroke-dasharray", values: "0 30;30 0;0 30", dur: "4s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 7v6h-6", stroke: "url(#trendGradient)", strokeWidth: "2", fill: "none", strokeLinecap: "round", strokeLinejoin: "round" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "9", cy: "11", r: "2", fill: "url(#trendGradient)", opacity: "0.7", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "r", values: "1;3;1", dur: "2s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "13", cy: "15", r: "2", fill: "url(#trendGradient)", opacity: "0.7", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "r", values: "1;3;1", dur: "2.5s", repeatCount: "indefinite" }) })
  ] }),
  DollarSign: ({ size: size2 = 24, color: color2 = "currentColor", animated = true }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: size2, height: size2, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "dollarGradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#059669" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "50%", stopColor: "#10B981" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#34D399" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10", fill: "url(#dollarGradient)", opacity: "0.1", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.05;0.15;0.05", dur: "3s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M12 1v22M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6",
        stroke: "url(#dollarGradient)",
        strokeWidth: "2.5",
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "stroke-width", values: "2;3;2", dur: "2s", repeatCount: "indefinite" })
      }
    )
  ] }),
  Wallet: ({ size: size2 = 24, color: color2 = "currentColor", animated = true }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: size2, height: size2, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "walletGradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#3B82F6" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "50%", stopColor: "#60A5FA" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#1D4ED8" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "6", width: "20", height: "12", rx: "3", fill: "url(#walletGradient)", opacity: "0.9", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.7;1;0.7", dur: "3s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "4", width: "20", height: "2", rx: "1", fill: "url(#walletGradient)", opacity: "0.7" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "18", cy: "12", r: "2", fill: "white", opacity: "0.9", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.6;1;0.6", dur: "2s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "4", y: "9", width: "8", height: "1.5", rx: "0.75", fill: "white", opacity: "0.6" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "4", y: "11.5", width: "6", height: "1", rx: "0.5", fill: "white", opacity: "0.4" })
  ] }),
  Trophy: ({ size: size2 = 24, color: color2 = "currentColor", animated = true }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: size2, height: size2, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "trophyGradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#F59E0B" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "50%", stopColor: "#FCD34D" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#D97706" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
      animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animateTransform", { attributeName: "transform", type: "rotate", values: "0 12 12;5 12 12;0 12 12;-5 12 12;0 12 12", dur: "4s", repeatCount: "indefinite" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M6 9H4.5a2.5 2.5 0 0 1 0-5H6M18 9h1.5a2.5 2.5 0 0 0 0-5H18",
          stroke: "url(#trophyGradient)",
          strokeWidth: "2",
          fill: "none"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6 9a6 6 0 0 0 12 0", fill: "url(#trophyGradient)", opacity: "0.8" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "8", y: "15", width: "8", height: "6", rx: "1", fill: "url(#trophyGradient)", opacity: "0.6" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "10", y: "18", width: "4", height: "1", rx: "0.5", fill: "white", opacity: "0.8" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "11", r: "1.5", fill: "white", opacity: "0.9", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.6;1;0.6", dur: "1.5s", repeatCount: "indefinite" }) })
    ] })
  ] }),
  Building2: ({ size: size2 = 24, color: color2 = "currentColor", animated = true }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: size2, height: size2, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "buildingGradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#6366F1" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "50%", stopColor: "#8B5CF6" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#4F46E5" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "4", width: "8", height: "17", rx: "1", fill: "url(#buildingGradient)", opacity: "0.8", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.6;0.9;0.6", dur: "3s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "13", y: "8", width: "8", height: "13", rx: "1", fill: "url(#buildingGradient)", opacity: "0.9", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.7;1;0.7", dur: "3.5s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "5", y: "7", width: "2", height: "2", rx: "0.5", fill: "white", opacity: "0.7", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.4;0.8;0.4", dur: "2s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "8", y: "7", width: "2", height: "2", rx: "0.5", fill: "white", opacity: "0.7", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.4;0.8;0.4", dur: "2.2s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "5", y: "11", width: "2", height: "2", rx: "0.5", fill: "white", opacity: "0.7", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.4;0.8;0.4", dur: "2.4s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "8", y: "11", width: "2", height: "2", rx: "0.5", fill: "white", opacity: "0.7", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.4;0.8;0.4", dur: "2.6s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "15", y: "11", width: "2", height: "2", rx: "0.5", fill: "white", opacity: "0.7", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.4;0.8;0.4", dur: "2.8s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "18", y: "11", width: "2", height: "2", rx: "0.5", fill: "white", opacity: "0.7", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.4;0.8;0.4", dur: "3s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "15", y: "15", width: "2", height: "2", rx: "0.5", fill: "white", opacity: "0.7", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.4;0.8;0.4", dur: "3.2s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "18", y: "15", width: "2", height: "2", rx: "0.5", fill: "white", opacity: "0.7", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.4;0.8;0.4", dur: "3.4s", repeatCount: "indefinite" }) })
  ] }),
  Users2: ({ size: size2 = 24, color: color2 = "currentColor", animated = true }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: size2, height: size2, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "users2Gradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#8B5CF6" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "50%", stopColor: "#A78BFA" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#7C3AED" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "7", cy: "6", r: "3", fill: "url(#users2Gradient)", opacity: "0.8", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.6;1;0.6", dur: "2s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "17", cy: "6", r: "3", fill: "url(#users2Gradient)", opacity: "0.8", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.6;1;0.6", dur: "2.5s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "10", r: "3", fill: "url(#users2Gradient)", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.8;1;0.8", dur: "3s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2 20v-2a4 4 0 0 1 4-4h2", stroke: "url(#users2Gradient)", strokeWidth: "2", fill: "none" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16 16h2a4 4 0 0 1 4 4v2", stroke: "url(#users2Gradient)", strokeWidth: "2", fill: "none" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 20v-2a4 4 0 0 1 4-4h0a4 4 0 0 1 4 4v2", stroke: "url(#users2Gradient)", strokeWidth: "2", fill: "none" })
  ] }),
  Fuel: ({ size: size2 = 24, color: color2 = "currentColor", animated = true }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: size2, height: size2, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "fuelGradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#10B981" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "50%", stopColor: "#34D399" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#059669" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3", y: "6", width: "12", height: "14", rx: "2", fill: "url(#fuelGradient)", opacity: "0.8", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.6;0.9;0.6", dur: "2s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15 11l4-4v10l-4-4", fill: "url(#fuelGradient)", opacity: "0.9", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animateTransform", { attributeName: "transform", type: "translate", values: "0 0;2 0;0 0", dur: "1.5s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "6", y: "9", width: "6", height: "2", rx: "1", fill: "white", opacity: "0.8", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.6;1;0.6", dur: "1s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "6", y: "12", width: "6", height: "2", rx: "1", fill: "white", opacity: "0.6", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.4;0.8;0.4", dur: "1.2s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "6", y: "15", width: "4", height: "2", rx: "1", fill: "white", opacity: "0.4", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.2;0.6;0.2", dur: "1.4s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "17", cy: "13", r: "1.5", fill: "url(#fuelGradient)", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "r", values: "1;2;1", dur: "2s", repeatCount: "indefinite" }) })
  ] }),
  Battery: ({ size: size2 = 24, color: color2 = "currentColor", animated = true }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: size2, height: size2, viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: "batteryGradient", x1: "0%", y1: "0%", x2: "100%", y2: "100%", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: "#10B981" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "50%", stopColor: "#34D399" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: "#6EE7B7" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "8", width: "16", height: "8", rx: "2", fill: "none", stroke: "url(#batteryGradient)", strokeWidth: "2" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "4", y: "10", width: "3", height: "4", rx: "1", fill: "url(#batteryGradient)", opacity: "0.9", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.7;1;0.7", dur: "1s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "8", y: "10", width: "3", height: "4", rx: "1", fill: "url(#batteryGradient)", opacity: "0.7", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.5;0.9;0.5", dur: "1.2s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "12", y: "10", width: "3", height: "4", rx: "1", fill: "url(#batteryGradient)", opacity: "0.5", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.3;0.7;0.3", dur: "1.4s", repeatCount: "indefinite" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "20", y: "10", width: "2", height: "4", rx: "1", fill: "url(#batteryGradient)", opacity: "0.8" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6 6l2 2M10 6l2 2M14 6l2 2", stroke: "url(#batteryGradient)", strokeWidth: "2", strokeLinecap: "round", children: animated && /* @__PURE__ */ jsxRuntimeExports.jsx("animate", { attributeName: "opacity", values: "0.5;1;0.5", dur: "2s", repeatCount: "indefinite" }) })
  ] })
};
const safeStringify = (obj, space = 2) => {
  return JSON.stringify(obj, (key2, value) => {
    if (typeof value === "bigint") {
      return value.toString() + "n";
    }
    return value;
  }, space);
};
const LoadingSkeleton = ({ height: height2 = 60, width: width2 = "100%", borderRadius: borderRadius2 = 2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Box,
  {
    sx: {
      width: width2,
      height: height2,
      borderRadius: borderRadius2,
      background: "linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%)",
      backgroundSize: "200% 100%",
      animation: "skeleton-loading 1.5s ease-in-out infinite",
      "@keyframes skeleton-loading": {
        "0%": { backgroundPosition: "200% 0" },
        "100%": { backgroundPosition: "-200% 0" }
      }
    }
  }
);
const Dashboard = () => {
  const theme2 = useTheme();
  const isMobile = useMediaQuery(theme2.breakpoints.down("sm"));
  useMediaQuery(theme2.breakpoints.down("md"));
  const wallet = useWallet();
  const chainId = useChainId();
  useSwitchChain();
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const [success, setSuccess] = reactExports.useState("");
  const [buyAmount, setBuyAmount] = reactExports.useState("");
  const [sellAmount, setSellAmount] = reactExports.useState("");
  const [buyTokenAmount, setBuyTokenAmount] = reactExports.useState("");
  const [referralCode, setReferralCode] = reactExports.useState("");
  const [orderHistory, setOrderHistory] = reactExports.useState([]);
  const [orderLoading, setOrderLoading] = reactExports.useState(false);
  const [notRegistered, setNotRegistered] = reactExports.useState(false);
  const [isFromReferralLink, setIsFromReferralLink] = reactExports.useState(false);
  const [mlmData, setMlmData] = reactExports.useState({
    directTeam: 0,
    strongTeam: 0,
    otherTeams: 0,
    levels: 0,
    totalIn: 0,
    totalOut: 0,
    activePortfolio: 0,
    teamGrowthWallet: 0,
    referralEarn: 0,
    levelEarn: 0,
    growthEarn: 0,
    leaderEarn: 0,
    developmentEarn: 0,
    totalWithdrawn: 0,
    teamGrowthLaps: 0,
    inOutBuy: 0,
    growthFuels: 0,
    activeOrders: 0,
    teamLevelStake: 0
  });
  const fetchMlmData = async () => {
    console.log(" [fetchMlmData] Starting data fetch process...");
    console.log(" [fetchMlmData] Wallet connected:", wallet.isConnected);
    console.log(" [fetchMlmData] Wallet account:", wallet.account);
    if (!wallet.isConnected || !wallet.account) {
      console.warn(" [fetchMlmData] Wallet not connected");
      setError("Wallet not connected. Please connect your wallet.");
      return;
    }
    try {
      setIsLoading(true);
      setError("");
      console.log(" [fetchMlmData] Loading state set to true");
      console.log(" [fetchMlmData] Fetching user info for account:", wallet.account);
      const userInfo = await stakingInteractions.getUserInfo(wallet.account);
      console.log(" [fetchMlmData] User Info Response:", safeStringify(userInfo));
      if (!userInfo?.joined) {
        console.warn(" [fetchMlmData] User not registered, showing registration form");
        setNotRegistered(true);
        setIsLoading(false);
        return;
      }
      console.log(" [fetchMlmData] User is registered, proceeding with data fetch");
      setNotRegistered(false);
      console.log(" [fetchMlmData] Fetching all contract data in parallel...");
      const [bonusInfo, rankQualify, directReferrals, unStakePotential, matureOrder] = await Promise.all([
        stakingInteractions.getBonusInfo(wallet.account).catch((err) => {
          console.error(" [fetchMlmData] getBonusInfo failed:", err);
          return {};
        }),
        stakingInteractions.getRankQualify(wallet.account).catch((err) => {
          console.error(" [fetchMlmData] getRankQualify failed:", err);
          return {};
        }),
        stakingInteractions.getDirectUser(wallet.account).catch((err) => {
          console.error(" [fetchMlmData] getDirectUser failed:", err);
          return [];
        }),
        stakingInteractions.getUnStakePotential(wallet.account).catch((err) => {
          console.error(" [fetchMlmData] getUnStakePotential failed:", err);
          return {};
        }),
        stakingInteractions.getMatureOrder(wallet.account).catch((err) => {
          console.error(" [fetchMlmData] getMatureOrder failed:", err);
          return {};
        })
      ]);
      console.log(" [fetchMlmData] Raw Contract Data:");
      console.log("   bonusInfo:", safeStringify(bonusInfo));
      console.log("   rankQualify:", safeStringify(rankQualify));
      console.log("   directReferrals:", safeStringify(directReferrals));
      console.log("   unStakePotential:", safeStringify(unStakePotential));
      console.log("   matureOrder:", safeStringify(matureOrder));
      console.log(" [fetchMlmData] Fetching USDT decimals...");
      const decimals = await readContract(config, {
        abi: USDT_ABI,
        address: USDT_ADDRESS,
        functionName: "decimals",
        chainId: 56
      });
      console.log(" [fetchMlmData] USDT Decimals fetched:", decimals);
      console.log(" [fetchMlmData] Processing and calculating data...");
      const directTeam = directReferrals?.length || 0;
      console.log(" [fetchMlmData] Direct Team Count:", directTeam);
      const strongTeam = Number(rankQualify?.strongTeam || 0);
      console.log(" [fetchMlmData] Strong Team Count:", strongTeam);
      const totalTeam = Number(rankQualify?.totalTeam || 0);
      console.log(" [fetchMlmData] Total Team Count:", totalTeam);
      const otherTeams = totalTeam - directTeam - strongTeam;
      console.log(" [fetchMlmData] Other Teams Count:", otherTeams);
      const levels = Number(rankQualify?.level || 0);
      console.log(" [fetchMlmData] Levels:", levels);
      const activeOrders = Number(matureOrder?.activeOrder || 0);
      console.log(" [fetchMlmData] Active Orders:", activeOrders);
      console.log(" [fetchMlmData] Starting order history fetch for financial calculations...");
      const orders = [];
      console.log(" [fetchMlmData] Getting total order count...");
      const stakeViewResponse = await stakingInteractions.userStakeView(wallet.account, BigInt(0)).catch((err) => {
        console.error(" [fetchMlmData] Failed to get total count:", err);
        return { totalCount: 0 };
      });
      const totalCount = Number(stakeViewResponse?.totalCount || 0);
      console.log(" [fetchMlmData] Total order count:", totalCount);
      let totalStakedFromOrders = 0;
      for (let i4 = 0; i4 < totalCount; i4++) {
        console.log(` [fetchMlmData] Fetching order ${i4 + 1}/${totalCount}...`);
        const orderResponse = await stakingInteractions.userStakeView(wallet.account, BigInt(i4)).catch((err) => {
          console.error(` [fetchMlmData] Failed to get order ${i4}:`, err);
          return {};
        });
        const stakeInfo = orderResponse?.stakeInfo || {};
        const orderValue = stakeInfo?.orderValue || BigInt(0);
        const orderTime = stakeInfo?.orderTime || 0;
        const orderGrowth = stakeInfo?.orderGrowth || BigInt(0);
        const isMature = stakeInfo?.isMature || 0;
        const isComplete = stakeInfo?.isComplete || false;
        const formattedAmount = Number(orderValue);
        const timestamp = Number(orderTime) * 1e3;
        const growthRate = Number(orderGrowth);
        const maturityStatus = Number(isMature);
        totalStakedFromOrders += formattedAmount;
        const orderDate = new Date(timestamp);
        const formattedDate = orderDate.toLocaleDateString("en-US", {
          year: "numeric",
          month: "short",
          day: "numeric",
          hour: "2-digit",
          minute: "2-digit"
        });
        const maturityPeriodDays = 15;
        const stakeDate = new Date(timestamp);
        const currentTime = /* @__PURE__ */ new Date();
        const timeElapsed = currentTime.getTime() - stakeDate.getTime();
        const daysElapsed = Math.floor(timeElapsed / (1e3 * 60 * 60 * 24));
        const totalMaturityTime = maturityPeriodDays * 24 * 60 * 60 * 1e3;
        const remainingTime = totalMaturityTime - timeElapsed;
        let remainingTimeText = "";
        if (isComplete) {
          remainingTimeText = "Completed";
        } else if (daysElapsed >= 15 || maturityStatus > 0) {
          remainingTimeText = "Matured";
        } else if (remainingTime > 0) {
          const remainingDays = Math.floor(remainingTime / (1e3 * 60 * 60 * 24));
          const remainingHours = Math.floor(remainingTime % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60));
          const remainingMinutes = Math.floor(remainingTime % (1e3 * 60 * 60) / (1e3 * 60));
          remainingTimeText = `${remainingDays}d ${remainingHours}h ${remainingMinutes}m`;
        } else {
          remainingTimeText = "Matured";
        }
        const processedOrder = {
          ...stakeInfo,
          amount: formattedAmount,
          timestamp,
          date: formattedDate,
          growthRate,
          maturityStatus,
          remainingTime: remainingTimeText,
          isStake: !isComplete
        };
        orders.push(processedOrder);
      }
      console.log(" [fetchMlmData] Total staked from orders:", totalStakedFromOrders);
      console.log(" [fetchMlmData] Processing financial data with decimals:", decimals);
      const isWeiFormat = (value) => value > 1e6;
      const formatValue = (rawValue) => {
        if (!rawValue || rawValue === 0) return 0;
        if (isWeiFormat(Number(rawValue))) {
          return parseFloat(formatUnits(rawValue, Number(decimals))) || 0;
        } else {
          return parseFloat(rawValue.toString()) || 0;
        }
      };
      const totalStakeRaw = bonusInfo?.totalStake || 0;
      const totalIn = formatValue(totalStakeRaw);
      const totalUnStakeRaw = bonusInfo?.totalUnStake || 0;
      const totalOut = formatValue(totalUnStakeRaw);
      const totalWithdrawnRaw = bonusInfo?.totalWithdrawn || 0;
      const totalWithdrawn = formatValue(totalWithdrawnRaw);
      const orderValueRaw = unStakePotential?.OrderValue || 0;
      const orderValueFormatted = formatValue(orderValueRaw);
      const activePortfolio = totalIn - (orderValueFormatted + totalOut);
      const referralGainsRaw = bonusInfo?.referralGains || 0;
      const levelGainsRaw = bonusInfo?.levelGains || 0;
      const growthGainsRaw = bonusInfo?.growthGains || 0;
      const referralEarn = formatValue(referralGainsRaw);
      const levelEarn = formatValue(levelGainsRaw);
      const growthEarn = formatValue(growthGainsRaw);
      const leaderGainsRaw = bonusInfo?.leaderGains || 0;
      const leaderEarn = formatValue(leaderGainsRaw);
      const developmentGainsRaw = bonusInfo?.developmentGains || 0;
      const developmentEarn = formatValue(developmentGainsRaw);
      const teamGrowthGainsRaw = bonusInfo?.teamGrowthGains || 0;
      const teamGrowthWallet = formatValue(teamGrowthGainsRaw);
      const teamLapsRaw = unStakePotential?.teamLaps || 0;
      const teamGrowthLaps = parseFloat(formatUnits(teamLapsRaw, 18)) || 0;
      const lastStakeRaw = userInfo?.lastStake || 0;
      const inOutBuyRaw = bonusInfo?.inOutBuy || 0;
      const lastStakeFormatted = formatValue(lastStakeRaw);
      const inOutBuyFormatted = formatValue(inOutBuyRaw);
      const inOutBuy = lastStakeFormatted - inOutBuyFormatted;
      const teamGrowthRaw = unStakePotential?.teamGrowth || 0;
      const growthFuels = parseFloat(formatUnits(teamGrowthRaw, 18)) || 0;
      const totalFuels = growthFuels + teamGrowthLaps;
      const totGainRaw = unStakePotential?.totGain || 0;
      const orderGrowthRaw = unStakePotential?.orderGrowth || 0;
      const totGainFormatted = formatValue(totGainRaw);
      const orderGrowthFormatted = formatValue(orderGrowthRaw);
      const availableWithdrawal = totGainFormatted + orderGrowthFormatted + growthFuels + orderValueFormatted;
      const teamLevelStakeRaw = bonusInfo?.teamLevelStake || 0;
      const teamLevelStake = formatValue(teamLevelStakeRaw);
      console.log(" [fetchMlmData] Team Level Stake:", teamLevelStake);
      const finalMlmData = {
        directTeam,
        strongTeam,
        otherTeams,
        levels,
        totalIn,
        totalOut,
        activePortfolio,
        teamGrowthWallet,
        referralEarn,
        levelEarn,
        growthEarn,
        leaderEarn,
        developmentEarn,
        totalWithdrawn,
        teamGrowthLaps,
        inOutBuy,
        growthFuels,
        totalFuels,
        activeOrders,
        availableWithdrawal,
        teamLevelStake
        // Add teamLevelStake to the final data
      };
      setMlmData(finalMlmData);
      setOrderHistory(orders);
      setOrderLoading(true);
    } catch (error2) {
      console.error(" [fetchMlmData] Critical error occurred:", error2);
      setError("Failed to fetch MLM data. Please try again.");
    } finally {
      setIsLoading(false);
      setOrderLoading(false);
    }
  };
  reactExports.useEffect(() => {
    console.log(" [useEffect] Checking for referral code in URL and auto-connecting wallet");
    if (hasReferralInUrl()) {
      const referrerFromUrl = getReferrerFromUrl();
      console.log(" [useEffect] Found referral code in URL:", referrerFromUrl);
      const ethAddressRegex = /^0x[a-fA-F0-9]{40}$/;
      if (ethAddressRegex.test(referrerFromUrl)) {
        setReferralCode(referrerFromUrl);
        setIsFromReferralLink(true);
        console.log(" [useEffect] Valid referral code set from URL");
        clearReferralFromUrl();
      } else {
        console.warn(" [useEffect] Invalid referral code format in URL:", referrerFromUrl);
      }
    }
    if (!wallet.isConnected) {
      console.log(" [useEffect] Wallet not connected, attempting auto-connect...");
      const autoConnect = async () => {
        try {
          await wallet.connectWallet();
          console.log(" [useEffect] Auto-connect successful");
        } catch (error2) {
          console.log(" [useEffect] Auto-connect failed (user may have cancelled):", error2.message);
        }
      };
      const timer = setTimeout(autoConnect, 1e3);
      return () => clearTimeout(timer);
    }
  }, []);
  reactExports.useEffect(() => {
    console.log(" [useEffect] Wallet state changed");
    console.log(" [useEffect] Wallet connected:", wallet.isConnected);
    console.log(" [useEffect] Wallet account:", wallet.account);
    if (wallet.isConnected && wallet.account) {
      console.log(" [useEffect] Triggering data fetch due to wallet connection");
      fetchMlmData();
    } else {
      console.log(" [useEffect] Wallet not ready, skipping data fetch");
    }
  }, [wallet.isConnected, wallet.account]);
  const handleRegister = async () => {
    console.log(" [handleRegister] Registration process started");
    if (!wallet.isConnected || !wallet.account) {
      console.warn(" [handleRegister] Wallet not connected");
      setError("Please connect your wallet to register.");
      return;
    }
    if (!referralCode || referralCode.trim() === "") {
      console.warn(" [handleRegister] No referral code provided");
      setError("Please enter a referral code to register.");
      return;
    }
    const ethAddressRegex = /^0x[a-fA-F0-9]{40}$/;
    if (!ethAddressRegex.test(referralCode)) {
      console.warn(" [handleRegister] Invalid referral code format:", referralCode);
      setError("Please enter a valid referral code (Ethereum address format).");
      return;
    }
    try {
      setIsLoading(true);
      setError("");
      setSuccess("");
      const refCode = referralCode;
      console.log(" [handleRegister] Proceeding with user registration...");
      const registerTx = await stakingInteractions.regUser(refCode, wallet.account);
      console.log(" [handleRegister] Registration transaction hash:", registerTx);
      console.log(" [handleRegister] Registration successful!");
      setSuccess(`Registration successful! Transaction: ${registerTx}`);
      setReferralCode("");
      console.log(" [handleRegister] Scheduling data refresh in 3 seconds...");
      setTimeout(fetchMlmData, 3e3);
    } catch (error2) {
      console.error(" [handleRegister] Registration failed:", error2);
      if (error2.message?.includes("User rejected")) {
        console.log(" [handleRegister] User rejected transaction");
        setError("Transaction was cancelled by user");
      } else if (error2.message?.includes("insufficient")) {
        console.log(" [handleRegister] Insufficient balance");
        setError("Insufficient USDT balance or BNB for gas fees. Ensure you have ~1 USDT and ~0.05 BNB.");
      } else if (error2.message?.includes("already registered")) {
        console.log(" [handleRegister] Already registered");
        setError("Address is already registered");
      } else {
        console.log(" [handleRegister] Unknown error");
        setError(`Failed to register: ${error2.message || "Unknown error"}`);
      }
    } finally {
      console.log(" [handleRegister] Registration process completed");
      setIsLoading(false);
    }
  };
  const handleMakestake = async (amount) => {
    console.log(" [handleMakestake] Initiating stake process");
    console.log(" [handleMakestake] Amount to stake:", amount, "USDT");
    try {
      console.log(" [handleMakestake] Calling makeStake function...");
      const txHash = await stakingInteractions.makeStake(amount, wallet.account);
      console.log(" [handleMakestake] Stake transaction successful!");
      console.log(" [handleMakestake] Transaction hash:", txHash);
      setSuccess(`Staked ${amount} USDT successfully! Tx: ${txHash.slice(0, 10)}...${txHash.slice(-8)}`);
      console.log(" [handleMakestake] Scheduling data refresh...");
      setTimeout(fetchMlmData, 3e3);
    } catch (error2) {
      console.error(" [handleMakestake] Stake failed:", error2);
      setError(`Stake failed: ${error2.message || error2}`);
    }
  };
  const handleWithdraw = async () => {
    console.log(" [handleWithdraw] Withdrawal process started");
    if (!wallet.isConnected || !wallet.account) {
      console.warn(" [handleWithdraw] Wallet not connected");
      setError("Please connect your wallet");
      return;
    }
    if (chainId !== 56) {
      setError("Please switch to BSC Mainnet (Chain ID: 56) to withdraw earnings.");
      return;
    }
    try {
      setOrderLoading(true);
      setError("");
      setSuccess("");
      const referralEarn = mlmData.referralEarn || 0;
      const levelEarn = mlmData.levelEarn || 0;
      const growthEarn = mlmData.growthEarn || 0;
      const teamGrowthWallet = mlmData.teamGrowthWallet || 0;
      const leaderEarn = mlmData.leaderEarn || 0;
      const developmentEarn = mlmData.developmentEarn || 0;
      const totalAvailable = referralEarn + levelEarn + growthEarn + teamGrowthWallet + leaderEarn + developmentEarn;
      console.log(" [handleWithdraw] Total available for withdrawal:", totalAvailable);
      if (totalAvailable <= 0) {
        console.warn(" [handleWithdraw] No earnings available");
        setError("No earnings available for withdrawal");
        return;
      }
      const decimals = await readContract(config, {
        abi: USDT_ABI,
        address: USDT_ADDRESS,
        functionName: "decimals",
        chainId: 56
      });
      const amountInWei = parseUnits(totalAvailable.toFixed(6), Number(decimals));
      console.log(" [handleWithdraw] Amount in wei:", amountInWei.toString());
      console.log(" [handleWithdraw] Executing withdrawal transaction...");
      const txHash = await stakingInteractions.makeUnstake(amountInWei, wallet.account);
      console.log(" [handleWithdraw] Withdrawal transaction successful!");
      setSuccess(`Withdrawal successful! Amount: $${totalAvailable.toFixed(2)} USDT. Tx: ${txHash.slice(0, 10)}...${txHash.slice(-8)}`);
      console.log(" [handleWithdraw] Scheduling data refresh in 3 seconds...");
      setTimeout(() => {
        fetchMlmData();
      }, 3e3);
    } catch (error2) {
      console.error(" [handleWithdraw] Withdrawal failed:", error2);
      setError(`Withdrawal failed: ${error2.message || error2}`);
    } finally {
      console.log(" [handleWithdraw] Withdrawal process completed");
      setOrderLoading(false);
    }
  };
  const handleBuy = async () => {
    console.log(" [Buy] Buy button clicked");
    if (!wallet.isConnected || !wallet.account) {
      setError("Wallet not connected. Please connect your wallet.");
      return;
    }
    if (!buyAmount || parseFloat(buyAmount) <= 0) {
      setError("Please enter a valid amount to buy");
      return;
    }
    try {
      setOrderLoading(true);
      setError("");
      setSuccess("");
      if (chainId !== 56) {
        setError("Please switch to BSC Mainnet (Chain ID: 56) to stake.");
        return;
      }
      const userInfo = await stakingInteractions.getUserInfo(wallet.account);
      if (!userInfo.joined) {
        setError("User is not registered. Please register first.");
        return;
      }
      const decimals = await readContract(config, {
        abi: USDT_ABI,
        address: USDT_ADDRESS,
        functionName: "decimals",
        chainId: 56
      });
      const amountInWei = parseUnits(buyAmount, Number(decimals));
      console.log(" [Buy] Sending approval transaction...");
      const approvalTx = await stakingInteractions.approveUSDT(amountInWei, wallet.account);
      console.log(" [Buy] Approval successful. Tx Hash:", approvalTx);
      setTimeout(() => {
        console.log(" [Buy] Proceeding to stake after approval...");
        handleMakestake(buyAmount);
      }, 5e3);
    } catch (error2) {
      console.error(" [Buy] Unexpected error:", error2);
      setError(`Unexpected error: ${error2.message || "Unknown error"}`);
    } finally {
      setOrderLoading(false);
    }
  };
  const handleSell = async () => {
    console.log(" [handleSell] Sell button clicked");
    if (!wallet.isConnected || !wallet.account) {
      setError("Wallet not connected. Please connect your wallet.");
      return;
    }
    if (!sellAmount || parseFloat(sellAmount) <= 0) {
      setError("Please enter a valid amount to sell");
      return;
    }
    try {
      setOrderLoading(true);
      setError("");
      setSuccess("");
      const decimals = await readContract(config, {
        abi: USDT_ABI,
        address: USDT_ADDRESS,
        functionName: "decimals",
        chainId: 56
      });
      const amountInWei = parseUnits(sellAmount, Number(decimals));
      const txHash = await stakingInteractions.makeUnstake(amountInWei, wallet.account);
      setSuccess(`Successfully sold ${sellAmount} USDT worth of tokens! Tx: ${txHash.slice(0, 10)}...${txHash.slice(-8)}`);
      setSellAmount("");
      setTimeout(fetchMlmData, 3e3);
    } catch (error2) {
      console.error(" [handleSell] Sell process failed:", error2);
      setError(`Failed to sell tokens: ${error2.message || "Unknown error"}`);
    } finally {
      setOrderLoading(false);
    }
  };
  const handleBuyToken = async () => {
    console.log(" [handleBuyToken] Buy token button clicked");
    if (!wallet.isConnected || !wallet.account) {
      setError("Wallet not connected. Please connect your wallet.");
      return;
    }
    if (!buyTokenAmount || parseFloat(buyTokenAmount) <= 0) {
      setError("Please enter a valid amount to buy tokens");
      return;
    }
    if (chainId !== 56) {
      setError("Please switch to BSC Mainnet (Chain ID: 56) to buy tokens.");
      return;
    }
    try {
      setOrderLoading(true);
      setError("");
      setSuccess("");
      const decimals = await readContract(config, {
        abi: USDT_ABI,
        address: USDT_ADDRESS,
        functionName: "decimals",
        chainId: 56
      });
      const amountInWei = parseUnits(buyTokenAmount, Number(decimals));
      const allowance = await readContract(config, {
        abi: USDT_ABI,
        address: USDT_ADDRESS,
        functionName: "allowance",
        args: [wallet.account, STAKING_CONTRACT_ADDRESS],
        chainId: 56
      });
      if (allowance < amountInWei) {
        const approvalTx = await stakingInteractions.approveUSDT(amountInWei, wallet.account);
        await waitForTransactionReceipt(config, { hash: approvalTx, chainId: 56 });
      }
      const txHash = await stakingInteractions.buyToken(buyTokenAmount, wallet.account);
      setSuccess(`Successfully bought tokens with ${buyTokenAmount} USDT! Tx: ${txHash.slice(0, 10)}...${txHash.slice(-8)}`);
      setBuyTokenAmount("");
      setTimeout(fetchMlmData, 3e3);
    } catch (error2) {
      console.error(" [handleBuyToken] Buy token process failed:", error2);
      if (error2.message?.includes("User rejected")) {
        setError("Transaction was cancelled by user");
      } else if (error2.message?.includes("insufficient")) {
        setError("Insufficient USDT balance for this transaction");
      } else {
        setError(`Failed to buy tokens: ${error2.message || "Unknown error occurred"}`);
      }
    } finally {
      setOrderLoading(false);
    }
  };
  if (!wallet.isConnected) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "xl", sx: { py: { xs: 3, sm: 4 } }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: {
      p: { xs: 3, sm: 4, md: 5 },
      boxShadow: { xs: 4, sm: 8, md: 12 },
      textAlign: "center",
      backgroundColor: "white",
      borderRadius: { xs: 3, sm: 4 },
      border: "1px solid rgba(0, 0, 0, 0.08)",
      position: "relative",
      overflow: "hidden",
      "&::before": {
        content: '""',
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        height: "4px",
        background: "linear-gradient(90deg, #1976d2 0%, #42a5f5 50%, #1976d2 100%)",
        backgroundSize: "200% 100%",
        animation: "shimmer 3s ease-in-out infinite"
      }
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", gutterBottom: true, sx: {
        color: "primary.main",
        fontWeight: 800,
        fontSize: { xs: "1.5rem", sm: "1.8rem", md: "2.2rem" },
        letterSpacing: "-0.02em",
        mb: 2
      }, children: "Welcome to SafeMint Dashboard" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", color: "text.secondary", sx: {
        mb: 4,
        fontSize: { xs: "1rem", sm: "1.1rem" },
        fontWeight: 500,
        lineHeight: 1.6
      }, children: "Connect your wallet to access the dashboard and start earning with our secure staking platform." }),
      isFromReferralLink && referralCode && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "info", sx: {
        mb: 4,
        borderRadius: 2,
        boxShadow: "0 4px 12px rgba(33, 150, 243, 0.15)"
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", sx: { fontWeight: 600 }, children: [
        " You were invited! Referral code: ",
        referralCode.slice(0, 6),
        "...",
        referralCode.slice(-4)
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "contained",
          size: "large",
          onClick: wallet.connectWallet,
          disabled: wallet.loading,
          sx: {
            minWidth: 220,
            py: { xs: 1.5, sm: 2 },
            px: { xs: 3, sm: 4 },
            fontSize: { xs: "1rem", sm: "1.1rem" },
            fontWeight: 700,
            borderRadius: "30px",
            textTransform: "none",
            boxShadow: "0 6px 20px rgba(25, 118, 210, 0.3)",
            transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
            "&:hover": {
              transform: "translateY(-2px)",
              boxShadow: "0 8px 25px rgba(25, 118, 210, 0.4)"
            }
          },
          children: wallet.loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 24, color: "inherit" }) : "Connect Wallet"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", sx: {
        mt: 3,
        fontSize: { xs: "0.9rem", sm: "1rem" },
        fontWeight: 500
      }, children: " Connecting your wallet is safe and secure" })
    ] }) });
  }
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Container,
      {
        maxWidth: "xl",
        sx: {
          py: { xs: 4, sm: 6 },
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          minHeight: "60vh"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
          textAlign: "center",
          p: { xs: 3, sm: 4 },
          borderRadius: 3,
          backgroundColor: "white",
          boxShadow: "0 8px 32px rgba(0,0,0,0.1)",
          border: "1px solid rgba(0, 0, 0, 0.08)"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 48, sx: { mb: 3 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: {
            color: "primary.main",
            fontWeight: 600,
            mb: 1
          }, children: "Loading Dashboard" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", sx: { fontWeight: 500 }, children: "Please wait while we fetch your data..." })
        ] })
      }
    );
  }
  if (notRegistered) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RegistrationForm,
      {
        referralCode,
        setReferralCode,
        onRegister: handleRegister,
        isLoading,
        error,
        success,
        setError,
        setSuccess,
        isFromReferralLink
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
    backgroundColor: "#f8f9fa",
    minHeight: "100vh",
    py: { xs: 2, sm: 3, md: 4 },
    pb: { xs: 12, sm: 4, md: 4 }
    // Add extra bottom padding for mobile to avoid footer overlap
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Container,
    {
      maxWidth: "xl",
      sx: {
        px: { xs: 1.5, sm: 2, md: 3 }
      },
      children: [
        error && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Alert,
          {
            severity: "error",
            sx: {
              mb: 3,
              backgroundColor: "white",
              borderRadius: 2,
              boxShadow: "0 4px 12px rgba(244, 67, 54, 0.15)",
              border: "1px solid rgba(244, 67, 54, 0.2)",
              fontWeight: 500
            },
            onClose: () => setError(""),
            children: error
          }
        ),
        success && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Alert,
          {
            severity: "success",
            sx: {
              mb: 3,
              backgroundColor: "white",
              borderRadius: 2,
              boxShadow: "0 4px 12px rgba(76, 175, 80, 0.15)",
              border: "1px solid rgba(76, 175, 80, 0.2)",
              fontWeight: 500
            },
            onClose: () => setSuccess(""),
            children: success
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box,
          {
            sx: {
              mb: { xs: 2, sm: 3 },
              display: "flex",
              flexDirection: { xs: "column", sm: "row" },
              justifyContent: "space-between",
              alignItems: { xs: "flex-start", sm: "center" },
              gap: { xs: 1.5, sm: 2 },
              p: { xs: 2, sm: 3, md: 4 },
              borderRadius: { xs: 3, sm: 4 },
              backgroundColor: "white",
              boxShadow: { xs: 2, sm: 4, md: 6 },
              border: "1px solid rgba(0, 0, 0, 0.08)",
              position: "relative",
              overflow: "hidden",
              "&::before": {
                content: '""',
                position: "absolute",
                top: 0,
                left: 0,
                right: 0,
                height: "4px",
                background: "linear-gradient(90deg, #1976d2 0%, #42a5f5 50%, #1976d2 100%)",
                backgroundSize: "200% 100%",
                animation: "shimmer 3s ease-in-out infinite"
              },
              "@keyframes shimmer": {
                "0%": { backgroundPosition: "-200% 0" },
                "100%": { backgroundPosition: "200% 0" }
              },
              animation: "float 6s ease-in-out infinite",
              "@keyframes float": {
                "0%, 100%": { transform: "translateY(0px)" },
                "50%": { transform: "translateY(-2px)" }
              }
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { flex: 1, minWidth: 0 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Typography,
                  {
                    variant: "h4",
                    gutterBottom: true,
                    sx: {
                      color: "primary.main",
                      fontWeight: 800,
                      fontSize: { xs: "1.4rem", sm: "1.6rem", md: "2.1rem" },
                      lineHeight: 1.1,
                      mb: { xs: 0.5, sm: 1 },
                      letterSpacing: "-0.02em"
                    },
                    children: "SafeMint Dashboard"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Typography,
                  {
                    variant: "body1",
                    color: "text.secondary",
                    sx: {
                      fontSize: { xs: "0.85rem", sm: "0.95rem", md: "1.05rem" },
                      lineHeight: 1.5,
                      fontWeight: 500
                    },
                    children: [
                      "Welcome back! ",
                      wallet.account?.slice(0, 6),
                      "...",
                      wallet.account?.slice(-4)
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outlined",
                  startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 18 }),
                  onClick: fetchMlmData,
                  disabled: isLoading,
                  size: isMobile ? "small" : "medium",
                  sx: {
                    fontSize: { xs: "0.8rem", sm: "0.875rem", md: "1rem" },
                    flex: { xs: 1, sm: "none" },
                    borderRadius: { xs: 2, sm: 3 },
                    fontWeight: 600,
                    px: { xs: 2, sm: 3 },
                    py: { xs: 1, sm: 1.5 },
                    borderWidth: "2px",
                    transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
                    "&:hover": {
                      borderWidth: "2px",
                      transform: "translateY(-2px)",
                      boxShadow: "0 8px 25px rgba(25, 118, 210, 0.15)"
                    }
                  },
                  children: "Refresh"
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: {
          p: { xs: 2, sm: 3, md: 4 },
          backgroundColor: "white",
          borderRadius: { xs: 3, sm: 4 },
          boxShadow: { xs: 2, sm: 4, md: 6 },
          mb: { xs: 2, sm: 3 },
          width: "100%",
          border: "1px solid rgba(0, 0, 0, 0.08)",
          position: "relative",
          overflow: "hidden",
          transition: "all 0.4s cubic-bezier(0.4, 0, 0.2, 1)",
          animation: "slideInUp 0.6s ease-out",
          "&:hover": {
            boxShadow: { xs: 4, sm: 8, md: 12 },
            transform: "translateY(-4px) scale(1.01)"
          },
          "&::before": {
            content: '""',
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            height: "3px",
            background: "linear-gradient(90deg, #1976d2 0%, #42a5f5 50%, #1976d2 100%)",
            backgroundSize: "200% 100%",
            animation: "shimmer 3s ease-in-out infinite"
          },
          "@keyframes slideInUp": {
            "0%": { opacity: 0, transform: "translateY(30px)" },
            "100%": { opacity: 1, transform: "translateY(0)" }
          },
          "@keyframes shimmer": {
            "0%": { backgroundPosition: "-200% 0" },
            "100%": { backgroundPosition: "200% 0" }
          }
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
            position: "absolute",
            top: 16,
            left: 16,
            width: 12,
            height: 12,
            zIndex: 1
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "circle",
            {
              cx: "6",
              cy: "6",
              r: "5",
              fill: "none",
              stroke: "#1976d2",
              strokeWidth: "1",
              opacity: "0.6",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animate",
                  {
                    attributeName: "r",
                    values: "3;5;3",
                    dur: "2s",
                    repeatCount: "indefinite"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animate",
                  {
                    attributeName: "opacity",
                    values: "0.6;0.2;0.6",
                    dur: "2s",
                    repeatCount: "indefinite"
                  }
                )
              ]
            }
          ) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "h6",
              gutterBottom: true,
              sx: {
                color: "primary.main",
                fontWeight: 700,
                mb: { xs: 2, sm: 3 },
                fontSize: { xs: "1.1rem", sm: "1.2rem", md: "1.35rem" },
                textAlign: { xs: "center", sm: "left" },
                letterSpacing: "-0.01em",
                pl: { xs: 0, sm: 3 }
              },
              children: "Token Information"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grid,
            {
              container: true,
              spacing: { xs: 2, sm: 2.5, md: 3 },
              sx: {
                width: "100%",
                margin: 0
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Grid,
                {
                  item: true,
                  xs: 12,
                  sm: 12,
                  md: 12,
                  lg: 12,
                  xl: 12,
                  sx: {
                    display: "flex",
                    justifyContent: "center",
                    width: { xs: "100%", sm: "100%", md: "auto" },
                    maxWidth: { xs: "100%", sm: "100%", md: "none" },
                    flexBasis: { xs: "100%", sm: "100%", md: "auto" }
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                    width: { xs: "100%", sm: "100%", md: "100%" },
                    maxWidth: "100%"
                  }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SafeMintTokenStats, { autoRefresh: true, refreshInterval: 3e4 }) })
                }
              )
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: {
          p: { xs: 2, sm: 3, md: 4 },
          backgroundColor: "white",
          borderRadius: { xs: 3, sm: 4 },
          boxShadow: { xs: 2, sm: 4, md: 6 },
          mb: { xs: 2, sm: 3 },
          width: "100%",
          border: "1px solid rgba(0, 0, 0, 0.08)",
          position: "relative",
          overflow: "hidden",
          transition: "all 0.4s cubic-bezier(0.4, 0, 0.2, 1)",
          animation: "slideInUp 0.8s ease-out",
          animationDelay: "0.1s",
          animationFillMode: "both",
          "&:hover": {
            boxShadow: { xs: 4, sm: 8, md: 12 },
            transform: "translateY(-4px) scale(1.01)"
          },
          "&::before": {
            content: '""',
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            height: "3px",
            background: "linear-gradient(90deg, #9c27b0 0%, #e1bee7 50%, #9c27b0 100%)",
            backgroundSize: "200% 100%",
            animation: "shimmer 3s ease-in-out infinite"
          }
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
            position: "absolute",
            top: 16,
            left: 16,
            width: 12,
            height: 12,
            zIndex: 1
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "circle",
            {
              cx: "6",
              cy: "6",
              r: "5",
              fill: "none",
              stroke: "#9c27b0",
              strokeWidth: "1",
              opacity: "0.6",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animate",
                  {
                    attributeName: "r",
                    values: "2;6;2",
                    dur: "2.5s",
                    repeatCount: "indefinite"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animate",
                  {
                    attributeName: "opacity",
                    values: "0.8;0.2;0.8",
                    dur: "2.5s",
                    repeatCount: "indefinite"
                  }
                )
              ]
            }
          ) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "h6",
              gutterBottom: true,
              sx: {
                color: "primary.main",
                mb: { xs: 2, sm: 3 },
                fontSize: { xs: "1.1rem", sm: "1.2rem", md: "1.35rem" },
                fontWeight: 700,
                textAlign: { xs: "center", sm: "left" },
                letterSpacing: "-0.01em",
                pl: { xs: 0, sm: 3 }
              },
              children: "Team Statistics"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grid,
            {
              container: true,
              spacing: { xs: 1.5, sm: 2, md: 2.5, lg: 3 },
              sx: {
                width: "100%",
                margin: 0,
                justifyContent: { xs: "center", sm: "flex-start" }
              },
              children: [
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.Users, { size: 120, animated: true }), title: "My Direct", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 80 }) : formatNumber(mlmData.directTeam), subtitle: "Direct Referrals", color: "primary.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.Star, { size: 120, animated: true }), title: "Strong Teams", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 80 }) : formatNumber(mlmData.strongTeam), subtitle: "Active Strong Teams", color: "secondary.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.Users, { size: 120, animated: true }), title: "Other Teams", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 80 }) : formatNumber(mlmData.otherTeams), subtitle: "Additional Team Members", color: "info.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.BarChart3, { size: 120, animated: true }), title: "Levels", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 80 }) : formatNumber(mlmData.levels), subtitle: "Achievement Levels", color: "warning.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.CheckCircle, { size: 120, animated: true }), title: "Active Orders", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 80 }) : formatNumber(mlmData.activeOrders), subtitle: "Current Active Orders", color: "success.main" }
              ].map((card, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                Grid,
                {
                  item: true,
                  xs: 6,
                  sm: 4,
                  md: 3,
                  lg: 2.4,
                  xl: 2.4,
                  sx: {
                    display: "flex",
                    justifyContent: "center",
                    width: { xs: "100%", sm: "100%", md: "auto" },
                    maxWidth: { xs: "100%", sm: "100%", md: "none" },
                    flexBasis: { xs: "100%", sm: "100%", md: "auto" }
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                    width: { xs: "100%", sm: "100%", md: "100%" },
                    maxWidth: "100%",
                    animation: "fadeInUp 0.6s ease-out",
                    animationDelay: `${index2 * 0.1}s`,
                    animationFillMode: "both",
                    "@keyframes fadeInUp": {
                      "0%": { opacity: 0, transform: "translateY(20px)" },
                      "100%": { opacity: 1, transform: "translateY(0)" }
                    }
                  }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    StatCard,
                    {
                      icon: card.icon,
                      title: card.title,
                      value: card.value,
                      subtitle: card.subtitle,
                      color: card.color
                    }
                  ) })
                },
                `team-stats-${index2}`
              ))
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: {
          p: { xs: 2, sm: 3, md: 4 },
          backgroundColor: "white",
          borderRadius: { xs: 3, sm: 4 },
          boxShadow: { xs: 2, sm: 4, md: 6 },
          mb: { xs: 2, sm: 3 },
          width: "100%",
          border: "1px solid rgba(0, 0, 0, 0.08)",
          position: "relative",
          overflow: "hidden",
          transition: "all 0.4s cubic-bezier(0.4, 0, 0.2, 1)",
          animation: "slideInUp 1s ease-out",
          animationDelay: "0.2s",
          animationFillMode: "both",
          "&:hover": {
            boxShadow: { xs: 4, sm: 8, md: 12 },
            transform: "translateY(-4px) scale(1.01)"
          },
          "&::before": {
            content: '""',
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            height: "3px",
            background: "linear-gradient(90deg, #4caf50 0%, #81c784 50%, #4caf50 100%)",
            backgroundSize: "200% 100%",
            animation: "shimmer 3s ease-in-out infinite"
          }
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
            position: "absolute",
            top: 16,
            left: 16,
            width: 12,
            height: 12,
            zIndex: 1
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "circle",
            {
              cx: "6",
              cy: "6",
              r: "5",
              fill: "none",
              stroke: "#4caf50",
              strokeWidth: "1",
              opacity: "0.6",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animate",
                  {
                    attributeName: "r",
                    values: "4;6;4",
                    dur: "3s",
                    repeatCount: "indefinite"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animate",
                  {
                    attributeName: "opacity",
                    values: "0.6;0.3;0.6",
                    dur: "3s",
                    repeatCount: "indefinite"
                  }
                )
              ]
            }
          ) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "h6",
              gutterBottom: true,
              sx: {
                color: "primary.main",
                mb: { xs: 2, sm: 3 },
                fontSize: { xs: "1.1rem", sm: "1.2rem", md: "1.35rem" },
                fontWeight: 700,
                textAlign: { xs: "center", sm: "left" },
                letterSpacing: "-0.01em",
                pl: { xs: 0, sm: 3 }
              },
              children: "Financial Overview"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grid,
            {
              container: true,
              spacing: { xs: 1.5, sm: 2, md: 2.5, lg: 3 },
              sx: {
                width: "100%",
                margin: 0,
                justifyContent: { xs: "center", sm: "flex-start" }
              },
              children: [
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.TrendingUp, { size: 120, animated: true }), title: "Total In", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.totalIn), subtitle: "Total Investments", color: "success.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.DollarSign, { size: 120, animated: true }), title: "Total Out", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.totalOut), subtitle: "Total Withdrawals", color: "info.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.Wallet, { size: 120, animated: true }), title: "Active Portfolio", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.activePortfolio), subtitle: "Current Investment Value", color: "primary.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.Trophy, { size: 120, animated: true }), title: "Team Growth Wallet", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.teamLevelStake), subtitle: "Growth Wallet Balance", color: "secondary.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.Building2, { size: 120, animated: true }), title: "Total Withdrawn", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.totalWithdrawn), subtitle: "Total Amount Withdrawn", color: "error.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.Users2, { size: 120, animated: true }), title: "Team Growth Laps", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.teamGrowthLaps), subtitle: "Team Growth Cycles", color: "warning.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.Wallet, { size: 120, animated: true }), title: "SafeMint Buy Potential", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.inOutBuy), subtitle: "Buy Potential Value", color: "info.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.Fuel, { size: 120, animated: true }), title: "Growth Fuels", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.growthFuels), subtitle: "Team Growth Potential", color: "success.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.Battery, { size: 120, animated: true }), title: "Total Fuels", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.totalFuels), subtitle: "Combined Fuel Resources", color: "primary.main" }
              ].map((card, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                Grid,
                {
                  item: true,
                  xs: 6,
                  sm: 6,
                  md: 4,
                  lg: 3,
                  xl: 3,
                  sx: {
                    display: "flex",
                    justifyContent: "center",
                    width: { xs: "100%", sm: "100%", md: "auto" },
                    maxWidth: { xs: "100%", sm: "100%", md: "none" },
                    flexBasis: { xs: "100%", sm: "100%", md: "auto" }
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                    width: { xs: "100%", sm: "100%", md: "100%" },
                    maxWidth: "100%",
                    animation: "fadeInUp 0.6s ease-out",
                    animationDelay: `${index2 * 0.08}s`,
                    animationFillMode: "both"
                  }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    StatCard,
                    {
                      icon: card.icon,
                      title: card.title,
                      value: card.value,
                      subtitle: card.subtitle,
                      color: card.color
                    }
                  ) })
                },
                `financial-${index2}`
              ))
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: {
          p: { xs: 2, sm: 3, md: 4 },
          backgroundColor: "white",
          borderRadius: { xs: 3, sm: 4 },
          boxShadow: { xs: 2, sm: 4, md: 6 },
          mb: { xs: 2, sm: 3 },
          width: "100%",
          border: "1px solid rgba(0, 0, 0, 0.08)",
          position: "relative",
          overflow: "hidden",
          transition: "all 0.4s cubic-bezier(0.4, 0, 0.2, 1)",
          animation: "slideInUp 1.2s ease-out",
          animationDelay: "0.3s",
          animationFillMode: "both",
          "&:hover": {
            boxShadow: { xs: 4, sm: 8, md: 12 },
            transform: "translateY(-4px) scale(1.01)"
          },
          "&::before": {
            content: '""',
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            height: "3px",
            background: "linear-gradient(90deg, #ff9800 0%, #ffcc02 50%, #ff9800 100%)",
            backgroundSize: "200% 100%",
            animation: "shimmer 3s ease-in-out infinite"
          }
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
            position: "absolute",
            top: 16,
            left: 16,
            width: 12,
            height: 12,
            zIndex: 1
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "circle",
            {
              cx: "6",
              cy: "6",
              r: "5",
              fill: "none",
              stroke: "#ff9800",
              strokeWidth: "1",
              opacity: "0.6",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animate",
                  {
                    attributeName: "r",
                    values: "3;5;3",
                    dur: "2.2s",
                    repeatCount: "indefinite"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "animate",
                  {
                    attributeName: "opacity",
                    values: "0.7;0.3;0.7",
                    dur: "2.2s",
                    repeatCount: "indefinite"
                  }
                )
              ]
            }
          ) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "h6",
              gutterBottom: true,
              sx: {
                color: "primary.main",
                mb: { xs: 2, sm: 3 },
                fontSize: { xs: "1.1rem", sm: "1.2rem", md: "1.35rem" },
                fontWeight: 700,
                textAlign: { xs: "center", sm: "left" },
                letterSpacing: "-0.01em",
                pl: { xs: 0, sm: 3 }
              },
              children: "Earnings Breakdown"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grid,
            {
              container: true,
              spacing: { xs: 1.5, sm: 2, md: 2.5, lg: 3 },
              sx: {
                width: "100%",
                margin: 0,
                justifyContent: { xs: "center", sm: "flex-start" }
              },
              children: [
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.Users, { size: 120, animated: true }), title: "Referral Earn", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.referralEarn), subtitle: "From Direct Referrals", color: "primary.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.BarChart3, { size: 120, animated: true }), title: "Level Earn", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.levelEarn), subtitle: "From Team Levels", color: "info.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.TrendingUp, { size: 120, animated: true }), title: "Growth Earn", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.growthEarn), subtitle: "From Growth System", color: "success.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.Trophy, { size: 120, animated: true }), title: "Leader Earn", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.leaderEarn), subtitle: "From Leadership", color: "warning.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.BarChart3, { size: 120, animated: true }), title: "Development Earn", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.developmentEarn), subtitle: "From Development", color: "info.main" },
                { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomSVGIcons.Users, { size: 120, animated: true }), title: "Team Growth", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 100 }) : formatCurrency(mlmData.teamGrowthWallet), subtitle: "Team Growth Wallet", color: "secondary.main" }
              ].map((card, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                Grid,
                {
                  item: true,
                  xs: 6,
                  sm: 6,
                  md: 4,
                  lg: 3,
                  xl: 3,
                  sx: {
                    display: "flex",
                    justifyContent: "center",
                    width: { xs: "100%", sm: "100%", md: "auto" },
                    maxWidth: { xs: "100%", sm: "100%", md: "none" },
                    flexBasis: { xs: "100%", sm: "100%", md: "auto" }
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                    width: { xs: "100%", sm: "100%", md: "100%" },
                    maxWidth: "100%",
                    animation: "fadeInUp 0.6s ease-out",
                    animationDelay: `${index2 * 0.12}s`,
                    animationFillMode: "both"
                  }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    StatCard,
                    {
                      icon: card.icon,
                      title: card.title,
                      value: card.value,
                      subtitle: card.subtitle,
                      color: card.color
                    }
                  ) })
                },
                `earnings-${index2}`
              ))
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: { xs: 2, sm: 2.5, md: 3 }, sx: { width: "100%", margin: 0 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grid,
            {
              item: true,
              xs: 12,
              sm: 12,
              md: 6,
              lg: 6,
              xl: 6,
              sx: {
                display: "flex",
                justifyContent: "center",
                width: { xs: "100%", sm: "100%", md: "auto" },
                maxWidth: { xs: "100%", sm: "100%", md: "none" },
                flexBasis: { xs: "100%", sm: "100%", md: "auto" }
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                width: { xs: "100%", sm: "100%", md: "100%" },
                maxWidth: "100%"
              }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: {
                p: { xs: 2, sm: 3, md: 4 },
                backgroundColor: "white",
                borderRadius: { xs: 3, sm: 4 },
                boxShadow: { xs: 2, sm: 4, md: 6 },
                height: "fit-content",
                width: "100%",
                border: "1px solid rgba(0, 0, 0, 0.08)",
                position: "relative",
                overflow: "hidden",
                transition: "all 0.4s cubic-bezier(0.4, 0, 0.2, 1)",
                animation: "slideInLeft 1.4s ease-out",
                animationDelay: "0.4s",
                animationFillMode: "both",
                "&:hover": {
                  boxShadow: { xs: 4, sm: 8, md: 12 },
                  transform: "translateY(-4px) scale(1.01)"
                },
                "&::before": {
                  content: '""',
                  position: "absolute",
                  top: 0,
                  left: 0,
                  right: 0,
                  height: "3px",
                  background: "linear-gradient(90deg, #2196f3 0%, #64b5f6 50%, #2196f3 100%)",
                  backgroundSize: "200% 100%",
                  animation: "shimmer 3s ease-in-out infinite"
                },
                "@keyframes slideInLeft": {
                  "0%": { opacity: 0, transform: "translateX(-30px)" },
                  "100%": { opacity: 1, transform: "translateX(0)" }
                }
              }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                  position: "absolute",
                  top: 16,
                  left: 16,
                  width: 12,
                  height: 12,
                  zIndex: 1
                }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "circle",
                  {
                    cx: "6",
                    cy: "6",
                    r: "5",
                    fill: "none",
                    stroke: "#2196f3",
                    strokeWidth: "1",
                    opacity: "0.6",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animate",
                        {
                          attributeName: "r",
                          values: "2;5;2",
                          dur: "2.8s",
                          repeatCount: "indefinite"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animate",
                        {
                          attributeName: "opacity",
                          values: "0.8;0.2;0.8",
                          dur: "2.8s",
                          repeatCount: "indefinite"
                        }
                      )
                    ]
                  }
                ) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Typography,
                  {
                    variant: "h6",
                    gutterBottom: true,
                    sx: {
                      color: "primary.main",
                      fontWeight: 700,
                      mb: { xs: 2, sm: 3 },
                      fontSize: { xs: "1.1rem", sm: "1.2rem", md: "1.35rem" },
                      textAlign: { xs: "center", sm: "left" },
                      letterSpacing: "-0.01em",
                      pl: { xs: 0, sm: 3 }
                    },
                    children: "Trading & Staking"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TradingSection,
                  {
                    buyAmount,
                    setBuyAmount,
                    sellAmount,
                    setSellAmount,
                    buyTokenAmount,
                    setBuyTokenAmount,
                    onBuy: handleBuy,
                    onSell: handleSell,
                    onBuyToken: handleBuyToken,
                    orderLoading
                  }
                )
              ] }) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grid,
            {
              item: true,
              xs: 12,
              sm: 12,
              md: 6,
              lg: 6,
              xl: 6,
              sx: {
                display: "flex",
                justifyContent: "center",
                width: { xs: "100%", sm: "100%", md: "auto" },
                maxWidth: { xs: "100%", sm: "100%", md: "none" },
                flexBasis: { xs: "100%", sm: "100%", md: "auto" }
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                width: { xs: "100%", sm: "100%", md: "100%" },
                maxWidth: "100%"
              }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: {
                p: { xs: 2, sm: 3, md: 4 },
                backgroundColor: "white",
                borderRadius: { xs: 3, sm: 4 },
                boxShadow: { xs: 2, sm: 4, md: 6 },
                height: "fit-content",
                width: "100%",
                border: "1px solid rgba(0, 0, 0, 0.08)",
                position: "relative",
                overflow: "hidden",
                transition: "all 0.4s cubic-bezier(0.4, 0, 0.2, 1)",
                animation: "slideInRight 1.4s ease-out",
                animationDelay: "0.5s",
                animationFillMode: "both",
                "&:hover": {
                  boxShadow: { xs: 4, sm: 8, md: 12 },
                  transform: "translateY(-4px) scale(1.01)"
                },
                "&::before": {
                  content: '""',
                  position: "absolute",
                  top: 0,
                  left: 0,
                  right: 0,
                  height: "3px",
                  background: "linear-gradient(90deg, #673ab7 0%, #9575cd 50%, #673ab7 100%)",
                  backgroundSize: "200% 100%",
                  animation: "shimmer 3s ease-in-out infinite"
                },
                "@keyframes slideInRight": {
                  "0%": { opacity: 0, transform: "translateX(30px)" },
                  "100%": { opacity: 1, transform: "translateX(0)" }
                }
              }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                  position: "absolute",
                  top: 16,
                  left: 16,
                  width: 12,
                  height: 12,
                  zIndex: 1
                }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "circle",
                  {
                    cx: "6",
                    cy: "6",
                    r: "5",
                    fill: "none",
                    stroke: "#673ab7",
                    strokeWidth: "1",
                    opacity: "0.6",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animate",
                        {
                          attributeName: "r",
                          values: "4;6;4",
                          dur: "2.6s",
                          repeatCount: "indefinite"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animate",
                        {
                          attributeName: "opacity",
                          values: "0.6;0.2;0.6",
                          dur: "2.6s",
                          repeatCount: "indefinite"
                        }
                      )
                    ]
                  }
                ) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Typography,
                  {
                    variant: "h6",
                    gutterBottom: true,
                    sx: {
                      color: "primary.main",
                      fontWeight: 700,
                      mb: { xs: 2, sm: 3 },
                      fontSize: { xs: "1.1rem", sm: "1.2rem", md: "1.35rem" },
                      textAlign: { xs: "center", sm: "left" },
                      letterSpacing: "-0.01em",
                      pl: { xs: 0, sm: 3 }
                    },
                    children: "Your Referral Code"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ReferralSection,
                  {
                    account: wallet.account,
                    onCopy: () => setSuccess("Referral code copied to clipboard!"),
                    onShare: () => setSuccess("Referral shared successfully!")
                  }
                )
              ] }) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grid,
            {
              item: true,
              xs: 12,
              sm: 12,
              md: 6,
              lg: 6,
              xl: 6,
              sx: {
                display: "flex",
                justifyContent: "center",
                width: { xs: "100%", sm: "100%", md: "auto" },
                maxWidth: { xs: "100%", sm: "100%", md: "none" },
                flexBasis: { xs: "100%", sm: "100%", md: "auto" }
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                width: { xs: "100%", sm: "100%", md: "100%" },
                maxWidth: "100%"
              }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: {
                p: { xs: 2, sm: 3, md: 4 },
                backgroundColor: "white",
                borderRadius: { xs: 3, sm: 4 },
                boxShadow: { xs: 2, sm: 4, md: 6 },
                height: "fit-content",
                width: "100%",
                border: "1px solid rgba(0, 0, 0, 0.08)",
                position: "relative",
                overflow: "hidden",
                transition: "all 0.4s cubic-bezier(0.4, 0, 0.2, 1)",
                animation: "slideInLeft 1.6s ease-out",
                animationDelay: "0.6s",
                animationFillMode: "both",
                "&:hover": {
                  boxShadow: { xs: 4, sm: 8, md: 12 },
                  transform: "translateY(-4px) scale(1.01)"
                },
                "&::before": {
                  content: '""',
                  position: "absolute",
                  top: 0,
                  left: 0,
                  right: 0,
                  height: "3px",
                  background: "linear-gradient(90deg, #4caf50 0%, #81c784 50%, #4caf50 100%)",
                  backgroundSize: "200% 100%",
                  animation: "shimmer 3s ease-in-out infinite"
                }
              }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                  position: "absolute",
                  top: 16,
                  left: 16,
                  width: 12,
                  height: 12,
                  zIndex: 1
                }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "circle",
                  {
                    cx: "6",
                    cy: "6",
                    r: "5",
                    fill: "none",
                    stroke: "#4caf50",
                    strokeWidth: "1",
                    opacity: "0.6",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animate",
                        {
                          attributeName: "r",
                          values: "3;6;3",
                          dur: "2.4s",
                          repeatCount: "indefinite"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animate",
                        {
                          attributeName: "opacity",
                          values: "0.7;0.2;0.7",
                          dur: "2.4s",
                          repeatCount: "indefinite"
                        }
                      )
                    ]
                  }
                ) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Typography,
                  {
                    variant: "h6",
                    gutterBottom: true,
                    sx: {
                      fontWeight: 700,
                      mb: { xs: 2, sm: 3 },
                      textAlign: "center",
                      color: "primary.main",
                      fontSize: { xs: "1.1rem", sm: "1.2rem", md: "1.35rem" },
                      letterSpacing: "-0.01em",
                      pl: { xs: 0, sm: 3 }
                    },
                    children: "Withdrawal Information"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 3 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
                    backgroundColor: "#f8f9fa",
                    p: { xs: 1.5, sm: 2 },
                    display: "flex",
                    justifyContent: "space-between",
                    borderRadius: "12px 12px 0 0",
                    borderBottom: "2px solid #e9ecef",
                    boxShadow: "0 2px 4px rgba(0,0,0,0.05)"
                  }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { fontWeight: 700, color: "text.primary", fontSize: { xs: "0.85rem", sm: "0.9rem" } }, children: "Earning Type" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { fontWeight: 700, color: "text.primary", fontSize: { xs: "0.85rem", sm: "0.9rem" } }, children: "Available Amount" })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                    border: "1px solid #e9ecef",
                    borderTop: "none",
                    borderRadius: "0 0 12px 12px",
                    overflow: "hidden",
                    boxShadow: "0 2px 8px rgba(0,0,0,0.08)"
                  }, children: [
                    { label: "Referral Earnings", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 16, width: 60 }) : mlmData.referralEarn },
                    { label: "Level Earnings", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 16, width: 60 }) : mlmData.levelEarn },
                    { label: "Growth Earnings", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 16, width: 60 }) : mlmData.growthEarn },
                    { label: "Team Growth Gains", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 16, width: 60 }) : mlmData.teamGrowthWallet },
                    { label: "Leader Earnings", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 16, width: 60 }) : mlmData.leaderEarn },
                    { label: "Development Earnings", value: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 16, width: 60 }) : mlmData.developmentEarn }
                  ].map((item, index2, array) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Box,
                    {
                      sx: {
                        display: "flex",
                        justifyContent: "space-between",
                        p: { xs: 1.5, sm: 2 },
                        borderBottom: index2 < array.length - 1 ? "1px solid #f1f3f4" : "none",
                        transition: "all 0.2s ease",
                        "&:hover": {
                          backgroundColor: "#f8f9fa"
                        }
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: {
                          color: "text.primary",
                          fontSize: { xs: "0.8rem", sm: "0.9rem" },
                          fontWeight: 500
                        }, children: item.label }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: {
                          fontWeight: 700,
                          color: "success.main",
                          fontSize: { xs: "0.8rem", sm: "0.9rem" }
                        }, children: typeof item.value === "object" ? item.value : `+ $${formatNumber(item.value)}` })
                      ]
                    },
                    item.label
                  )) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
                  backgroundColor: "#f8f9fa",
                  p: { xs: 2, sm: 3 },
                  borderRadius: 3,
                  mb: 3,
                  textAlign: "center",
                  border: "2px solid #e9ecef",
                  boxShadow: "0 4px 12px rgba(0,0,0,0.08)",
                  position: "relative",
                  overflow: "hidden",
                  "&::before": {
                    content: '""',
                    position: "absolute",
                    top: 0,
                    left: 0,
                    right: 0,
                    height: "3px",
                    background: "linear-gradient(90deg, #4caf50 0%, #81c784 50%, #4caf50 100%)",
                    backgroundSize: "200% 100%",
                    animation: "shimmer 2s ease-in-out infinite"
                  }
                }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: {
                    fontWeight: 800,
                    color: "primary.main",
                    mb: 1,
                    fontSize: { xs: "1.6rem", sm: "2.2rem", md: "2.8rem" },
                    letterSpacing: "-0.02em"
                  }, children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, { height: 40, width: 120 }) : `$${formatNumber(
                    mlmData.referralEarn + mlmData.levelEarn + mlmData.growthEarn + mlmData.teamGrowthWallet + mlmData.leaderEarn + mlmData.developmentEarn
                  )}` }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", sx: {
                    color: "text.secondary",
                    fontWeight: 600,
                    fontSize: { xs: "0.85rem", sm: "0.95rem", md: "1.05rem" }
                  }, children: "Total Available for Withdrawal" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    variant: "contained",
                    size: "large",
                    sx: {
                      backgroundColor: "#4CAF50",
                      color: "white",
                      borderRadius: "30px",
                      px: { xs: 4, sm: 5 },
                      py: { xs: 1.5, sm: 2 },
                      fontSize: { xs: "0.95rem", sm: "1.05rem", md: "1.15rem" },
                      fontWeight: 700,
                      textTransform: "none",
                      boxShadow: "0 6px 20px rgba(76, 175, 80, 0.3)",
                      transition: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
                      "&:hover": {
                        backgroundColor: "#45a049",
                        transform: "translateY(-2px)",
                        boxShadow: "0 8px 25px rgba(76, 175, 80, 0.4)"
                      },
                      "&:disabled": {
                        backgroundColor: "#cccccc",
                        transform: "none",
                        boxShadow: "none"
                      }
                    },
                    disabled: orderLoading || mlmData.referralEarn + mlmData.levelEarn + mlmData.growthEarn + mlmData.teamGrowthWallet + mlmData.leaderEarn + mlmData.developmentEarn <= 0,
                    onClick: handleWithdraw,
                    children: orderLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 24, color: "inherit" }) : "Withdraw Earnings"
                  }
                ) })
              ] }) })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grid,
            {
              item: true,
              xs: 12,
              sm: 12,
              md: 6,
              lg: 6,
              xl: 6,
              sx: {
                display: "flex",
                justifyContent: "center",
                width: { xs: "100%", sm: "100%", md: "auto" },
                maxWidth: { xs: "100%", sm: "100%", md: "none" },
                flexBasis: { xs: "100%", sm: "100%", md: "auto" }
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                width: { xs: "100%", sm: "100%", md: "100%" },
                maxWidth: "100%"
              }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: {
                p: { xs: 2, sm: 3, md: 4 },
                backgroundColor: "white",
                borderRadius: { xs: 3, sm: 4 },
                boxShadow: { xs: 2, sm: 4, md: 6 },
                height: "fit-content",
                width: "100%",
                border: "1px solid rgba(0, 0, 0, 0.08)",
                position: "relative",
                overflow: "hidden",
                transition: "all 0.4s cubic-bezier(0.4, 0, 0.2, 1)",
                animation: "slideInRight 1.6s ease-out",
                animationDelay: "0.7s",
                animationFillMode: "both",
                "&:hover": {
                  boxShadow: { xs: 4, sm: 8, md: 12 },
                  transform: "translateY(-4px) scale(1.01)"
                },
                "&::before": {
                  content: '""',
                  position: "absolute",
                  top: 0,
                  left: 0,
                  right: 0,
                  height: "3px",
                  background: "linear-gradient(90deg, #f44336 0%, #ef5350 50%, #f44336 100%)",
                  backgroundSize: "200% 100%",
                  animation: "shimmer 3s ease-in-out infinite"
                }
              }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
                  position: "absolute",
                  top: 16,
                  left: 16,
                  width: 12,
                  height: 12,
                  zIndex: 1
                }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "circle",
                  {
                    cx: "6",
                    cy: "6",
                    r: "5",
                    fill: "none",
                    stroke: "#f44336",
                    strokeWidth: "1",
                    opacity: "0.6",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animate",
                        {
                          attributeName: "r",
                          values: "2;6;2",
                          dur: "3.2s",
                          repeatCount: "indefinite"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animate",
                        {
                          attributeName: "opacity",
                          values: "0.8;0.2;0.8",
                          dur: "3.2s",
                          repeatCount: "indefinite"
                        }
                      )
                    ]
                  }
                ) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Typography,
                  {
                    variant: "h6",
                    gutterBottom: true,
                    sx: {
                      color: "primary.main",
                      fontWeight: 700,
                      mb: { xs: 2, sm: 3 },
                      fontSize: { xs: "1.1rem", sm: "1.2rem", md: "1.35rem" },
                      textAlign: { xs: "center", sm: "left" },
                      letterSpacing: "-0.01em",
                      pl: { xs: 0, sm: 3 }
                    },
                    children: "Order History"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  OrderHistoryTable,
                  {
                    orderHistory,
                    orderLoading,
                    formatDate
                  }
                )
              ] }) })
            }
          )
        ] })
      ]
    }
  ) });
};
function TabPanel({ children, value, index: index2, ...other }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      role: "tabpanel",
      hidden: value !== index2,
      id: `history-tabpanel-${index2}`,
      "aria-labelledby": `history-tab-${index2}`,
      ...other,
      children: value === index2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { p: 3 }, children })
    }
  );
}
const HistoryPage = () => {
  const wallet = useWallet();
  const [tabValue, setTabValue] = reactExports.useState(0);
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const [historyData, setHistoryData] = reactExports.useState(null);
  const fetchHistoryData = async () => {
    if (!wallet.isConnected || !wallet.account) {
      setError("Please connect your wallet to view history");
      return;
    }
    try {
      setLoading(true);
      setError("");
      console.log(" [HistoryPage] Fetching complete history for:", wallet.account);
      const data2 = await stakingInteractions.getCompleteUserHistory(wallet.account);
      setHistoryData(data2);
      console.log(" [HistoryPage] History data received:", {
        stakeHistoryCount: data2?.stakeHistory?.length || 0,
        directReferralsCount: data2?.directReferrals?.length || 0,
        sampleStake: data2?.stakeHistory?.[0] || null
      });
    } catch (error2) {
      console.error(" [HistoryPage] Error fetching history:", error2);
      setError(`Failed to fetch history data: ${error2.message || "Please try again."}`);
    } finally {
      setLoading(false);
    }
  };
  reactExports.useEffect(() => {
    if (wallet.isConnected && wallet.account) {
      fetchHistoryData();
    }
  }, [wallet.isConnected, wallet.account]);
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };
  if (!wallet.isConnected) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "xl", sx: { py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "warning", children: "Please connect your wallet to view your transaction history." }) });
  }
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "xl", sx: { py: 4, display: "flex", justifyContent: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {}) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "xl", sx: { py: 4 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 4, display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h4", gutterBottom: true, sx: { color: "primary.main", fontWeight: "bold", display: "flex", alignItems: "center" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { style: { marginRight: 8 } }),
          "Transaction History"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", color: "text.secondary", children: "Complete overview of your USDT deposits, withdrawals, team activity, and earnings history" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          variant: "outlined",
          startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshCw, { size: 18 }),
          onClick: fetchHistoryData,
          disabled: loading,
          sx: {
            borderRadius: "25px",
            px: 3,
            "&:hover": {
              backgroundColor: "primary.main",
              color: "white"
            }
          },
          children: loading ? "Refreshing..." : "Refresh Data"
        }
      )
    ] }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 3 }, onClose: () => setError(""), children: error }),
    historyData && /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 3, sx: { mb: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "primary.main", color: "white", boxShadow: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: "bold" }, children: "Total Stakes" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: historyData.stakeHistory?.length || 0 })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Wallet, { size: 40, style: { opacity: 0.8 } })
      ] }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "success.main", color: "white", boxShadow: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: "bold" }, children: "Active Deposits" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: historyData.stakeHistory?.filter((stake) => !stake.isComplete).length || 0 })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 40, style: { opacity: 0.8 } })
      ] }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "info.main", color: "white", boxShadow: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: "bold" }, children: "Completed" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: historyData.stakeHistory?.filter((stake) => stake.isComplete).length || 0 })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 40, style: { opacity: 0.8 } })
      ] }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "secondary.main", color: "white", boxShadow: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { fontWeight: "bold" }, children: "Direct Team" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: historyData.directReferrals?.length || 0 })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { size: 40, style: { opacity: 0.8 } })
      ] }) }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { sx: { mb: 3 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Tabs,
        {
          value: tabValue,
          onChange: handleTabChange,
          variant: "scrollable",
          scrollButtons: "auto",
          sx: { borderBottom: 1, borderColor: "divider" },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Tab,
              {
                label: "Deposits",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { size: 18 }),
                iconPosition: "start"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Tab,
              {
                label: "Withdrawals",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingDown, { size: 18 }),
                iconPosition: "start"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Tab,
              {
                label: "Direct Team",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { size: 18 }),
                iconPosition: "start"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Tab,
              {
                label: "Team Overview",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UsersRound, { size: 18 }),
                iconPosition: "start"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Tab,
              {
                label: "Earnings",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DollarSign, { size: 18 }),
                iconPosition: "start"
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabPanel, { value: tabValue, index: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DepositHistory, { historyData }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabPanel, { value: tabValue, index: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(WithdrawalHistory, { historyData }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabPanel, { value: tabValue, index: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DirectTeamHistory, { historyData }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabPanel, { value: tabValue, index: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TeamOverview, { historyData }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabPanel, { value: tabValue, index: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(EarningsHistory, { historyData }) })
    ] })
  ] });
};
const DepositHistory = ({ historyData }) => {
  const deposits = historyData?.stakeHistory?.filter((stake) => !stake.isComplete) || [];
  if (deposits.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { textAlign: "center", py: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 64, style: { color: "#9e9e9e", marginBottom: 16 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", color: "text.secondary", children: "No active deposits" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "All your deposits have been completed or withdrawn." })
    ] });
  }
  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 3, sx: { mb: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "white", boxShadow: 3, borderRadius: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "primary.main", fontWeight: "bold" }, children: "Active Deposits" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", sx: { color: "text.primary" }, children: deposits.length })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 40, style: { color: "#6200ea" } })
      ] }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "white", boxShadow: 3, borderRadius: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "success.main", fontWeight: "bold" }, children: "Total Invested" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", sx: { color: "text.primary" }, children: formatCurrency(
            deposits.reduce((sum, deposit) => {
              const amount = deposit.amount || Number(deposit.orderValue || 0);
              console.log(" [Summary] Deposit amount:", amount);
              return sum + amount;
            }, 0)
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DollarSign, { size: 40, style: { color: "#4caf50" } })
      ] }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "white", boxShadow: 3, borderRadius: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "info.main", fontWeight: "bold" }, children: "Expected Growth" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", sx: { color: "text.primary" }, children: formatCurrency(
            deposits.reduce((sum, deposit) => {
              const orderGrowth = deposit.orderGrowth || BigInt(0);
              const amount = Number(orderGrowth);
              return sum + amount;
            }, 0)
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 40, style: { color: "#2196f3" } })
      ] }) }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", gutterBottom: true, sx: { display: "flex", alignItems: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Clock3, { size: 20, style: { marginRight: 8 } }),
        "Active Deposits (",
        deposits.length,
        ")"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { sx: { backgroundColor: "grey.50" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Order Details" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Investment" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Growth" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Timeline" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Status" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Actions" }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: deposits.length > 0 ? deposits.map((deposit, index2) => {
          const orderValue = deposit.orderValue || BigInt(0);
          const orderGrowth = deposit.orderGrowth || BigInt(0);
          const orderTime = Number(deposit.orderTime || 0);
          const orderId = deposit.orderID?.toString() || `DEP-${index2 + 1}`;
          const growthRate = Number(orderGrowth);
          console.log(" [DepositHistory] Deposit data:", {
            orderValue: orderValue.toString(),
            orderGrowth: orderGrowth.toString(),
            orderTime,
            orderId,
            amount: deposit.amount,
            timestamp: deposit.timestamp,
            date: deposit.date,
            remainingTime: deposit.remainingTime
          });
          let investmentAmount = deposit.amount || Number(orderValue);
          let growthAmount = Number(orderGrowth);
          console.log(" [DepositHistory] Parsed amounts:", { investmentAmount, growthAmount });
          const isMature = Number(deposit.isMature || 0) > 0;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { hover: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", fontWeight: "bold", color: "primary.main", children: [
                "#",
                orderId
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: "Order ID" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", fontWeight: "bold", color: "primary.main", children: formatCurrency(investmentAmount) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: "USDT Invested" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body1", fontWeight: "bold", color: "success.main", children: [
                "+",
                formatCurrency(growthAmount)
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", color: "success.main", children: [
                growthRate,
                "% Growth Rate"
              ] })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", fontWeight: "bold", children: deposit.date || (orderTime > 0 ? formatDate(orderTime) : "N/A") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: orderTime > 0 ? formatTimeAgo(orderTime) : "Deposit Date" }),
              deposit.remainingTime && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Typography,
                {
                  variant: "caption",
                  color: deposit.remainingTime === "Matured" || deposit.remainingTime === "Completed" ? "success.main" : "warning.main",
                  sx: { display: "block", mt: 0.5, fontWeight: "bold" },
                  children: [
                    " ",
                    deposit.remainingTime
                  ]
                }
              )
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", flexDirection: "column", gap: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Chip,
                {
                  label: deposit.isComplete ? "Completed" : "Active",
                  color: deposit.isComplete ? "success" : "primary",
                  size: "small",
                  icon: deposit.isComplete ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { size: 16 })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Chip,
                {
                  label: isMature ? "Mature" : "Growing",
                  color: isMature ? "success" : "warning",
                  size: "small",
                  variant: "outlined"
                }
              )
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", gap: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Copy Order ID", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  size: "small",
                  onClick: () => copyToClipboard(orderId),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { size: 16 })
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "View on Explorer", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  size: "small",
                  onClick: () => window.open(`https://bscscan.com/tx/${orderId}`, "_blank"),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { size: 16 })
                }
              ) })
            ] }) })
          ] }, `deposit-${index2}-${orderId}`);
        }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell, { colSpan: 6, sx: { textAlign: "center", py: 4 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Wallet, { size: 48, style: { color: "#9e9e9e", marginBottom: 8 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", color: "text.secondary", children: "No active deposits found" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Your deposit transactions will appear here once you make your first deposit." })
        ] }) }) })
      ] }) })
    ] }) })
  ] });
};
const WithdrawalHistory = ({ historyData }) => {
  const withdrawals = historyData?.stakeHistory?.filter((stake) => stake.isComplete) || [];
  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text);
  };
  const totalWithdrawn = withdrawals.reduce((sum, withdrawal) => {
    const orderValue = withdrawal.orderValue || BigInt(0);
    const orderGrowth = withdrawal.orderGrowth || BigInt(0);
    const principal = Number(orderValue);
    const growth = Number(orderGrowth);
    return sum + principal + growth;
  }, 0);
  const totalProfit = withdrawals.reduce((sum, withdrawal) => {
    const orderGrowth = withdrawal.orderGrowth || BigInt(0);
    const growth = Number(orderGrowth);
    return sum + growth;
  }, 0);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 3, sx: { mb: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "white", boxShadow: 3, borderRadius: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "success.main", fontWeight: "bold" }, children: "Completed" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", sx: { color: "text.primary" }, children: withdrawals.length })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 40, style: { color: "#4caf50" } })
      ] }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "white", boxShadow: 3, borderRadius: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "error.main", fontWeight: "bold" }, children: "Total Withdrawn" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", sx: { color: "text.primary" }, children: formatCurrency(totalWithdrawn) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingDown, { size: 40, style: { color: "#f44336" } })
      ] }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "white", boxShadow: 3, borderRadius: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "warning.main", fontWeight: "bold" }, children: "Total Profit" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", sx: { color: "text.primary" }, children: formatCurrency(totalProfit) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DollarSign, { size: 40, style: { color: "#ff9800" } })
      ] }) }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", gutterBottom: true, sx: { display: "flex", alignItems: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingDown, { size: 20, style: { marginRight: 8 } }),
        "Completed Withdrawals (",
        withdrawals.length,
        ")"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { sx: { backgroundColor: "grey.50" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Order Details" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Principal" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Profit Earned" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Total Received" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Completion Date" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Actions" }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: withdrawals.length > 0 ? withdrawals.map((withdrawal, index2) => {
          const orderValue = withdrawal.orderValue || BigInt(0);
          const orderGrowth = withdrawal.orderGrowth || BigInt(0);
          const orderTime = Number(withdrawal.orderTime || 0);
          const orderId = withdrawal.orderID?.toString() || `WTH-${index2 + 1}`;
          const principalAmount = Number(orderValue);
          const growthAmount = Number(orderGrowth);
          const totalReceived = principalAmount + growthAmount;
          const profitPercentage = principalAmount > 0 ? growthAmount / principalAmount * 100 : 0;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { hover: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", fontWeight: "bold", color: "primary.main", children: [
                "#",
                orderId
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: "Order ID" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", fontWeight: "bold", color: "primary.main", children: formatCurrency(principalAmount) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: "Original Investment" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body1", fontWeight: "bold", color: "success.main", children: [
                "+",
                formatCurrency(growthAmount)
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "caption", color: "success.main", children: [
                profitPercentage.toFixed(1),
                "% Profit"
              ] })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", fontWeight: "bold", color: "secondary.main", children: formatCurrency(totalReceived) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: "Total Payout" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", fontWeight: "bold", children: withdrawal.date || (orderTime > 0 ? formatDate(orderTime) : "N/A") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: orderTime > 0 ? formatTimeAgo(orderTime) : "Completion Date" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Chip,
                {
                  label: " Completed",
                  color: "success",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingDown, { size: 16 }),
                  sx: { mt: 0.5, display: "block", width: "fit-content" }
                }
              )
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", gap: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Copy Order ID", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  size: "small",
                  onClick: () => copyToClipboard(orderId),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { size: 16 })
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "View on Explorer", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  size: "small",
                  onClick: () => window.open(`https://bscscan.com/tx/${orderId}`, "_blank"),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { size: 16 })
                }
              ) })
            ] }) })
          ] }, `withdrawal-${index2}-${orderId}`);
        }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell, { colSpan: 6, sx: { textAlign: "center", py: 4 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingDown, { size: 48, style: { color: "#9e9e9e", marginBottom: 8 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", color: "text.secondary", children: "No completed withdrawals found" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Your completed withdrawal transactions will appear here." })
        ] }) }) })
      ] }) })
    ] }) })
  ] });
};
const DirectTeamHistory = ({ historyData }) => {
  const teamDetails = historyData?.teamDetails || [];
  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 3, sx: { mb: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { background: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)", color: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: " Direct Team" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: teamDetails.length })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { size: 40, style: { opacity: 0.8 } })
      ] }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { background: "linear-gradient(135deg, #f093fb 0%, #f5576c 100%)", color: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: " Total Deposits" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: formatCurrency(teamDetails.reduce((sum, member) => sum + member.recentDeposited, 0)) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DollarSign, { size: 40, style: { opacity: 0.8 } })
      ] }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { background: "linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)", color: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: " Active Members" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: teamDetails.filter((member) => member.userStatus === "Active").length })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 40, style: { opacity: 0.8 } })
      ] }) }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", gutterBottom: true, sx: { display: "flex", alignItems: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { size: 20, style: { marginRight: 8 } }),
        "Direct Team Members (",
        teamDetails.length,
        ")"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { sx: { backgroundColor: "grey.50" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " Date" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " Address" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " Sponsor" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " Level" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " Directs" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " Recent Deposited" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " Tag Name" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " User Status" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " Actions" }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: teamDetails.length > 0 ? teamDetails.map((member, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          TableRow,
          {
            hover: true,
            sx: {
              "&:hover": {
                backgroundColor: "rgba(25, 118, 210, 0.08)",
                transform: "scale(1.01)",
                transition: "all 0.2s ease-in-out",
                boxShadow: "0 4px 8px rgba(0,0,0,0.1)"
              },
              cursor: "pointer",
              transition: "all 0.2s ease-in-out"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", fontWeight: "bold", children: member.date }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: formatTimeAgo(member.joinTimestamp) })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Tooltip,
                {
                  title: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { p: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", fontWeight: "bold", children: "Full Address:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { fontFamily: "monospace", wordBreak: "break-all" }, children: member.address }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "grey.300", sx: { mt: 1, display: "block" }, children: "Click to copy full address" })
                  ] }),
                  arrow: true,
                  placement: "top",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Box,
                    {
                      onClick: () => copyToClipboard(member.address),
                      sx: {
                        cursor: "pointer",
                        "&:hover": { backgroundColor: "rgba(0,0,0,0.04)", borderRadius: 1, p: 0.5 }
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { fontFamily: "monospace", fontWeight: "bold" }, children: `${member.address.slice(0, 8)}...${member.address.slice(-6)}` }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: " Click to copy" })
                      ]
                    }
                  )
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { fontFamily: "monospace", fontWeight: "bold" }, children: `${member.sponsor.slice(0, 8)}...${member.sponsor.slice(-6)}` }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: " Sponsor" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Chip,
                {
                  label: `Level ${member.level}`,
                  color: "primary",
                  size: "small",
                  sx: { fontWeight: "bold" }
                }
              ) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { textAlign: "center" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", fontWeight: "bold", color: "secondary.main", children: member.directs }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: "Direct Refs" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", fontWeight: "bold", color: "success.main", children: formatCurrency(member.recentDeposited) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: "Latest Deposit" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", fontWeight: "bold", color: "primary.main", children: member.tagName }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: " Tag" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Chip,
                {
                  label: member.userStatus,
                  color: member.userStatus === "Active" ? "success" : member.userStatus === "Inactive" ? "error" : "default",
                  size: "small",
                  icon: member.userStatus === "Active" ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { size: 16 }),
                  sx: { fontWeight: "bold" }
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", gap: 1 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Copy Address", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton,
                  {
                    size: "small",
                    onClick: () => copyToClipboard(member.address),
                    sx: {
                      "&:hover": {
                        backgroundColor: "primary.main",
                        color: "white",
                        transform: "scale(1.1)"
                      },
                      transition: "all 0.2s ease"
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { size: 16 })
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "View on BSCScan", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton,
                  {
                    size: "small",
                    onClick: () => window.open(`https://bscscan.com/address/${member.address}`, "_blank"),
                    sx: {
                      "&:hover": {
                        backgroundColor: "success.main",
                        color: "white",
                        transform: "scale(1.1)"
                      },
                      transition: "all 0.2s ease"
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { size: 16 })
                  }
                ) })
              ] }) })
            ]
          },
          `team-member-${index2}`
        )) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell, { colSpan: 9, sx: { textAlign: "center", py: 4 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { size: 48, style: { color: "#9e9e9e", marginBottom: 8 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", color: "text.secondary", children: "No direct team members found" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Start building your team by sharing your referral link with others." })
        ] }) }) })
      ] }) })
    ] }) })
  ] });
};
const TeamOverview = ({ historyData }) => {
  if (!historyData?.rankQualify || !historyData?.userInfo) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { textAlign: "center", py: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(UsersRound, { size: 64, style: { color: "#9e9e9e", marginBottom: 16 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", color: "text.secondary", children: "No team data available" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Team statistics will appear here once you start building your network." })
    ] });
  }
  const { rankQualify, userInfo } = historyData;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 3, sx: { mb: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { background: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)", color: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: { textAlign: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { size: 40, style: { marginBottom: 8 } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: formatNumber(Number(rankQualify.directs || 0)) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "Direct Team" })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { background: "linear-gradient(135deg, #f093fb 0%, #f5576c 100%)", color: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: { textAlign: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(UsersRound, { size: 40, style: { marginBottom: 8 } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: formatNumber(Number(rankQualify.strongTeam || 0)) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "Strong Team" })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { background: "linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)", color: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: { textAlign: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(UsersRound, { size: 40, style: { marginBottom: 8 } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: formatNumber(Number(rankQualify.totalTeam || 0)) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "Total Team" })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { background: "linear-gradient(135deg, #11998e 0%, #38ef7d 100%)", color: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: { textAlign: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 40, style: { marginBottom: 8 } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: formatNumber(Number(rankQualify.level || 0)) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "Current Level" })
      ] }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 3, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", gutterBottom: true, sx: { display: "flex", alignItems: "center" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(UsersRound, { size: 20, style: { marginRight: 8 } }),
          "Team Performance"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", flexDirection: "column", gap: 3 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", mb: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "Direct Team Progress" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", fontWeight: "bold", children: [
                Number(rankQualify.directs || 0),
                "/10"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              LinearProgress,
              {
                variant: "determinate",
                value: Math.min(Number(rankQualify.directs || 0) / 10 * 100, 100),
                sx: { height: 8, borderRadius: 4 }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", mb: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "Strong Team Progress" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", fontWeight: "bold", children: [
                Number(rankQualify.strongTeam || 0),
                "/50"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              LinearProgress,
              {
                variant: "determinate",
                value: Math.min(Number(rankQualify.strongTeam || 0) / 50 * 100, 100),
                sx: { height: 8, borderRadius: 4 },
                color: "secondary"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", mb: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", children: "Total Team Growth" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", fontWeight: "bold", children: [
                Number(rankQualify.totalTeam || 0),
                "/100"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              LinearProgress,
              {
                variant: "determinate",
                value: Math.min(Number(rankQualify.totalTeam || 0) / 100 * 100, 100),
                sx: { height: 8, borderRadius: 4 },
                color: "success"
              }
            )
          ] })
        ] })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", gutterBottom: true, sx: { display: "flex", alignItems: "center" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Wallet, { size: 20, style: { marginRight: 8 } }),
          "Account Information"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", flexDirection: "column", gap: 2 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "User Level:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Chip,
              {
                label: `Level ${formatNumber(Number(userInfo.userLevel || 0))}`,
                color: "primary",
                size: "small"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "Last Investment:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { fontWeight: "bold", color: "primary.main", children: formatCurrency(parseFloat(formatUnits(userInfo.lastStake || 0, 6))) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "Registration Status:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Chip,
              {
                label: userInfo.joined ? "Verified" : "Pending",
                color: userInfo.joined ? "success" : "warning",
                size: "small",
                icon: userInfo.joined ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircleCheckBig, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { size: 16 })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", justifyContent: "space-between", alignItems: "center" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { children: "DAO Membership:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Chip,
              {
                label: userInfo.isDAO ? "Active Member" : "Standard",
                color: userInfo.isDAO ? "success" : "default",
                size: "small",
                variant: userInfo.isDAO ? "filled" : "outlined"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { my: 1 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { textAlign: "center", p: 2, bgcolor: "grey.50", borderRadius: 1 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "text.secondary", children: [
              "Team Rank: ",
              /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
                "Level ",
                Number(rankQualify.level || 0)
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: "Keep growing your team to unlock higher levels!" })
          ] })
        ] })
      ] }) }) })
    ] })
  ] });
};
const EarningsHistory = ({ historyData }) => {
  const { bonusInfo, directReferrals, stakeHistory } = historyData;
  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text);
  };
  const earningsData = [
    {
      type: "Referral Earnings",
      amount: parseFloat(formatUnits(bonusInfo.referralGains || 0, 6)),
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { size: 16 }),
      color: "primary",
      description: "Direct referral commissions",
      source: "Direct Team",
      addresses: directReferrals || []
    },
    {
      type: "Level Earnings",
      amount: parseFloat(formatUnits(bonusInfo.levelGains || 0, 6)),
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartNoAxesColumnIncreasing, { size: 16 }),
      color: "secondary",
      description: "Multi-level team commissions",
      source: "Team Levels",
      addresses: []
    },
    {
      type: "Growth Earnings",
      amount: parseFloat(formatUnits(bonusInfo.growthGains || 0, 6)),
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 16 }),
      color: "success",
      description: "Investment growth rewards",
      source: "Personal Stakes",
      addresses: []
    },
    {
      type: "Team Growth Earnings",
      amount: parseFloat(formatUnits(bonusInfo.teamGrowthGains || 0, 6)),
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UsersRound, { size: 16 }),
      color: "info",
      description: "Team performance bonuses",
      source: "Team Performance",
      addresses: directReferrals || []
    },
    {
      type: "Leader Earnings",
      amount: parseFloat(formatUnits(bonusInfo.leaderGains || 0, 6)),
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Crown, { size: 16 }),
      color: "warning",
      description: "Leadership achievement rewards",
      source: "Leadership Rank",
      addresses: []
    },
    {
      type: "Development Earnings",
      amount: parseFloat(formatUnits(bonusInfo.developmentGains || 0, 6)),
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Building2, { size: 16 }),
      color: "error",
      description: "Platform development rewards",
      source: "Development Fund",
      addresses: []
    }
  ];
  const totalDeposits = stakeHistory?.reduce((sum, stake) => sum + (stake.amount || 0), 0) || 0;
  const activeDeposits = stakeHistory?.filter((stake) => !stake.isComplete).length || 0;
  const completedDeposits = stakeHistory?.filter((stake) => stake.isComplete).length || 0;
  const totalEarnings = earningsData.reduce((sum, item) => sum + item.amount, 0);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mb: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { background: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)", boxShadow: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: { textAlign: "center", py: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h3", sx: { color: "white", fontWeight: "bold", mb: 1 }, children: [
        " ",
        formatCurrency(totalEarnings)
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", sx: { color: "rgba(255,255,255,0.9)" }, children: "Total Lifetime Earnings" })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 3, sx: { mb: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "success.main", color: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: " Total Deposits" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: formatCurrency(totalDeposits) })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "primary.main", color: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: " Active Stakes" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: activeDeposits })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "info.main", color: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: " Completed" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: completedDeposits })
      ] }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "secondary.main", color: "white" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", children: " Team Size" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", fontWeight: "bold", children: directReferrals?.length || 0 })
      ] }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", gutterBottom: true, sx: { fontWeight: "bold", mb: 3 }, children: " Detailed Earnings History" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { mb: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { sx: { backgroundColor: "grey.50" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " Date" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " Amount" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " From User" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " Level" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " Reward Type" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: " Actions" }) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: historyData.earningsDetails && historyData.earningsDetails.length > 0 ? historyData.earningsDetails.map((earning, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TableRow,
        {
          hover: true,
          sx: {
            "&:hover": {
              backgroundColor: "rgba(76, 175, 80, 0.08)",
              transform: "scale(1.01)",
              transition: "all 0.2s ease-in-out"
            },
            transition: "all 0.2s ease-in-out"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", fontWeight: "bold", children: earning.date }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: formatTimeAgo(earning.timestamp) })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", fontWeight: "bold", color: "success.main", children: [
                "+",
                formatCurrency(earning.amount)
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: " Earned" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Tooltip,
              {
                title: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { p: 1 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", fontWeight: "bold", children: "Full Address:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { fontFamily: "monospace", wordBreak: "break-all" }, children: earning.fromUser })
                ] }),
                arrow: true,
                placement: "top",
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { fontFamily: "monospace", fontWeight: "bold" }, children: `${earning.fromUser.slice(0, 8)}...${earning.fromUser.slice(-6)}` }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: " Source" })
                ] })
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Chip,
              {
                label: earning.level === 0 ? "Direct" : `Level ${earning.level}`,
                color: earning.level === 0 ? "success" : earning.level === 1 ? "primary" : "secondary",
                size: "small",
                sx: { fontWeight: "bold" }
              }
            ) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", fontWeight: "bold", color: "primary.main", children: earning.rewardType }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "caption", color: "text.secondary", children: " Bonus Type" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", gap: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "Copy Address", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  size: "small",
                  onClick: () => copyToClipboard(earning.fromUser),
                  sx: {
                    "&:hover": {
                      backgroundColor: "primary.main",
                      color: "white",
                      transform: "scale(1.1)"
                    },
                    transition: "all 0.2s ease"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { size: 16 })
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { title: "View on BSCScan", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  size: "small",
                  onClick: () => window.open(`https://bscscan.com/address/${earning.fromUser}`, "_blank"),
                  sx: {
                    "&:hover": {
                      backgroundColor: "success.main",
                      color: "white",
                      transform: "scale(1.1)"
                    },
                    transition: "all 0.2s ease"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { size: 16 })
                }
              ) })
            ] }) })
          ]
        },
        `earning-${index2}`
      )) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableCell, { colSpan: 6, sx: { textAlign: "center", py: 4 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", color: "text.secondary", children: "No earnings data available" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Your earnings will appear here once you start earning rewards." })
      ] }) }) })
    ] }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mt: 4 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", gutterBottom: true, children: "Additional Information" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", gutterBottom: true, children: "Total Staked" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", children: formatCurrency(parseFloat(formatUnits(bonusInfo.totalStake || 0, 6))) })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", gutterBottom: true, children: "Total Withdrawn" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", children: formatCurrency(parseFloat(formatUnits(bonusInfo.totalWithdrwan || 0, 6))) })
        ] }) }) })
      ] })
    ] })
  ] });
};
const UnstakePage = () => {
  const wallet = useWallet();
  const [loading, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const [success, setSuccess] = reactExports.useState("");
  const [tokenAmount, setTokenAmount] = reactExports.useState("");
  const [tokenBalance, setTokenBalance] = reactExports.useState("0");
  const [estimatedUsdt, setEstimatedUsdt] = reactExports.useState("0");
  const [refreshing, setRefreshing] = reactExports.useState(false);
  const [tokenPrice, setTokenPrice] = reactExports.useState("0");
  const [approving, setApproving] = reactExports.useState(false);
  const fetchTokenBalance = async () => {
    if (!wallet.isConnected || !wallet.account) return;
    try {
      console.log(" [SwapPage] Fetching USER SafeMint token balance for wallet:", wallet.account);
      setRefreshing(true);
      const balance = await safeMintTokenService.getBalance(wallet.account);
      console.log(" [SwapPage] Raw USER SafeMint balance (wei):", balance.toString());
      const formattedBalance = formatUnits(balance, 18);
      console.log(" [SwapPage] Formatted USER SafeMint balance:", formattedBalance);
      setTokenBalance(formattedBalance);
      console.log(" [SwapPage] USER SafeMint token balance updated:", formattedBalance, "SMT");
    } catch (error2) {
      console.error(" [SwapPage] Error fetching USER SafeMint token balance:", error2);
      setTokenBalance("0");
    } finally {
      setRefreshing(false);
    }
  };
  const fetchTokenPrice = async () => {
    try {
      console.log(" [UnstakePage] Fetching real-time token price...");
      const tokenInfo = await safeMintTokenService.getTokenInfo();
      const priceInUSDT = formatEther(tokenInfo.rateInUSDT);
      setTokenPrice(priceInUSDT);
      console.log(" [UnstakePage] Token price updated:", priceInUSDT, "USDT");
    } catch (error2) {
      console.error(" [UnstakePage] Error fetching token price:", error2);
      setTokenPrice("1.0");
    }
  };
  const refreshAllData = async () => {
    if (!wallet.isConnected || !wallet.account) return;
    setRefreshing(true);
    try {
      await Promise.all([
        fetchTokenBalance(),
        fetchTokenPrice()
      ]);
    } catch (error2) {
      console.error(" [UnstakePage] Error refreshing data:", error2);
    } finally {
      setRefreshing(false);
    }
  };
  reactExports.useEffect(() => {
    if (wallet.isConnected && wallet.account) {
      console.log(" [UnstakePage] Wallet connected, fetching balances for:", wallet.account);
      console.log(" [UnstakePage] Current chain ID:", wallet.chainId);
      if (wallet.chainId !== 56) {
        console.warn(" [UnstakePage] Warning: Not on BSC Mainnet (Chain ID 56). Current chain:", wallet.chainId);
      }
      fetchTokenBalance();
      fetchTokenPrice();
    } else {
      console.log(" [UnstakePage] Wallet not connected, skipping balance fetch");
    }
  }, [wallet.isConnected, wallet.account, wallet.chainId]);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      fetchTokenPrice();
    }, 3e4);
    return () => clearInterval(interval);
  }, []);
  reactExports.useEffect(() => {
    if (tokenAmount && !isNaN(parseFloat(tokenAmount)) && tokenPrice && parseFloat(tokenPrice) > 0) {
      const usdtToReceive = parseFloat(tokenAmount) * parseFloat(tokenPrice);
      setEstimatedUsdt(usdtToReceive.toFixed(6));
    } else {
      setEstimatedUsdt("0");
    }
  }, [tokenAmount, tokenPrice]);
  const handleUnstake = async () => {
    if (!wallet.isConnected || !wallet.account) {
      setError("Please connect your wallet");
      return;
    }
    if (!tokenAmount || parseFloat(tokenAmount) <= 0) {
      setError("Please enter a valid token amount");
      return;
    }
    if (parseFloat(tokenAmount) > parseFloat(tokenBalance)) {
      setError("Insufficient token balance");
      return;
    }
    try {
      setLoading(true);
      setError("");
      setSuccess("");
      try {
        const userInfo = await stakingInteractions.getUserInfo(wallet.account);
        console.log("User info:", userInfo);
        if (!userInfo.joined) {
          setError("You must be registered to unstake tokens. Please register first.");
          return;
        }
      } catch (regError) {
        console.error("Error checking registration:", regError);
        setError("Unable to verify registration status. Please try again.");
        return;
      }
      console.log(` [Unstake] Unstaking ${tokenAmount} tokens for USDT...`);
      const usdtEquivalent = parseFloat(tokenAmount) * parseFloat(tokenPrice);
      const amountInWei = parseUnits(usdtEquivalent.toString(), 6);
      console.log(" [Unstake] USDT equivalent amount in wei:", amountInWei.toString());
      try {
        const tokenAmountInWei = parseUnits(tokenAmount, 18);
        const allowance = await safeMintTokenService.getAllowance(wallet.account, STAKING_CONTRACT_ADDRESS);
        if (allowance < tokenAmountInWei) {
          console.log(" [Unstake] Insufficient allowance, requesting approval...");
          setError("Approving tokens for unstake...");
          try {
            setApproving(true);
            const approvalTx = await safeMintTokenService.approve(STAKING_CONTRACT_ADDRESS, tokenAmountInWei, wallet.account);
            console.log(" [Unstake] Approval transaction:", approvalTx);
            setError("Approval submitted. Waiting for confirmation...");
            await new Promise((resolve) => setTimeout(resolve, 5e3));
            console.log(" [Unstake] Approval confirmed, proceeding with unstake...");
            setError("");
          } catch (approvalError) {
            console.error(" [Unstake] Approval failed:", approvalError);
            setError("Token approval failed. Please try again.");
            return;
          } finally {
            setApproving(false);
          }
        }
      } catch (allowanceError) {
        console.error("Error checking token allowance:", allowanceError);
        setError("Unable to check token allowance. Please try again.");
        return;
      }
      console.log(" [Unstake] Calling sellToken function...");
      const txHash = await stakingInteractions.sellToken(amountInWei, wallet.account);
      console.log(" [Unstake] Transaction successful! Hash:", txHash);
      setSuccess(` Unstake successful! Sold ${tokenAmount} tokens for ${usdtEquivalent.toFixed(6)} USDT. Tx: ${txHash.slice(0, 10)}...${txHash.slice(-8)}`);
      setTokenAmount("");
      console.log(" [Unstake] Refreshing balances...");
      setTimeout(() => {
        refreshAllData();
      }, 3e3);
    } catch (error2) {
      console.error(" [Unstake] Unstake error:", error2);
      let errorMessage = "Unstake failed. Please try again.";
      if (error2.message) {
        if (error2.message.includes("insufficient allowance")) {
          errorMessage = "Insufficient token allowance. Please approve tokens for the contract.";
        } else if (error2.message.includes("insufficient balance")) {
          errorMessage = "Insufficient balance. Please check your wallet balance.";
        } else if (error2.message.includes("insufficient")) {
          errorMessage = "Insufficient balance or allowance. Please check your balance.";
        } else if (error2.message.includes("rejected") || error2.message.includes("denied")) {
          errorMessage = "Transaction was rejected by user. Please try again.";
        } else if (error2.message.includes("gas")) {
          errorMessage = "Transaction failed due to gas issues. Please increase gas limit or try again.";
        } else if (error2.message.includes("network") || error2.message.includes("connection")) {
          errorMessage = "Network error. Please check your connection and try again.";
        } else if (error2.message.includes("not registered")) {
          errorMessage = "You must be registered to unstake tokens. Please register first.";
        } else if (error2.message.includes("slippage")) {
          errorMessage = "Price changed during transaction. Please try again.";
        } else {
          errorMessage = error2.message;
        }
      }
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  };
  if (!wallet.isConnected) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "md", sx: { py: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "warning", children: "Please connect your wallet to access the unstake feature." }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "md", sx: { py: 4 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 4, textAlign: "center" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h4", gutterBottom: true, sx: { color: "primary.main", fontWeight: "bold" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingDown, { size: 24, style: { marginRight: 8, verticalAlign: "middle" } }),
        "Unstake SafeMint Tokens"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body1", color: "text.secondary", children: "Convert your SafeMint tokens back to USDT" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "white", boxShadow: 3, mb: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "space-between", alignItems: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", sx: { display: "flex", alignItems: "center", color: "primary.main" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { sx: { mr: 1 } }),
        "SafeMint Token Price"
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h4", sx: { mt: 1, color: "success.main", fontWeight: "bold" }, children: [
        "$",
        parseFloat(tokenPrice).toFixed(6),
        " USDT"
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { backgroundColor: "white", boxShadow: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", gutterBottom: true, sx: { display: "flex", alignItems: "center" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingDown, { sx: { mr: 1 } }),
        "Unstake SafeMint Tokens"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 3, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { item: true, xs: 12, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", gutterBottom: true, children: "SafeMint Tokens to Unstake" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              fullWidth: true,
              label: "SafeMint Token Amount",
              value: tokenAmount,
              onChange: (e2) => setTokenAmount(e2.target.value),
              type: "number",
              slotProps: {
                htmlInput: { min: 0, step: 1e-6 },
                input: {
                  endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment, { position: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      size: "small",
                      onClick: () => setTokenAmount(tokenBalance),
                      sx: { minWidth: "auto", px: 1 },
                      children: "MAX"
                    }
                  ) })
                }
              },
              helperText: `Available: ${formatNumber(parseFloat(tokenBalance || "0"), 6)} SMT`
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sx: { textAlign: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingDown, { sx: { fontSize: 40, color: "primary.main" } }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { item: true, xs: 12, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "subtitle1", gutterBottom: true, children: "USDT You'll Receive (Estimated)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              fullWidth: true,
              label: "USDT Amount",
              value: estimatedUsdt,
              slotProps: {
                input: {
                  readOnly: true,
                  endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment, { position: "end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Chip,
                    {
                      label: `$${parseFloat(tokenPrice).toFixed(6)} per SMT`,
                      size: "small",
                      color: "secondary"
                    }
                  ) })
                }
              },
              helperText: `1 SafeMint Token = $${parseFloat(tokenPrice).toFixed(6)} USDT`
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { sx: { my: 3 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { mb: 3 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", gutterBottom: true, children: "Transaction Summary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 2, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { item: true, xs: 6, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "You Unstake:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body1", fontWeight: "bold", children: [
              formatNumber(parseFloat(tokenAmount || "0"), 6),
              " SMT"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { item: true, xs: 6, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "You Receive:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body1", fontWeight: "bold", children: [
              formatNumber(parseFloat(estimatedUsdt || "0"), 6),
              " USDT"
            ] })
          ] })
        ] })
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 2 }, onClose: () => setError(""), children: error }),
      success && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "success", sx: { mb: 2 }, onClose: () => setSuccess(""), children: success }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          fullWidth: true,
          variant: "contained",
          size: "large",
          onClick: handleUnstake,
          disabled: loading || !tokenAmount || parseFloat(tokenAmount) <= 0,
          startIcon: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, { size: 20 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingDown, { size: 18 }),
          sx: {
            py: 1.5,
            fontSize: "1.1rem",
            background: "linear-gradient(45deg, #f44336 30%, #d32f2f 90%)",
            "&:hover": {
              background: "linear-gradient(45deg, #d32f2f 30%, #c62828 90%)"
            }
          },
          children: loading ? "Unstaking..." : "Unstake Tokens"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { mt: 2, p: 2, bgcolor: "grey.50", borderRadius: 1 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "body2", color: "text.secondary", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Note:" }),
        " This unstake converts your SafeMint tokens to USDT at the current market rate of $$",
        parseFloat(tokenPrice).toFixed(6),
        " USDT per token. Prices are updated in real-time from the SafeMint contract. Make sure you have enough balance and the transaction will require gas fees."
      ] }) })
    ] }) })
  ] });
};
const TokenTest = () => {
  const [loading, setLoading] = reactExports.useState(false);
  const [result, setResult] = reactExports.useState(null);
  const [error, setError] = reactExports.useState(null);
  const testGetRate = async () => {
    setLoading(true);
    setError(null);
    try {
      const rate = await safeMintTokenService.getRateInUSDT();
      setResult({
        type: "Rate",
        data: {
          raw: rate.toString(),
          formatted: safeMintTokenService.formatRate(rate),
          ether: formatEther(rate)
        }
      });
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  const testGetReserves = async () => {
    setLoading(true);
    setError(null);
    try {
      const reserves = await safeMintTokenService.getReserves();
      setResult({
        type: "Reserves",
        data: {
          tokenSupply: {
            raw: reserves.tokenSupply.toString(),
            formatted: safeMintTokenService.formatBalance(reserves.tokenSupply),
            ether: formatEther(reserves.tokenSupply)
          },
          usdtBalance: {
            raw: reserves.usdtBalance.toString(),
            formatted: safeMintTokenService.formatBalance(reserves.usdtBalance),
            ether: formatEther(reserves.usdtBalance)
          },
          blockTimestampLast: reserves.blockTimestampLast.toString()
        }
      });
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  const testGetTokenInfo = async () => {
    setLoading(true);
    setError(null);
    try {
      const info = await safeMintTokenService.getTokenInfo();
      setResult({
        type: "Token Info",
        data: {
          name: info.name,
          symbol: info.symbol,
          decimals: info.decimals,
          totalSupply: {
            raw: info.totalSupply.toString(),
            formatted: safeMintTokenService.formatBalance(info.totalSupply),
            ether: formatEther(info.totalSupply)
          },
          rateInUSDT: {
            raw: info.rateInUSDT.toString(),
            formatted: safeMintTokenService.formatRate(info.rateInUSDT),
            ether: formatEther(info.rateInUSDT)
          },
          reserves: {
            tokenSupply: {
              raw: info.reserves.tokenSupply.toString(),
              formatted: safeMintTokenService.formatBalance(info.reserves.tokenSupply),
              ether: formatEther(info.reserves.tokenSupply)
            },
            usdtBalance: {
              raw: info.reserves.usdtBalance.toString(),
              formatted: safeMintTokenService.formatBalance(info.reserves.usdtBalance),
              ether: formatEther(info.reserves.usdtBalance)
            },
            blockTimestampLast: info.reserves.blockTimestampLast.toString()
          }
        }
      });
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "xl", sx: { py: 4 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", gutterBottom: true, sx: { color: "primary.main", fontWeight: "bold", mb: 4 }, children: "SafeMint Token Service Test" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { mb: 4, p: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", gutterBottom: true, children: "Test Functions" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", gap: 2, flexWrap: "wrap" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "contained",
            onClick: testGetRate,
            disabled: loading,
            sx: { minWidth: 120 },
            children: "Get Rate"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "contained",
            onClick: testGetReserves,
            disabled: loading,
            sx: { minWidth: 120 },
            children: "Get Reserves"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "contained",
            onClick: testGetTokenInfo,
            disabled: loading,
            sx: { minWidth: 120 },
            children: "Get Token Info"
          }
        )
      ] })
    ] }) }),
    loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: "flex", justifyContent: "center", mb: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {}) }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, { severity: "error", sx: { mb: 4 }, children: error }),
    result && /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: { mb: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography, { variant: "h6", gutterBottom: true, children: [
        result.type,
        " Results"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { component: "pre", sx: {
        backgroundColor: "grey.100",
        p: 2,
        borderRadius: 1,
        overflow: "auto",
        fontSize: "0.875rem"
      }, children: JSON.stringify(result.data, null, 2) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h5", gutterBottom: true, sx: { color: "primary.main", fontWeight: "bold", mb: 3 }, children: "Component Tests" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 3, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { item: true, xs: 12, md: 6, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", gutterBottom: true, children: "Token Price Card" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TokenPriceCard, { autoRefresh: false })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { item: true, xs: 12, md: 6, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", gutterBottom: true, children: "SafeMint Token Stats" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SafeMintTokenStats, { autoRefresh: false })
      ] })
    ] })
  ] });
};
const SafeMintHTML = () => {
  const [mobileMenuOpen, setMobileMenuOpen] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const style2 = document.createElement("style");
    style2.textContent = `
      .safemint-page {
        margin: 0;
        overflow-x: hidden;
        background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
        color: white;
        font-family: 'Inter', sans-serif;
        min-height: 100vh;
      }

      .glass-card {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        transition: all 0.3s ease;
      }

      .glass-card:hover {
        transform: translateY(-10px);
        box-shadow: 0 20px 40px rgba(0, 255, 255, 0.2);
      }

      .gradient-text {
        background: linear-gradient(90deg, #00d4ff, #0099cc);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .btn-primary {
        background: linear-gradient(90deg, #00d4ff, #0099cc);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 50px;
        font-weight: 600;
        transition: all 0.3s ease;
        cursor: pointer;
      }

      .btn-primary:hover {
        transform: translateY(-3px);
        box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4);
      }

      .stats-card {
        background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(0, 153, 204, 0.1));
        border: 1px solid rgba(0, 212, 255, 0.3);
        padding: 1.5rem;
        border-radius: 12px;
        text-align: center;
      }

      .level-badge {
        background: linear-gradient(135deg, #ffd700, #ffed4e);
        color: #000;
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: bold;
        font-size: 0.875rem;
        display: inline-block;
      }

      .bonus-highlight {
        background: linear-gradient(135deg, #00ff88, #00cc6a);
        color: white;
        padding: 4px 12px;
        border-radius: 15px;
        font-size: 0.75rem;
        font-weight: bold;
        display: inline-block;
      }

      @keyframes float {
        0% { transform: translateY(0px); }
        50% { transform: translateY(-20px); }
        100% { transform: translateY(0px); }
      }

      .floating {
        animation: float 3s ease-in-out infinite;
      }
    `;
    document.head.appendChild(style2);
    return () => {
      document.head.removeChild(style2);
    };
  }, []);
  const toggleMobileMenu = () => {
    setMobileMenuOpen(!mobileMenuOpen);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: "safemint-page", sx: { pt: 0 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AppBar,
      {
        position: "fixed",
        sx: {
          background: "rgba(15, 15, 35, 0.95)",
          backdropFilter: "blur(20px)",
          borderBottom: "1px solid rgba(0, 212, 255, 0.1)",
          zIndex: 1100
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Toolbar, { sx: { justifyContent: "space-between" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", alignItems: "center", gap: 2 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Box,
              {
                sx: {
                  width: 48,
                  height: 48,
                  borderRadius: 3,
                  background: "linear-gradient(135deg, #00d4ff, #0099cc, #00ff88)",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  boxShadow: "0 8px 25px rgba(0, 212, 255, 0.4)"
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { fontSize: "24px", fontWeight: 900, color: "#000" }, children: "S" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography,
              {
                variant: "h5",
                className: "gradient-text",
                sx: { fontWeight: 700, fontSize: "1.75rem" },
                children: "SafeMint"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: { display: { xs: "none", lg: "flex" }, gap: 2 }, children: ["Home", "Smart Contract", "Technology", "About", "Opportunity", "Roadmap", "Terms"].map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              sx: {
                color: "#e2e8f0",
                fontWeight: 500,
                px: 2,
                py: 1,
                borderRadius: 2,
                transition: "all 0.3s ease",
                "&:hover": {
                  color: "#00d4ff",
                  backgroundColor: "rgba(0, 212, 255, 0.1)"
                }
              },
              children: item
            },
            item
          )) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: { xs: "none", lg: "flex" }, gap: 2 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outlined",
                sx: {
                  borderColor: "rgba(0, 212, 255, 0.5)",
                  color: "#00d4ff",
                  borderRadius: 25,
                  px: 3
                },
                children: "Login"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                className: "btn-primary",
                sx: {
                  borderRadius: 25,
                  px: 3
                },
                children: "Register"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              sx: { display: { xs: "block", lg: "none" }, color: "#00d4ff" },
              onClick: toggleMobileMenu,
              children: ""
            }
          )
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box,
      {
        sx: {
          minHeight: "100vh",
          display: "flex",
          alignItems: "center",
          pt: 10,
          textAlign: "center"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "lg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "h1",
              className: "gradient-text floating",
              sx: {
                fontSize: { xs: "3rem", sm: "4rem", md: "6rem", lg: "8rem" },
                fontWeight: 900,
                mb: 4,
                lineHeight: 0.9
              },
              children: "SafeMint"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "h3",
              sx: {
                fontSize: { xs: "1.5rem", md: "2.5rem" },
                mb: 4,
                color: "#e2e8f0"
              },
              children: "Smart Contract Investment Platform"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography,
            {
              variant: "h6",
              sx: {
                mb: 6,
                color: "#94a3b8",
                maxWidth: "800px",
                mx: "auto",
                lineHeight: 1.6
              },
              children: "The SafeMint project is designed around a simple yet powerful economic principle: Flow of Value In (IN) and Flow of Value Out (OUT). Create continuous cycles of buying, selling, and reinvesting for sustainable growth."
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { display: "flex", gap: 3, justifyContent: "center", flexWrap: "wrap" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                className: "btn-primary",
                size: "large",
                sx: {
                  fontSize: "1.1rem",
                  px: 6,
                  py: 2
                },
                children: "Start Investing"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outlined",
                size: "large",
                sx: {
                  borderColor: "#00d4ff",
                  color: "#00d4ff",
                  fontSize: "1.1rem",
                  px: 6,
                  py: 2,
                  borderRadius: 25
                },
                children: "Learn More"
              }
            )
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { maxWidth: "lg", sx: { mb: 8 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { className: "glass-card", sx: { p: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: 4, children: [
      { icon: "", value: "15,847", label: "Active Users" },
      { icon: "", value: "$2.4M", label: "Total Value Locked" },
      { icon: "", value: "156.7%", label: "Average ROI" },
      { icon: "", value: "8,234", label: "Team Members" }
    ].map((stat, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { className: "stats-card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { sx: { fontSize: "2rem", mb: 1 }, children: stat.icon }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h4", sx: { fontWeight: 900, color: "#00d4ff", mb: 1 }, children: stat.value }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", sx: { color: "#94a3b8" }, children: stat.label })
    ] }) }, index2)) }) }) })
  ] });
};
const IconsShowcase = () => {
  const theme2 = useTheme();
  useMediaQuery(theme2.breakpoints.down("sm"));
  const iconList = [
    { name: "Users", component: CustomSVGIcons.Users, description: "Team Members & Direct Referrals" },
    { name: "Star", component: CustomSVGIcons.Star, description: "Strong Teams & Achievements" },
    { name: "BarChart3", component: CustomSVGIcons.BarChart3, description: "Levels & Analytics" },
    { name: "CheckCircle", component: CustomSVGIcons.CheckCircle, description: "Active Orders & Completion" },
    { name: "TrendingUp", component: CustomSVGIcons.TrendingUp, description: "Growth & Earnings" },
    { name: "DollarSign", component: CustomSVGIcons.DollarSign, description: "Financial Transactions" },
    { name: "Wallet", component: CustomSVGIcons.Wallet, description: "Portfolio & Wallets" },
    { name: "Trophy", component: CustomSVGIcons.Trophy, description: "Leadership & Achievements" },
    { name: "Building2", component: CustomSVGIcons.Building2, description: "Withdrawals & Infrastructure" },
    { name: "Users2", component: CustomSVGIcons.Users2, description: "Team Growth Laps" },
    { name: "Fuel", component: CustomSVGIcons.Fuel, description: "Growth Fuels & Energy" },
    { name: "Battery", component: CustomSVGIcons.Battery, description: "Total Fuels & Power" }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { sx: {
    backgroundColor: "#f8f9fa",
    minHeight: "100vh",
    py: { xs: 3, sm: 4, md: 6 },
    pb: { xs: 12, sm: 4, md: 4 }
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { maxWidth: "xl", sx: { px: { xs: 1.5, sm: 2, md: 3 } }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: {
      mb: { xs: 3, sm: 4, md: 6 },
      textAlign: "center",
      p: { xs: 3, sm: 4, md: 5 },
      borderRadius: { xs: 3, sm: 4 },
      backgroundColor: "white",
      boxShadow: { xs: 4, sm: 8, md: 12 },
      border: "1px solid rgba(0, 0, 0, 0.08)",
      position: "relative",
      overflow: "hidden",
      "&::before": {
        content: '""',
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        height: "4px",
        background: "linear-gradient(90deg, #1976d2 0%, #42a5f5 50%, #1976d2 100%)",
        backgroundSize: "200% 100%",
        animation: "shimmer 3s ease-in-out infinite"
      },
      "@keyframes shimmer": {
        "0%": { backgroundPosition: "-200% 0" },
        "100%": { backgroundPosition: "200% 0" }
      }
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "h3",
          gutterBottom: true,
          sx: {
            color: "primary.main",
            fontWeight: 800,
            fontSize: { xs: "1.8rem", sm: "2.2rem", md: "2.8rem" },
            letterSpacing: "-0.02em",
            mb: 2
          },
          children: " Custom SVG Icons Showcase"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "h6",
          color: "text.secondary",
          sx: {
            fontSize: { xs: "1rem", sm: "1.1rem", md: "1.2rem" },
            fontWeight: 500,
            lineHeight: 1.6,
            maxWidth: "800px",
            mx: "auto"
          },
          children: "Beautiful, animated SVG icons designed specifically for the SafeMint Dashboard. Each icon features smooth animations, gradient colors, and modern design."
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { container: true, spacing: { xs: 2, sm: 3, md: 4 }, children: iconList.map((iconData, index2) => {
      const IconComponent = iconData.component;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, sm: 6, md: 4, lg: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { sx: {
        height: "100%",
        backgroundColor: "white",
        borderRadius: { xs: 3, sm: 4 },
        boxShadow: { xs: 2, sm: 4, md: 6 },
        border: "1px solid rgba(0, 0, 0, 0.08)",
        transition: "all 0.4s cubic-bezier(0.4, 0, 0.2, 1)",
        animation: "slideInUp 0.6s ease-out",
        animationDelay: `${index2 * 0.1}s`,
        animationFillMode: "both",
        "&:hover": {
          boxShadow: { xs: 4, sm: 8, md: 12 },
          transform: "translateY(-8px) scale(1.02)",
          "& .icon-container": {
            transform: "scale(1.1)"
          }
        },
        "@keyframes slideInUp": {
          "0%": { opacity: 0, transform: "translateY(30px)" },
          "100%": { opacity: 1, transform: "translateY(0)" }
        }
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { sx: {
        p: { xs: 3, sm: 4 },
        textAlign: "center",
        height: "100%",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box,
          {
            className: "icon-container",
            sx: {
              mb: 3,
              p: 4,
              borderRadius: "50%",
              backgroundColor: "rgba(25, 118, 210, 0.05)",
              border: "2px solid rgba(25, 118, 210, 0.1)",
              transition: "all 0.3s ease",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              width: 180,
              height: 180
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconComponent, { size: 120, animated: true })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography,
          {
            variant: "h6",
            gutterBottom: true,
            sx: {
              color: "primary.main",
              fontWeight: 700,
              fontSize: { xs: "1.1rem", sm: "1.2rem" },
              mb: 1
            },
            children: iconData.name
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography,
          {
            variant: "body2",
            color: "text.secondary",
            sx: {
              fontSize: { xs: "0.85rem", sm: "0.9rem" },
              lineHeight: 1.5,
              fontWeight: 500,
              textAlign: "center"
            },
            children: iconData.description
          }
        )
      ] }) }) }, iconData.name);
    }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Paper, { sx: {
      mt: { xs: 4, sm: 6 },
      p: { xs: 3, sm: 4, md: 5 },
      backgroundColor: "white",
      borderRadius: { xs: 3, sm: 4 },
      boxShadow: { xs: 2, sm: 4, md: 6 },
      border: "1px solid rgba(0, 0, 0, 0.08)"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography,
        {
          variant: "h5",
          gutterBottom: true,
          sx: {
            color: "primary.main",
            fontWeight: 700,
            mb: 3,
            textAlign: "center"
          },
          children: " Icon Features"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { container: true, spacing: 3, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { textAlign: "center" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", color: "primary.main", gutterBottom: true, sx: { fontWeight: 600 }, children: " Smooth Animations" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Each icon features carefully crafted CSS animations that bring life to the interface" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { textAlign: "center" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", color: "primary.main", gutterBottom: true, sx: { fontWeight: 600 }, children: " Gradient Colors" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Beautiful gradient color schemes that match the SafeMint brand identity" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { item: true, xs: 12, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box, { sx: { textAlign: "center" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "h6", color: "primary.main", gutterBottom: true, sx: { fontWeight: 600 }, children: " Responsive Design" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography, { variant: "body2", color: "text.secondary", children: "Scalable SVG icons that look perfect on all screen sizes and devices" })
        ] }) })
      ] })
    ] })
  ] }) });
};
const theme = createTheme({
  palette: {
    primary: {
      main: "#6200ea",
      // Deep purple
      light: "#9d46ff",
      dark: "#0a00b6",
      contrastText: "#ffffff"
    },
    secondary: {
      main: "#00bcd4",
      // Cyan
      light: "#62efff",
      dark: "#008ba3",
      contrastText: "#000000"
    },
    background: {
      default: "#f5f5f5",
      paper: "#ffffff"
    },
    error: {
      main: "#f44336"
    },
    warning: {
      main: "#ff9800"
    },
    info: {
      main: "#2196f3"
    },
    success: {
      main: "#4caf50"
    }
  },
  typography: {
    fontFamily: '"Poppins", "Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontWeight: 700
    },
    h2: {
      fontWeight: 600
    },
    h3: {
      fontWeight: 600
    },
    button: {
      fontWeight: 600,
      textTransform: "none"
    }
  },
  breakpoints: {
    values: {
      xs: 0,
      sm: 600,
      md: 900,
      lg: 1200,
      xl: 1536
    }
  },
  shape: {
    borderRadius: 12
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 30,
          padding: "10px 24px",
          boxShadow: "0 4px 10px rgba(0, 0, 0, 0.15)"
        },
        containedPrimary: {
          "&:hover": {
            boxShadow: "0 6px 15px rgba(98, 0, 234, 0.3)"
          }
        },
        containedSecondary: {
          "&:hover": {
            boxShadow: "0 6px 15px rgba(0, 188, 212, 0.3)"
          }
        }
      }
    },
    MuiPaper: {
      styleOverrides: {
        rounded: {
          borderRadius: 16
        },
        elevation1: {
          boxShadow: "0 4px 20px rgba(0, 0, 0, 0.05)"
        },
        elevation3: {
          boxShadow: "0 8px 30px rgba(0, 0, 0, 0.1)"
        }
      }
    }
  }
});
const queryClient = new QueryClient();
function App() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ThemeProvider, { theme, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CssBaseline, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(WagmiProvider, { config, children: /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ jsxRuntimeExports.jsx(WalletProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MLMProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransactionHistoryProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BrowserRouter, { basename: "/app", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Navbar, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/dashboard", element: /* @__PURE__ */ jsxRuntimeExports.jsx(MLMDashboard, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/ui", element: /* @__PURE__ */ jsxRuntimeExports.jsx(SafeMintHTML, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/history", element: /* @__PURE__ */ jsxRuntimeExports.jsx(HistoryPage, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/swap", element: /* @__PURE__ */ jsxRuntimeExports.jsx(UnstakePage, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/token-test", element: /* @__PURE__ */ jsxRuntimeExports.jsx(TokenTest, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/icons", element: /* @__PURE__ */ jsxRuntimeExports.jsx(IconsShowcase, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/", replace: true }) })
      ] })
    ] }) }) }) }) }) }) })
  ] });
}
clientExports.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
);
export {
  T as $,
  AccountController as A,
  BaseError$4 as B,
  CoreHelperUtil as C,
  clean as D,
  EventsController as E,
  aexists as F,
  Gi as G,
  HttpRequestError as H,
  InvalidAddressError as I,
  abytes as J,
  anumber as K,
  randomBytes as L,
  ModalController as M,
  NetworkController as N,
  OptionsController as O,
  concatBytes$1 as P,
  sha256$3 as Q,
  RouterController as R,
  SnackController as S,
  ThemeController as T,
  UiHelperUtil as U,
  n$2 as V,
  W3mFrameRpcConstants as W,
  e$2 as X,
  Yi as Y,
  f as Z,
  __vitePreload as _,
  i$5 as a,
  keccak256 as a$,
  i3 as a0,
  e$1 as a1,
  o$3 as a2,
  base256emoji$1 as a3,
  base64$1 as a4,
  base58 as a5,
  base36$1 as a6,
  base32$1 as a7,
  base16$1 as a8,
  base10$1 as a9,
  parseStructs as aA,
  isStructSignature as aB,
  InvalidAbiItemError as aC,
  splitParameters as aD,
  parseAbiParameter as aE,
  modifiers as aF,
  InvalidAbiParametersError as aG,
  assertSize as aH,
  padRight as aI,
  BaseError$2 as aJ,
  fromBytes as aK,
  toNumber as aL,
  toBigInt as aM,
  getChainContractAddress as aN,
  getAction$1 as aO,
  readContract$1 as aP,
  packetToBytes as aQ,
  assertRequest as aR,
  numberToHex as aS,
  formatTransactionRequest as aT,
  parseAccount as aU,
  extract as aV,
  getCallError as aW,
  getAbiItem as aX,
  AbiEventNotFoundError as aY,
  formatAbiItem$1 as aZ,
  toEventSelector as a_,
  base8$1 as aa,
  base2$1 as ab,
  identityBase as ac,
  safeJsonParse as ad,
  safeJsonStringify as ae,
  eventsExports as af,
  cjsExports$3 as ag,
  o as ah,
  cjsExports$1 as ai,
  cjsExports$2 as aj,
  cjsExports as ak,
  k$1 as al,
  A$1 as am,
  E$1 as an,
  y$3 as ao,
  Ot$1 as ap,
  Nt as aq,
  QRCodeUtil as ar,
  e as as,
  n2 as at,
  formatUnits as au,
  fallback as av,
  http as aw,
  r$5 as ax,
  toHex as ay,
  parseSignature as az,
  b,
  hexToBool as b$,
  toBytes$1 as b0,
  encodeFunctionData as b1,
  estimateGas$1 as b2,
  getContractError as b3,
  hexToNumber as b4,
  AbiEventSignatureEmptyTopicsError as b5,
  AbiEventSignatureNotFoundError as b6,
  DecodeLogTopicsMismatch as b7,
  decodeAbiParameters as b8,
  AbiDecodingDataSizeTooSmallError as b9,
  slice as bA,
  formatAbiParameters as bB,
  stringify as bC,
  from$1 as bD,
  hexToBytes$1 as bE,
  getBlockNumber as bF,
  getTransaction as bG,
  toRpc as bH,
  serializeStateOverride as bI,
  formatBlock as bJ,
  decodeFunctionResult as bK,
  AbiDecodingZeroDataError as bL,
  RawContractError as bM,
  getNodeError as bN,
  UnknownNodeError as bO,
  validate as bP,
  formatAbiItem as bQ,
  hexToBigInt as bR,
  deploylessCallViaBytecodeBytecode as bS,
  recoverAddress as bT,
  multicall3Abi as bU,
  multicall3Bytecode as bV,
  erc1271Abi as bW,
  erc6492SignatureValidatorAbi as bX,
  encodeDeployData as bY,
  erc6492SignatureValidatorByteCode as bZ,
  CallExecutionError as b_,
  PositionOutOfBoundsError as ba,
  DecodeLogDataMismatch as bb,
  size$3 as bc,
  formatLog as bd,
  AbiEncodingLengthMismatchError as be,
  concatHex as bf,
  pad$1 as bg,
  stringToHex as bh,
  boolToHex as bi,
  integerRegex$1 as bj,
  bytesRegex$1 as bk,
  BytesSizeMismatchError as bl,
  arrayRegex as bm,
  UnsupportedPackedAbiType as bn,
  recoverAuthorizationAddress as bo,
  getAddress as bp,
  LruMap as bq,
  bytesToHex$1 as br,
  keccak_256 as bs,
  size$2 as bt,
  fromNumber as bu,
  concat as bv,
  padLeft as bw,
  fromBoolean as bx,
  IntegerOutOfRangeError2 as by,
  fromString$1 as bz,
  i$2 as c,
  ContractFunctionExecutionError as c0,
  observe as c1,
  poll as c2,
  getBlock as c3,
  InvalidInputRpcError as c4,
  receiptStatuses as c5,
  trim as c6,
  sliceHex as c7,
  AccountNotFoundError as c8,
  getChainId$1 as c9,
  hexToBytes as cA,
  sha256$2 as cB,
  sha384 as cC,
  sha512$1 as cD,
  EventEmitter as cE,
  defineChain as cF,
  slice$1 as cG,
  stringToBytes as cH,
  decodeFunctionData as cI,
  hexToString as cJ,
  erc20Abi as cK,
  getDefaultExportFromCjs as cL,
  require$$3 as cM,
  requireBuffer as cN,
  requireInherits_browser as cO,
  getAugmentedNamespace as cP,
  requireEvents as cQ,
  requireEventemitter3 as cR,
  getTransactionCount as ca,
  withResolvers as cb,
  withRetry as cc,
  watchBlockNumber as cd,
  waitForTransactionReceipt$1 as ce,
  sendRawTransaction as cf,
  prepareTransactionRequest$1 as cg,
  multicall$1 as ch,
  getTransactionReceipt as ci,
  estimateMaxPriorityFeePerGas as cj,
  getGasPrice as ck,
  estimateFeesPerGas as cl,
  getEnsText as cm,
  getEnsName$1 as cn,
  getEnsAvatar$1 as co,
  getEnsAddress$1 as cp,
  getBalance$1 as cq,
  createClient as cr,
  parseAbi as cs,
  prettyPrint as ct,
  formatGwei as cu,
  ContractFunctionZeroDataError as cv,
  ContractFunctionRevertedError as cw,
  formatTransactionReceipt as cx,
  bytesToHex as cy,
  isBytes as cz,
  ApiController as d,
  initializeTheming as e,
  customElement as f,
  getUrl as g,
  decodeErrorResult as h,
  isAddress as i,
  localBatchGatewayRequest as j,
  call as k,
  localBatchGatewayUrl as l,
  concat$1 as m,
  encodeAbiParameters as n,
  isHex as o,
  proxy as p,
  ref as q,
  r$1 as r,
  stringify$1 as s,
  subscribe as t,
  subscribeKey as u,
  ConnectionController as v,
  Hash as w,
  x,
  ahash as y,
  toBytes as z
};
